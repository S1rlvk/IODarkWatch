/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_leaflet_dist_leaflet-src_js"],{

/***/ "(app-pages-browser)/./node_modules/leaflet/dist/leaflet-src.js":
/*!**************************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet-src.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n/* @preserve\n * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com\n * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade\n */\n\n(function (global, factory) {\n  ( false ? 0 : _typeof(exports)) === 'object' && \"object\" !== 'undefined' ? factory(exports) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n})(this, function (exports) {\n  'use strict';\n\n  var version = \"1.9.4\";\n\n  /*\r\n   * @namespace Util\r\n   *\r\n   * Various utility functions, used by Leaflet internally.\r\n   */\n\n  // @function extend(dest: Object, src?: Object): Object\n  // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.\n  function extend(dest) {\n    var i, j, len, src;\n    for (j = 1, len = arguments.length; j < len; j++) {\n      src = arguments[j];\n      for (i in src) {\n        dest[i] = src[i];\n      }\n    }\n    return dest;\n  }\n\n  // @function create(proto: Object, properties?: Object): Object\n  // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)\n  var create$2 = Object.create || function () {\n    function F() {}\n    return function (proto) {\n      F.prototype = proto;\n      return new F();\n    };\n  }();\n\n  // @function bind(fn: Function, …): Function\n  // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n  // Has a `L.bind()` shortcut.\n  function bind(fn, obj) {\n    var slice = Array.prototype.slice;\n    if (fn.bind) {\n      return fn.bind.apply(fn, slice.call(arguments, 1));\n    }\n    var args = slice.call(arguments, 2);\n    return function () {\n      return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);\n    };\n  }\n\n  // @property lastId: Number\n  // Last unique ID used by [`stamp()`](#util-stamp)\n  var lastId = 0;\n\n  // @function stamp(obj: Object): Number\n  // Returns the unique ID of an object, assigning it one if it doesn't have it.\n  function stamp(obj) {\n    if (!('_leaflet_id' in obj)) {\n      obj['_leaflet_id'] = ++lastId;\n    }\n    return obj._leaflet_id;\n  }\n\n  // @function throttle(fn: Function, time: Number, context: Object): Function\n  // Returns a function which executes function `fn` with the given scope `context`\n  // (so that the `this` keyword refers to `context` inside `fn`'s code). The function\n  // `fn` will be called no more than one time per given amount of `time`. The arguments\n  // received by the bound function will be any arguments passed when binding the\n  // function, followed by any arguments passed when invoking the bound function.\n  // Has an `L.throttle` shortcut.\n  function throttle(fn, time, context) {\n    var lock, args, wrapperFn, later;\n    later = function later() {\n      // reset lock and call if queued\n      lock = false;\n      if (args) {\n        wrapperFn.apply(context, args);\n        args = false;\n      }\n    };\n    wrapperFn = function wrapperFn() {\n      if (lock) {\n        // called too soon, queue to call later\n        args = arguments;\n      } else {\n        // call and lock until later\n        fn.apply(context, arguments);\n        setTimeout(later, time);\n        lock = true;\n      }\n    };\n    return wrapperFn;\n  }\n\n  // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number\n  // Returns the number `num` modulo `range` in such a way so it lies within\n  // `range[0]` and `range[1]`. The returned value will be always smaller than\n  // `range[1]` unless `includeMax` is set to `true`.\n  function wrapNum(x, range, includeMax) {\n    var max = range[1],\n      min = range[0],\n      d = max - min;\n    return x === max && includeMax ? x : ((x - min) % d + d) % d + min;\n  }\n\n  // @function falseFn(): Function\n  // Returns a function which always returns `false`.\n  function falseFn() {\n    return false;\n  }\n\n  // @function formatNum(num: Number, precision?: Number|false): Number\n  // Returns the number `num` rounded with specified `precision`.\n  // The default `precision` value is 6 decimal places.\n  // `false` can be passed to skip any processing (can be useful to avoid round-off errors).\n  function formatNum(num, precision) {\n    if (precision === false) {\n      return num;\n    }\n    var pow = Math.pow(10, precision === undefined ? 6 : precision);\n    return Math.round(num * pow) / pow;\n  }\n\n  // @function trim(str: String): String\n  // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)\n  function trim(str) {\n    return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n  }\n\n  // @function splitWords(str: String): String[]\n  // Trims and splits the string on whitespace and returns the array of parts.\n  function splitWords(str) {\n    return trim(str).split(/\\s+/);\n  }\n\n  // @function setOptions(obj: Object, options: Object): Object\n  // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.\n  function setOptions(obj, options) {\n    if (!Object.prototype.hasOwnProperty.call(obj, 'options')) {\n      obj.options = obj.options ? create$2(obj.options) : {};\n    }\n    for (var i in options) {\n      obj.options[i] = options[i];\n    }\n    return obj.options;\n  }\n\n  // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String\n  // Converts an object into a parameter URL string, e.g. `{a: \"foo\", b: \"bar\"}`\n  // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will\n  // be appended at the end. If `uppercase` is `true`, the parameter names will\n  // be uppercased (e.g. `'?A=foo&B=bar'`)\n  function getParamString(obj, existingUrl, uppercase) {\n    var params = [];\n    for (var i in obj) {\n      params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\n    }\n    return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');\n  }\n  var templateRe = /\\{ *([\\w_ -]+) *\\}/g;\n\n  // @function template(str: String, data: Object): String\n  // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`\n  // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string\n  // `('Hello foo, bar')`. You can also specify functions instead of strings for\n  // data values — they will be evaluated passing `data` as an argument.\n  function template(str, data) {\n    return str.replace(templateRe, function (str, key) {\n      var value = data[key];\n      if (value === undefined) {\n        throw new Error('No value provided for variable ' + str);\n      } else if (typeof value === 'function') {\n        value = value(data);\n      }\n      return value;\n    });\n  }\n\n  // @function isArray(obj): Boolean\n  // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)\n  var isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  };\n\n  // @function indexOf(array: Array, el: Object): Number\n  // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)\n  function indexOf(array, el) {\n    for (var i = 0; i < array.length; i++) {\n      if (array[i] === el) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  // @property emptyImageUrl: String\n  // Data URI string containing a base64-encoded empty GIF image.\n  // Used as a hack to free memory from unused images on WebKit-powered\n  // mobile devices (by setting image `src` to this string).\n  var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';\n\n  // inspired by https://paulirish.com/2011/requestanimationframe-for-smart-animating/\n\n  function getPrefixed(name) {\n    return window['webkit' + name] || window['moz' + name] || window['ms' + name];\n  }\n  var lastTime = 0;\n\n  // fallback for IE 7-8\n  function timeoutDefer(fn) {\n    var time = +new Date(),\n      timeToCall = Math.max(0, 16 - (time - lastTime));\n    lastTime = time + timeToCall;\n    return window.setTimeout(fn, timeToCall);\n  }\n  var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;\n  var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function (id) {\n    window.clearTimeout(id);\n  };\n\n  // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number\n  // Schedules `fn` to be executed when the browser repaints. `fn` is bound to\n  // `context` if given. When `immediate` is set, `fn` is called immediately if\n  // the browser doesn't have native support for\n  // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),\n  // otherwise it's delayed. Returns a request ID that can be used to cancel the request.\n  function requestAnimFrame(fn, context, immediate) {\n    if (immediate && requestFn === timeoutDefer) {\n      fn.call(context);\n    } else {\n      return requestFn.call(window, bind(fn, context));\n    }\n  }\n\n  // @function cancelAnimFrame(id: Number): undefined\n  // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).\n  function cancelAnimFrame(id) {\n    if (id) {\n      cancelFn.call(window, id);\n    }\n  }\n  var Util = {\n    __proto__: null,\n    extend: extend,\n    create: create$2,\n    bind: bind,\n    get lastId() {\n      return lastId;\n    },\n    stamp: stamp,\n    throttle: throttle,\n    wrapNum: wrapNum,\n    falseFn: falseFn,\n    formatNum: formatNum,\n    trim: trim,\n    splitWords: splitWords,\n    setOptions: setOptions,\n    getParamString: getParamString,\n    template: template,\n    isArray: isArray,\n    indexOf: indexOf,\n    emptyImageUrl: emptyImageUrl,\n    requestFn: requestFn,\n    cancelFn: cancelFn,\n    requestAnimFrame: requestAnimFrame,\n    cancelAnimFrame: cancelAnimFrame\n  };\n\n  // @class Class\n  // @aka L.Class\n\n  // @section\n  // @uninheritable\n\n  // Thanks to John Resig and Dean Edwards for inspiration!\n\n  function Class() {}\n  Class.extend = function (props) {\n    // @function extend(props: Object): Function\n    // [Extends the current class](#class-inheritance) given the properties to be included.\n    // Returns a Javascript function that is a class constructor (to be called with `new`).\n    var NewClass = function NewClass() {\n      setOptions(this);\n\n      // call the constructor\n      if (this.initialize) {\n        this.initialize.apply(this, arguments);\n      }\n\n      // call all constructor hooks\n      this.callInitHooks();\n    };\n    var parentProto = NewClass.__super__ = this.prototype;\n    var proto = create$2(parentProto);\n    proto.constructor = NewClass;\n    NewClass.prototype = proto;\n\n    // inherit parent's statics\n    for (var i in this) {\n      if (Object.prototype.hasOwnProperty.call(this, i) && i !== 'prototype' && i !== '__super__') {\n        NewClass[i] = this[i];\n      }\n    }\n\n    // mix static properties into the class\n    if (props.statics) {\n      extend(NewClass, props.statics);\n    }\n\n    // mix includes into the prototype\n    if (props.includes) {\n      checkDeprecatedMixinEvents(props.includes);\n      extend.apply(null, [proto].concat(props.includes));\n    }\n\n    // mix given properties into the prototype\n    extend(proto, props);\n    delete proto.statics;\n    delete proto.includes;\n\n    // merge options\n    if (proto.options) {\n      proto.options = parentProto.options ? create$2(parentProto.options) : {};\n      extend(proto.options, props.options);\n    }\n    proto._initHooks = [];\n\n    // add method for calling all hooks\n    proto.callInitHooks = function () {\n      if (this._initHooksCalled) {\n        return;\n      }\n      if (parentProto.callInitHooks) {\n        parentProto.callInitHooks.call(this);\n      }\n      this._initHooksCalled = true;\n      for (var i = 0, len = proto._initHooks.length; i < len; i++) {\n        proto._initHooks[i].call(this);\n      }\n    };\n    return NewClass;\n  };\n\n  // @function include(properties: Object): this\n  // [Includes a mixin](#class-includes) into the current class.\n  Class.include = function (props) {\n    var parentOptions = this.prototype.options;\n    extend(this.prototype, props);\n    if (props.options) {\n      this.prototype.options = parentOptions;\n      this.mergeOptions(props.options);\n    }\n    return this;\n  };\n\n  // @function mergeOptions(options: Object): this\n  // [Merges `options`](#class-options) into the defaults of the class.\n  Class.mergeOptions = function (options) {\n    extend(this.prototype.options, options);\n    return this;\n  };\n\n  // @function addInitHook(fn: Function): this\n  // Adds a [constructor hook](#class-constructor-hooks) to the class.\n  Class.addInitHook = function (fn) {\n    // (Function) || (String, args...)\n    var args = Array.prototype.slice.call(arguments, 1);\n    var init = typeof fn === 'function' ? fn : function () {\n      this[fn].apply(this, args);\n    };\n    this.prototype._initHooks = this.prototype._initHooks || [];\n    this.prototype._initHooks.push(init);\n    return this;\n  };\n  function checkDeprecatedMixinEvents(includes) {\n    /* global L: true */\n    if (typeof L === 'undefined' || !L || !L.Mixin) {\n      return;\n    }\n    includes = isArray(includes) ? includes : [includes];\n    for (var i = 0; i < includes.length; i++) {\n      if (includes[i] === L.Mixin.Events) {\n        console.warn('Deprecated include of L.Mixin.Events: ' + 'this property will be removed in future releases, ' + 'please inherit from L.Evented instead.', new Error().stack);\n      }\n    }\n  }\n\n  /*\r\n   * @class Evented\r\n   * @aka L.Evented\r\n   * @inherits Class\r\n   *\r\n   * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * map.on('click', function(e) {\r\n   * \talert(e.latlng);\r\n   * } );\r\n   * ```\r\n   *\r\n   * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:\r\n   *\r\n   * ```js\r\n   * function onClick(e) { ... }\r\n   *\r\n   * map.on('click', onClick);\r\n   * map.off('click', onClick);\r\n   * ```\r\n   */\n\n  var Events = {\n    /* @method on(type: String, fn: Function, context?: Object): this\r\n     * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).\r\n     *\r\n     * @alternative\r\n     * @method on(eventMap: Object): this\r\n     * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\n     */\n    on: function on(types, fn, context) {\n      // types can be a map of types/handlers\n      if (_typeof(types) === 'object') {\n        for (var type in types) {\n          // we don't process space-separated events here for performance;\n          // it's a hot path since Layer uses the on(obj) syntax\n          this._on(type, types[type], fn);\n        }\n      } else {\n        // types can be a string of space-separated words\n        types = splitWords(types);\n        for (var i = 0, len = types.length; i < len; i++) {\n          this._on(types[i], fn, context);\n        }\n      }\n      return this;\n    },\n    /* @method off(type: String, fn?: Function, context?: Object): this\r\n     * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.\r\n     *\r\n     * @alternative\r\n     * @method off(eventMap: Object): this\r\n     * Removes a set of type/listener pairs.\r\n     *\r\n     * @alternative\r\n     * @method off: this\r\n     * Removes all listeners to all events on the object. This includes implicitly attached events.\r\n     */\n    off: function off(types, fn, context) {\n      if (!arguments.length) {\n        // clear all listeners if called without arguments\n        delete this._events;\n      } else if (_typeof(types) === 'object') {\n        for (var type in types) {\n          this._off(type, types[type], fn);\n        }\n      } else {\n        types = splitWords(types);\n        var removeAll = arguments.length === 1;\n        for (var i = 0, len = types.length; i < len; i++) {\n          if (removeAll) {\n            this._off(types[i]);\n          } else {\n            this._off(types[i], fn, context);\n          }\n        }\n      }\n      return this;\n    },\n    // attach listener (without syntactic sugar now)\n    _on: function _on(type, fn, context, _once) {\n      if (typeof fn !== 'function') {\n        console.warn('wrong listener type: ' + _typeof(fn));\n        return;\n      }\n\n      // check if fn already there\n      if (this._listens(type, fn, context) !== false) {\n        return;\n      }\n      if (context === this) {\n        // Less memory footprint.\n        context = undefined;\n      }\n      var newListener = {\n        fn: fn,\n        ctx: context\n      };\n      if (_once) {\n        newListener.once = true;\n      }\n      this._events = this._events || {};\n      this._events[type] = this._events[type] || [];\n      this._events[type].push(newListener);\n    },\n    _off: function _off(type, fn, context) {\n      var listeners, i, len;\n      if (!this._events) {\n        return;\n      }\n      listeners = this._events[type];\n      if (!listeners) {\n        return;\n      }\n      if (arguments.length === 1) {\n        // remove all\n        if (this._firingCount) {\n          // Set all removed listeners to noop\n          // so they are not called if remove happens in fire\n          for (i = 0, len = listeners.length; i < len; i++) {\n            listeners[i].fn = falseFn;\n          }\n        }\n        // clear all listeners for a type if function isn't specified\n        delete this._events[type];\n        return;\n      }\n      if (typeof fn !== 'function') {\n        console.warn('wrong listener type: ' + _typeof(fn));\n        return;\n      }\n\n      // find fn and remove it\n      var index = this._listens(type, fn, context);\n      if (index !== false) {\n        var listener = listeners[index];\n        if (this._firingCount) {\n          // set the removed listener to noop so that's not called if remove happens in fire\n          listener.fn = falseFn;\n\n          /* copy array in case events are being fired */\n          this._events[type] = listeners = listeners.slice();\n        }\n        listeners.splice(index, 1);\n      }\n    },\n    // @method fire(type: String, data?: Object, propagate?: Boolean): this\n    // Fires an event of the specified type. You can optionally provide a data\n    // object — the first argument of the listener function will contain its\n    // properties. The event can optionally be propagated to event parents.\n    fire: function fire(type, data, propagate) {\n      if (!this.listens(type, propagate)) {\n        return this;\n      }\n      var event = extend({}, data, {\n        type: type,\n        target: this,\n        sourceTarget: data && data.sourceTarget || this\n      });\n      if (this._events) {\n        var listeners = this._events[type];\n        if (listeners) {\n          this._firingCount = this._firingCount + 1 || 1;\n          for (var i = 0, len = listeners.length; i < len; i++) {\n            var l = listeners[i];\n            // off overwrites l.fn, so we need to copy fn to a var\n            var fn = l.fn;\n            if (l.once) {\n              this.off(type, fn, l.ctx);\n            }\n            fn.call(l.ctx || this, event);\n          }\n          this._firingCount--;\n        }\n      }\n      if (propagate) {\n        // propagate the event to parents (set with addEventParent)\n        this._propagateEvent(event);\n      }\n      return this;\n    },\n    // @method listens(type: String, propagate?: Boolean): Boolean\n    // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean\n    // Returns `true` if a particular event type has any listeners attached to it.\n    // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.\n    listens: function listens(type, fn, context, propagate) {\n      if (typeof type !== 'string') {\n        console.warn('\"string\" type argument expected');\n      }\n\n      // we don't overwrite the input `fn` value, because we need to use it for propagation\n      var _fn = fn;\n      if (typeof fn !== 'function') {\n        propagate = !!fn;\n        _fn = undefined;\n        context = undefined;\n      }\n      var listeners = this._events && this._events[type];\n      if (listeners && listeners.length) {\n        if (this._listens(type, _fn, context) !== false) {\n          return true;\n        }\n      }\n      if (propagate) {\n        // also check parents for listeners if event propagates\n        for (var id in this._eventParents) {\n          if (this._eventParents[id].listens(type, fn, context, propagate)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    },\n    // returns the index (number) or false\n    _listens: function _listens(type, fn, context) {\n      if (!this._events) {\n        return false;\n      }\n      var listeners = this._events[type] || [];\n      if (!fn) {\n        return !!listeners.length;\n      }\n      if (context === this) {\n        // Less memory footprint.\n        context = undefined;\n      }\n      for (var i = 0, len = listeners.length; i < len; i++) {\n        if (listeners[i].fn === fn && listeners[i].ctx === context) {\n          return i;\n        }\n      }\n      return false;\n    },\n    // @method once(…): this\n    // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.\n    once: function once(types, fn, context) {\n      // types can be a map of types/handlers\n      if (_typeof(types) === 'object') {\n        for (var type in types) {\n          // we don't process space-separated events here for performance;\n          // it's a hot path since Layer uses the on(obj) syntax\n          this._on(type, types[type], fn, true);\n        }\n      } else {\n        // types can be a string of space-separated words\n        types = splitWords(types);\n        for (var i = 0, len = types.length; i < len; i++) {\n          this._on(types[i], fn, context, true);\n        }\n      }\n      return this;\n    },\n    // @method addEventParent(obj: Evented): this\n    // Adds an event parent - an `Evented` that will receive propagated events\n    addEventParent: function addEventParent(obj) {\n      this._eventParents = this._eventParents || {};\n      this._eventParents[stamp(obj)] = obj;\n      return this;\n    },\n    // @method removeEventParent(obj: Evented): this\n    // Removes an event parent, so it will stop receiving propagated events\n    removeEventParent: function removeEventParent(obj) {\n      if (this._eventParents) {\n        delete this._eventParents[stamp(obj)];\n      }\n      return this;\n    },\n    _propagateEvent: function _propagateEvent(e) {\n      for (var id in this._eventParents) {\n        this._eventParents[id].fire(e.type, extend({\n          layer: e.target,\n          propagatedFrom: e.target\n        }, e), true);\n      }\n    }\n  };\n\n  // aliases; we should ditch those eventually\n\n  // @method addEventListener(…): this\n  // Alias to [`on(…)`](#evented-on)\n  Events.addEventListener = Events.on;\n\n  // @method removeEventListener(…): this\n  // Alias to [`off(…)`](#evented-off)\n\n  // @method clearAllEventListeners(…): this\n  // Alias to [`off()`](#evented-off)\n  Events.removeEventListener = Events.clearAllEventListeners = Events.off;\n\n  // @method addOneTimeEventListener(…): this\n  // Alias to [`once(…)`](#evented-once)\n  Events.addOneTimeEventListener = Events.once;\n\n  // @method fireEvent(…): this\n  // Alias to [`fire(…)`](#evented-fire)\n  Events.fireEvent = Events.fire;\n\n  // @method hasEventListeners(…): Boolean\n  // Alias to [`listens(…)`](#evented-listens)\n  Events.hasEventListeners = Events.listens;\n  var Evented = Class.extend(Events);\n\n  /*\r\n   * @class Point\r\n   * @aka L.Point\r\n   *\r\n   * Represents a point with `x` and `y` coordinates in pixels.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var point = L.point(200, 300);\r\n   * ```\r\n   *\r\n   * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```js\r\n   * map.panBy([200, 300]);\r\n   * map.panBy(L.point(200, 300));\r\n   * ```\r\n   *\r\n   * Note that `Point` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n  function Point(x, y, round) {\n    // @property x: Number; The `x` coordinate of the point\n    this.x = round ? Math.round(x) : x;\n    // @property y: Number; The `y` coordinate of the point\n    this.y = round ? Math.round(y) : y;\n  }\n  var trunc = Math.trunc || function (v) {\n    return v > 0 ? Math.floor(v) : Math.ceil(v);\n  };\n  Point.prototype = {\n    // @method clone(): Point\n    // Returns a copy of the current point.\n    clone: function clone() {\n      return new Point(this.x, this.y);\n    },\n    // @method add(otherPoint: Point): Point\n    // Returns the result of addition of the current and the given points.\n    add: function add(point) {\n      // non-destructive, returns a new point\n      return this.clone()._add(toPoint(point));\n    },\n    _add: function _add(point) {\n      // destructive, used directly for performance in situations where it's safe to modify existing point\n      this.x += point.x;\n      this.y += point.y;\n      return this;\n    },\n    // @method subtract(otherPoint: Point): Point\n    // Returns the result of subtraction of the given point from the current.\n    subtract: function subtract(point) {\n      return this.clone()._subtract(toPoint(point));\n    },\n    _subtract: function _subtract(point) {\n      this.x -= point.x;\n      this.y -= point.y;\n      return this;\n    },\n    // @method divideBy(num: Number): Point\n    // Returns the result of division of the current point by the given number.\n    divideBy: function divideBy(num) {\n      return this.clone()._divideBy(num);\n    },\n    _divideBy: function _divideBy(num) {\n      this.x /= num;\n      this.y /= num;\n      return this;\n    },\n    // @method multiplyBy(num: Number): Point\n    // Returns the result of multiplication of the current point by the given number.\n    multiplyBy: function multiplyBy(num) {\n      return this.clone()._multiplyBy(num);\n    },\n    _multiplyBy: function _multiplyBy(num) {\n      this.x *= num;\n      this.y *= num;\n      return this;\n    },\n    // @method scaleBy(scale: Point): Point\n    // Multiply each coordinate of the current point by each coordinate of\n    // `scale`. In linear algebra terms, multiply the point by the\n    // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)\n    // defined by `scale`.\n    scaleBy: function scaleBy(point) {\n      return new Point(this.x * point.x, this.y * point.y);\n    },\n    // @method unscaleBy(scale: Point): Point\n    // Inverse of `scaleBy`. Divide each coordinate of the current point by\n    // each coordinate of `scale`.\n    unscaleBy: function unscaleBy(point) {\n      return new Point(this.x / point.x, this.y / point.y);\n    },\n    // @method round(): Point\n    // Returns a copy of the current point with rounded coordinates.\n    round: function round() {\n      return this.clone()._round();\n    },\n    _round: function _round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      return this;\n    },\n    // @method floor(): Point\n    // Returns a copy of the current point with floored coordinates (rounded down).\n    floor: function floor() {\n      return this.clone()._floor();\n    },\n    _floor: function _floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      return this;\n    },\n    // @method ceil(): Point\n    // Returns a copy of the current point with ceiled coordinates (rounded up).\n    ceil: function ceil() {\n      return this.clone()._ceil();\n    },\n    _ceil: function _ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      return this;\n    },\n    // @method trunc(): Point\n    // Returns a copy of the current point with truncated coordinates (rounded towards zero).\n    trunc: function trunc() {\n      return this.clone()._trunc();\n    },\n    _trunc: function _trunc() {\n      this.x = trunc(this.x);\n      this.y = trunc(this.y);\n      return this;\n    },\n    // @method distanceTo(otherPoint: Point): Number\n    // Returns the cartesian distance between the current and the given points.\n    distanceTo: function distanceTo(point) {\n      point = toPoint(point);\n      var x = point.x - this.x,\n        y = point.y - this.y;\n      return Math.sqrt(x * x + y * y);\n    },\n    // @method equals(otherPoint: Point): Boolean\n    // Returns `true` if the given point has the same coordinates.\n    equals: function equals(point) {\n      point = toPoint(point);\n      return point.x === this.x && point.y === this.y;\n    },\n    // @method contains(otherPoint: Point): Boolean\n    // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).\n    contains: function contains(point) {\n      point = toPoint(point);\n      return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);\n    },\n    // @method toString(): String\n    // Returns a string representation of the point for debugging purposes.\n    toString: function toString() {\n      return 'Point(' + formatNum(this.x) + ', ' + formatNum(this.y) + ')';\n    }\n  };\n\n  // @factory L.point(x: Number, y: Number, round?: Boolean)\n  // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.\n\n  // @alternative\n  // @factory L.point(coords: Number[])\n  // Expects an array of the form `[x, y]` instead.\n\n  // @alternative\n  // @factory L.point(coords: Object)\n  // Expects a plain object of the form `{x: Number, y: Number}` instead.\n  function toPoint(x, y, round) {\n    if (x instanceof Point) {\n      return x;\n    }\n    if (isArray(x)) {\n      return new Point(x[0], x[1]);\n    }\n    if (x === undefined || x === null) {\n      return x;\n    }\n    if (_typeof(x) === 'object' && 'x' in x && 'y' in x) {\n      return new Point(x.x, x.y);\n    }\n    return new Point(x, y, round);\n  }\n\n  /*\r\n   * @class Bounds\r\n   * @aka L.Bounds\r\n   *\r\n   * Represents a rectangular area in pixel coordinates.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var p1 = L.point(10, 10),\r\n   * p2 = L.point(40, 60),\r\n   * bounds = L.bounds(p1, p2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * otherBounds.intersects([[10, 10], [40, 60]]);\r\n   * ```\r\n   *\r\n   * Note that `Bounds` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n  function Bounds(a, b) {\n    if (!a) {\n      return;\n    }\n    var points = b ? [a, b] : a;\n    for (var i = 0, len = points.length; i < len; i++) {\n      this.extend(points[i]);\n    }\n  }\n  Bounds.prototype = {\n    // @method extend(point: Point): this\n    // Extends the bounds to contain the given point.\n\n    // @alternative\n    // @method extend(otherBounds: Bounds): this\n    // Extend the bounds to contain the given bounds\n    extend: function extend(obj) {\n      var min2, max2;\n      if (!obj) {\n        return this;\n      }\n      if (obj instanceof Point || typeof obj[0] === 'number' || 'x' in obj) {\n        min2 = max2 = toPoint(obj);\n      } else {\n        obj = toBounds(obj);\n        min2 = obj.min;\n        max2 = obj.max;\n        if (!min2 || !max2) {\n          return this;\n        }\n      }\n\n      // @property min: Point\n      // The top left corner of the rectangle.\n      // @property max: Point\n      // The bottom right corner of the rectangle.\n      if (!this.min && !this.max) {\n        this.min = min2.clone();\n        this.max = max2.clone();\n      } else {\n        this.min.x = Math.min(min2.x, this.min.x);\n        this.max.x = Math.max(max2.x, this.max.x);\n        this.min.y = Math.min(min2.y, this.min.y);\n        this.max.y = Math.max(max2.y, this.max.y);\n      }\n      return this;\n    },\n    // @method getCenter(round?: Boolean): Point\n    // Returns the center point of the bounds.\n    getCenter: function getCenter(round) {\n      return toPoint((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);\n    },\n    // @method getBottomLeft(): Point\n    // Returns the bottom-left point of the bounds.\n    getBottomLeft: function getBottomLeft() {\n      return toPoint(this.min.x, this.max.y);\n    },\n    // @method getTopRight(): Point\n    // Returns the top-right point of the bounds.\n    getTopRight: function getTopRight() {\n      // -> Point\n      return toPoint(this.max.x, this.min.y);\n    },\n    // @method getTopLeft(): Point\n    // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).\n    getTopLeft: function getTopLeft() {\n      return this.min; // left, top\n    },\n    // @method getBottomRight(): Point\n    // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).\n    getBottomRight: function getBottomRight() {\n      return this.max; // right, bottom\n    },\n    // @method getSize(): Point\n    // Returns the size of the given bounds\n    getSize: function getSize() {\n      return this.max.subtract(this.min);\n    },\n    // @method contains(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle contains the given one.\n    // @alternative\n    // @method contains(point: Point): Boolean\n    // Returns `true` if the rectangle contains the given point.\n    contains: function contains(obj) {\n      var min, max;\n      if (typeof obj[0] === 'number' || obj instanceof Point) {\n        obj = toPoint(obj);\n      } else {\n        obj = toBounds(obj);\n      }\n      if (obj instanceof Bounds) {\n        min = obj.min;\n        max = obj.max;\n      } else {\n        min = max = obj;\n      }\n      return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;\n    },\n    // @method intersects(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle intersects the given bounds. Two bounds\n    // intersect if they have at least one point in common.\n    intersects: function intersects(bounds) {\n      // (Bounds) -> Boolean\n      bounds = toBounds(bounds);\n      var min = this.min,\n        max = this.max,\n        min2 = bounds.min,\n        max2 = bounds.max,\n        xIntersects = max2.x >= min.x && min2.x <= max.x,\n        yIntersects = max2.y >= min.y && min2.y <= max.y;\n      return xIntersects && yIntersects;\n    },\n    // @method overlaps(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle overlaps the given bounds. Two bounds\n    // overlap if their intersection is an area.\n    overlaps: function overlaps(bounds) {\n      // (Bounds) -> Boolean\n      bounds = toBounds(bounds);\n      var min = this.min,\n        max = this.max,\n        min2 = bounds.min,\n        max2 = bounds.max,\n        xOverlaps = max2.x > min.x && min2.x < max.x,\n        yOverlaps = max2.y > min.y && min2.y < max.y;\n      return xOverlaps && yOverlaps;\n    },\n    // @method isValid(): Boolean\n    // Returns `true` if the bounds are properly initialized.\n    isValid: function isValid() {\n      return !!(this.min && this.max);\n    },\n    // @method pad(bufferRatio: Number): Bounds\n    // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.\n    // For example, a ratio of 0.5 extends the bounds by 50% in each direction.\n    // Negative values will retract the bounds.\n    pad: function pad(bufferRatio) {\n      var min = this.min,\n        max = this.max,\n        heightBuffer = Math.abs(min.x - max.x) * bufferRatio,\n        widthBuffer = Math.abs(min.y - max.y) * bufferRatio;\n      return toBounds(toPoint(min.x - heightBuffer, min.y - widthBuffer), toPoint(max.x + heightBuffer, max.y + widthBuffer));\n    },\n    // @method equals(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle is equivalent to the given bounds.\n    equals: function equals(bounds) {\n      if (!bounds) {\n        return false;\n      }\n      bounds = toBounds(bounds);\n      return this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight());\n    }\n  };\n\n  // @factory L.bounds(corner1: Point, corner2: Point)\n  // Creates a Bounds object from two corners coordinate pairs.\n  // @alternative\n  // @factory L.bounds(points: Point[])\n  // Creates a Bounds object from the given array of points.\n  function toBounds(a, b) {\n    if (!a || a instanceof Bounds) {\n      return a;\n    }\n    return new Bounds(a, b);\n  }\n\n  /*\r\n   * @class LatLngBounds\r\n   * @aka L.LatLngBounds\r\n   *\r\n   * Represents a rectangular geographical area on a map.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var corner1 = L.latLng(40.712, -74.227),\r\n   * corner2 = L.latLng(40.774, -74.125),\r\n   * bounds = L.latLngBounds(corner1, corner2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * map.fitBounds([\r\n   * \t[40.712, -74.227],\r\n   * \t[40.774, -74.125]\r\n   * ]);\r\n   * ```\r\n   *\r\n   * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.\r\n   *\r\n   * Note that `LatLngBounds` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n  function LatLngBounds(corner1, corner2) {\n    // (LatLng, LatLng) or (LatLng[])\n    if (!corner1) {\n      return;\n    }\n    var latlngs = corner2 ? [corner1, corner2] : corner1;\n    for (var i = 0, len = latlngs.length; i < len; i++) {\n      this.extend(latlngs[i]);\n    }\n  }\n  LatLngBounds.prototype = {\n    // @method extend(latlng: LatLng): this\n    // Extend the bounds to contain the given point\n\n    // @alternative\n    // @method extend(otherBounds: LatLngBounds): this\n    // Extend the bounds to contain the given bounds\n    extend: function extend(obj) {\n      var sw = this._southWest,\n        ne = this._northEast,\n        sw2,\n        ne2;\n      if (obj instanceof LatLng) {\n        sw2 = obj;\n        ne2 = obj;\n      } else if (obj instanceof LatLngBounds) {\n        sw2 = obj._southWest;\n        ne2 = obj._northEast;\n        if (!sw2 || !ne2) {\n          return this;\n        }\n      } else {\n        return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;\n      }\n      if (!sw && !ne) {\n        this._southWest = new LatLng(sw2.lat, sw2.lng);\n        this._northEast = new LatLng(ne2.lat, ne2.lng);\n      } else {\n        sw.lat = Math.min(sw2.lat, sw.lat);\n        sw.lng = Math.min(sw2.lng, sw.lng);\n        ne.lat = Math.max(ne2.lat, ne.lat);\n        ne.lng = Math.max(ne2.lng, ne.lng);\n      }\n      return this;\n    },\n    // @method pad(bufferRatio: Number): LatLngBounds\n    // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.\n    // For example, a ratio of 0.5 extends the bounds by 50% in each direction.\n    // Negative values will retract the bounds.\n    pad: function pad(bufferRatio) {\n      var sw = this._southWest,\n        ne = this._northEast,\n        heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\n        widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\n      return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\n    },\n    // @method getCenter(): LatLng\n    // Returns the center point of the bounds.\n    getCenter: function getCenter() {\n      return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);\n    },\n    // @method getSouthWest(): LatLng\n    // Returns the south-west point of the bounds.\n    getSouthWest: function getSouthWest() {\n      return this._southWest;\n    },\n    // @method getNorthEast(): LatLng\n    // Returns the north-east point of the bounds.\n    getNorthEast: function getNorthEast() {\n      return this._northEast;\n    },\n    // @method getNorthWest(): LatLng\n    // Returns the north-west point of the bounds.\n    getNorthWest: function getNorthWest() {\n      return new LatLng(this.getNorth(), this.getWest());\n    },\n    // @method getSouthEast(): LatLng\n    // Returns the south-east point of the bounds.\n    getSouthEast: function getSouthEast() {\n      return new LatLng(this.getSouth(), this.getEast());\n    },\n    // @method getWest(): Number\n    // Returns the west longitude of the bounds\n    getWest: function getWest() {\n      return this._southWest.lng;\n    },\n    // @method getSouth(): Number\n    // Returns the south latitude of the bounds\n    getSouth: function getSouth() {\n      return this._southWest.lat;\n    },\n    // @method getEast(): Number\n    // Returns the east longitude of the bounds\n    getEast: function getEast() {\n      return this._northEast.lng;\n    },\n    // @method getNorth(): Number\n    // Returns the north latitude of the bounds\n    getNorth: function getNorth() {\n      return this._northEast.lat;\n    },\n    // @method contains(otherBounds: LatLngBounds): Boolean\n    // Returns `true` if the rectangle contains the given one.\n\n    // @alternative\n    // @method contains (latlng: LatLng): Boolean\n    // Returns `true` if the rectangle contains the given point.\n    contains: function contains(obj) {\n      // (LatLngBounds) or (LatLng) -> Boolean\n      if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {\n        obj = toLatLng(obj);\n      } else {\n        obj = toLatLngBounds(obj);\n      }\n      var sw = this._southWest,\n        ne = this._northEast,\n        sw2,\n        ne2;\n      if (obj instanceof LatLngBounds) {\n        sw2 = obj.getSouthWest();\n        ne2 = obj.getNorthEast();\n      } else {\n        sw2 = ne2 = obj;\n      }\n      return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;\n    },\n    // @method intersects(otherBounds: LatLngBounds): Boolean\n    // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.\n    intersects: function intersects(bounds) {\n      bounds = toLatLngBounds(bounds);\n      var sw = this._southWest,\n        ne = this._northEast,\n        sw2 = bounds.getSouthWest(),\n        ne2 = bounds.getNorthEast(),\n        latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat,\n        lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;\n      return latIntersects && lngIntersects;\n    },\n    // @method overlaps(otherBounds: LatLngBounds): Boolean\n    // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.\n    overlaps: function overlaps(bounds) {\n      bounds = toLatLngBounds(bounds);\n      var sw = this._southWest,\n        ne = this._northEast,\n        sw2 = bounds.getSouthWest(),\n        ne2 = bounds.getNorthEast(),\n        latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat,\n        lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;\n      return latOverlaps && lngOverlaps;\n    },\n    // @method toBBoxString(): String\n    // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.\n    toBBoxString: function toBBoxString() {\n      return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\n    },\n    // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean\n    // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.\n    equals: function equals(bounds, maxMargin) {\n      if (!bounds) {\n        return false;\n      }\n      bounds = toLatLngBounds(bounds);\n      return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);\n    },\n    // @method isValid(): Boolean\n    // Returns `true` if the bounds are properly initialized.\n    isValid: function isValid() {\n      return !!(this._southWest && this._northEast);\n    }\n  };\n\n  // TODO International date line?\n\n  // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)\n  // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.\n\n  // @alternative\n  // @factory L.latLngBounds(latlngs: LatLng[])\n  // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).\n  function toLatLngBounds(a, b) {\n    if (a instanceof LatLngBounds) {\n      return a;\n    }\n    return new LatLngBounds(a, b);\n  }\n\n  /* @class LatLng\r\n   * @aka L.LatLng\r\n   *\r\n   * Represents a geographical point with a certain latitude and longitude.\r\n   *\r\n   * @example\r\n   *\r\n   * ```\r\n   * var latlng = L.latLng(50.5, 30.5);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```\r\n   * map.panTo([50, 30]);\r\n   * map.panTo({lon: 30, lat: 50});\r\n   * map.panTo({lat: 50, lng: 30});\r\n   * map.panTo(L.latLng(50, 30));\r\n   * ```\r\n   *\r\n   * Note that `LatLng` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n  function LatLng(lat, lng, alt) {\n    if (isNaN(lat) || isNaN(lng)) {\n      throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\n    }\n\n    // @property lat: Number\n    // Latitude in degrees\n    this.lat = +lat;\n\n    // @property lng: Number\n    // Longitude in degrees\n    this.lng = +lng;\n\n    // @property alt: Number\n    // Altitude in meters (optional)\n    if (alt !== undefined) {\n      this.alt = +alt;\n    }\n  }\n  LatLng.prototype = {\n    // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean\n    // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.\n    equals: function equals(obj, maxMargin) {\n      if (!obj) {\n        return false;\n      }\n      obj = toLatLng(obj);\n      var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));\n      return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);\n    },\n    // @method toString(): String\n    // Returns a string representation of the point (for debugging purposes).\n    toString: function toString(precision) {\n      return 'LatLng(' + formatNum(this.lat, precision) + ', ' + formatNum(this.lng, precision) + ')';\n    },\n    // @method distanceTo(otherLatLng: LatLng): Number\n    // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).\n    distanceTo: function distanceTo(other) {\n      return Earth.distance(this, toLatLng(other));\n    },\n    // @method wrap(): LatLng\n    // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.\n    wrap: function wrap() {\n      return Earth.wrapLatLng(this);\n    },\n    // @method toBounds(sizeInMeters: Number): LatLngBounds\n    // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.\n    toBounds: function toBounds(sizeInMeters) {\n      var latAccuracy = 180 * sizeInMeters / 40075017,\n        lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);\n      return toLatLngBounds([this.lat - latAccuracy, this.lng - lngAccuracy], [this.lat + latAccuracy, this.lng + lngAccuracy]);\n    },\n    clone: function clone() {\n      return new LatLng(this.lat, this.lng, this.alt);\n    }\n  };\n\n  // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng\n  // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).\n\n  // @alternative\n  // @factory L.latLng(coords: Array): LatLng\n  // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.\n\n  // @alternative\n  // @factory L.latLng(coords: Object): LatLng\n  // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.\n\n  function toLatLng(a, b, c) {\n    if (a instanceof LatLng) {\n      return a;\n    }\n    if (isArray(a) && _typeof(a[0]) !== 'object') {\n      if (a.length === 3) {\n        return new LatLng(a[0], a[1], a[2]);\n      }\n      if (a.length === 2) {\n        return new LatLng(a[0], a[1]);\n      }\n      return null;\n    }\n    if (a === undefined || a === null) {\n      return a;\n    }\n    if (_typeof(a) === 'object' && 'lat' in a) {\n      return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);\n    }\n    if (b === undefined) {\n      return null;\n    }\n    return new LatLng(a, b, c);\n  }\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.Base\r\n   * Object that defines coordinate reference systems for projecting\r\n   * geographical points into pixel (screen) coordinates and back (and to\r\n   * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See\r\n   * [spatial reference system](https://en.wikipedia.org/wiki/Spatial_reference_system).\r\n   *\r\n   * Leaflet defines the most usual CRSs by default. If you want to use a\r\n   * CRS not defined by default, take a look at the\r\n   * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.\r\n   *\r\n   * Note that the CRS instances do not inherit from Leaflet's `Class` object,\r\n   * and can't be instantiated. Also, new classes can't inherit from them,\r\n   * and methods can't be added to them with the `include` function.\r\n   */\n\n  var CRS = {\n    // @method latLngToPoint(latlng: LatLng, zoom: Number): Point\n    // Projects geographical coordinates into pixel coordinates for a given zoom.\n    latLngToPoint: function latLngToPoint(latlng, zoom) {\n      var projectedPoint = this.projection.project(latlng),\n        scale = this.scale(zoom);\n      return this.transformation._transform(projectedPoint, scale);\n    },\n    // @method pointToLatLng(point: Point, zoom: Number): LatLng\n    // The inverse of `latLngToPoint`. Projects pixel coordinates on a given\n    // zoom into geographical coordinates.\n    pointToLatLng: function pointToLatLng(point, zoom) {\n      var scale = this.scale(zoom),\n        untransformedPoint = this.transformation.untransform(point, scale);\n      return this.projection.unproject(untransformedPoint);\n    },\n    // @method project(latlng: LatLng): Point\n    // Projects geographical coordinates into coordinates in units accepted for\n    // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).\n    project: function project(latlng) {\n      return this.projection.project(latlng);\n    },\n    // @method unproject(point: Point): LatLng\n    // Given a projected coordinate returns the corresponding LatLng.\n    // The inverse of `project`.\n    unproject: function unproject(point) {\n      return this.projection.unproject(point);\n    },\n    // @method scale(zoom: Number): Number\n    // Returns the scale used when transforming projected coordinates into\n    // pixel coordinates for a particular zoom. For example, it returns\n    // `256 * 2^zoom` for Mercator-based CRS.\n    scale: function scale(zoom) {\n      return 256 * Math.pow(2, zoom);\n    },\n    // @method zoom(scale: Number): Number\n    // Inverse of `scale()`, returns the zoom level corresponding to a scale\n    // factor of `scale`.\n    zoom: function zoom(scale) {\n      return Math.log(scale / 256) / Math.LN2;\n    },\n    // @method getProjectedBounds(zoom: Number): Bounds\n    // Returns the projection's bounds scaled and transformed for the provided `zoom`.\n    getProjectedBounds: function getProjectedBounds(zoom) {\n      if (this.infinite) {\n        return null;\n      }\n      var b = this.projection.bounds,\n        s = this.scale(zoom),\n        min = this.transformation.transform(b.min, s),\n        max = this.transformation.transform(b.max, s);\n      return new Bounds(min, max);\n    },\n    // @method distance(latlng1: LatLng, latlng2: LatLng): Number\n    // Returns the distance between two geographical coordinates.\n\n    // @property code: String\n    // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)\n    //\n    // @property wrapLng: Number[]\n    // An array of two numbers defining whether the longitude (horizontal) coordinate\n    // axis wraps around a given range and how. Defaults to `[-180, 180]` in most\n    // geographical CRSs. If `undefined`, the longitude axis does not wrap around.\n    //\n    // @property wrapLat: Number[]\n    // Like `wrapLng`, but for the latitude (vertical) axis.\n\n    // wrapLng: [min, max],\n    // wrapLat: [min, max],\n\n    // @property infinite: Boolean\n    // If true, the coordinate space will be unbounded (infinite in both axes)\n    infinite: false,\n    // @method wrapLatLng(latlng: LatLng): LatLng\n    // Returns a `LatLng` where lat and lng has been wrapped according to the\n    // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.\n    wrapLatLng: function wrapLatLng(latlng) {\n      var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,\n        lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,\n        alt = latlng.alt;\n      return new LatLng(lat, lng, alt);\n    },\n    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\n    // Returns a `LatLngBounds` with the same size as the given one, ensuring\n    // that its center is within the CRS's bounds.\n    // Only accepts actual `L.LatLngBounds` instances, not arrays.\n    wrapLatLngBounds: function wrapLatLngBounds(bounds) {\n      var center = bounds.getCenter(),\n        newCenter = this.wrapLatLng(center),\n        latShift = center.lat - newCenter.lat,\n        lngShift = center.lng - newCenter.lng;\n      if (latShift === 0 && lngShift === 0) {\n        return bounds;\n      }\n      var sw = bounds.getSouthWest(),\n        ne = bounds.getNorthEast(),\n        newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),\n        newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);\n      return new LatLngBounds(newSw, newNe);\n    }\n  };\n\n  /*\n   * @namespace CRS\n   * @crs L.CRS.Earth\n   *\n   * Serves as the base for CRS that are global such that they cover the earth.\n   * Can only be used as the base for other CRS and cannot be used directly,\n   * since it does not have a `code`, `projection` or `transformation`. `distance()` returns\n   * meters.\n   */\n\n  var Earth = extend({}, CRS, {\n    wrapLng: [-180, 180],\n    // Mean Earth Radius, as recommended for use by\n    // the International Union of Geodesy and Geophysics,\n    // see https://rosettacode.org/wiki/Haversine_formula\n    R: 6371000,\n    // distance between two geographical points using spherical law of cosines approximation\n    distance: function distance(latlng1, latlng2) {\n      var rad = Math.PI / 180,\n        lat1 = latlng1.lat * rad,\n        lat2 = latlng2.lat * rad,\n        sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),\n        sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),\n        a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,\n        c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n      return this.R * c;\n    }\n  });\n\n  /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.SphericalMercator\r\n   *\r\n   * Spherical Mercator projection — the most common projection for online maps,\r\n   * used by almost all free and commercial tile providers. Assumes that Earth is\r\n   * a sphere. Used by the `EPSG:3857` CRS.\r\n   */\n\n  var earthRadius = 6378137;\n  var SphericalMercator = {\n    R: earthRadius,\n    MAX_LATITUDE: 85.0511287798,\n    project: function project(latlng) {\n      var d = Math.PI / 180,\n        max = this.MAX_LATITUDE,\n        lat = Math.max(Math.min(max, latlng.lat), -max),\n        sin = Math.sin(lat * d);\n      return new Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);\n    },\n    unproject: function unproject(point) {\n      var d = 180 / Math.PI;\n      return new LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);\n    },\n    bounds: function () {\n      var d = earthRadius * Math.PI;\n      return new Bounds([-d, -d], [d, d]);\n    }()\n  };\n\n  /*\r\n   * @class Transformation\r\n   * @aka L.Transformation\r\n   *\r\n   * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`\r\n   * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing\r\n   * the reverse. Used by Leaflet in its projections code.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var transformation = L.transformation(2, 5, -1, 10),\r\n   * \tp = L.point(1, 2),\r\n   * \tp2 = transformation.transform(p), //  L.point(7, 8)\r\n   * \tp3 = transformation.untransform(p2); //  L.point(1, 2)\r\n   * ```\r\n   */\n\n  // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)\n  // Creates a `Transformation` object with the given coefficients.\n  function Transformation(a, b, c, d) {\n    if (isArray(a)) {\n      // use array properties\n      this._a = a[0];\n      this._b = a[1];\n      this._c = a[2];\n      this._d = a[3];\n      return;\n    }\n    this._a = a;\n    this._b = b;\n    this._c = c;\n    this._d = d;\n  }\n  Transformation.prototype = {\n    // @method transform(point: Point, scale?: Number): Point\n    // Returns a transformed point, optionally multiplied by the given scale.\n    // Only accepts actual `L.Point` instances, not arrays.\n    transform: function transform(point, scale) {\n      // (Point, Number) -> Point\n      return this._transform(point.clone(), scale);\n    },\n    // destructive transform (faster)\n    _transform: function _transform(point, scale) {\n      scale = scale || 1;\n      point.x = scale * (this._a * point.x + this._b);\n      point.y = scale * (this._c * point.y + this._d);\n      return point;\n    },\n    // @method untransform(point: Point, scale?: Number): Point\n    // Returns the reverse transformation of the given point, optionally divided\n    // by the given scale. Only accepts actual `L.Point` instances, not arrays.\n    untransform: function untransform(point, scale) {\n      scale = scale || 1;\n      return new Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);\n    }\n  };\n\n  // factory L.transformation(a: Number, b: Number, c: Number, d: Number)\n\n  // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)\n  // Instantiates a Transformation object with the given coefficients.\n\n  // @alternative\n  // @factory L.transformation(coefficients: Array): Transformation\n  // Expects an coefficients array of the form\n  // `[a: Number, b: Number, c: Number, d: Number]`.\n\n  function toTransformation(a, b, c, d) {\n    return new Transformation(a, b, c, d);\n  }\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3857\r\n   *\r\n   * The most common CRS for online maps, used by almost all free and commercial\r\n   * tile providers. Uses Spherical Mercator projection. Set in by default in\r\n   * Map's `crs` option.\r\n   */\n\n  var EPSG3857 = extend({}, Earth, {\n    code: 'EPSG:3857',\n    projection: SphericalMercator,\n    transformation: function () {\n      var scale = 0.5 / (Math.PI * SphericalMercator.R);\n      return toTransformation(scale, 0.5, -scale, 0.5);\n    }()\n  });\n  var EPSG900913 = extend({}, EPSG3857, {\n    code: 'EPSG:900913'\n  });\n\n  // @namespace SVG; @section\n  // There are several static functions which can be called without instantiating L.SVG:\n\n  // @function create(name: String): SVGElement\n  // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),\n  // corresponding to the class name passed. For example, using 'line' will return\n  // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).\n  function svgCreate(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n  }\n\n  // @function pointsToPath(rings: Point[], closed: Boolean): String\n  // Generates a SVG path string for multiple rings, with each ring turning\n  // into \"M..L..L..\" instructions\n  function pointsToPath(rings, closed) {\n    var str = '',\n      i,\n      j,\n      len,\n      len2,\n      points,\n      p;\n    for (i = 0, len = rings.length; i < len; i++) {\n      points = rings[i];\n      for (j = 0, len2 = points.length; j < len2; j++) {\n        p = points[j];\n        str += (j ? 'L' : 'M') + p.x + ' ' + p.y;\n      }\n\n      // closes the ring for polygons; \"x\" is VML syntax\n      str += closed ? Browser.svg ? 'z' : 'x' : '';\n    }\n\n    // SVG complains about empty path strings\n    return str || 'M0 0';\n  }\n\n  /*\r\n   * @namespace Browser\r\n   * @aka L.Browser\r\n   *\r\n   * A namespace with static properties for browser/feature detection used by Leaflet internally.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * if (L.Browser.ielt9) {\r\n   *   alert('Upgrade your browser, dude!');\r\n   * }\r\n   * ```\r\n   */\n\n  var style = document.documentElement.style;\n\n  // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).\n  var ie = 'ActiveXObject' in window;\n\n  // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.\n  var ielt9 = ie && !document.addEventListener;\n\n  // @property edge: Boolean; `true` for the Edge web browser.\n  var edge = 'msLaunchUri' in navigator && !('documentMode' in document);\n\n  // @property webkit: Boolean;\n  // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).\n  var webkit = userAgentContains('webkit');\n\n  // @property android: Boolean\n  // **Deprecated.** `true` for any browser running on an Android platform.\n  var android = userAgentContains('android');\n\n  // @property android23: Boolean; **Deprecated.** `true` for browsers running on Android 2 or Android 3.\n  var android23 = userAgentContains('android 2') || userAgentContains('android 3');\n\n  /* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */\n  var webkitVer = parseInt(/WebKit\\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit\n  // @property androidStock: Boolean; **Deprecated.** `true` for the Android stock browser (i.e. not Chrome)\n  var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window);\n\n  // @property opera: Boolean; `true` for the Opera browser\n  var opera = !!window.opera;\n\n  // @property chrome: Boolean; `true` for the Chrome browser.\n  var chrome = !edge && userAgentContains('chrome');\n\n  // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.\n  var gecko = userAgentContains('gecko') && !webkit && !opera && !ie;\n\n  // @property safari: Boolean; `true` for the Safari browser.\n  var safari = !chrome && userAgentContains('safari');\n  var phantom = userAgentContains('phantom');\n\n  // @property opera12: Boolean\n  // `true` for the Opera browser supporting CSS transforms (version 12 or later).\n  var opera12 = 'OTransition' in style;\n\n  // @property win: Boolean; `true` when the browser is running in a Windows platform\n  var win = navigator.platform.indexOf('Win') === 0;\n\n  // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.\n  var ie3d = ie && 'transition' in style;\n\n  // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.\n  var webkit3d = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() && !android23;\n\n  // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.\n  var gecko3d = 'MozPerspective' in style;\n\n  // @property any3d: Boolean\n  // `true` for all browsers supporting CSS transforms.\n  var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;\n\n  // @property mobile: Boolean; `true` for all browsers running in a mobile device.\n  var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');\n\n  // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.\n  var mobileWebkit = mobile && webkit;\n\n  // @property mobileWebkit3d: Boolean\n  // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.\n  var mobileWebkit3d = mobile && webkit3d;\n\n  // @property msPointer: Boolean\n  // `true` for browsers implementing the Microsoft touch events model (notably IE10).\n  var msPointer = !window.PointerEvent && window.MSPointerEvent;\n\n  // @property pointer: Boolean\n  // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).\n  var pointer = !!(window.PointerEvent || msPointer);\n\n  // @property touchNative: Boolean\n  // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).\n  // **This does not necessarily mean** that the browser is running in a computer with\n  // a touchscreen, it only means that the browser is capable of understanding\n  // touch events.\n  var touchNative = 'ontouchstart' in window || !!window.TouchEvent;\n\n  // @property touch: Boolean\n  // `true` for all browsers supporting either [touch](#browser-touch) or [pointer](#browser-pointer) events.\n  // Note: pointer events will be preferred (if available), and processed for all `touch*` listeners.\n  var touch = !window.L_NO_TOUCH && (touchNative || pointer);\n\n  // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.\n  var mobileOpera = mobile && opera;\n\n  // @property mobileGecko: Boolean\n  // `true` for gecko-based browsers running in a mobile device.\n  var mobileGecko = mobile && gecko;\n\n  // @property retina: Boolean\n  // `true` for browsers on a high-resolution \"retina\" screen or on any screen when browser's display zoom is more than 100%.\n  var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;\n\n  // @property passiveEvents: Boolean\n  // `true` for browsers that support passive events.\n  var passiveEvents = function () {\n    var supportsPassiveOption = false;\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function get() {\n          // eslint-disable-line getter-return\n          supportsPassiveOption = true;\n        }\n      });\n      window.addEventListener('testPassiveEventSupport', falseFn, opts);\n      window.removeEventListener('testPassiveEventSupport', falseFn, opts);\n    } catch (e) {\n      // Errors can safely be ignored since this is only a browser support test.\n    }\n    return supportsPassiveOption;\n  }();\n\n  // @property canvas: Boolean\n  // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n  var canvas$1 = function () {\n    return !!document.createElement('canvas').getContext;\n  }();\n\n  // @property svg: Boolean\n  // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).\n  var svg$1 = !!(document.createElementNS && svgCreate('svg').createSVGRect);\n  var inlineSvg = !!svg$1 && function () {\n    var div = document.createElement('div');\n    div.innerHTML = '<svg/>';\n    return (div.firstChild && div.firstChild.namespaceURI) === 'http://www.w3.org/2000/svg';\n  }();\n\n  // @property vml: Boolean\n  // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).\n  var vml = !svg$1 && function () {\n    try {\n      var div = document.createElement('div');\n      div.innerHTML = '<v:shape adj=\"1\"/>';\n      var shape = div.firstChild;\n      shape.style.behavior = 'url(#default#VML)';\n      return shape && _typeof(shape.adj) === 'object';\n    } catch (e) {\n      return false;\n    }\n  }();\n\n  // @property mac: Boolean; `true` when the browser is running in a Mac platform\n  var mac = navigator.platform.indexOf('Mac') === 0;\n\n  // @property mac: Boolean; `true` when the browser is running in a Linux platform\n  var linux = navigator.platform.indexOf('Linux') === 0;\n  function userAgentContains(str) {\n    return navigator.userAgent.toLowerCase().indexOf(str) >= 0;\n  }\n  var Browser = {\n    ie: ie,\n    ielt9: ielt9,\n    edge: edge,\n    webkit: webkit,\n    android: android,\n    android23: android23,\n    androidStock: androidStock,\n    opera: opera,\n    chrome: chrome,\n    gecko: gecko,\n    safari: safari,\n    phantom: phantom,\n    opera12: opera12,\n    win: win,\n    ie3d: ie3d,\n    webkit3d: webkit3d,\n    gecko3d: gecko3d,\n    any3d: any3d,\n    mobile: mobile,\n    mobileWebkit: mobileWebkit,\n    mobileWebkit3d: mobileWebkit3d,\n    msPointer: msPointer,\n    pointer: pointer,\n    touch: touch,\n    touchNative: touchNative,\n    mobileOpera: mobileOpera,\n    mobileGecko: mobileGecko,\n    retina: retina,\n    passiveEvents: passiveEvents,\n    canvas: canvas$1,\n    svg: svg$1,\n    vml: vml,\n    inlineSvg: inlineSvg,\n    mac: mac,\n    linux: linux\n  };\n\n  /*\n   * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n   */\n\n  var POINTER_DOWN = Browser.msPointer ? 'MSPointerDown' : 'pointerdown';\n  var POINTER_MOVE = Browser.msPointer ? 'MSPointerMove' : 'pointermove';\n  var POINTER_UP = Browser.msPointer ? 'MSPointerUp' : 'pointerup';\n  var POINTER_CANCEL = Browser.msPointer ? 'MSPointerCancel' : 'pointercancel';\n  var pEvent = {\n    touchstart: POINTER_DOWN,\n    touchmove: POINTER_MOVE,\n    touchend: POINTER_UP,\n    touchcancel: POINTER_CANCEL\n  };\n  var handle = {\n    touchstart: _onPointerStart,\n    touchmove: _handlePointer,\n    touchend: _handlePointer,\n    touchcancel: _handlePointer\n  };\n  var _pointers = {};\n  var _pointerDocListener = false;\n\n  // Provides a touch events wrapper for (ms)pointer events.\n  // ref https://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\n  function addPointerListener(obj, type, handler) {\n    if (type === 'touchstart') {\n      _addPointerDocListener();\n    }\n    if (!handle[type]) {\n      console.warn('wrong event specified:', type);\n      return falseFn;\n    }\n    handler = handle[type].bind(this, handler);\n    obj.addEventListener(pEvent[type], handler, false);\n    return handler;\n  }\n  function removePointerListener(obj, type, handler) {\n    if (!pEvent[type]) {\n      console.warn('wrong event specified:', type);\n      return;\n    }\n    obj.removeEventListener(pEvent[type], handler, false);\n  }\n  function _globalPointerDown(e) {\n    _pointers[e.pointerId] = e;\n  }\n  function _globalPointerMove(e) {\n    if (_pointers[e.pointerId]) {\n      _pointers[e.pointerId] = e;\n    }\n  }\n  function _globalPointerUp(e) {\n    delete _pointers[e.pointerId];\n  }\n  function _addPointerDocListener() {\n    // need to keep track of what pointers and how many are active to provide e.touches emulation\n    if (!_pointerDocListener) {\n      // we listen document as any drags that end by moving the touch off the screen get fired there\n      document.addEventListener(POINTER_DOWN, _globalPointerDown, true);\n      document.addEventListener(POINTER_MOVE, _globalPointerMove, true);\n      document.addEventListener(POINTER_UP, _globalPointerUp, true);\n      document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);\n      _pointerDocListener = true;\n    }\n  }\n  function _handlePointer(handler, e) {\n    if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || 'mouse')) {\n      return;\n    }\n    e.touches = [];\n    for (var i in _pointers) {\n      e.touches.push(_pointers[i]);\n    }\n    e.changedTouches = [e];\n    handler(e);\n  }\n  function _onPointerStart(handler, e) {\n    // IE10 specific: MsTouch needs preventDefault. See #2000\n    if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {\n      preventDefault(e);\n    }\n    _handlePointer(handler, e);\n  }\n\n  /*\r\n   * Extends the event handling code with double tap support for mobile browsers.\r\n   *\r\n   * Note: currently most browsers fire native dblclick, with only a few exceptions\r\n   * (see https://github.com/Leaflet/Leaflet/issues/7012#issuecomment-595087386)\r\n   */\n\n  function makeDblclick(event) {\n    // in modern browsers `type` cannot be just overridden:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only\n    var newEvent = {},\n      prop,\n      i;\n    for (i in event) {\n      prop = event[i];\n      newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;\n    }\n    event = newEvent;\n    newEvent.type = 'dblclick';\n    newEvent.detail = 2;\n    newEvent.isTrusted = false;\n    newEvent._simulated = true; // for debug purposes\n    return newEvent;\n  }\n  var delay = 200;\n  function addDoubleTapListener(obj, handler) {\n    // Most browsers handle double tap natively\n    obj.addEventListener('dblclick', handler);\n\n    // On some platforms the browser doesn't fire native dblclicks for touch events.\n    // It seems that in all such cases `detail` property of `click` event is always `1`.\n    // So here we rely on that fact to avoid excessive 'dblclick' simulation when not needed.\n    var last = 0,\n      detail;\n    function simDblclick(e) {\n      if (e.detail !== 1) {\n        detail = e.detail; // keep in sync to avoid false dblclick in some cases\n        return;\n      }\n      if (e.pointerType === 'mouse' || e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents) {\n        return;\n      }\n\n      // When clicking on an <input>, the browser generates a click on its\n      // <label> (and vice versa) triggering two clicks in quick succession.\n      // This ignores clicks on elements which are a label with a 'for'\n      // attribute (or children of such a label), but not children of\n      // a <input>.\n      var path = getPropagationPath(e);\n      if (path.some(function (el) {\n        return el instanceof HTMLLabelElement && el.attributes[\"for\"];\n      }) && !path.some(function (el) {\n        return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;\n      })) {\n        return;\n      }\n      var now = Date.now();\n      if (now - last <= delay) {\n        detail++;\n        if (detail === 2) {\n          handler(makeDblclick(e));\n        }\n      } else {\n        detail = 1;\n      }\n      last = now;\n    }\n    obj.addEventListener('click', simDblclick);\n    return {\n      dblclick: handler,\n      simDblclick: simDblclick\n    };\n  }\n  function removeDoubleTapListener(obj, handlers) {\n    obj.removeEventListener('dblclick', handlers.dblclick);\n    obj.removeEventListener('click', handlers.simDblclick);\n  }\n\n  /*\r\n   * @namespace DomUtil\r\n   *\r\n   * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)\r\n   * tree, used by Leaflet internally.\r\n   *\r\n   * Most functions expecting or returning a `HTMLElement` also work for\r\n   * SVG elements. The only difference is that classes refer to CSS classes\r\n   * in HTML and SVG classes in SVG.\r\n   */\n\n  // @property TRANSFORM: String\n  // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).\n  var TRANSFORM = testProp(['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']);\n\n  // webkitTransition comes first because some browser versions that drop vendor prefix don't do\n  // the same for the transitionend event, in particular the Android 4.1 stock browser\n\n  // @property TRANSITION: String\n  // Vendor-prefixed transition style name.\n  var TRANSITION = testProp(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);\n\n  // @property TRANSITION_END: String\n  // Vendor-prefixed transitionend event name.\n  var TRANSITION_END = TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';\n\n  // @function get(id: String|HTMLElement): HTMLElement\n  // Returns an element given its DOM id, or returns the element itself\n  // if it was passed directly.\n  function get(id) {\n    return typeof id === 'string' ? document.getElementById(id) : id;\n  }\n\n  // @function getStyle(el: HTMLElement, styleAttrib: String): String\n  // Returns the value for a certain style attribute on an element,\n  // including computed values or values set through CSS.\n  function getStyle(el, style) {\n    var value = el.style[style] || el.currentStyle && el.currentStyle[style];\n    if ((!value || value === 'auto') && document.defaultView) {\n      var css = document.defaultView.getComputedStyle(el, null);\n      value = css ? css[style] : null;\n    }\n    return value === 'auto' ? null : value;\n  }\n\n  // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement\n  // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.\n  function create$1(tagName, className, container) {\n    var el = document.createElement(tagName);\n    el.className = className || '';\n    if (container) {\n      container.appendChild(el);\n    }\n    return el;\n  }\n\n  // @function remove(el: HTMLElement)\n  // Removes `el` from its parent element\n  function _remove(el) {\n    var parent = el.parentNode;\n    if (parent) {\n      parent.removeChild(el);\n    }\n  }\n\n  // @function empty(el: HTMLElement)\n  // Removes all of `el`'s children elements from `el`\n  function empty(el) {\n    while (el.firstChild) {\n      el.removeChild(el.firstChild);\n    }\n  }\n\n  // @function toFront(el: HTMLElement)\n  // Makes `el` the last child of its parent, so it renders in front of the other children.\n  function toFront(el) {\n    var parent = el.parentNode;\n    if (parent && parent.lastChild !== el) {\n      parent.appendChild(el);\n    }\n  }\n\n  // @function toBack(el: HTMLElement)\n  // Makes `el` the first child of its parent, so it renders behind the other children.\n  function toBack(el) {\n    var parent = el.parentNode;\n    if (parent && parent.firstChild !== el) {\n      parent.insertBefore(el, parent.firstChild);\n    }\n  }\n\n  // @function hasClass(el: HTMLElement, name: String): Boolean\n  // Returns `true` if the element's class attribute contains `name`.\n  function hasClass(el, name) {\n    if (el.classList !== undefined) {\n      return el.classList.contains(name);\n    }\n    var className = getClass(el);\n    return className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\n  }\n\n  // @function addClass(el: HTMLElement, name: String)\n  // Adds `name` to the element's class attribute.\n  function addClass(el, name) {\n    if (el.classList !== undefined) {\n      var classes = splitWords(name);\n      for (var i = 0, len = classes.length; i < len; i++) {\n        el.classList.add(classes[i]);\n      }\n    } else if (!hasClass(el, name)) {\n      var className = getClass(el);\n      setClass(el, (className ? className + ' ' : '') + name);\n    }\n  }\n\n  // @function removeClass(el: HTMLElement, name: String)\n  // Removes `name` from the element's class attribute.\n  function removeClass(el, name) {\n    if (el.classList !== undefined) {\n      el.classList.remove(name);\n    } else {\n      setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\n    }\n  }\n\n  // @function setClass(el: HTMLElement, name: String)\n  // Sets the element's class.\n  function setClass(el, name) {\n    if (el.className.baseVal === undefined) {\n      el.className = name;\n    } else {\n      // in case of SVG element\n      el.className.baseVal = name;\n    }\n  }\n\n  // @function getClass(el: HTMLElement): String\n  // Returns the element's class.\n  function getClass(el) {\n    // Check if the element is an SVGElementInstance and use the correspondingElement instead\n    // (Required for linked SVG elements in IE11.)\n    if (el.correspondingElement) {\n      el = el.correspondingElement;\n    }\n    return el.className.baseVal === undefined ? el.className : el.className.baseVal;\n  }\n\n  // @function setOpacity(el: HTMLElement, opacity: Number)\n  // Set the opacity of an element (including old IE support).\n  // `opacity` must be a number from `0` to `1`.\n  function _setOpacity(el, value) {\n    if ('opacity' in el.style) {\n      el.style.opacity = value;\n    } else if ('filter' in el.style) {\n      _setOpacityIE(el, value);\n    }\n  }\n  function _setOpacityIE(el, value) {\n    var filter = false,\n      filterName = 'DXImageTransform.Microsoft.Alpha';\n\n    // filters collection throws an error if we try to retrieve a filter that doesn't exist\n    try {\n      filter = el.filters.item(filterName);\n    } catch (e) {\n      // don't set opacity to 1 if we haven't already set an opacity,\n      // it isn't needed and breaks transparent pngs.\n      if (value === 1) {\n        return;\n      }\n    }\n    value = Math.round(value * 100);\n    if (filter) {\n      filter.Enabled = value !== 100;\n      filter.Opacity = value;\n    } else {\n      el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\n    }\n  }\n\n  // @function testProp(props: String[]): String|false\n  // Goes through the array of style names and returns the first name\n  // that is a valid style name for an element. If no such name is found,\n  // it returns false. Useful for vendor-prefixed styles like `transform`.\n  function testProp(props) {\n    var style = document.documentElement.style;\n    for (var i = 0; i < props.length; i++) {\n      if (props[i] in style) {\n        return props[i];\n      }\n    }\n    return false;\n  }\n\n  // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)\n  // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels\n  // and optionally scaled by `scale`. Does not have an effect if the\n  // browser doesn't support 3D CSS transforms.\n  function setTransform(el, offset, scale) {\n    var pos = offset || new Point(0, 0);\n    el.style[TRANSFORM] = (Browser.ie3d ? 'translate(' + pos.x + 'px,' + pos.y + 'px)' : 'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') + (scale ? ' scale(' + scale + ')' : '');\n  }\n\n  // @function setPosition(el: HTMLElement, position: Point)\n  // Sets the position of `el` to coordinates specified by `position`,\n  // using CSS translate or top/left positioning depending on the browser\n  // (used by Leaflet internally to position its layers).\n  function setPosition(el, point) {\n    /*eslint-disable */\n    el._leaflet_pos = point;\n    /* eslint-enable */\n\n    if (Browser.any3d) {\n      setTransform(el, point);\n    } else {\n      el.style.left = point.x + 'px';\n      el.style.top = point.y + 'px';\n    }\n  }\n\n  // @function getPosition(el: HTMLElement): Point\n  // Returns the coordinates of an element previously positioned with setPosition.\n  function getPosition(el) {\n    // this method is only used for elements previously positioned using setPosition,\n    // so it's safe to cache the position for performance\n\n    return el._leaflet_pos || new Point(0, 0);\n  }\n\n  // @function disableTextSelection()\n  // Prevents the user from generating `selectstart` DOM events, usually generated\n  // when the user drags the mouse through a page with text. Used internally\n  // by Leaflet to override the behaviour of any click-and-drag interaction on\n  // the map. Affects drag interactions on the whole document.\n\n  // @function enableTextSelection()\n  // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).\n  var disableTextSelection;\n  var enableTextSelection;\n  var _userSelect;\n  if ('onselectstart' in document) {\n    disableTextSelection = function disableTextSelection() {\n      on(window, 'selectstart', preventDefault);\n    };\n    enableTextSelection = function enableTextSelection() {\n      off(window, 'selectstart', preventDefault);\n    };\n  } else {\n    var userSelectProperty = testProp(['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\n    disableTextSelection = function disableTextSelection() {\n      if (userSelectProperty) {\n        var style = document.documentElement.style;\n        _userSelect = style[userSelectProperty];\n        style[userSelectProperty] = 'none';\n      }\n    };\n    enableTextSelection = function enableTextSelection() {\n      if (userSelectProperty) {\n        document.documentElement.style[userSelectProperty] = _userSelect;\n        _userSelect = undefined;\n      }\n    };\n  }\n\n  // @function disableImageDrag()\n  // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but\n  // for `dragstart` DOM events, usually generated when the user drags an image.\n  function disableImageDrag() {\n    on(window, 'dragstart', preventDefault);\n  }\n\n  // @function enableImageDrag()\n  // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).\n  function enableImageDrag() {\n    off(window, 'dragstart', preventDefault);\n  }\n  var _outlineElement, _outlineStyle;\n  // @function preventOutline(el: HTMLElement)\n  // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)\n  // of the element `el` invisible. Used internally by Leaflet to prevent\n  // focusable elements from displaying an outline when the user performs a\n  // drag interaction on them.\n  function preventOutline(element) {\n    while (element.tabIndex === -1) {\n      element = element.parentNode;\n    }\n    if (!element.style) {\n      return;\n    }\n    restoreOutline();\n    _outlineElement = element;\n    _outlineStyle = element.style.outlineStyle;\n    element.style.outlineStyle = 'none';\n    on(window, 'keydown', restoreOutline);\n  }\n\n  // @function restoreOutline()\n  // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().\n  function restoreOutline() {\n    if (!_outlineElement) {\n      return;\n    }\n    _outlineElement.style.outlineStyle = _outlineStyle;\n    _outlineElement = undefined;\n    _outlineStyle = undefined;\n    off(window, 'keydown', restoreOutline);\n  }\n\n  // @function getSizedParentNode(el: HTMLElement): HTMLElement\n  // Finds the closest parent node which size (width and height) is not null.\n  function getSizedParentNode(element) {\n    do {\n      element = element.parentNode;\n    } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);\n    return element;\n  }\n\n  // @function getScale(el: HTMLElement): Object\n  // Computes the CSS scale currently applied on the element.\n  // Returns an object with `x` and `y` members as horizontal and vertical scales respectively,\n  // and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).\n  function getScale(element) {\n    var rect = element.getBoundingClientRect(); // Read-only in old browsers.\n\n    return {\n      x: rect.width / element.offsetWidth || 1,\n      y: rect.height / element.offsetHeight || 1,\n      boundingClientRect: rect\n    };\n  }\n  var DomUtil = {\n    __proto__: null,\n    TRANSFORM: TRANSFORM,\n    TRANSITION: TRANSITION,\n    TRANSITION_END: TRANSITION_END,\n    get: get,\n    getStyle: getStyle,\n    create: create$1,\n    remove: _remove,\n    empty: empty,\n    toFront: toFront,\n    toBack: toBack,\n    hasClass: hasClass,\n    addClass: addClass,\n    removeClass: removeClass,\n    setClass: setClass,\n    getClass: getClass,\n    setOpacity: _setOpacity,\n    testProp: testProp,\n    setTransform: setTransform,\n    setPosition: setPosition,\n    getPosition: getPosition,\n    get disableTextSelection() {\n      return disableTextSelection;\n    },\n    get enableTextSelection() {\n      return enableTextSelection;\n    },\n    disableImageDrag: disableImageDrag,\n    enableImageDrag: enableImageDrag,\n    preventOutline: preventOutline,\n    restoreOutline: restoreOutline,\n    getSizedParentNode: getSizedParentNode,\n    getScale: getScale\n  };\n\n  /*\r\n   * @namespace DomEvent\r\n   * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.\r\n   */\n\n  // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.\n\n  // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this\n  // Adds a listener function (`fn`) to a particular DOM event type of the\n  // element `el`. You can optionally specify the context of the listener\n  // (object the `this` keyword will point to). You can also pass several\n  // space-separated types (e.g. `'click dblclick'`).\n\n  // @alternative\n  // @function on(el: HTMLElement, eventMap: Object, context?: Object): this\n  // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\n  function on(obj, types, fn, context) {\n    if (types && _typeof(types) === 'object') {\n      for (var type in types) {\n        addOne(obj, type, types[type], fn);\n      }\n    } else {\n      types = splitWords(types);\n      for (var i = 0, len = types.length; i < len; i++) {\n        addOne(obj, types[i], fn, context);\n      }\n    }\n    return this;\n  }\n  var eventsKey = '_leaflet_events';\n\n  // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this\n  // Removes a previously added listener function.\n  // Note that if you passed a custom context to on, you must pass the same\n  // context to `off` in order to remove the listener.\n\n  // @alternative\n  // @function off(el: HTMLElement, eventMap: Object, context?: Object): this\n  // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\n\n  // @alternative\n  // @function off(el: HTMLElement, types: String): this\n  // Removes all previously added listeners of given types.\n\n  // @alternative\n  // @function off(el: HTMLElement): this\n  // Removes all previously added listeners from given HTMLElement\n  function off(obj, types, fn, context) {\n    if (arguments.length === 1) {\n      batchRemove(obj);\n      delete obj[eventsKey];\n    } else if (types && _typeof(types) === 'object') {\n      for (var type in types) {\n        removeOne(obj, type, types[type], fn);\n      }\n    } else {\n      types = splitWords(types);\n      if (arguments.length === 2) {\n        batchRemove(obj, function (type) {\n          return indexOf(types, type) !== -1;\n        });\n      } else {\n        for (var i = 0, len = types.length; i < len; i++) {\n          removeOne(obj, types[i], fn, context);\n        }\n      }\n    }\n    return this;\n  }\n  function batchRemove(obj, filterFn) {\n    for (var id in obj[eventsKey]) {\n      var type = id.split(/\\d/)[0];\n      if (!filterFn || filterFn(type)) {\n        removeOne(obj, type, null, null, id);\n      }\n    }\n  }\n  var mouseSubst = {\n    mouseenter: 'mouseover',\n    mouseleave: 'mouseout',\n    wheel: !('onwheel' in window) && 'mousewheel'\n  };\n  function addOne(obj, type, fn, context) {\n    var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');\n    if (obj[eventsKey] && obj[eventsKey][id]) {\n      return this;\n    }\n    var handler = function handler(e) {\n      return fn.call(context || obj, e || window.event);\n    };\n    var originalHandler = handler;\n    if (!Browser.touchNative && Browser.pointer && type.indexOf('touch') === 0) {\n      // Needs DomEvent.Pointer.js\n      handler = addPointerListener(obj, type, handler);\n    } else if (Browser.touch && type === 'dblclick') {\n      handler = addDoubleTapListener(obj, handler);\n    } else if ('addEventListener' in obj) {\n      if (type === 'touchstart' || type === 'touchmove' || type === 'wheel' || type === 'mousewheel') {\n        obj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? {\n          passive: false\n        } : false);\n      } else if (type === 'mouseenter' || type === 'mouseleave') {\n        handler = function handler(e) {\n          e = e || window.event;\n          if (isExternalTarget(obj, e)) {\n            originalHandler(e);\n          }\n        };\n        obj.addEventListener(mouseSubst[type], handler, false);\n      } else {\n        obj.addEventListener(type, originalHandler, false);\n      }\n    } else {\n      obj.attachEvent('on' + type, handler);\n    }\n    obj[eventsKey] = obj[eventsKey] || {};\n    obj[eventsKey][id] = handler;\n  }\n  function removeOne(obj, type, fn, context, id) {\n    id = id || type + stamp(fn) + (context ? '_' + stamp(context) : '');\n    var handler = obj[eventsKey] && obj[eventsKey][id];\n    if (!handler) {\n      return this;\n    }\n    if (!Browser.touchNative && Browser.pointer && type.indexOf('touch') === 0) {\n      removePointerListener(obj, type, handler);\n    } else if (Browser.touch && type === 'dblclick') {\n      removeDoubleTapListener(obj, handler);\n    } else if ('removeEventListener' in obj) {\n      obj.removeEventListener(mouseSubst[type] || type, handler, false);\n    } else {\n      obj.detachEvent('on' + type, handler);\n    }\n    obj[eventsKey][id] = null;\n  }\n\n  // @function stopPropagation(ev: DOMEvent): this\n  // Stop the given event from propagation to parent elements. Used inside the listener functions:\n  // ```js\n  // L.DomEvent.on(div, 'click', function (ev) {\n  // \tL.DomEvent.stopPropagation(ev);\n  // });\n  // ```\n  function stopPropagation(e) {\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    } else if (e.originalEvent) {\n      // In case of Leaflet event.\n      e.originalEvent._stopped = true;\n    } else {\n      e.cancelBubble = true;\n    }\n    return this;\n  }\n\n  // @function disableScrollPropagation(el: HTMLElement): this\n  // Adds `stopPropagation` to the element's `'wheel'` events (plus browser variants).\n  function disableScrollPropagation(el) {\n    addOne(el, 'wheel', stopPropagation);\n    return this;\n  }\n\n  // @function disableClickPropagation(el: HTMLElement): this\n  // Adds `stopPropagation` to the element's `'click'`, `'dblclick'`, `'contextmenu'`,\n  // `'mousedown'` and `'touchstart'` events (plus browser variants).\n  function disableClickPropagation(el) {\n    on(el, 'mousedown touchstart dblclick contextmenu', stopPropagation);\n    el['_leaflet_disable_click'] = true;\n    return this;\n  }\n\n  // @function preventDefault(ev: DOMEvent): this\n  // Prevents the default action of the DOM Event `ev` from happening (such as\n  // following a link in the href of the a element, or doing a POST request\n  // with page reload when a `<form>` is submitted).\n  // Use it inside listener functions.\n  function preventDefault(e) {\n    if (e.preventDefault) {\n      e.preventDefault();\n    } else {\n      e.returnValue = false;\n    }\n    return this;\n  }\n\n  // @function stop(ev: DOMEvent): this\n  // Does `stopPropagation` and `preventDefault` at the same time.\n  function stop(e) {\n    preventDefault(e);\n    stopPropagation(e);\n    return this;\n  }\n\n  // @function getPropagationPath(ev: DOMEvent): Array\n  // Compatibility polyfill for [`Event.composedPath()`](https://developer.mozilla.org/en-US/docs/Web/API/Event/composedPath).\n  // Returns an array containing the `HTMLElement`s that the given DOM event\n  // should propagate to (if not stopped).\n  function getPropagationPath(ev) {\n    if (ev.composedPath) {\n      return ev.composedPath();\n    }\n    var path = [];\n    var el = ev.target;\n    while (el) {\n      path.push(el);\n      el = el.parentNode;\n    }\n    return path;\n  }\n\n  // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point\n  // Gets normalized mouse position from a DOM event relative to the\n  // `container` (border excluded) or to the whole page if not specified.\n  function getMousePosition(e, container) {\n    if (!container) {\n      return new Point(e.clientX, e.clientY);\n    }\n    var scale = getScale(container),\n      offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)\n\n    return new Point(\n    // offset.left/top values are in page scale (like clientX/Y),\n    // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).\n    (e.clientX - offset.left) / scale.x - container.clientLeft, (e.clientY - offset.top) / scale.y - container.clientTop);\n  }\n\n  //  except , Safari and\n  // We need double the scroll pixels (see #7403 and #4538) for all Browsers\n  // except OSX (Mac) -> 3x, Chrome running on Linux 1x\n\n  var wheelPxFactor = Browser.linux && Browser.chrome ? window.devicePixelRatio : Browser.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;\n  // @function getWheelDelta(ev: DOMEvent): Number\n  // Gets normalized wheel delta from a wheel DOM event, in vertical\n  // pixels scrolled (negative if scrolling down).\n  // Events from pointing devices without precise scrolling are mapped to\n  // a best guess of 60 pixels.\n  function getWheelDelta(e) {\n    return Browser.edge ? e.wheelDeltaY / 2 :\n    // Don't trust window-geometry-based delta\n    e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor :\n    // Pixels\n    e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 :\n    // Lines\n    e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 :\n    // Pages\n    e.deltaX || e.deltaZ ? 0 :\n    // Skip horizontal/depth wheel events\n    e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 :\n    // Legacy IE pixels\n    e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 :\n    // Legacy Moz lines\n    e.detail ? e.detail / -32765 * 60 :\n    // Legacy Moz pages\n    0;\n  }\n\n  // check if element really left/entered the event target (for mouseenter/mouseleave)\n  function isExternalTarget(el, e) {\n    var related = e.relatedTarget;\n    if (!related) {\n      return true;\n    }\n    try {\n      while (related && related !== el) {\n        related = related.parentNode;\n      }\n    } catch (err) {\n      return false;\n    }\n    return related !== el;\n  }\n  var DomEvent = {\n    __proto__: null,\n    on: on,\n    off: off,\n    stopPropagation: stopPropagation,\n    disableScrollPropagation: disableScrollPropagation,\n    disableClickPropagation: disableClickPropagation,\n    preventDefault: preventDefault,\n    stop: stop,\n    getPropagationPath: getPropagationPath,\n    getMousePosition: getMousePosition,\n    getWheelDelta: getWheelDelta,\n    isExternalTarget: isExternalTarget,\n    addListener: on,\n    removeListener: off\n  };\n\n  /*\n   * @class PosAnimation\n   * @aka L.PosAnimation\n   * @inherits Evented\n   * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.\n   *\n   * @example\n   * ```js\n   * var myPositionMarker = L.marker([48.864716, 2.294694]).addTo(map);\n   *\n   * myPositionMarker.on(\"click\", function() {\n   * \tvar pos = map.latLngToLayerPoint(myPositionMarker.getLatLng());\n   * \tpos.y -= 25;\n   * \tvar fx = new L.PosAnimation();\n   *\n   * \tfx.once('end',function() {\n   * \t\tpos.y += 25;\n   * \t\tfx.run(myPositionMarker._icon, pos, 0.8);\n   * \t});\n   *\n   * \tfx.run(myPositionMarker._icon, pos, 0.3);\n   * });\n   *\n   * ```\n   *\n   * @constructor L.PosAnimation()\n   * Creates a `PosAnimation` object.\n   *\n   */\n\n  var PosAnimation = Evented.extend({\n    // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)\n    // Run an animation of a given element to a new position, optionally setting\n    // duration in seconds (`0.25` by default) and easing linearity factor (3rd\n    // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),\n    // `0.5` by default).\n    run: function run(el, newPos, duration, easeLinearity) {\n      this.stop();\n      this._el = el;\n      this._inProgress = true;\n      this._duration = duration || 0.25;\n      this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n      this._startPos = getPosition(el);\n      this._offset = newPos.subtract(this._startPos);\n      this._startTime = +new Date();\n\n      // @event start: Event\n      // Fired when the animation starts\n      this.fire('start');\n      this._animate();\n    },\n    // @method stop()\n    // Stops the animation (if currently running).\n    stop: function stop() {\n      if (!this._inProgress) {\n        return;\n      }\n      this._step(true);\n      this._complete();\n    },\n    _animate: function _animate() {\n      // animation loop\n      this._animId = requestAnimFrame(this._animate, this);\n      this._step();\n    },\n    _step: function _step(round) {\n      var elapsed = +new Date() - this._startTime,\n        duration = this._duration * 1000;\n      if (elapsed < duration) {\n        this._runFrame(this._easeOut(elapsed / duration), round);\n      } else {\n        this._runFrame(1);\n        this._complete();\n      }\n    },\n    _runFrame: function _runFrame(progress, round) {\n      var pos = this._startPos.add(this._offset.multiplyBy(progress));\n      if (round) {\n        pos._round();\n      }\n      setPosition(this._el, pos);\n\n      // @event step: Event\n      // Fired continuously during the animation.\n      this.fire('step');\n    },\n    _complete: function _complete() {\n      cancelAnimFrame(this._animId);\n      this._inProgress = false;\n      // @event end: Event\n      // Fired when the animation ends.\n      this.fire('end');\n    },\n    _easeOut: function _easeOut(t) {\n      return 1 - Math.pow(1 - t, this._easeOutPower);\n    }\n  });\n\n  /*\r\n   * @class Map\r\n   * @aka L.Map\r\n   * @inherits Evented\r\n   *\r\n   * The central class of the API — it is used to create a map on a page and manipulate it.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * // initialize the map on the \"map\" div with a given center and zoom\r\n   * var map = L.map('map', {\r\n   * \tcenter: [51.505, -0.09],\r\n   * \tzoom: 13\r\n   * });\r\n   * ```\r\n   *\r\n   */\n\n  var Map = Evented.extend({\n    options: {\n      // @section Map State Options\n      // @option crs: CRS = L.CRS.EPSG3857\n      // The [Coordinate Reference System](#crs) to use. Don't change this if you're not\n      // sure what it means.\n      crs: EPSG3857,\n      // @option center: LatLng = undefined\n      // Initial geographic center of the map\n      center: undefined,\n      // @option zoom: Number = undefined\n      // Initial map zoom level\n      zoom: undefined,\n      // @option minZoom: Number = *\n      // Minimum zoom level of the map.\n      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\n      // the lowest of their `minZoom` options will be used instead.\n      minZoom: undefined,\n      // @option maxZoom: Number = *\n      // Maximum zoom level of the map.\n      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\n      // the highest of their `maxZoom` options will be used instead.\n      maxZoom: undefined,\n      // @option layers: Layer[] = []\n      // Array of layers that will be added to the map initially\n      layers: [],\n      // @option maxBounds: LatLngBounds = null\n      // When this option is set, the map restricts the view to the given\n      // geographical bounds, bouncing the user back if the user tries to pan\n      // outside the view. To set the restriction dynamically, use\n      // [`setMaxBounds`](#map-setmaxbounds) method.\n      maxBounds: undefined,\n      // @option renderer: Renderer = *\n      // The default method for drawing vector layers on the map. `L.SVG`\n      // or `L.Canvas` by default depending on browser support.\n      renderer: undefined,\n      // @section Animation Options\n      // @option zoomAnimation: Boolean = true\n      // Whether the map zoom animation is enabled. By default it's enabled\n      // in all browsers that support CSS3 Transitions except Android.\n      zoomAnimation: true,\n      // @option zoomAnimationThreshold: Number = 4\n      // Won't animate zoom if the zoom difference exceeds this value.\n      zoomAnimationThreshold: 4,\n      // @option fadeAnimation: Boolean = true\n      // Whether the tile fade animation is enabled. By default it's enabled\n      // in all browsers that support CSS3 Transitions except Android.\n      fadeAnimation: true,\n      // @option markerZoomAnimation: Boolean = true\n      // Whether markers animate their zoom with the zoom animation, if disabled\n      // they will disappear for the length of the animation. By default it's\n      // enabled in all browsers that support CSS3 Transitions except Android.\n      markerZoomAnimation: true,\n      // @option transform3DLimit: Number = 2^23\n      // Defines the maximum size of a CSS translation transform. The default\n      // value should not be changed unless a web browser positions layers in\n      // the wrong place after doing a large `panBy`.\n      transform3DLimit: 8388608,\n      // Precision limit of a 32-bit float\n\n      // @section Interaction Options\n      // @option zoomSnap: Number = 1\n      // Forces the map's zoom level to always be a multiple of this, particularly\n      // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.\n      // By default, the zoom level snaps to the nearest integer; lower values\n      // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`\n      // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.\n      zoomSnap: 1,\n      // @option zoomDelta: Number = 1\n      // Controls how much the map's zoom level will change after a\n      // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`\n      // or `-` on the keyboard, or using the [zoom controls](#control-zoom).\n      // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.\n      zoomDelta: 1,\n      // @option trackResize: Boolean = true\n      // Whether the map automatically handles browser window resize to update itself.\n      trackResize: true\n    },\n    initialize: function initialize(id, options) {\n      // (HTMLElement or String, Object)\n      options = setOptions(this, options);\n\n      // Make sure to assign internal flags at the beginning,\n      // to avoid inconsistent state in some edge cases.\n      this._handlers = [];\n      this._layers = {};\n      this._zoomBoundLayers = {};\n      this._sizeChanged = true;\n      this._initContainer(id);\n      this._initLayout();\n\n      // hack for https://github.com/Leaflet/Leaflet/issues/1980\n      this._onResize = bind(this._onResize, this);\n      this._initEvents();\n      if (options.maxBounds) {\n        this.setMaxBounds(options.maxBounds);\n      }\n      if (options.zoom !== undefined) {\n        this._zoom = this._limitZoom(options.zoom);\n      }\n      if (options.center && options.zoom !== undefined) {\n        this.setView(toLatLng(options.center), options.zoom, {\n          reset: true\n        });\n      }\n      this.callInitHooks();\n\n      // don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n      this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;\n\n      // zoom transitions run with the same duration for all layers, so if one of transitionend events\n      // happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n      if (this._zoomAnimated) {\n        this._createAnimProxy();\n        on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);\n      }\n      this._addLayers(this.options.layers);\n    },\n    // @section Methods for modifying map state\n\n    // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this\n    // Sets the view of the map (geographical center and zoom) with the given\n    // animation options.\n    setView: function setView(center, zoom, options) {\n      zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n      center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);\n      options = options || {};\n      this._stop();\n      if (this._loaded && !options.reset && options !== true) {\n        if (options.animate !== undefined) {\n          options.zoom = extend({\n            animate: options.animate\n          }, options.zoom);\n          options.pan = extend({\n            animate: options.animate,\n            duration: options.duration\n          }, options.pan);\n        }\n\n        // try animating pan or zoom\n        var moved = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);\n        if (moved) {\n          // prevent resize handler call, the view will refresh after animation anyway\n          clearTimeout(this._sizeTimer);\n          return this;\n        }\n      }\n\n      // animation didn't start, just reset the map view\n      this._resetView(center, zoom, options.pan && options.pan.noMoveStart);\n      return this;\n    },\n    // @method setZoom(zoom: Number, options?: Zoom/pan options): this\n    // Sets the zoom of the map.\n    setZoom: function setZoom(zoom, options) {\n      if (!this._loaded) {\n        this._zoom = zoom;\n        return this;\n      }\n      return this.setView(this.getCenter(), zoom, {\n        zoom: options\n      });\n    },\n    // @method zoomIn(delta?: Number, options?: Zoom options): this\n    // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\n    zoomIn: function zoomIn(delta, options) {\n      delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);\n      return this.setZoom(this._zoom + delta, options);\n    },\n    // @method zoomOut(delta?: Number, options?: Zoom options): this\n    // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\n    zoomOut: function zoomOut(delta, options) {\n      delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);\n      return this.setZoom(this._zoom - delta, options);\n    },\n    // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this\n    // Zooms the map while keeping a specified geographical point on the map\n    // stationary (e.g. used internally for scroll zoom and double-click zoom).\n    // @alternative\n    // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this\n    // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.\n    setZoomAround: function setZoomAround(latlng, zoom, options) {\n      var scale = this.getZoomScale(zoom),\n        viewHalf = this.getSize().divideBy(2),\n        containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),\n        centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\n        newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\n      return this.setView(newCenter, zoom, {\n        zoom: options\n      });\n    },\n    _getBoundsCenterZoom: function _getBoundsCenterZoom(bounds, options) {\n      options = options || {};\n      bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);\n      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\n        paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\n        zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\n      zoom = typeof options.maxZoom === 'number' ? Math.min(options.maxZoom, zoom) : zoom;\n      if (zoom === Infinity) {\n        return {\n          center: bounds.getCenter(),\n          zoom: zoom\n        };\n      }\n      var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\n        swPoint = this.project(bounds.getSouthWest(), zoom),\n        nePoint = this.project(bounds.getNorthEast(), zoom),\n        center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\n      return {\n        center: center,\n        zoom: zoom\n      };\n    },\n    // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this\n    // Sets a map view that contains the given geographical bounds with the\n    // maximum zoom level possible.\n    fitBounds: function fitBounds(bounds, options) {\n      bounds = toLatLngBounds(bounds);\n      if (!bounds.isValid()) {\n        throw new Error('Bounds are not valid.');\n      }\n      var target = this._getBoundsCenterZoom(bounds, options);\n      return this.setView(target.center, target.zoom, options);\n    },\n    // @method fitWorld(options?: fitBounds options): this\n    // Sets a map view that mostly contains the whole world with the maximum\n    // zoom level possible.\n    fitWorld: function fitWorld(options) {\n      return this.fitBounds([[-90, -180], [90, 180]], options);\n    },\n    // @method panTo(latlng: LatLng, options?: Pan options): this\n    // Pans the map to a given center.\n    panTo: function panTo(center, options) {\n      // (LatLng)\n      return this.setView(center, this._zoom, {\n        pan: options\n      });\n    },\n    // @method panBy(offset: Point, options?: Pan options): this\n    // Pans the map by a given number of pixels (animated).\n    panBy: function panBy(offset, options) {\n      offset = toPoint(offset).round();\n      options = options || {};\n      if (!offset.x && !offset.y) {\n        return this.fire('moveend');\n      }\n      // If we pan too far, Chrome gets issues with tiles\n      // and makes them disappear or appear in the wrong place (slightly offset) #2602\n      if (options.animate !== true && !this.getSize().contains(offset)) {\n        this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());\n        return this;\n      }\n      if (!this._panAnim) {\n        this._panAnim = new PosAnimation();\n        this._panAnim.on({\n          'step': this._onPanTransitionStep,\n          'end': this._onPanTransitionEnd\n        }, this);\n      }\n\n      // don't fire movestart if animating inertia\n      if (!options.noMoveStart) {\n        this.fire('movestart');\n      }\n\n      // animate pan unless animate: false specified\n      if (options.animate !== false) {\n        addClass(this._mapPane, 'leaflet-pan-anim');\n        var newPos = this._getMapPanePos().subtract(offset).round();\n        this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n      } else {\n        this._rawPanBy(offset);\n        this.fire('move').fire('moveend');\n      }\n      return this;\n    },\n    // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this\n    // Sets the view of the map (geographical center and zoom) performing a smooth\n    // pan-zoom animation.\n    flyTo: function flyTo(targetCenter, targetZoom, options) {\n      options = options || {};\n      if (options.animate === false || !Browser.any3d) {\n        return this.setView(targetCenter, targetZoom, options);\n      }\n      this._stop();\n      var from = this.project(this.getCenter()),\n        to = this.project(targetCenter),\n        size = this.getSize(),\n        startZoom = this._zoom;\n      targetCenter = toLatLng(targetCenter);\n      targetZoom = targetZoom === undefined ? startZoom : targetZoom;\n      var w0 = Math.max(size.x, size.y),\n        w1 = w0 * this.getZoomScale(startZoom, targetZoom),\n        u1 = to.distanceTo(from) || 1,\n        rho = 1.42,\n        rho2 = rho * rho;\n      function r(i) {\n        var s1 = i ? -1 : 1,\n          s2 = i ? w1 : w0,\n          t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,\n          b1 = 2 * s2 * rho2 * u1,\n          b = t1 / b1,\n          sq = Math.sqrt(b * b + 1) - b;\n\n        // workaround for floating point precision bug when sq = 0, log = -Infinite,\n        // thus triggering an infinite loop in flyTo\n        var log = sq < 0.000000001 ? -18 : Math.log(sq);\n        return log;\n      }\n      function sinh(n) {\n        return (Math.exp(n) - Math.exp(-n)) / 2;\n      }\n      function cosh(n) {\n        return (Math.exp(n) + Math.exp(-n)) / 2;\n      }\n      function tanh(n) {\n        return sinh(n) / cosh(n);\n      }\n      var r0 = r(0);\n      function w(s) {\n        return w0 * (cosh(r0) / cosh(r0 + rho * s));\n      }\n      function u(s) {\n        return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;\n      }\n      function easeOut(t) {\n        return 1 - Math.pow(1 - t, 1.5);\n      }\n      var start = Date.now(),\n        S = (r(1) - r0) / rho,\n        duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;\n      function frame() {\n        var t = (Date.now() - start) / duration,\n          s = easeOut(t) * S;\n        if (t <= 1) {\n          this._flyToFrame = requestAnimFrame(frame, this);\n          this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), {\n            flyTo: true\n          });\n        } else {\n          this._move(targetCenter, targetZoom)._moveEnd(true);\n        }\n      }\n      this._moveStart(true, options.noMoveStart);\n      frame.call(this);\n      return this;\n    },\n    // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this\n    // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),\n    // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).\n    flyToBounds: function flyToBounds(bounds, options) {\n      var target = this._getBoundsCenterZoom(bounds, options);\n      return this.flyTo(target.center, target.zoom, options);\n    },\n    // @method setMaxBounds(bounds: LatLngBounds): this\n    // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).\n    setMaxBounds: function setMaxBounds(bounds) {\n      bounds = toLatLngBounds(bounds);\n      if (this.listens('moveend', this._panInsideMaxBounds)) {\n        this.off('moveend', this._panInsideMaxBounds);\n      }\n      if (!bounds.isValid()) {\n        this.options.maxBounds = null;\n        return this;\n      }\n      this.options.maxBounds = bounds;\n      if (this._loaded) {\n        this._panInsideMaxBounds();\n      }\n      return this.on('moveend', this._panInsideMaxBounds);\n    },\n    // @method setMinZoom(zoom: Number): this\n    // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).\n    setMinZoom: function setMinZoom(zoom) {\n      var oldZoom = this.options.minZoom;\n      this.options.minZoom = zoom;\n      if (this._loaded && oldZoom !== zoom) {\n        this.fire('zoomlevelschange');\n        if (this.getZoom() < this.options.minZoom) {\n          return this.setZoom(zoom);\n        }\n      }\n      return this;\n    },\n    // @method setMaxZoom(zoom: Number): this\n    // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).\n    setMaxZoom: function setMaxZoom(zoom) {\n      var oldZoom = this.options.maxZoom;\n      this.options.maxZoom = zoom;\n      if (this._loaded && oldZoom !== zoom) {\n        this.fire('zoomlevelschange');\n        if (this.getZoom() > this.options.maxZoom) {\n          return this.setZoom(zoom);\n        }\n      }\n      return this;\n    },\n    // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this\n    // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.\n    panInsideBounds: function panInsideBounds(bounds, options) {\n      this._enforcingBounds = true;\n      var center = this.getCenter(),\n        newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));\n      if (!center.equals(newCenter)) {\n        this.panTo(newCenter, options);\n      }\n      this._enforcingBounds = false;\n      return this;\n    },\n    // @method panInside(latlng: LatLng, options?: padding options): this\n    // Pans the map the minimum amount to make the `latlng` visible. Use\n    // padding options to fit the display to more restricted bounds.\n    // If `latlng` is already within the (optionally padded) display bounds,\n    // the map will not be panned.\n    panInside: function panInside(latlng, options) {\n      options = options || {};\n      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\n        paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\n        pixelCenter = this.project(this.getCenter()),\n        pixelPoint = this.project(latlng),\n        pixelBounds = this.getPixelBounds(),\n        paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]),\n        paddedSize = paddedBounds.getSize();\n      if (!paddedBounds.contains(pixelPoint)) {\n        this._enforcingBounds = true;\n        var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());\n        var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);\n        pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;\n        pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;\n        this.panTo(this.unproject(pixelCenter), options);\n        this._enforcingBounds = false;\n      }\n      return this;\n    },\n    // @method invalidateSize(options: Zoom/pan options): this\n    // Checks if the map container size changed and updates the map if so —\n    // call it after you've changed the map size dynamically, also animating\n    // pan by default. If `options.pan` is `false`, panning will not occur.\n    // If `options.debounceMoveend` is `true`, it will delay `moveend` event so\n    // that it doesn't happen often even if the method is called many\n    // times in a row.\n\n    // @alternative\n    // @method invalidateSize(animate: Boolean): this\n    // Checks if the map container size changed and updates the map if so —\n    // call it after you've changed the map size dynamically, also animating\n    // pan by default.\n    invalidateSize: function invalidateSize(options) {\n      if (!this._loaded) {\n        return this;\n      }\n      options = extend({\n        animate: false,\n        pan: true\n      }, options === true ? {\n        animate: true\n      } : options);\n      var oldSize = this.getSize();\n      this._sizeChanged = true;\n      this._lastCenter = null;\n      var newSize = this.getSize(),\n        oldCenter = oldSize.divideBy(2).round(),\n        newCenter = newSize.divideBy(2).round(),\n        offset = oldCenter.subtract(newCenter);\n      if (!offset.x && !offset.y) {\n        return this;\n      }\n      if (options.animate && options.pan) {\n        this.panBy(offset);\n      } else {\n        if (options.pan) {\n          this._rawPanBy(offset);\n        }\n        this.fire('move');\n        if (options.debounceMoveend) {\n          clearTimeout(this._sizeTimer);\n          this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);\n        } else {\n          this.fire('moveend');\n        }\n      }\n\n      // @section Map state change events\n      // @event resize: ResizeEvent\n      // Fired when the map is resized.\n      return this.fire('resize', {\n        oldSize: oldSize,\n        newSize: newSize\n      });\n    },\n    // @section Methods for modifying map state\n    // @method stop(): this\n    // Stops the currently running `panTo` or `flyTo` animation, if any.\n    stop: function stop() {\n      this.setZoom(this._limitZoom(this._zoom));\n      if (!this.options.zoomSnap) {\n        this.fire('viewreset');\n      }\n      return this._stop();\n    },\n    // @section Geolocation methods\n    // @method locate(options?: Locate options): this\n    // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)\n    // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,\n    // and optionally sets the map view to the user's location with respect to\n    // detection accuracy (or to the world view if geolocation failed).\n    // Note that, if your page doesn't use HTTPS, this method will fail in\n    // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))\n    // See `Locate options` for more details.\n    locate: function locate(options) {\n      options = this._locateOptions = extend({\n        timeout: 10000,\n        watch: false\n        // setView: false\n        // maxZoom: <Number>\n        // maximumAge: 0\n        // enableHighAccuracy: false\n      }, options);\n      if (!('geolocation' in navigator)) {\n        this._handleGeolocationError({\n          code: 0,\n          message: 'Geolocation not supported.'\n        });\n        return this;\n      }\n      var onResponse = bind(this._handleGeolocationResponse, this),\n        onError = bind(this._handleGeolocationError, this);\n      if (options.watch) {\n        this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);\n      } else {\n        navigator.geolocation.getCurrentPosition(onResponse, onError, options);\n      }\n      return this;\n    },\n    // @method stopLocate(): this\n    // Stops watching location previously initiated by `map.locate({watch: true})`\n    // and aborts resetting the map view if map.locate was called with\n    // `{setView: true}`.\n    stopLocate: function stopLocate() {\n      if (navigator.geolocation && navigator.geolocation.clearWatch) {\n        navigator.geolocation.clearWatch(this._locationWatchId);\n      }\n      if (this._locateOptions) {\n        this._locateOptions.setView = false;\n      }\n      return this;\n    },\n    _handleGeolocationError: function _handleGeolocationError(error) {\n      if (!this._container._leaflet_id) {\n        return;\n      }\n      var c = error.code,\n        message = error.message || (c === 1 ? 'permission denied' : c === 2 ? 'position unavailable' : 'timeout');\n      if (this._locateOptions.setView && !this._loaded) {\n        this.fitWorld();\n      }\n\n      // @section Location events\n      // @event locationerror: ErrorEvent\n      // Fired when geolocation (using the [`locate`](#map-locate) method) failed.\n      this.fire('locationerror', {\n        code: c,\n        message: 'Geolocation error: ' + message + '.'\n      });\n    },\n    _handleGeolocationResponse: function _handleGeolocationResponse(pos) {\n      if (!this._container._leaflet_id) {\n        return;\n      }\n      var lat = pos.coords.latitude,\n        lng = pos.coords.longitude,\n        latlng = new LatLng(lat, lng),\n        bounds = latlng.toBounds(pos.coords.accuracy * 2),\n        options = this._locateOptions;\n      if (options.setView) {\n        var zoom = this.getBoundsZoom(bounds);\n        this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);\n      }\n      var data = {\n        latlng: latlng,\n        bounds: bounds,\n        timestamp: pos.timestamp\n      };\n      for (var i in pos.coords) {\n        if (typeof pos.coords[i] === 'number') {\n          data[i] = pos.coords[i];\n        }\n      }\n\n      // @event locationfound: LocationEvent\n      // Fired when geolocation (using the [`locate`](#map-locate) method)\n      // went successfully.\n      this.fire('locationfound', data);\n    },\n    // TODO Appropriate docs section?\n    // @section Other Methods\n    // @method addHandler(name: String, HandlerClass: Function): this\n    // Adds a new `Handler` to the map, given its name and constructor function.\n    addHandler: function addHandler(name, HandlerClass) {\n      if (!HandlerClass) {\n        return this;\n      }\n      var handler = this[name] = new HandlerClass(this);\n      this._handlers.push(handler);\n      if (this.options[name]) {\n        handler.enable();\n      }\n      return this;\n    },\n    // @method remove(): this\n    // Destroys the map and clears all related event listeners.\n    remove: function remove() {\n      this._initEvents(true);\n      if (this.options.maxBounds) {\n        this.off('moveend', this._panInsideMaxBounds);\n      }\n      if (this._containerId !== this._container._leaflet_id) {\n        throw new Error('Map container is being reused by another instance');\n      }\n      try {\n        // throws error in IE6-8\n        delete this._container._leaflet_id;\n        delete this._containerId;\n      } catch (e) {\n        /*eslint-disable */\n        this._container._leaflet_id = undefined;\n        /* eslint-enable */\n        this._containerId = undefined;\n      }\n      if (this._locationWatchId !== undefined) {\n        this.stopLocate();\n      }\n      this._stop();\n      _remove(this._mapPane);\n      if (this._clearControlPos) {\n        this._clearControlPos();\n      }\n      if (this._resizeRequest) {\n        cancelAnimFrame(this._resizeRequest);\n        this._resizeRequest = null;\n      }\n      this._clearHandlers();\n      if (this._loaded) {\n        // @section Map state change events\n        // @event unload: Event\n        // Fired when the map is destroyed with [remove](#map-remove) method.\n        this.fire('unload');\n      }\n      var i;\n      for (i in this._layers) {\n        this._layers[i].remove();\n      }\n      for (i in this._panes) {\n        _remove(this._panes[i]);\n      }\n      this._layers = [];\n      this._panes = [];\n      delete this._mapPane;\n      delete this._renderer;\n      return this;\n    },\n    // @section Other Methods\n    // @method createPane(name: String, container?: HTMLElement): HTMLElement\n    // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,\n    // then returns it. The pane is created as a child of `container`, or\n    // as a child of the main map pane if not set.\n    createPane: function createPane(name, container) {\n      var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),\n        pane = create$1('div', className, container || this._mapPane);\n      if (name) {\n        this._panes[name] = pane;\n      }\n      return pane;\n    },\n    // @section Methods for Getting Map State\n\n    // @method getCenter(): LatLng\n    // Returns the geographical center of the map view\n    getCenter: function getCenter() {\n      this._checkIfLoaded();\n      if (this._lastCenter && !this._moved()) {\n        return this._lastCenter.clone();\n      }\n      return this.layerPointToLatLng(this._getCenterLayerPoint());\n    },\n    // @method getZoom(): Number\n    // Returns the current zoom level of the map view\n    getZoom: function getZoom() {\n      return this._zoom;\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the geographical bounds visible in the current map view\n    getBounds: function getBounds() {\n      var bounds = this.getPixelBounds(),\n        sw = this.unproject(bounds.getBottomLeft()),\n        ne = this.unproject(bounds.getTopRight());\n      return new LatLngBounds(sw, ne);\n    },\n    // @method getMinZoom(): Number\n    // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.\n    getMinZoom: function getMinZoom() {\n      return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;\n    },\n    // @method getMaxZoom(): Number\n    // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).\n    getMaxZoom: function getMaxZoom() {\n      return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;\n    },\n    // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number\n    // Returns the maximum zoom level on which the given bounds fit to the map\n    // view in its entirety. If `inside` (optional) is set to `true`, the method\n    // instead returns the minimum zoom level on which the map view fits into\n    // the given bounds in its entirety.\n    getBoundsZoom: function getBoundsZoom(bounds, inside, padding) {\n      // (LatLngBounds[, Boolean, Point]) -> Number\n      bounds = toLatLngBounds(bounds);\n      padding = toPoint(padding || [0, 0]);\n      var zoom = this.getZoom() || 0,\n        min = this.getMinZoom(),\n        max = this.getMaxZoom(),\n        nw = bounds.getNorthWest(),\n        se = bounds.getSouthEast(),\n        size = this.getSize().subtract(padding),\n        boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),\n        snap = Browser.any3d ? this.options.zoomSnap : 1,\n        scalex = size.x / boundsSize.x,\n        scaley = size.y / boundsSize.y,\n        scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);\n      zoom = this.getScaleZoom(scale, zoom);\n      if (snap) {\n        zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level\n        zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;\n      }\n      return Math.max(min, Math.min(max, zoom));\n    },\n    // @method getSize(): Point\n    // Returns the current size of the map container (in pixels).\n    getSize: function getSize() {\n      if (!this._size || this._sizeChanged) {\n        this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0);\n        this._sizeChanged = false;\n      }\n      return this._size.clone();\n    },\n    // @method getPixelBounds(): Bounds\n    // Returns the bounds of the current map view in projected pixel\n    // coordinates (sometimes useful in layer and overlay implementations).\n    getPixelBounds: function getPixelBounds(center, zoom) {\n      var topLeftPoint = this._getTopLeftPoint(center, zoom);\n      return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\n    },\n    // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to\n    // the map pane? \"left point of the map layer\" can be confusing, specially\n    // since there can be negative offsets.\n    // @method getPixelOrigin(): Point\n    // Returns the projected pixel coordinates of the top left point of\n    // the map layer (useful in custom layer and overlay implementations).\n    getPixelOrigin: function getPixelOrigin() {\n      this._checkIfLoaded();\n      return this._pixelOrigin;\n    },\n    // @method getPixelWorldBounds(zoom?: Number): Bounds\n    // Returns the world's bounds in pixel coordinates for zoom level `zoom`.\n    // If `zoom` is omitted, the map's current zoom level is used.\n    getPixelWorldBounds: function getPixelWorldBounds(zoom) {\n      return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);\n    },\n    // @section Other Methods\n\n    // @method getPane(pane: String|HTMLElement): HTMLElement\n    // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).\n    getPane: function getPane(pane) {\n      return typeof pane === 'string' ? this._panes[pane] : pane;\n    },\n    // @method getPanes(): Object\n    // Returns a plain object containing the names of all [panes](#map-pane) as keys and\n    // the panes as values.\n    getPanes: function getPanes() {\n      return this._panes;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTML element that contains the map.\n    getContainer: function getContainer() {\n      return this._container;\n    },\n    // @section Conversion Methods\n\n    // @method getZoomScale(toZoom: Number, fromZoom: Number): Number\n    // Returns the scale factor to be applied to a map transition from zoom level\n    // `fromZoom` to `toZoom`. Used internally to help with zoom animations.\n    getZoomScale: function getZoomScale(toZoom, fromZoom) {\n      // TODO replace with universal implementation after refactoring projections\n      var crs = this.options.crs;\n      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\n      return crs.scale(toZoom) / crs.scale(fromZoom);\n    },\n    // @method getScaleZoom(scale: Number, fromZoom: Number): Number\n    // Returns the zoom level that the map would end up at, if it is at `fromZoom`\n    // level and everything is scaled by a factor of `scale`. Inverse of\n    // [`getZoomScale`](#map-getZoomScale).\n    getScaleZoom: function getScaleZoom(scale, fromZoom) {\n      var crs = this.options.crs;\n      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\n      var zoom = crs.zoom(scale * crs.scale(fromZoom));\n      return isNaN(zoom) ? Infinity : zoom;\n    },\n    // @method project(latlng: LatLng, zoom: Number): Point\n    // Projects a geographical coordinate `LatLng` according to the projection\n    // of the map's CRS, then scales it according to `zoom` and the CRS's\n    // `Transformation`. The result is pixel coordinate relative to\n    // the CRS origin.\n    project: function project(latlng, zoom) {\n      zoom = zoom === undefined ? this._zoom : zoom;\n      return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);\n    },\n    // @method unproject(point: Point, zoom: Number): LatLng\n    // Inverse of [`project`](#map-project).\n    unproject: function unproject(point, zoom) {\n      zoom = zoom === undefined ? this._zoom : zoom;\n      return this.options.crs.pointToLatLng(toPoint(point), zoom);\n    },\n    // @method layerPointToLatLng(point: Point): LatLng\n    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n    // returns the corresponding geographical coordinate (for the current zoom level).\n    layerPointToLatLng: function layerPointToLatLng(point) {\n      var projectedPoint = toPoint(point).add(this.getPixelOrigin());\n      return this.unproject(projectedPoint);\n    },\n    // @method latLngToLayerPoint(latlng: LatLng): Point\n    // Given a geographical coordinate, returns the corresponding pixel coordinate\n    // relative to the [origin pixel](#map-getpixelorigin).\n    latLngToLayerPoint: function latLngToLayerPoint(latlng) {\n      var projectedPoint = this.project(toLatLng(latlng))._round();\n      return projectedPoint._subtract(this.getPixelOrigin());\n    },\n    // @method wrapLatLng(latlng: LatLng): LatLng\n    // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the\n    // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the\n    // CRS's bounds.\n    // By default this means longitude is wrapped around the dateline so its\n    // value is between -180 and +180 degrees.\n    wrapLatLng: function wrapLatLng(latlng) {\n      return this.options.crs.wrapLatLng(toLatLng(latlng));\n    },\n    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\n    // Returns a `LatLngBounds` with the same size as the given one, ensuring that\n    // its center is within the CRS's bounds.\n    // By default this means the center longitude is wrapped around the dateline so its\n    // value is between -180 and +180 degrees, and the majority of the bounds\n    // overlaps the CRS's bounds.\n    wrapLatLngBounds: function wrapLatLngBounds(latlng) {\n      return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));\n    },\n    // @method distance(latlng1: LatLng, latlng2: LatLng): Number\n    // Returns the distance between two geographical coordinates according to\n    // the map's CRS. By default this measures distance in meters.\n    distance: function distance(latlng1, latlng2) {\n      return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));\n    },\n    // @method containerPointToLayerPoint(point: Point): Point\n    // Given a pixel coordinate relative to the map container, returns the corresponding\n    // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).\n    containerPointToLayerPoint: function containerPointToLayerPoint(point) {\n      // (Point)\n      return toPoint(point).subtract(this._getMapPanePos());\n    },\n    // @method layerPointToContainerPoint(point: Point): Point\n    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n    // returns the corresponding pixel coordinate relative to the map container.\n    layerPointToContainerPoint: function layerPointToContainerPoint(point) {\n      // (Point)\n      return toPoint(point).add(this._getMapPanePos());\n    },\n    // @method containerPointToLatLng(point: Point): LatLng\n    // Given a pixel coordinate relative to the map container, returns\n    // the corresponding geographical coordinate (for the current zoom level).\n    containerPointToLatLng: function containerPointToLatLng(point) {\n      var layerPoint = this.containerPointToLayerPoint(toPoint(point));\n      return this.layerPointToLatLng(layerPoint);\n    },\n    // @method latLngToContainerPoint(latlng: LatLng): Point\n    // Given a geographical coordinate, returns the corresponding pixel coordinate\n    // relative to the map container.\n    latLngToContainerPoint: function latLngToContainerPoint(latlng) {\n      return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));\n    },\n    // @method mouseEventToContainerPoint(ev: MouseEvent): Point\n    // Given a MouseEvent object, returns the pixel coordinate relative to the\n    // map container where the event took place.\n    mouseEventToContainerPoint: function mouseEventToContainerPoint(e) {\n      return getMousePosition(e, this._container);\n    },\n    // @method mouseEventToLayerPoint(ev: MouseEvent): Point\n    // Given a MouseEvent object, returns the pixel coordinate relative to\n    // the [origin pixel](#map-getpixelorigin) where the event took place.\n    mouseEventToLayerPoint: function mouseEventToLayerPoint(e) {\n      return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\n    },\n    // @method mouseEventToLatLng(ev: MouseEvent): LatLng\n    // Given a MouseEvent object, returns geographical coordinate where the\n    // event took place.\n    mouseEventToLatLng: function mouseEventToLatLng(e) {\n      // (MouseEvent)\n      return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\n    },\n    // map initialization methods\n\n    _initContainer: function _initContainer(id) {\n      var container = this._container = get(id);\n      if (!container) {\n        throw new Error('Map container not found.');\n      } else if (container._leaflet_id) {\n        throw new Error('Map container is already initialized.');\n      }\n      on(container, 'scroll', this._onScroll, this);\n      this._containerId = stamp(container);\n    },\n    _initLayout: function _initLayout() {\n      var container = this._container;\n      this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;\n      addClass(container, 'leaflet-container' + (Browser.touch ? ' leaflet-touch' : '') + (Browser.retina ? ' leaflet-retina' : '') + (Browser.ielt9 ? ' leaflet-oldie' : '') + (Browser.safari ? ' leaflet-safari' : '') + (this._fadeAnimated ? ' leaflet-fade-anim' : ''));\n      var position = getStyle(container, 'position');\n      if (position !== 'absolute' && position !== 'relative' && position !== 'fixed' && position !== 'sticky') {\n        container.style.position = 'relative';\n      }\n      this._initPanes();\n      if (this._initControlPos) {\n        this._initControlPos();\n      }\n    },\n    _initPanes: function _initPanes() {\n      var panes = this._panes = {};\n      this._paneRenderers = {};\n\n      // @section\n      //\n      // Panes are DOM elements used to control the ordering of layers on the map. You\n      // can access panes with [`map.getPane`](#map-getpane) or\n      // [`map.getPanes`](#map-getpanes) methods. New panes can be created with the\n      // [`map.createPane`](#map-createpane) method.\n      //\n      // Every map has the following default panes that differ only in zIndex.\n      //\n      // @pane mapPane: HTMLElement = 'auto'\n      // Pane that contains all other map panes\n\n      this._mapPane = this.createPane('mapPane', this._container);\n      setPosition(this._mapPane, new Point(0, 0));\n\n      // @pane tilePane: HTMLElement = 200\n      // Pane for `GridLayer`s and `TileLayer`s\n      this.createPane('tilePane');\n      // @pane overlayPane: HTMLElement = 400\n      // Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s\n      this.createPane('overlayPane');\n      // @pane shadowPane: HTMLElement = 500\n      // Pane for overlay shadows (e.g. `Marker` shadows)\n      this.createPane('shadowPane');\n      // @pane markerPane: HTMLElement = 600\n      // Pane for `Icon`s of `Marker`s\n      this.createPane('markerPane');\n      // @pane tooltipPane: HTMLElement = 650\n      // Pane for `Tooltip`s.\n      this.createPane('tooltipPane');\n      // @pane popupPane: HTMLElement = 700\n      // Pane for `Popup`s.\n      this.createPane('popupPane');\n      if (!this.options.markerZoomAnimation) {\n        addClass(panes.markerPane, 'leaflet-zoom-hide');\n        addClass(panes.shadowPane, 'leaflet-zoom-hide');\n      }\n    },\n    // private methods that modify map state\n\n    // @section Map state change events\n    _resetView: function _resetView(center, zoom, noMoveStart) {\n      setPosition(this._mapPane, new Point(0, 0));\n      var loading = !this._loaded;\n      this._loaded = true;\n      zoom = this._limitZoom(zoom);\n      this.fire('viewprereset');\n      var zoomChanged = this._zoom !== zoom;\n      this._moveStart(zoomChanged, noMoveStart)._move(center, zoom)._moveEnd(zoomChanged);\n\n      // @event viewreset: Event\n      // Fired when the map needs to redraw its content (this usually happens\n      // on map zoom or load). Very useful for creating custom overlays.\n      this.fire('viewreset');\n\n      // @event load: Event\n      // Fired when the map is initialized (when its center and zoom are set\n      // for the first time).\n      if (loading) {\n        this.fire('load');\n      }\n    },\n    _moveStart: function _moveStart(zoomChanged, noMoveStart) {\n      // @event zoomstart: Event\n      // Fired when the map zoom is about to change (e.g. before zoom animation).\n      // @event movestart: Event\n      // Fired when the view of the map starts changing (e.g. user starts dragging the map).\n      if (zoomChanged) {\n        this.fire('zoomstart');\n      }\n      if (!noMoveStart) {\n        this.fire('movestart');\n      }\n      return this;\n    },\n    _move: function _move(center, zoom, data, supressEvent) {\n      if (zoom === undefined) {\n        zoom = this._zoom;\n      }\n      var zoomChanged = this._zoom !== zoom;\n      this._zoom = zoom;\n      this._lastCenter = center;\n      this._pixelOrigin = this._getNewPixelOrigin(center);\n      if (!supressEvent) {\n        // @event zoom: Event\n        // Fired repeatedly during any change in zoom level,\n        // including zoom and fly animations.\n        if (zoomChanged || data && data.pinch) {\n          // Always fire 'zoom' if pinching because #3530\n          this.fire('zoom', data);\n        }\n\n        // @event move: Event\n        // Fired repeatedly during any movement of the map,\n        // including pan and fly animations.\n        this.fire('move', data);\n      } else if (data && data.pinch) {\n        // Always fire 'zoom' if pinching because #3530\n        this.fire('zoom', data);\n      }\n      return this;\n    },\n    _moveEnd: function _moveEnd(zoomChanged) {\n      // @event zoomend: Event\n      // Fired when the map zoom changed, after any animations.\n      if (zoomChanged) {\n        this.fire('zoomend');\n      }\n\n      // @event moveend: Event\n      // Fired when the center of the map stops changing\n      // (e.g. user stopped dragging the map or after non-centered zoom).\n      return this.fire('moveend');\n    },\n    _stop: function _stop() {\n      cancelAnimFrame(this._flyToFrame);\n      if (this._panAnim) {\n        this._panAnim.stop();\n      }\n      return this;\n    },\n    _rawPanBy: function _rawPanBy(offset) {\n      setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\n    },\n    _getZoomSpan: function _getZoomSpan() {\n      return this.getMaxZoom() - this.getMinZoom();\n    },\n    _panInsideMaxBounds: function _panInsideMaxBounds() {\n      if (!this._enforcingBounds) {\n        this.panInsideBounds(this.options.maxBounds);\n      }\n    },\n    _checkIfLoaded: function _checkIfLoaded() {\n      if (!this._loaded) {\n        throw new Error('Set map center and zoom first.');\n      }\n    },\n    // DOM event handling\n\n    // @section Interaction events\n    _initEvents: function _initEvents(remove) {\n      this._targets = {};\n      this._targets[stamp(this._container)] = this;\n      var onOff = remove ? off : on;\n\n      // @event click: MouseEvent\n      // Fired when the user clicks (or taps) the map.\n      // @event dblclick: MouseEvent\n      // Fired when the user double-clicks (or double-taps) the map.\n      // @event mousedown: MouseEvent\n      // Fired when the user pushes the mouse button on the map.\n      // @event mouseup: MouseEvent\n      // Fired when the user releases the mouse button on the map.\n      // @event mouseover: MouseEvent\n      // Fired when the mouse enters the map.\n      // @event mouseout: MouseEvent\n      // Fired when the mouse leaves the map.\n      // @event mousemove: MouseEvent\n      // Fired while the mouse moves over the map.\n      // @event contextmenu: MouseEvent\n      // Fired when the user pushes the right mouse button on the map, prevents\n      // default browser context menu from showing if there are listeners on\n      // this event. Also fired on mobile when the user holds a single touch\n      // for a second (also called long press).\n      // @event keypress: KeyboardEvent\n      // Fired when the user presses a key from the keyboard that produces a character value while the map is focused.\n      // @event keydown: KeyboardEvent\n      // Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,\n      // the `keydown` event is fired for keys that produce a character value and for keys\n      // that do not produce a character value.\n      // @event keyup: KeyboardEvent\n      // Fired when the user releases a key from the keyboard while the map is focused.\n      onOff(this._container, 'click dblclick mousedown mouseup ' + 'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);\n      if (this.options.trackResize) {\n        onOff(window, 'resize', this._onResize, this);\n      }\n      if (Browser.any3d && this.options.transform3DLimit) {\n        (remove ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);\n      }\n    },\n    _onResize: function _onResize() {\n      cancelAnimFrame(this._resizeRequest);\n      this._resizeRequest = requestAnimFrame(function () {\n        this.invalidateSize({\n          debounceMoveend: true\n        });\n      }, this);\n    },\n    _onScroll: function _onScroll() {\n      this._container.scrollTop = 0;\n      this._container.scrollLeft = 0;\n    },\n    _onMoveEnd: function _onMoveEnd() {\n      var pos = this._getMapPanePos();\n      if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have\n        // a pixel offset on very high values, see: https://jsfiddle.net/dg6r5hhb/\n        this._resetView(this.getCenter(), this.getZoom());\n      }\n    },\n    _findEventTargets: function _findEventTargets(e, type) {\n      var targets = [],\n        target,\n        isHover = type === 'mouseout' || type === 'mouseover',\n        src = e.target || e.srcElement,\n        dragging = false;\n      while (src) {\n        target = this._targets[stamp(src)];\n        if (target && (type === 'click' || type === 'preclick') && this._draggableMoved(target)) {\n          // Prevent firing click after you just dragged an object.\n          dragging = true;\n          break;\n        }\n        if (target && target.listens(type, true)) {\n          if (isHover && !isExternalTarget(src, e)) {\n            break;\n          }\n          targets.push(target);\n          if (isHover) {\n            break;\n          }\n        }\n        if (src === this._container) {\n          break;\n        }\n        src = src.parentNode;\n      }\n      if (!targets.length && !dragging && !isHover && this.listens(type, true)) {\n        targets = [this];\n      }\n      return targets;\n    },\n    _isClickDisabled: function _isClickDisabled(el) {\n      while (el && el !== this._container) {\n        if (el['_leaflet_disable_click']) {\n          return true;\n        }\n        el = el.parentNode;\n      }\n    },\n    _handleDOMEvent: function _handleDOMEvent(e) {\n      var el = e.target || e.srcElement;\n      if (!this._loaded || el['_leaflet_disable_events'] || e.type === 'click' && this._isClickDisabled(el)) {\n        return;\n      }\n      var type = e.type;\n      if (type === 'mousedown') {\n        // prevents outline when clicking on keyboard-focusable element\n        preventOutline(el);\n      }\n      this._fireDOMEvent(e, type);\n    },\n    _mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],\n    _fireDOMEvent: function _fireDOMEvent(e, type, canvasTargets) {\n      if (e.type === 'click') {\n        // Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).\n        // @event preclick: MouseEvent\n        // Fired before mouse click on the map (sometimes useful when you\n        // want something to happen on click before any existing click\n        // handlers start running).\n        var synth = extend({}, e);\n        synth.type = 'preclick';\n        this._fireDOMEvent(synth, synth.type, canvasTargets);\n      }\n\n      // Find the layer the event is propagating from and its parents.\n      var targets = this._findEventTargets(e, type);\n      if (canvasTargets) {\n        var filtered = []; // pick only targets with listeners\n        for (var i = 0; i < canvasTargets.length; i++) {\n          if (canvasTargets[i].listens(type, true)) {\n            filtered.push(canvasTargets[i]);\n          }\n        }\n        targets = filtered.concat(targets);\n      }\n      if (!targets.length) {\n        return;\n      }\n      if (type === 'contextmenu') {\n        preventDefault(e);\n      }\n      var target = targets[0];\n      var data = {\n        originalEvent: e\n      };\n      if (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {\n        var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);\n        data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);\n        data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);\n        data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);\n      }\n      for (i = 0; i < targets.length; i++) {\n        targets[i].fire(type, data, true);\n        if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {\n          return;\n        }\n      }\n    },\n    _draggableMoved: function _draggableMoved(obj) {\n      obj = obj.dragging && obj.dragging.enabled() ? obj : this;\n      return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();\n    },\n    _clearHandlers: function _clearHandlers() {\n      for (var i = 0, len = this._handlers.length; i < len; i++) {\n        this._handlers[i].disable();\n      }\n    },\n    // @section Other Methods\n\n    // @method whenReady(fn: Function, context?: Object): this\n    // Runs the given function `fn` when the map gets initialized with\n    // a view (center and zoom) and at least one layer, or immediately\n    // if it's already initialized, optionally passing a function context.\n    whenReady: function whenReady(callback, context) {\n      if (this._loaded) {\n        callback.call(context || this, {\n          target: this\n        });\n      } else {\n        this.on('load', callback, context);\n      }\n      return this;\n    },\n    // private methods for getting map state\n\n    _getMapPanePos: function _getMapPanePos() {\n      return getPosition(this._mapPane) || new Point(0, 0);\n    },\n    _moved: function _moved() {\n      var pos = this._getMapPanePos();\n      return pos && !pos.equals([0, 0]);\n    },\n    _getTopLeftPoint: function _getTopLeftPoint(center, zoom) {\n      var pixelOrigin = center && zoom !== undefined ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin();\n      return pixelOrigin.subtract(this._getMapPanePos());\n    },\n    _getNewPixelOrigin: function _getNewPixelOrigin(center, zoom) {\n      var viewHalf = this.getSize()._divideBy(2);\n      return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();\n    },\n    _latLngToNewLayerPoint: function _latLngToNewLayerPoint(latlng, zoom, center) {\n      var topLeft = this._getNewPixelOrigin(center, zoom);\n      return this.project(latlng, zoom)._subtract(topLeft);\n    },\n    _latLngBoundsToNewLayerBounds: function _latLngBoundsToNewLayerBounds(latLngBounds, zoom, center) {\n      var topLeft = this._getNewPixelOrigin(center, zoom);\n      return toBounds([this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)]);\n    },\n    // layer point of the current center\n    _getCenterLayerPoint: function _getCenterLayerPoint() {\n      return this.containerPointToLayerPoint(this.getSize()._divideBy(2));\n    },\n    // offset of the specified place to the current center in pixels\n    _getCenterOffset: function _getCenterOffset(latlng) {\n      return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\n    },\n    // adjust center for view to get inside bounds\n    _limitCenter: function _limitCenter(center, zoom, bounds) {\n      if (!bounds) {\n        return center;\n      }\n      var centerPoint = this.project(center, zoom),\n        viewHalf = this.getSize().divideBy(2),\n        viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\n        offset = this._getBoundsOffset(viewBounds, bounds, zoom);\n\n      // If offset is less than a pixel, ignore.\n      // This prevents unstable projections from getting into\n      // an infinite loop of tiny offsets.\n      if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {\n        return center;\n      }\n      return this.unproject(centerPoint.add(offset), zoom);\n    },\n    // adjust offset for view to get inside bounds\n    _limitOffset: function _limitOffset(offset, bounds) {\n      if (!bounds) {\n        return offset;\n      }\n      var viewBounds = this.getPixelBounds(),\n        newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\n      return offset.add(this._getBoundsOffset(newBounds, bounds));\n    },\n    // returns offset needed for pxBounds to get inside maxBounds at a specified zoom\n    _getBoundsOffset: function _getBoundsOffset(pxBounds, maxBounds, zoom) {\n      var projectedMaxBounds = toBounds(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)),\n        minOffset = projectedMaxBounds.min.subtract(pxBounds.min),\n        maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),\n        dx = this._rebound(minOffset.x, -maxOffset.x),\n        dy = this._rebound(minOffset.y, -maxOffset.y);\n      return new Point(dx, dy);\n    },\n    _rebound: function _rebound(left, right) {\n      return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\n    },\n    _limitZoom: function _limitZoom(zoom) {\n      var min = this.getMinZoom(),\n        max = this.getMaxZoom(),\n        snap = Browser.any3d ? this.options.zoomSnap : 1;\n      if (snap) {\n        zoom = Math.round(zoom / snap) * snap;\n      }\n      return Math.max(min, Math.min(max, zoom));\n    },\n    _onPanTransitionStep: function _onPanTransitionStep() {\n      this.fire('move');\n    },\n    _onPanTransitionEnd: function _onPanTransitionEnd() {\n      removeClass(this._mapPane, 'leaflet-pan-anim');\n      this.fire('moveend');\n    },\n    _tryAnimatedPan: function _tryAnimatedPan(center, options) {\n      // difference between the new and current centers in pixels\n      var offset = this._getCenterOffset(center)._trunc();\n\n      // don't animate too far unless animate: true specified in options\n      if ((options && options.animate) !== true && !this.getSize().contains(offset)) {\n        return false;\n      }\n      this.panBy(offset, options);\n      return true;\n    },\n    _createAnimProxy: function _createAnimProxy() {\n      var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');\n      this._panes.mapPane.appendChild(proxy);\n      this.on('zoomanim', function (e) {\n        var prop = TRANSFORM,\n          transform = this._proxy.style[prop];\n        setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));\n\n        // workaround for case when transform is the same and so transitionend event is not fired\n        if (transform === this._proxy.style[prop] && this._animatingZoom) {\n          this._onZoomTransitionEnd();\n        }\n      }, this);\n      this.on('load moveend', this._animMoveEnd, this);\n      this._on('unload', this._destroyAnimProxy, this);\n    },\n    _destroyAnimProxy: function _destroyAnimProxy() {\n      _remove(this._proxy);\n      this.off('load moveend', this._animMoveEnd, this);\n      delete this._proxy;\n    },\n    _animMoveEnd: function _animMoveEnd() {\n      var c = this.getCenter(),\n        z = this.getZoom();\n      setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));\n    },\n    _catchTransitionEnd: function _catchTransitionEnd(e) {\n      if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\n        this._onZoomTransitionEnd();\n      }\n    },\n    _nothingToAnimate: function _nothingToAnimate() {\n      return !this._container.getElementsByClassName('leaflet-zoom-animated').length;\n    },\n    _tryAnimatedZoom: function _tryAnimatedZoom(center, zoom, options) {\n      if (this._animatingZoom) {\n        return true;\n      }\n      options = options || {};\n\n      // don't animate if disabled, not supported or zoom difference is too large\n      if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {\n        return false;\n      }\n\n      // offset is the pixel coords of the zoom origin relative to the current center\n      var scale = this.getZoomScale(zoom),\n        offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);\n\n      // don't animate if the zoom origin isn't within one screen from the current center, unless forced\n      if (options.animate !== true && !this.getSize().contains(offset)) {\n        return false;\n      }\n      requestAnimFrame(function () {\n        this._moveStart(true, options.noMoveStart || false)._animateZoom(center, zoom, true);\n      }, this);\n      return true;\n    },\n    _animateZoom: function _animateZoom(center, zoom, startAnim, noUpdate) {\n      if (!this._mapPane) {\n        return;\n      }\n      if (startAnim) {\n        this._animatingZoom = true;\n\n        // remember what center/zoom to set after animation\n        this._animateToCenter = center;\n        this._animateToZoom = zoom;\n        addClass(this._mapPane, 'leaflet-zoom-anim');\n      }\n\n      // @section Other Events\n      // @event zoomanim: ZoomAnimEvent\n      // Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.\n      this.fire('zoomanim', {\n        center: center,\n        zoom: zoom,\n        noUpdate: noUpdate\n      });\n      if (!this._tempFireZoomEvent) {\n        this._tempFireZoomEvent = this._zoom !== this._animateToZoom;\n      }\n      this._move(this._animateToCenter, this._animateToZoom, undefined, true);\n\n      // Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693\n      setTimeout(bind(this._onZoomTransitionEnd, this), 250);\n    },\n    _onZoomTransitionEnd: function _onZoomTransitionEnd() {\n      if (!this._animatingZoom) {\n        return;\n      }\n      if (this._mapPane) {\n        removeClass(this._mapPane, 'leaflet-zoom-anim');\n      }\n      this._animatingZoom = false;\n      this._move(this._animateToCenter, this._animateToZoom, undefined, true);\n      if (this._tempFireZoomEvent) {\n        this.fire('zoom');\n      }\n      delete this._tempFireZoomEvent;\n      this.fire('move');\n      this._moveEnd(true);\n    }\n  });\n\n  // @section\n\n  // @factory L.map(id: String, options?: Map options)\n  // Instantiates a map object given the DOM ID of a `<div>` element\n  // and optionally an object literal with `Map options`.\n  //\n  // @alternative\n  // @factory L.map(el: HTMLElement, options?: Map options)\n  // Instantiates a map object given an instance of a `<div>` HTML element\n  // and optionally an object literal with `Map options`.\n  function createMap(id, options) {\n    return new Map(id, options);\n  }\n\n  /*\r\n   * @class Control\r\n   * @aka L.Control\r\n   * @inherits Class\r\n   *\r\n   * L.Control is a base class for implementing map controls. Handles positioning.\r\n   * All other controls extend from this class.\r\n   */\n\n  var Control = Class.extend({\n    // @section\n    // @aka Control Options\n    options: {\n      // @option position: String = 'topright'\n      // The position of the control (one of the map corners). Possible values are `'topleft'`,\n      // `'topright'`, `'bottomleft'` or `'bottomright'`\n      position: 'topright'\n    },\n    initialize: function initialize(options) {\n      setOptions(this, options);\n    },\n    /* @section\r\n     * Classes extending L.Control will inherit the following methods:\r\n     *\r\n     * @method getPosition: string\r\n     * Returns the position of the control.\r\n     */\n    getPosition: function getPosition() {\n      return this.options.position;\n    },\n    // @method setPosition(position: string): this\n    // Sets the position of the control.\n    setPosition: function setPosition(position) {\n      var map = this._map;\n      if (map) {\n        map.removeControl(this);\n      }\n      this.options.position = position;\n      if (map) {\n        map.addControl(this);\n      }\n      return this;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTMLElement that contains the control.\n    getContainer: function getContainer() {\n      return this._container;\n    },\n    // @method addTo(map: Map): this\n    // Adds the control to the given map.\n    addTo: function addTo(map) {\n      this.remove();\n      this._map = map;\n      var container = this._container = this.onAdd(map),\n        pos = this.getPosition(),\n        corner = map._controlCorners[pos];\n      addClass(container, 'leaflet-control');\n      if (pos.indexOf('bottom') !== -1) {\n        corner.insertBefore(container, corner.firstChild);\n      } else {\n        corner.appendChild(container);\n      }\n      this._map.on('unload', this.remove, this);\n      return this;\n    },\n    // @method remove: this\n    // Removes the control from the map it is currently active on.\n    remove: function remove() {\n      if (!this._map) {\n        return this;\n      }\n      _remove(this._container);\n      if (this.onRemove) {\n        this.onRemove(this._map);\n      }\n      this._map.off('unload', this.remove, this);\n      this._map = null;\n      return this;\n    },\n    _refocusOnMap: function _refocusOnMap(e) {\n      // if map exists and event is not a keyboard event\n      if (this._map && e && e.screenX > 0 && e.screenY > 0) {\n        this._map.getContainer().focus();\n      }\n    }\n  });\n  var control = function control(options) {\n    return new Control(options);\n  };\n\n  /* @section Extension methods\r\n   * @uninheritable\r\n   *\r\n   * Every control should extend from `L.Control` and (re-)implement the following methods.\r\n   *\r\n   * @method onAdd(map: Map): HTMLElement\r\n   * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).\r\n   *\r\n   * @method onRemove(map: Map)\r\n   * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).\r\n   */\n\n  /* @namespace Map\r\n   * @section Methods for Layers and Controls\r\n   */\n  Map.include({\n    // @method addControl(control: Control): this\n    // Adds the given control to the map\n    addControl: function addControl(control) {\n      control.addTo(this);\n      return this;\n    },\n    // @method removeControl(control: Control): this\n    // Removes the given control from the map\n    removeControl: function removeControl(control) {\n      control.remove();\n      return this;\n    },\n    _initControlPos: function _initControlPos() {\n      var corners = this._controlCorners = {},\n        l = 'leaflet-',\n        container = this._controlContainer = create$1('div', l + 'control-container', this._container);\n      function createCorner(vSide, hSide) {\n        var className = l + vSide + ' ' + l + hSide;\n        corners[vSide + hSide] = create$1('div', className, container);\n      }\n      createCorner('top', 'left');\n      createCorner('top', 'right');\n      createCorner('bottom', 'left');\n      createCorner('bottom', 'right');\n    },\n    _clearControlPos: function _clearControlPos() {\n      for (var i in this._controlCorners) {\n        _remove(this._controlCorners[i]);\n      }\n      _remove(this._controlContainer);\n      delete this._controlCorners;\n      delete this._controlContainer;\n    }\n  });\n\n  /*\r\n   * @class Control.Layers\r\n   * @aka L.Control.Layers\r\n   * @inherits Control\r\n   *\r\n   * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](https://leafletjs.com/examples/layers-control/)). Extends `Control`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var baseLayers = {\r\n   * \t\"Mapbox\": mapbox,\r\n   * \t\"OpenStreetMap\": osm\r\n   * };\r\n   *\r\n   * var overlays = {\r\n   * \t\"Marker\": marker,\r\n   * \t\"Roads\": roadsLayer\r\n   * };\r\n   *\r\n   * L.control.layers(baseLayers, overlays).addTo(map);\r\n   * ```\r\n   *\r\n   * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:\r\n   *\r\n   * ```js\r\n   * {\r\n   *     \"<someName1>\": layer1,\r\n   *     \"<someName2>\": layer2\r\n   * }\r\n   * ```\r\n   *\r\n   * The layer names can contain HTML, which allows you to add additional styling to the items:\r\n   *\r\n   * ```js\r\n   * {\"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>\": myLayer}\r\n   * ```\r\n   */\n\n  var Layers = Control.extend({\n    // @section\n    // @aka Control.Layers options\n    options: {\n      // @option collapsed: Boolean = true\n      // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.\n      collapsed: true,\n      position: 'topright',\n      // @option autoZIndex: Boolean = true\n      // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.\n      autoZIndex: true,\n      // @option hideSingleBase: Boolean = false\n      // If `true`, the base layers in the control will be hidden when there is only one.\n      hideSingleBase: false,\n      // @option sortLayers: Boolean = false\n      // Whether to sort the layers. When `false`, layers will keep the order\n      // in which they were added to the control.\n      sortLayers: false,\n      // @option sortFunction: Function = *\n      // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\n      // that will be used for sorting the layers, when `sortLayers` is `true`.\n      // The function receives both the `L.Layer` instances and their names, as in\n      // `sortFunction(layerA, layerB, nameA, nameB)`.\n      // By default, it sorts layers alphabetically by their name.\n      sortFunction: function sortFunction(layerA, layerB, nameA, nameB) {\n        return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;\n      }\n    },\n    initialize: function initialize(baseLayers, overlays, options) {\n      setOptions(this, options);\n      this._layerControlInputs = [];\n      this._layers = [];\n      this._lastZIndex = 0;\n      this._handlingClick = false;\n      this._preventClick = false;\n      for (var i in baseLayers) {\n        this._addLayer(baseLayers[i], i);\n      }\n      for (i in overlays) {\n        this._addLayer(overlays[i], i, true);\n      }\n    },\n    onAdd: function onAdd(map) {\n      this._initLayout();\n      this._update();\n      this._map = map;\n      map.on('zoomend', this._checkDisabledLayers, this);\n      for (var i = 0; i < this._layers.length; i++) {\n        this._layers[i].layer.on('add remove', this._onLayerChange, this);\n      }\n      return this._container;\n    },\n    addTo: function addTo(map) {\n      Control.prototype.addTo.call(this, map);\n      // Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.\n      return this._expandIfNotCollapsed();\n    },\n    onRemove: function onRemove() {\n      this._map.off('zoomend', this._checkDisabledLayers, this);\n      for (var i = 0; i < this._layers.length; i++) {\n        this._layers[i].layer.off('add remove', this._onLayerChange, this);\n      }\n    },\n    // @method addBaseLayer(layer: Layer, name: String): this\n    // Adds a base layer (radio button entry) with the given name to the control.\n    addBaseLayer: function addBaseLayer(layer, name) {\n      this._addLayer(layer, name);\n      return this._map ? this._update() : this;\n    },\n    // @method addOverlay(layer: Layer, name: String): this\n    // Adds an overlay (checkbox entry) with the given name to the control.\n    addOverlay: function addOverlay(layer, name) {\n      this._addLayer(layer, name, true);\n      return this._map ? this._update() : this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Remove the given layer from the control.\n    removeLayer: function removeLayer(layer) {\n      layer.off('add remove', this._onLayerChange, this);\n      var obj = this._getLayer(stamp(layer));\n      if (obj) {\n        this._layers.splice(this._layers.indexOf(obj), 1);\n      }\n      return this._map ? this._update() : this;\n    },\n    // @method expand(): this\n    // Expand the control container if collapsed.\n    expand: function expand() {\n      addClass(this._container, 'leaflet-control-layers-expanded');\n      this._section.style.height = null;\n      var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);\n      if (acceptableHeight < this._section.clientHeight) {\n        addClass(this._section, 'leaflet-control-layers-scrollbar');\n        this._section.style.height = acceptableHeight + 'px';\n      } else {\n        removeClass(this._section, 'leaflet-control-layers-scrollbar');\n      }\n      this._checkDisabledLayers();\n      return this;\n    },\n    // @method collapse(): this\n    // Collapse the control container if expanded.\n    collapse: function collapse() {\n      removeClass(this._container, 'leaflet-control-layers-expanded');\n      return this;\n    },\n    _initLayout: function _initLayout() {\n      var className = 'leaflet-control-layers',\n        container = this._container = create$1('div', className),\n        collapsed = this.options.collapsed;\n\n      // makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released\n      container.setAttribute('aria-haspopup', true);\n      disableClickPropagation(container);\n      disableScrollPropagation(container);\n      var section = this._section = create$1('section', className + '-list');\n      if (collapsed) {\n        this._map.on('click', this.collapse, this);\n        on(container, {\n          mouseenter: this._expandSafely,\n          mouseleave: this.collapse\n        }, this);\n      }\n      var link = this._layersLink = create$1('a', className + '-toggle', container);\n      link.href = '#';\n      link.title = 'Layers';\n      link.setAttribute('role', 'button');\n      on(link, {\n        keydown: function keydown(e) {\n          if (e.keyCode === 13) {\n            this._expandSafely();\n          }\n        },\n        // Certain screen readers intercept the key event and instead send a click event\n        click: function click(e) {\n          preventDefault(e);\n          this._expandSafely();\n        }\n      }, this);\n      if (!collapsed) {\n        this.expand();\n      }\n      this._baseLayersList = create$1('div', className + '-base', section);\n      this._separator = create$1('div', className + '-separator', section);\n      this._overlaysList = create$1('div', className + '-overlays', section);\n      container.appendChild(section);\n    },\n    _getLayer: function _getLayer(id) {\n      for (var i = 0; i < this._layers.length; i++) {\n        if (this._layers[i] && stamp(this._layers[i].layer) === id) {\n          return this._layers[i];\n        }\n      }\n    },\n    _addLayer: function _addLayer(layer, name, overlay) {\n      if (this._map) {\n        layer.on('add remove', this._onLayerChange, this);\n      }\n      this._layers.push({\n        layer: layer,\n        name: name,\n        overlay: overlay\n      });\n      if (this.options.sortLayers) {\n        this._layers.sort(bind(function (a, b) {\n          return this.options.sortFunction(a.layer, b.layer, a.name, b.name);\n        }, this));\n      }\n      if (this.options.autoZIndex && layer.setZIndex) {\n        this._lastZIndex++;\n        layer.setZIndex(this._lastZIndex);\n      }\n      this._expandIfNotCollapsed();\n    },\n    _update: function _update() {\n      if (!this._container) {\n        return this;\n      }\n      empty(this._baseLayersList);\n      empty(this._overlaysList);\n      this._layerControlInputs = [];\n      var baseLayersPresent,\n        overlaysPresent,\n        i,\n        obj,\n        baseLayersCount = 0;\n      for (i = 0; i < this._layers.length; i++) {\n        obj = this._layers[i];\n        this._addItem(obj);\n        overlaysPresent = overlaysPresent || obj.overlay;\n        baseLayersPresent = baseLayersPresent || !obj.overlay;\n        baseLayersCount += !obj.overlay ? 1 : 0;\n      }\n\n      // Hide base layers section if there's only one layer.\n      if (this.options.hideSingleBase) {\n        baseLayersPresent = baseLayersPresent && baseLayersCount > 1;\n        this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';\n      }\n      this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\n      return this;\n    },\n    _onLayerChange: function _onLayerChange(e) {\n      if (!this._handlingClick) {\n        this._update();\n      }\n      var obj = this._getLayer(stamp(e.target));\n\n      // @namespace Map\n      // @section Layer events\n      // @event baselayerchange: LayersControlEvent\n      // Fired when the base layer is changed through the [layers control](#control-layers).\n      // @event overlayadd: LayersControlEvent\n      // Fired when an overlay is selected through the [layers control](#control-layers).\n      // @event overlayremove: LayersControlEvent\n      // Fired when an overlay is deselected through the [layers control](#control-layers).\n      // @namespace Control.Layers\n      var type = obj.overlay ? e.type === 'add' ? 'overlayadd' : 'overlayremove' : e.type === 'add' ? 'baselayerchange' : null;\n      if (type) {\n        this._map.fire(type, obj);\n      }\n    },\n    // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)\n    _createRadioElement: function _createRadioElement(name, checked) {\n      var radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' + name + '\"' + (checked ? ' checked=\"checked\"' : '') + '/>';\n      var radioFragment = document.createElement('div');\n      radioFragment.innerHTML = radioHtml;\n      return radioFragment.firstChild;\n    },\n    _addItem: function _addItem(obj) {\n      var label = document.createElement('label'),\n        checked = this._map.hasLayer(obj.layer),\n        input;\n      if (obj.overlay) {\n        input = document.createElement('input');\n        input.type = 'checkbox';\n        input.className = 'leaflet-control-layers-selector';\n        input.defaultChecked = checked;\n      } else {\n        input = this._createRadioElement('leaflet-base-layers_' + stamp(this), checked);\n      }\n      this._layerControlInputs.push(input);\n      input.layerId = stamp(obj.layer);\n      on(input, 'click', this._onInputClick, this);\n      var name = document.createElement('span');\n      name.innerHTML = ' ' + obj.name;\n\n      // Helps from preventing layer control flicker when checkboxes are disabled\n      // https://github.com/Leaflet/Leaflet/issues/2771\n      var holder = document.createElement('span');\n      label.appendChild(holder);\n      holder.appendChild(input);\n      holder.appendChild(name);\n      var container = obj.overlay ? this._overlaysList : this._baseLayersList;\n      container.appendChild(label);\n      this._checkDisabledLayers();\n      return label;\n    },\n    _onInputClick: function _onInputClick() {\n      // expanding the control on mobile with a click can cause adding a layer - we don't want this\n      if (this._preventClick) {\n        return;\n      }\n      var inputs = this._layerControlInputs,\n        input,\n        layer;\n      var addedLayers = [],\n        removedLayers = [];\n      this._handlingClick = true;\n      for (var i = inputs.length - 1; i >= 0; i--) {\n        input = inputs[i];\n        layer = this._getLayer(input.layerId).layer;\n        if (input.checked) {\n          addedLayers.push(layer);\n        } else if (!input.checked) {\n          removedLayers.push(layer);\n        }\n      }\n\n      // Bugfix issue 2318: Should remove all old layers before readding new ones\n      for (i = 0; i < removedLayers.length; i++) {\n        if (this._map.hasLayer(removedLayers[i])) {\n          this._map.removeLayer(removedLayers[i]);\n        }\n      }\n      for (i = 0; i < addedLayers.length; i++) {\n        if (!this._map.hasLayer(addedLayers[i])) {\n          this._map.addLayer(addedLayers[i]);\n        }\n      }\n      this._handlingClick = false;\n      this._refocusOnMap();\n    },\n    _checkDisabledLayers: function _checkDisabledLayers() {\n      var inputs = this._layerControlInputs,\n        input,\n        layer,\n        zoom = this._map.getZoom();\n      for (var i = inputs.length - 1; i >= 0; i--) {\n        input = inputs[i];\n        layer = this._getLayer(input.layerId).layer;\n        input.disabled = layer.options.minZoom !== undefined && zoom < layer.options.minZoom || layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom;\n      }\n    },\n    _expandIfNotCollapsed: function _expandIfNotCollapsed() {\n      if (this._map && !this.options.collapsed) {\n        this.expand();\n      }\n      return this;\n    },\n    _expandSafely: function _expandSafely() {\n      var section = this._section;\n      this._preventClick = true;\n      on(section, 'click', preventDefault);\n      this.expand();\n      var that = this;\n      setTimeout(function () {\n        off(section, 'click', preventDefault);\n        that._preventClick = false;\n      });\n    }\n  });\n\n  // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)\n  // Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.\n  var layers = function layers(baseLayers, overlays, options) {\n    return new Layers(baseLayers, overlays, options);\n  };\n\n  /*\r\n   * @class Control.Zoom\r\n   * @aka L.Control.Zoom\r\n   * @inherits Control\r\n   *\r\n   * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.\r\n   */\n\n  var Zoom = Control.extend({\n    // @section\n    // @aka Control.Zoom options\n    options: {\n      position: 'topleft',\n      // @option zoomInText: String = '<span aria-hidden=\"true\">+</span>'\n      // The text set on the 'zoom in' button.\n      zoomInText: '<span aria-hidden=\"true\">+</span>',\n      // @option zoomInTitle: String = 'Zoom in'\n      // The title set on the 'zoom in' button.\n      zoomInTitle: 'Zoom in',\n      // @option zoomOutText: String = '<span aria-hidden=\"true\">&#x2212;</span>'\n      // The text set on the 'zoom out' button.\n      zoomOutText: '<span aria-hidden=\"true\">&#x2212;</span>',\n      // @option zoomOutTitle: String = 'Zoom out'\n      // The title set on the 'zoom out' button.\n      zoomOutTitle: 'Zoom out'\n    },\n    onAdd: function onAdd(map) {\n      var zoomName = 'leaflet-control-zoom',\n        container = create$1('div', zoomName + ' leaflet-bar'),\n        options = this.options;\n      this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + '-in', container, this._zoomIn);\n      this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + '-out', container, this._zoomOut);\n      this._updateDisabled();\n      map.on('zoomend zoomlevelschange', this._updateDisabled, this);\n      return container;\n    },\n    onRemove: function onRemove(map) {\n      map.off('zoomend zoomlevelschange', this._updateDisabled, this);\n    },\n    disable: function disable() {\n      this._disabled = true;\n      this._updateDisabled();\n      return this;\n    },\n    enable: function enable() {\n      this._disabled = false;\n      this._updateDisabled();\n      return this;\n    },\n    _zoomIn: function _zoomIn(e) {\n      if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {\n        this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\n      }\n    },\n    _zoomOut: function _zoomOut(e) {\n      if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {\n        this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\n      }\n    },\n    _createButton: function _createButton(html, title, className, container, fn) {\n      var link = create$1('a', className, container);\n      link.innerHTML = html;\n      link.href = '#';\n      link.title = title;\n\n      /*\r\n       * Will force screen readers like VoiceOver to read this as \"Zoom in - button\"\r\n       */\n      link.setAttribute('role', 'button');\n      link.setAttribute('aria-label', title);\n      disableClickPropagation(link);\n      on(link, 'click', stop);\n      on(link, 'click', fn, this);\n      on(link, 'click', this._refocusOnMap, this);\n      return link;\n    },\n    _updateDisabled: function _updateDisabled() {\n      var map = this._map,\n        className = 'leaflet-disabled';\n      removeClass(this._zoomInButton, className);\n      removeClass(this._zoomOutButton, className);\n      this._zoomInButton.setAttribute('aria-disabled', 'false');\n      this._zoomOutButton.setAttribute('aria-disabled', 'false');\n      if (this._disabled || map._zoom === map.getMinZoom()) {\n        addClass(this._zoomOutButton, className);\n        this._zoomOutButton.setAttribute('aria-disabled', 'true');\n      }\n      if (this._disabled || map._zoom === map.getMaxZoom()) {\n        addClass(this._zoomInButton, className);\n        this._zoomInButton.setAttribute('aria-disabled', 'true');\n      }\n    }\n  });\n\n  // @namespace Map\n  // @section Control options\n  // @option zoomControl: Boolean = true\n  // Whether a [zoom control](#control-zoom) is added to the map by default.\n  Map.mergeOptions({\n    zoomControl: true\n  });\n  Map.addInitHook(function () {\n    if (this.options.zoomControl) {\n      // @section Controls\n      // @property zoomControl: Control.Zoom\n      // The default zoom control (only available if the\n      // [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).\n      this.zoomControl = new Zoom();\n      this.addControl(this.zoomControl);\n    }\n  });\n\n  // @namespace Control.Zoom\n  // @factory L.control.zoom(options: Control.Zoom options)\n  // Creates a zoom control\n  var zoom = function zoom(options) {\n    return new Zoom(options);\n  };\n\n  /*\n   * @class Control.Scale\n   * @aka L.Control.Scale\n   * @inherits Control\n   *\n   * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.\n   *\n   * @example\n   *\n   * ```js\n   * L.control.scale().addTo(map);\n   * ```\n   */\n\n  var Scale = Control.extend({\n    // @section\n    // @aka Control.Scale options\n    options: {\n      position: 'bottomleft',\n      // @option maxWidth: Number = 100\n      // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).\n      maxWidth: 100,\n      // @option metric: Boolean = True\n      // Whether to show the metric scale line (m/km).\n      metric: true,\n      // @option imperial: Boolean = True\n      // Whether to show the imperial scale line (mi/ft).\n      imperial: true\n\n      // @option updateWhenIdle: Boolean = false\n      // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).\n    },\n    onAdd: function onAdd(map) {\n      var className = 'leaflet-control-scale',\n        container = create$1('div', className),\n        options = this.options;\n      this._addScales(options, className + '-line', container);\n      map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n      map.whenReady(this._update, this);\n      return container;\n    },\n    onRemove: function onRemove(map) {\n      map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n    },\n    _addScales: function _addScales(options, className, container) {\n      if (options.metric) {\n        this._mScale = create$1('div', className, container);\n      }\n      if (options.imperial) {\n        this._iScale = create$1('div', className, container);\n      }\n    },\n    _update: function _update() {\n      var map = this._map,\n        y = map.getSize().y / 2;\n      var maxMeters = map.distance(map.containerPointToLatLng([0, y]), map.containerPointToLatLng([this.options.maxWidth, y]));\n      this._updateScales(maxMeters);\n    },\n    _updateScales: function _updateScales(maxMeters) {\n      if (this.options.metric && maxMeters) {\n        this._updateMetric(maxMeters);\n      }\n      if (this.options.imperial && maxMeters) {\n        this._updateImperial(maxMeters);\n      }\n    },\n    _updateMetric: function _updateMetric(maxMeters) {\n      var meters = this._getRoundNum(maxMeters),\n        label = meters < 1000 ? meters + ' m' : meters / 1000 + ' km';\n      this._updateScale(this._mScale, label, meters / maxMeters);\n    },\n    _updateImperial: function _updateImperial(maxMeters) {\n      var maxFeet = maxMeters * 3.2808399,\n        maxMiles,\n        miles,\n        feet;\n      if (maxFeet > 5280) {\n        maxMiles = maxFeet / 5280;\n        miles = this._getRoundNum(maxMiles);\n        this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);\n      } else {\n        feet = this._getRoundNum(maxFeet);\n        this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);\n      }\n    },\n    _updateScale: function _updateScale(scale, text, ratio) {\n      scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';\n      scale.innerHTML = text;\n    },\n    _getRoundNum: function _getRoundNum(num) {\n      var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n        d = num / pow10;\n      d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;\n      return pow10 * d;\n    }\n  });\n\n  // @factory L.control.scale(options?: Control.Scale options)\n  // Creates an scale control with the given options.\n  var scale = function scale(options) {\n    return new Scale(options);\n  };\n  var ukrainianFlag = '<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"8\" viewBox=\"0 0 12 8\" class=\"leaflet-attribution-flag\"><path fill=\"#4C7BE1\" d=\"M0 0h12v4H0z\"/><path fill=\"#FFD500\" d=\"M0 4h12v3H0z\"/><path fill=\"#E0BC00\" d=\"M0 7h12v1H0z\"/></svg>';\n\n  /*\r\n   * @class Control.Attribution\r\n   * @aka L.Control.Attribution\r\n   * @inherits Control\r\n   *\r\n   * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.\r\n   */\n\n  var Attribution = Control.extend({\n    // @section\n    // @aka Control.Attribution options\n    options: {\n      position: 'bottomright',\n      // @option prefix: String|false = 'Leaflet'\n      // The HTML text shown before the attributions. Pass `false` to disable.\n      prefix: '<a href=\"https://leafletjs.com\" title=\"A JavaScript library for interactive maps\">' + (Browser.inlineSvg ? ukrainianFlag + ' ' : '') + 'Leaflet</a>'\n    },\n    initialize: function initialize(options) {\n      setOptions(this, options);\n      this._attributions = {};\n    },\n    onAdd: function onAdd(map) {\n      map.attributionControl = this;\n      this._container = create$1('div', 'leaflet-control-attribution');\n      disableClickPropagation(this._container);\n\n      // TODO ugly, refactor\n      for (var i in map._layers) {\n        if (map._layers[i].getAttribution) {\n          this.addAttribution(map._layers[i].getAttribution());\n        }\n      }\n      this._update();\n      map.on('layeradd', this._addAttribution, this);\n      return this._container;\n    },\n    onRemove: function onRemove(map) {\n      map.off('layeradd', this._addAttribution, this);\n    },\n    _addAttribution: function _addAttribution(ev) {\n      if (ev.layer.getAttribution) {\n        this.addAttribution(ev.layer.getAttribution());\n        ev.layer.once('remove', function () {\n          this.removeAttribution(ev.layer.getAttribution());\n        }, this);\n      }\n    },\n    // @method setPrefix(prefix: String|false): this\n    // The HTML text shown before the attributions. Pass `false` to disable.\n    setPrefix: function setPrefix(prefix) {\n      this.options.prefix = prefix;\n      this._update();\n      return this;\n    },\n    // @method addAttribution(text: String): this\n    // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).\n    addAttribution: function addAttribution(text) {\n      if (!text) {\n        return this;\n      }\n      if (!this._attributions[text]) {\n        this._attributions[text] = 0;\n      }\n      this._attributions[text]++;\n      this._update();\n      return this;\n    },\n    // @method removeAttribution(text: String): this\n    // Removes an attribution text.\n    removeAttribution: function removeAttribution(text) {\n      if (!text) {\n        return this;\n      }\n      if (this._attributions[text]) {\n        this._attributions[text]--;\n        this._update();\n      }\n      return this;\n    },\n    _update: function _update() {\n      if (!this._map) {\n        return;\n      }\n      var attribs = [];\n      for (var i in this._attributions) {\n        if (this._attributions[i]) {\n          attribs.push(i);\n        }\n      }\n      var prefixAndAttribs = [];\n      if (this.options.prefix) {\n        prefixAndAttribs.push(this.options.prefix);\n      }\n      if (attribs.length) {\n        prefixAndAttribs.push(attribs.join(', '));\n      }\n      this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden=\"true\">|</span> ');\n    }\n  });\n\n  // @namespace Map\n  // @section Control options\n  // @option attributionControl: Boolean = true\n  // Whether a [attribution control](#control-attribution) is added to the map by default.\n  Map.mergeOptions({\n    attributionControl: true\n  });\n  Map.addInitHook(function () {\n    if (this.options.attributionControl) {\n      new Attribution().addTo(this);\n    }\n  });\n\n  // @namespace Control.Attribution\n  // @factory L.control.attribution(options: Control.Attribution options)\n  // Creates an attribution control.\n  var attribution = function attribution(options) {\n    return new Attribution(options);\n  };\n  Control.Layers = Layers;\n  Control.Zoom = Zoom;\n  Control.Scale = Scale;\n  Control.Attribution = Attribution;\n  control.layers = layers;\n  control.zoom = zoom;\n  control.scale = scale;\n  control.attribution = attribution;\n\n  /*\n  \tL.Handler is a base class for handler classes that are used internally to inject\n  \tinteraction features like dragging to classes like Map and Marker.\n  */\n\n  // @class Handler\n  // @aka L.Handler\n  // Abstract class for map interaction handlers\n\n  var Handler = Class.extend({\n    initialize: function initialize(map) {\n      this._map = map;\n    },\n    // @method enable(): this\n    // Enables the handler\n    enable: function enable() {\n      if (this._enabled) {\n        return this;\n      }\n      this._enabled = true;\n      this.addHooks();\n      return this;\n    },\n    // @method disable(): this\n    // Disables the handler\n    disable: function disable() {\n      if (!this._enabled) {\n        return this;\n      }\n      this._enabled = false;\n      this.removeHooks();\n      return this;\n    },\n    // @method enabled(): Boolean\n    // Returns `true` if the handler is enabled\n    enabled: function enabled() {\n      return !!this._enabled;\n    }\n\n    // @section Extension methods\n    // Classes inheriting from `Handler` must implement the two following methods:\n    // @method addHooks()\n    // Called when the handler is enabled, should add event hooks.\n    // @method removeHooks()\n    // Called when the handler is disabled, should remove the event hooks added previously.\n  });\n\n  // @section There is static function which can be called without instantiating L.Handler:\n  // @function addTo(map: Map, name: String): this\n  // Adds a new Handler to the given map with the given name.\n  Handler.addTo = function (map, name) {\n    map.addHandler(name, this);\n    return this;\n  };\n  var Mixin = {\n    Events: Events\n  };\n\n  /*\r\n   * @class Draggable\r\n   * @aka L.Draggable\r\n   * @inherits Evented\r\n   *\r\n   * A class for making DOM elements draggable (including touch support).\r\n   * Used internally for map and marker dragging. Only works for elements\r\n   * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).\r\n   *\r\n   * @example\r\n   * ```js\r\n   * var draggable = new L.Draggable(elementToDrag);\r\n   * draggable.enable();\r\n   * ```\r\n   */\n\n  var START = Browser.touch ? 'touchstart mousedown' : 'mousedown';\n  var Draggable = Evented.extend({\n    options: {\n      // @section\n      // @aka Draggable options\n      // @option clickTolerance: Number = 3\n      // The max number of pixels a user can shift the mouse pointer during a click\n      // for it to be considered a valid click (as opposed to a mouse drag).\n      clickTolerance: 3\n    },\n    // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)\n    // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).\n    initialize: function initialize(element, dragStartTarget, preventOutline, options) {\n      setOptions(this, options);\n      this._element = element;\n      this._dragStartTarget = dragStartTarget || element;\n      this._preventOutline = preventOutline;\n    },\n    // @method enable()\n    // Enables the dragging ability\n    enable: function enable() {\n      if (this._enabled) {\n        return;\n      }\n      on(this._dragStartTarget, START, this._onDown, this);\n      this._enabled = true;\n    },\n    // @method disable()\n    // Disables the dragging ability\n    disable: function disable() {\n      if (!this._enabled) {\n        return;\n      }\n\n      // If we're currently dragging this draggable,\n      // disabling it counts as first ending the drag.\n      if (Draggable._dragging === this) {\n        this.finishDrag(true);\n      }\n      off(this._dragStartTarget, START, this._onDown, this);\n      this._enabled = false;\n      this._moved = false;\n    },\n    _onDown: function _onDown(e) {\n      // Ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (!this._enabled) {\n        return;\n      }\n      this._moved = false;\n      if (hasClass(this._element, 'leaflet-zoom-anim')) {\n        return;\n      }\n      if (e.touches && e.touches.length !== 1) {\n        // Finish dragging to avoid conflict with touchZoom\n        if (Draggable._dragging === this) {\n          this.finishDrag();\n        }\n        return;\n      }\n      if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {\n        return;\n      }\n      Draggable._dragging = this; // Prevent dragging multiple objects at once.\n\n      if (this._preventOutline) {\n        preventOutline(this._element);\n      }\n      disableImageDrag();\n      disableTextSelection();\n      if (this._moving) {\n        return;\n      }\n\n      // @event down: Event\n      // Fired when a drag is about to start.\n      this.fire('down');\n      var first = e.touches ? e.touches[0] : e,\n        sizedParent = getSizedParentNode(this._element);\n      this._startPoint = new Point(first.clientX, first.clientY);\n      this._startPos = getPosition(this._element);\n\n      // Cache the scale, so that we can continuously compensate for it during drag (_onMove).\n      this._parentScale = getScale(sizedParent);\n      var mouseevent = e.type === 'mousedown';\n      on(document, mouseevent ? 'mousemove' : 'touchmove', this._onMove, this);\n      on(document, mouseevent ? 'mouseup' : 'touchend touchcancel', this._onUp, this);\n    },\n    _onMove: function _onMove(e) {\n      // Ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (!this._enabled) {\n        return;\n      }\n      if (e.touches && e.touches.length > 1) {\n        this._moved = true;\n        return;\n      }\n      var first = e.touches && e.touches.length === 1 ? e.touches[0] : e,\n        offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);\n      if (!offset.x && !offset.y) {\n        return;\n      }\n      if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {\n        return;\n      }\n\n      // We assume that the parent container's position, border and scale do not change for the duration of the drag.\n      // Therefore there is no need to account for the position and border (they are eliminated by the subtraction)\n      // and we can use the cached value for the scale.\n      offset.x /= this._parentScale.x;\n      offset.y /= this._parentScale.y;\n      preventDefault(e);\n      if (!this._moved) {\n        // @event dragstart: Event\n        // Fired when a drag starts\n        this.fire('dragstart');\n        this._moved = true;\n        addClass(document.body, 'leaflet-dragging');\n        this._lastTarget = e.target || e.srcElement;\n        // IE and Edge do not give the <use> element, so fetch it\n        // if necessary\n        if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {\n          this._lastTarget = this._lastTarget.correspondingUseElement;\n        }\n        addClass(this._lastTarget, 'leaflet-drag-target');\n      }\n      this._newPos = this._startPos.add(offset);\n      this._moving = true;\n      this._lastEvent = e;\n      this._updatePosition();\n    },\n    _updatePosition: function _updatePosition() {\n      var e = {\n        originalEvent: this._lastEvent\n      };\n\n      // @event predrag: Event\n      // Fired continuously during dragging *before* each corresponding\n      // update of the element's position.\n      this.fire('predrag', e);\n      setPosition(this._element, this._newPos);\n\n      // @event drag: Event\n      // Fired continuously during dragging.\n      this.fire('drag', e);\n    },\n    _onUp: function _onUp() {\n      // Ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (!this._enabled) {\n        return;\n      }\n      this.finishDrag();\n    },\n    finishDrag: function finishDrag(noInertia) {\n      removeClass(document.body, 'leaflet-dragging');\n      if (this._lastTarget) {\n        removeClass(this._lastTarget, 'leaflet-drag-target');\n        this._lastTarget = null;\n      }\n      off(document, 'mousemove touchmove', this._onMove, this);\n      off(document, 'mouseup touchend touchcancel', this._onUp, this);\n      enableImageDrag();\n      enableTextSelection();\n      var fireDragend = this._moved && this._moving;\n      this._moving = false;\n      Draggable._dragging = false;\n      if (fireDragend) {\n        // @event dragend: DragEndEvent\n        // Fired when the drag ends.\n        this.fire('dragend', {\n          noInertia: noInertia,\n          distance: this._newPos.distanceTo(this._startPos)\n        });\n      }\n    }\n  });\n\n  /*\r\n   * @namespace PolyUtil\r\n   * Various utility functions for polygon geometries.\r\n   */\n\n  /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]\r\n   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).\r\n   * Used by Leaflet to only show polygon points that are on the screen or near, increasing\r\n   * performance. Note that polygon points needs different algorithm for clipping\r\n   * than polyline, so there's a separate method for it.\r\n   */\n  function clipPolygon(points, bounds, round) {\n    var clippedPoints,\n      edges = [1, 4, 2, 8],\n      i,\n      j,\n      k,\n      a,\n      b,\n      len,\n      edge,\n      p;\n    for (i = 0, len = points.length; i < len; i++) {\n      points[i]._code = _getBitCode(points[i], bounds);\n    }\n\n    // for each edge (left, bottom, right, top)\n    for (k = 0; k < 4; k++) {\n      edge = edges[k];\n      clippedPoints = [];\n      for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n        a = points[i];\n        b = points[j];\n\n        // if a is inside the clip window\n        if (!(a._code & edge)) {\n          // if b is outside the clip window (a->b goes out of screen)\n          if (b._code & edge) {\n            p = _getEdgeIntersection(b, a, edge, bounds, round);\n            p._code = _getBitCode(p, bounds);\n            clippedPoints.push(p);\n          }\n          clippedPoints.push(a);\n\n          // else if b is inside the clip window (a->b enters the screen)\n        } else if (!(b._code & edge)) {\n          p = _getEdgeIntersection(b, a, edge, bounds, round);\n          p._code = _getBitCode(p, bounds);\n          clippedPoints.push(p);\n        }\n      }\n      points = clippedPoints;\n    }\n    return points;\n  }\n\n  /* @function polygonCenter(latlngs: LatLng[], crs: CRS): LatLng\r\n   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polygon.\r\n   */\n  function polygonCenter(latlngs, crs) {\n    var i, j, p1, p2, f, area, x, y, center;\n    if (!latlngs || latlngs.length === 0) {\n      throw new Error('latlngs not passed');\n    }\n    if (!isFlat(latlngs)) {\n      console.warn('latlngs are not flat! Only the first ring will be used');\n      latlngs = latlngs[0];\n    }\n    var centroidLatLng = toLatLng([0, 0]);\n    var bounds = toLatLngBounds(latlngs);\n    var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());\n    // tests showed that below 1700 rounding errors are happening\n    if (areaBounds < 1700) {\n      // getting a inexact center, to move the latlngs near to [0, 0] to prevent rounding errors\n      centroidLatLng = centroid(latlngs);\n    }\n    var len = latlngs.length;\n    var points = [];\n    for (i = 0; i < len; i++) {\n      var latlng = toLatLng(latlngs[i]);\n      points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));\n    }\n    area = x = y = 0;\n\n    // polygon centroid algorithm;\n    for (i = 0, j = len - 1; i < len; j = i++) {\n      p1 = points[i];\n      p2 = points[j];\n      f = p1.y * p2.x - p2.y * p1.x;\n      x += (p1.x + p2.x) * f;\n      y += (p1.y + p2.y) * f;\n      area += f * 3;\n    }\n    if (area === 0) {\n      // Polygon is so small that all points are on same pixel.\n      center = points[0];\n    } else {\n      center = [x / area, y / area];\n    }\n    var latlngCenter = crs.unproject(toPoint(center));\n    return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);\n  }\n\n  /* @function centroid(latlngs: LatLng[]): LatLng\r\n   * Returns the 'center of mass' of the passed LatLngs.\r\n   */\n  function centroid(coords) {\n    var latSum = 0;\n    var lngSum = 0;\n    var len = 0;\n    for (var i = 0; i < coords.length; i++) {\n      var latlng = toLatLng(coords[i]);\n      latSum += latlng.lat;\n      lngSum += latlng.lng;\n      len++;\n    }\n    return toLatLng([latSum / len, lngSum / len]);\n  }\n  var PolyUtil = {\n    __proto__: null,\n    clipPolygon: clipPolygon,\n    polygonCenter: polygonCenter,\n    centroid: centroid\n  };\n\n  /*\r\n   * @namespace LineUtil\r\n   *\r\n   * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.\r\n   */\n\n  // Simplify polyline with vertex reduction and Douglas-Peucker simplification.\n  // Improves rendering performance dramatically by lessening the number of points to draw.\n\n  // @function simplify(points: Point[], tolerance: Number): Point[]\n  // Dramatically reduces the number of points in a polyline while retaining\n  // its shape and returns a new array of simplified points, using the\n  // [Ramer-Douglas-Peucker algorithm](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm).\n  // Used for a huge performance boost when processing/displaying Leaflet polylines for\n  // each zoom level and also reducing visual noise. tolerance affects the amount of\n  // simplification (lesser value means higher quality but slower and with more points).\n  // Also released as a separated micro-library [Simplify.js](https://mourner.github.io/simplify-js/).\n  function simplify(points, tolerance) {\n    if (!tolerance || !points.length) {\n      return points.slice();\n    }\n    var sqTolerance = tolerance * tolerance;\n\n    // stage 1: vertex reduction\n    points = _reducePoints(points, sqTolerance);\n\n    // stage 2: Douglas-Peucker simplification\n    points = _simplifyDP(points, sqTolerance);\n    return points;\n  }\n\n  // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number\n  // Returns the distance between point `p` and segment `p1` to `p2`.\n  function pointToSegmentDistance(p, p1, p2) {\n    return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));\n  }\n\n  // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number\n  // Returns the closest point from a point `p` on a segment `p1` to `p2`.\n  function closestPointOnSegment(p, p1, p2) {\n    return _sqClosestPointOnSegment(p, p1, p2);\n  }\n\n  // Ramer-Douglas-Peucker simplification, see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\n  function _simplifyDP(points, sqTolerance) {\n    var len = points.length,\n      ArrayConstructor = (typeof Uint8Array === \"undefined\" ? \"undefined\" : _typeof(Uint8Array)) !== undefined + '' ? Uint8Array : Array,\n      markers = new ArrayConstructor(len);\n    markers[0] = markers[len - 1] = 1;\n    _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\n    var i,\n      newPoints = [];\n    for (i = 0; i < len; i++) {\n      if (markers[i]) {\n        newPoints.push(points[i]);\n      }\n    }\n    return newPoints;\n  }\n  function _simplifyDPStep(points, markers, sqTolerance, first, last) {\n    var maxSqDist = 0,\n      index,\n      i,\n      sqDist;\n    for (i = first + 1; i <= last - 1; i++) {\n      sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);\n      if (sqDist > maxSqDist) {\n        index = i;\n        maxSqDist = sqDist;\n      }\n    }\n    if (maxSqDist > sqTolerance) {\n      markers[index] = 1;\n      _simplifyDPStep(points, markers, sqTolerance, first, index);\n      _simplifyDPStep(points, markers, sqTolerance, index, last);\n    }\n  }\n\n  // reduce points that are too close to each other to a single point\n  function _reducePoints(points, sqTolerance) {\n    var reducedPoints = [points[0]];\n    for (var i = 1, prev = 0, len = points.length; i < len; i++) {\n      if (_sqDist(points[i], points[prev]) > sqTolerance) {\n        reducedPoints.push(points[i]);\n        prev = i;\n      }\n    }\n    if (prev < len - 1) {\n      reducedPoints.push(points[len - 1]);\n    }\n    return reducedPoints;\n  }\n  var _lastCode;\n\n  // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean\n  // Clips the segment a to b by rectangular bounds with the\n  // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)\n  // (modifying the segment points directly!). Used by Leaflet to only show polyline\n  // points that are on the screen or near, increasing performance.\n  function clipSegment(a, b, bounds, useLastCode, round) {\n    var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),\n      codeB = _getBitCode(b, bounds),\n      codeOut,\n      p,\n      newCode;\n\n    // save 2nd code to avoid calculating it on the next segment\n    _lastCode = codeB;\n    while (true) {\n      // if a,b is inside the clip window (trivial accept)\n      if (!(codeA | codeB)) {\n        return [a, b];\n      }\n\n      // if a,b is outside the clip window (trivial reject)\n      if (codeA & codeB) {\n        return false;\n      }\n\n      // other cases\n      codeOut = codeA || codeB;\n      p = _getEdgeIntersection(a, b, codeOut, bounds, round);\n      newCode = _getBitCode(p, bounds);\n      if (codeOut === codeA) {\n        a = p;\n        codeA = newCode;\n      } else {\n        b = p;\n        codeB = newCode;\n      }\n    }\n  }\n  function _getEdgeIntersection(a, b, code, bounds, round) {\n    var dx = b.x - a.x,\n      dy = b.y - a.y,\n      min = bounds.min,\n      max = bounds.max,\n      x,\n      y;\n    if (code & 8) {\n      // top\n      x = a.x + dx * (max.y - a.y) / dy;\n      y = max.y;\n    } else if (code & 4) {\n      // bottom\n      x = a.x + dx * (min.y - a.y) / dy;\n      y = min.y;\n    } else if (code & 2) {\n      // right\n      x = max.x;\n      y = a.y + dy * (max.x - a.x) / dx;\n    } else if (code & 1) {\n      // left\n      x = min.x;\n      y = a.y + dy * (min.x - a.x) / dx;\n    }\n    return new Point(x, y, round);\n  }\n  function _getBitCode(p, bounds) {\n    var code = 0;\n    if (p.x < bounds.min.x) {\n      // left\n      code |= 1;\n    } else if (p.x > bounds.max.x) {\n      // right\n      code |= 2;\n    }\n    if (p.y < bounds.min.y) {\n      // bottom\n      code |= 4;\n    } else if (p.y > bounds.max.y) {\n      // top\n      code |= 8;\n    }\n    return code;\n  }\n\n  // square distance (to avoid unnecessary Math.sqrt calls)\n  function _sqDist(p1, p2) {\n    var dx = p2.x - p1.x,\n      dy = p2.y - p1.y;\n    return dx * dx + dy * dy;\n  }\n\n  // return closest point on segment or distance to that point\n  function _sqClosestPointOnSegment(p, p1, p2, sqDist) {\n    var x = p1.x,\n      y = p1.y,\n      dx = p2.x - x,\n      dy = p2.y - y,\n      dot = dx * dx + dy * dy,\n      t;\n    if (dot > 0) {\n      t = ((p.x - x) * dx + (p.y - y) * dy) / dot;\n      if (t > 1) {\n        x = p2.x;\n        y = p2.y;\n      } else if (t > 0) {\n        x += dx * t;\n        y += dy * t;\n      }\n    }\n    dx = p.x - x;\n    dy = p.y - y;\n    return sqDist ? dx * dx + dy * dy : new Point(x, y);\n  }\n\n  // @function isFlat(latlngs: LatLng[]): Boolean\n  // Returns true if `latlngs` is a flat array, false is nested.\n  function isFlat(latlngs) {\n    return !isArray(latlngs[0]) || _typeof(latlngs[0][0]) !== 'object' && typeof latlngs[0][0] !== 'undefined';\n  }\n  function _flat(latlngs) {\n    console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');\n    return isFlat(latlngs);\n  }\n\n  /* @function polylineCenter(latlngs: LatLng[], crs: CRS): LatLng\r\n   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polyline.\r\n   */\n  function polylineCenter(latlngs, crs) {\n    var i, halfDist, segDist, dist, p1, p2, ratio, center;\n    if (!latlngs || latlngs.length === 0) {\n      throw new Error('latlngs not passed');\n    }\n    if (!isFlat(latlngs)) {\n      console.warn('latlngs are not flat! Only the first ring will be used');\n      latlngs = latlngs[0];\n    }\n    var centroidLatLng = toLatLng([0, 0]);\n    var bounds = toLatLngBounds(latlngs);\n    var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());\n    // tests showed that below 1700 rounding errors are happening\n    if (areaBounds < 1700) {\n      // getting a inexact center, to move the latlngs near to [0, 0] to prevent rounding errors\n      centroidLatLng = centroid(latlngs);\n    }\n    var len = latlngs.length;\n    var points = [];\n    for (i = 0; i < len; i++) {\n      var latlng = toLatLng(latlngs[i]);\n      points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));\n    }\n    for (i = 0, halfDist = 0; i < len - 1; i++) {\n      halfDist += points[i].distanceTo(points[i + 1]) / 2;\n    }\n\n    // The line is so small in the current view that all points are on the same pixel.\n    if (halfDist === 0) {\n      center = points[0];\n    } else {\n      for (i = 0, dist = 0; i < len - 1; i++) {\n        p1 = points[i];\n        p2 = points[i + 1];\n        segDist = p1.distanceTo(p2);\n        dist += segDist;\n        if (dist > halfDist) {\n          ratio = (dist - halfDist) / segDist;\n          center = [p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y)];\n          break;\n        }\n      }\n    }\n    var latlngCenter = crs.unproject(toPoint(center));\n    return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);\n  }\n  var LineUtil = {\n    __proto__: null,\n    simplify: simplify,\n    pointToSegmentDistance: pointToSegmentDistance,\n    closestPointOnSegment: closestPointOnSegment,\n    clipSegment: clipSegment,\n    _getEdgeIntersection: _getEdgeIntersection,\n    _getBitCode: _getBitCode,\n    _sqClosestPointOnSegment: _sqClosestPointOnSegment,\n    isFlat: isFlat,\n    _flat: _flat,\n    polylineCenter: polylineCenter\n  };\n\n  /*\r\n   * @namespace Projection\r\n   * @section\r\n   * Leaflet comes with a set of already defined Projections out of the box:\r\n   *\r\n   * @projection L.Projection.LonLat\r\n   *\r\n   * Equirectangular, or Plate Carree projection — the most simple projection,\r\n   * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as\r\n   * latitude. Also suitable for flat worlds, e.g. game maps. Used by the\r\n   * `EPSG:4326` and `Simple` CRS.\r\n   */\n\n  var LonLat = {\n    project: function project(latlng) {\n      return new Point(latlng.lng, latlng.lat);\n    },\n    unproject: function unproject(point) {\n      return new LatLng(point.y, point.x);\n    },\n    bounds: new Bounds([-180, -90], [180, 90])\n  };\n\n  /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.Mercator\r\n   *\r\n   * Elliptical Mercator projection — more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.\r\n   */\n\n  var Mercator = {\n    R: 6378137,\n    R_MINOR: 6356752.314245179,\n    bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),\n    project: function project(latlng) {\n      var d = Math.PI / 180,\n        r = this.R,\n        y = latlng.lat * d,\n        tmp = this.R_MINOR / r,\n        e = Math.sqrt(1 - tmp * tmp),\n        con = e * Math.sin(y);\n      var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);\n      y = -r * Math.log(Math.max(ts, 1E-10));\n      return new Point(latlng.lng * d * r, y);\n    },\n    unproject: function unproject(point) {\n      var d = 180 / Math.PI,\n        r = this.R,\n        tmp = this.R_MINOR / r,\n        e = Math.sqrt(1 - tmp * tmp),\n        ts = Math.exp(-point.y / r),\n        phi = Math.PI / 2 - 2 * Math.atan(ts);\n      for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {\n        con = e * Math.sin(phi);\n        con = Math.pow((1 - con) / (1 + con), e / 2);\n        dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;\n        phi += dphi;\n      }\n      return new LatLng(phi * d, point.x * d / r);\n    }\n  };\n\n  /*\n   * @class Projection\n    * An object with methods for projecting geographical coordinates of the world onto\n   * a flat surface (and back). See [Map projection](https://en.wikipedia.org/wiki/Map_projection).\n    * @property bounds: Bounds\n   * The bounds (specified in CRS units) where the projection is valid\n    * @method project(latlng: LatLng): Point\n   * Projects geographical coordinates into a 2D point.\n   * Only accepts actual `L.LatLng` instances, not arrays.\n    * @method unproject(point: Point): LatLng\n   * The inverse of `project`. Projects a 2D point into a geographical location.\n   * Only accepts actual `L.Point` instances, not arrays.\n    * Note that the projection instances do not inherit from Leaflet's `Class` object,\n   * and can't be instantiated. Also, new classes can't inherit from them,\n   * and methods can't be added to them with the `include` function.\n    */\n\n  var index = {\n    __proto__: null,\n    LonLat: LonLat,\n    Mercator: Mercator,\n    SphericalMercator: SphericalMercator\n  };\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3395\r\n   *\r\n   * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.\r\n   */\n  var EPSG3395 = extend({}, Earth, {\n    code: 'EPSG:3395',\n    projection: Mercator,\n    transformation: function () {\n      var scale = 0.5 / (Math.PI * Mercator.R);\n      return toTransformation(scale, 0.5, -scale, 0.5);\n    }()\n  });\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG4326\r\n   *\r\n   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.\r\n   *\r\n   * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),\r\n   * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`\r\n   * with this CRS, ensure that there are two 256x256 pixel tiles covering the\r\n   * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),\r\n   * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.\r\n   */\n\n  var EPSG4326 = extend({}, Earth, {\n    code: 'EPSG:4326',\n    projection: LonLat,\n    transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)\n  });\n\n  /*\n   * @namespace CRS\n   * @crs L.CRS.Simple\n   *\n   * A simple CRS that maps longitude and latitude into `x` and `y` directly.\n   * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`\n   * axis should still be inverted (going from bottom to top). `distance()` returns\n   * simple euclidean distance.\n   */\n\n  var Simple = extend({}, CRS, {\n    projection: LonLat,\n    transformation: toTransformation(1, 0, -1, 0),\n    scale: function scale(zoom) {\n      return Math.pow(2, zoom);\n    },\n    zoom: function zoom(scale) {\n      return Math.log(scale) / Math.LN2;\n    },\n    distance: function distance(latlng1, latlng2) {\n      var dx = latlng2.lng - latlng1.lng,\n        dy = latlng2.lat - latlng1.lat;\n      return Math.sqrt(dx * dx + dy * dy);\n    },\n    infinite: true\n  });\n  CRS.Earth = Earth;\n  CRS.EPSG3395 = EPSG3395;\n  CRS.EPSG3857 = EPSG3857;\n  CRS.EPSG900913 = EPSG900913;\n  CRS.EPSG4326 = EPSG4326;\n  CRS.Simple = Simple;\n\n  /*\n   * @class Layer\n   * @inherits Evented\n   * @aka L.Layer\n   * @aka ILayer\n   *\n   * A set of methods from the Layer base class that all Leaflet layers use.\n   * Inherits all methods, options and events from `L.Evented`.\n   *\n   * @example\n   *\n   * ```js\n   * var layer = L.marker(latlng).addTo(map);\n   * layer.addTo(map);\n   * layer.remove();\n   * ```\n   *\n   * @event add: Event\n   * Fired after the layer is added to a map\n   *\n   * @event remove: Event\n   * Fired after the layer is removed from a map\n   */\n\n  var Layer = Evented.extend({\n    // Classes extending `L.Layer` will inherit the following options:\n    options: {\n      // @option pane: String = 'overlayPane'\n      // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.\n      pane: 'overlayPane',\n      // @option attribution: String = null\n      // String to be shown in the attribution control, e.g. \"© OpenStreetMap contributors\". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.\n      attribution: null,\n      bubblingMouseEvents: true\n    },\n    /* @section\n     * Classes extending `L.Layer` will inherit the following methods:\n     *\n     * @method addTo(map: Map|LayerGroup): this\n     * Adds the layer to the given map or layer group.\n     */\n    addTo: function addTo(map) {\n      map.addLayer(this);\n      return this;\n    },\n    // @method remove: this\n    // Removes the layer from the map it is currently active on.\n    remove: function remove() {\n      return this.removeFrom(this._map || this._mapToAdd);\n    },\n    // @method removeFrom(map: Map): this\n    // Removes the layer from the given map\n    //\n    // @alternative\n    // @method removeFrom(group: LayerGroup): this\n    // Removes the layer from the given `LayerGroup`\n    removeFrom: function removeFrom(obj) {\n      if (obj) {\n        obj.removeLayer(this);\n      }\n      return this;\n    },\n    // @method getPane(name? : String): HTMLElement\n    // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.\n    getPane: function getPane(name) {\n      return this._map.getPane(name ? this.options[name] || name : this.options.pane);\n    },\n    addInteractiveTarget: function addInteractiveTarget(targetEl) {\n      this._map._targets[stamp(targetEl)] = this;\n      return this;\n    },\n    removeInteractiveTarget: function removeInteractiveTarget(targetEl) {\n      delete this._map._targets[stamp(targetEl)];\n      return this;\n    },\n    // @method getAttribution: String\n    // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).\n    getAttribution: function getAttribution() {\n      return this.options.attribution;\n    },\n    _layerAdd: function _layerAdd(e) {\n      var map = e.target;\n\n      // check in case layer gets added and then removed before the map is ready\n      if (!map.hasLayer(this)) {\n        return;\n      }\n      this._map = map;\n      this._zoomAnimated = map._zoomAnimated;\n      if (this.getEvents) {\n        var events = this.getEvents();\n        map.on(events, this);\n        this.once('remove', function () {\n          map.off(events, this);\n        }, this);\n      }\n      this.onAdd(map);\n      this.fire('add');\n      map.fire('layeradd', {\n        layer: this\n      });\n    }\n  });\n\n  /* @section Extension methods\n   * @uninheritable\n   *\n   * Every layer should extend from `L.Layer` and (re-)implement the following methods.\n   *\n   * @method onAdd(map: Map): this\n   * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).\n   *\n   * @method onRemove(map: Map): this\n   * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).\n   *\n   * @method getEvents(): Object\n   * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.\n   *\n   * @method getAttribution(): String\n   * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.\n   *\n   * @method beforeAdd(map: Map): this\n   * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.\n   */\n\n  /* @namespace Map\n   * @section Layer events\n   *\n   * @event layeradd: LayerEvent\n   * Fired when a new layer is added to the map.\n   *\n   * @event layerremove: LayerEvent\n   * Fired when some layer is removed from the map\n   *\n   * @section Methods for Layers and Controls\n   */\n  Map.include({\n    // @method addLayer(layer: Layer): this\n    // Adds the given layer to the map\n    addLayer: function addLayer(layer) {\n      if (!layer._layerAdd) {\n        throw new Error('The provided object is not a Layer.');\n      }\n      var id = stamp(layer);\n      if (this._layers[id]) {\n        return this;\n      }\n      this._layers[id] = layer;\n      layer._mapToAdd = this;\n      if (layer.beforeAdd) {\n        layer.beforeAdd(this);\n      }\n      this.whenReady(layer._layerAdd, layer);\n      return this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Removes the given layer from the map.\n    removeLayer: function removeLayer(layer) {\n      var id = stamp(layer);\n      if (!this._layers[id]) {\n        return this;\n      }\n      if (this._loaded) {\n        layer.onRemove(this);\n      }\n      delete this._layers[id];\n      if (this._loaded) {\n        this.fire('layerremove', {\n          layer: layer\n        });\n        layer.fire('remove');\n      }\n      layer._map = layer._mapToAdd = null;\n      return this;\n    },\n    // @method hasLayer(layer: Layer): Boolean\n    // Returns `true` if the given layer is currently added to the map\n    hasLayer: function hasLayer(layer) {\n      return stamp(layer) in this._layers;\n    },\n    /* @method eachLayer(fn: Function, context?: Object): this\n     * Iterates over the layers of the map, optionally specifying context of the iterator function.\n     * ```\n     * map.eachLayer(function(layer){\n     *     layer.bindPopup('Hello');\n     * });\n     * ```\n     */\n    eachLayer: function eachLayer(method, context) {\n      for (var i in this._layers) {\n        method.call(context, this._layers[i]);\n      }\n      return this;\n    },\n    _addLayers: function _addLayers(layers) {\n      layers = layers ? isArray(layers) ? layers : [layers] : [];\n      for (var i = 0, len = layers.length; i < len; i++) {\n        this.addLayer(layers[i]);\n      }\n    },\n    _addZoomLimit: function _addZoomLimit(layer) {\n      if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {\n        this._zoomBoundLayers[stamp(layer)] = layer;\n        this._updateZoomLevels();\n      }\n    },\n    _removeZoomLimit: function _removeZoomLimit(layer) {\n      var id = stamp(layer);\n      if (this._zoomBoundLayers[id]) {\n        delete this._zoomBoundLayers[id];\n        this._updateZoomLevels();\n      }\n    },\n    _updateZoomLevels: function _updateZoomLevels() {\n      var minZoom = Infinity,\n        maxZoom = -Infinity,\n        oldZoomSpan = this._getZoomSpan();\n      for (var i in this._zoomBoundLayers) {\n        var options = this._zoomBoundLayers[i].options;\n        minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);\n        maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);\n      }\n      this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;\n      this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;\n\n      // @section Map state change events\n      // @event zoomlevelschange: Event\n      // Fired when the number of zoomlevels on the map is changed due\n      // to adding or removing a layer.\n      if (oldZoomSpan !== this._getZoomSpan()) {\n        this.fire('zoomlevelschange');\n      }\n      if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {\n        this.setZoom(this._layersMaxZoom);\n      }\n      if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {\n        this.setZoom(this._layersMinZoom);\n      }\n    }\n  });\n\n  /*\r\n   * @class LayerGroup\r\n   * @aka L.LayerGroup\r\n   * @inherits Interactive layer\r\n   *\r\n   * Used to group several layers and handle them as one. If you add it to the map,\r\n   * any layers added or removed from the group will be added/removed on the map as\r\n   * well. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.layerGroup([marker1, marker2])\r\n   * \t.addLayer(polyline)\r\n   * \t.addTo(map);\r\n   * ```\r\n   */\n\n  var LayerGroup = Layer.extend({\n    initialize: function initialize(layers, options) {\n      setOptions(this, options);\n      this._layers = {};\n      var i, len;\n      if (layers) {\n        for (i = 0, len = layers.length; i < len; i++) {\n          this.addLayer(layers[i]);\n        }\n      }\n    },\n    // @method addLayer(layer: Layer): this\n    // Adds the given layer to the group.\n    addLayer: function addLayer(layer) {\n      var id = this.getLayerId(layer);\n      this._layers[id] = layer;\n      if (this._map) {\n        this._map.addLayer(layer);\n      }\n      return this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Removes the given layer from the group.\n    // @alternative\n    // @method removeLayer(id: Number): this\n    // Removes the layer with the given internal ID from the group.\n    removeLayer: function removeLayer(layer) {\n      var id = layer in this._layers ? layer : this.getLayerId(layer);\n      if (this._map && this._layers[id]) {\n        this._map.removeLayer(this._layers[id]);\n      }\n      delete this._layers[id];\n      return this;\n    },\n    // @method hasLayer(layer: Layer): Boolean\n    // Returns `true` if the given layer is currently added to the group.\n    // @alternative\n    // @method hasLayer(id: Number): Boolean\n    // Returns `true` if the given internal ID is currently added to the group.\n    hasLayer: function hasLayer(layer) {\n      var layerId = typeof layer === 'number' ? layer : this.getLayerId(layer);\n      return layerId in this._layers;\n    },\n    // @method clearLayers(): this\n    // Removes all the layers from the group.\n    clearLayers: function clearLayers() {\n      return this.eachLayer(this.removeLayer, this);\n    },\n    // @method invoke(methodName: String, …): this\n    // Calls `methodName` on every layer contained in this group, passing any\n    // additional parameters. Has no effect if the layers contained do not\n    // implement `methodName`.\n    invoke: function invoke(methodName) {\n      var args = Array.prototype.slice.call(arguments, 1),\n        i,\n        layer;\n      for (i in this._layers) {\n        layer = this._layers[i];\n        if (layer[methodName]) {\n          layer[methodName].apply(layer, args);\n        }\n      }\n      return this;\n    },\n    onAdd: function onAdd(map) {\n      this.eachLayer(map.addLayer, map);\n    },\n    onRemove: function onRemove(map) {\n      this.eachLayer(map.removeLayer, map);\n    },\n    // @method eachLayer(fn: Function, context?: Object): this\n    // Iterates over the layers of the group, optionally specifying context of the iterator function.\n    // ```js\n    // group.eachLayer(function (layer) {\n    // \tlayer.bindPopup('Hello');\n    // });\n    // ```\n    eachLayer: function eachLayer(method, context) {\n      for (var i in this._layers) {\n        method.call(context, this._layers[i]);\n      }\n      return this;\n    },\n    // @method getLayer(id: Number): Layer\n    // Returns the layer with the given internal ID.\n    getLayer: function getLayer(id) {\n      return this._layers[id];\n    },\n    // @method getLayers(): Layer[]\n    // Returns an array of all the layers added to the group.\n    getLayers: function getLayers() {\n      var layers = [];\n      this.eachLayer(layers.push, layers);\n      return layers;\n    },\n    // @method setZIndex(zIndex: Number): this\n    // Calls `setZIndex` on every layer contained in this group, passing the z-index.\n    setZIndex: function setZIndex(zIndex) {\n      return this.invoke('setZIndex', zIndex);\n    },\n    // @method getLayerId(layer: Layer): Number\n    // Returns the internal ID for a layer\n    getLayerId: function getLayerId(layer) {\n      return stamp(layer);\n    }\n  });\n\n  // @factory L.layerGroup(layers?: Layer[], options?: Object)\n  // Create a layer group, optionally given an initial set of layers and an `options` object.\n  var layerGroup = function layerGroup(layers, options) {\n    return new LayerGroup(layers, options);\n  };\n\n  /*\r\n   * @class FeatureGroup\r\n   * @aka L.FeatureGroup\r\n   * @inherits LayerGroup\r\n   *\r\n   * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:\r\n   *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))\r\n   *  * Events are propagated to the `FeatureGroup`, so if the group has an event\r\n   * handler, it will handle events from any of the layers. This includes mouse events\r\n   * and custom events.\r\n   *  * Has `layeradd` and `layerremove` events\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.featureGroup([marker1, marker2, polyline])\r\n   * \t.bindPopup('Hello world!')\r\n   * \t.on('click', function() { alert('Clicked on a member of the group!'); })\r\n   * \t.addTo(map);\r\n   * ```\r\n   */\n\n  var FeatureGroup = LayerGroup.extend({\n    addLayer: function addLayer(layer) {\n      if (this.hasLayer(layer)) {\n        return this;\n      }\n      layer.addEventParent(this);\n      LayerGroup.prototype.addLayer.call(this, layer);\n\n      // @event layeradd: LayerEvent\n      // Fired when a layer is added to this `FeatureGroup`\n      return this.fire('layeradd', {\n        layer: layer\n      });\n    },\n    removeLayer: function removeLayer(layer) {\n      if (!this.hasLayer(layer)) {\n        return this;\n      }\n      if (layer in this._layers) {\n        layer = this._layers[layer];\n      }\n      layer.removeEventParent(this);\n      LayerGroup.prototype.removeLayer.call(this, layer);\n\n      // @event layerremove: LayerEvent\n      // Fired when a layer is removed from this `FeatureGroup`\n      return this.fire('layerremove', {\n        layer: layer\n      });\n    },\n    // @method setStyle(style: Path options): this\n    // Sets the given path options to each layer of the group that has a `setStyle` method.\n    setStyle: function setStyle(style) {\n      return this.invoke('setStyle', style);\n    },\n    // @method bringToFront(): this\n    // Brings the layer group to the top of all other layers\n    bringToFront: function bringToFront() {\n      return this.invoke('bringToFront');\n    },\n    // @method bringToBack(): this\n    // Brings the layer group to the back of all other layers\n    bringToBack: function bringToBack() {\n      return this.invoke('bringToBack');\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).\n    getBounds: function getBounds() {\n      var bounds = new LatLngBounds();\n      for (var id in this._layers) {\n        var layer = this._layers[id];\n        bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());\n      }\n      return bounds;\n    }\n  });\n\n  // @factory L.featureGroup(layers?: Layer[], options?: Object)\n  // Create a feature group, optionally given an initial set of layers and an `options` object.\n  var featureGroup = function featureGroup(layers, options) {\n    return new FeatureGroup(layers, options);\n  };\n\n  /*\r\n   * @class Icon\r\n   * @aka L.Icon\r\n   *\r\n   * Represents an icon to provide when creating a marker.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var myIcon = L.icon({\r\n   *     iconUrl: 'my-icon.png',\r\n   *     iconRetinaUrl: 'my-icon@2x.png',\r\n   *     iconSize: [38, 95],\r\n   *     iconAnchor: [22, 94],\r\n   *     popupAnchor: [-3, -76],\r\n   *     shadowUrl: 'my-icon-shadow.png',\r\n   *     shadowRetinaUrl: 'my-icon-shadow@2x.png',\r\n   *     shadowSize: [68, 95],\r\n   *     shadowAnchor: [22, 94]\r\n   * });\r\n   *\r\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\r\n   * ```\r\n   *\r\n   * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.\r\n   *\r\n   */\n\n  var Icon = Class.extend({\n    /* @section\r\n     * @aka Icon options\r\n     *\r\n     * @option iconUrl: String = null\r\n     * **(required)** The URL to the icon image (absolute or relative to your script path).\r\n     *\r\n     * @option iconRetinaUrl: String = null\r\n     * The URL to a retina sized version of the icon image (absolute or relative to your\r\n     * script path). Used for Retina screen devices.\r\n     *\r\n     * @option iconSize: Point = null\r\n     * Size of the icon image in pixels.\r\n     *\r\n     * @option iconAnchor: Point = null\r\n     * The coordinates of the \"tip\" of the icon (relative to its top left corner). The icon\r\n     * will be aligned so that this point is at the marker's geographical location. Centered\r\n     * by default if size is specified, also can be set in CSS with negative margins.\r\n     *\r\n     * @option popupAnchor: Point = [0, 0]\r\n     * The coordinates of the point from which popups will \"open\", relative to the icon anchor.\r\n     *\r\n     * @option tooltipAnchor: Point = [0, 0]\r\n     * The coordinates of the point from which tooltips will \"open\", relative to the icon anchor.\r\n     *\r\n     * @option shadowUrl: String = null\r\n     * The URL to the icon shadow image. If not specified, no shadow image will be created.\r\n     *\r\n     * @option shadowRetinaUrl: String = null\r\n     *\r\n     * @option shadowSize: Point = null\r\n     * Size of the shadow image in pixels.\r\n     *\r\n     * @option shadowAnchor: Point = null\r\n     * The coordinates of the \"tip\" of the shadow (relative to its top left corner) (the same\r\n     * as iconAnchor if not specified).\r\n     *\r\n     * @option className: String = ''\r\n     * A custom class name to assign to both icon and shadow images. Empty by default.\r\n     */\n\n    options: {\n      popupAnchor: [0, 0],\n      tooltipAnchor: [0, 0],\n      // @option crossOrigin: Boolean|String = false\n      // Whether the crossOrigin attribute will be added to the tiles.\n      // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.\n      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n      crossOrigin: false\n    },\n    initialize: function initialize(options) {\n      setOptions(this, options);\n    },\n    // @method createIcon(oldIcon?: HTMLElement): HTMLElement\n    // Called internally when the icon has to be shown, returns a `<img>` HTML element\n    // styled according to the options.\n    createIcon: function createIcon(oldIcon) {\n      return this._createIcon('icon', oldIcon);\n    },\n    // @method createShadow(oldIcon?: HTMLElement): HTMLElement\n    // As `createIcon`, but for the shadow beneath it.\n    createShadow: function createShadow(oldIcon) {\n      return this._createIcon('shadow', oldIcon);\n    },\n    _createIcon: function _createIcon(name, oldIcon) {\n      var src = this._getIconUrl(name);\n      if (!src) {\n        if (name === 'icon') {\n          throw new Error('iconUrl not set in Icon options (see the docs).');\n        }\n        return null;\n      }\n      var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);\n      this._setIconStyles(img, name);\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n      return img;\n    },\n    _setIconStyles: function _setIconStyles(img, name) {\n      var options = this.options;\n      var sizeOption = options[name + 'Size'];\n      if (typeof sizeOption === 'number') {\n        sizeOption = [sizeOption, sizeOption];\n      }\n      var size = toPoint(sizeOption),\n        anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));\n      img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');\n      if (anchor) {\n        img.style.marginLeft = -anchor.x + 'px';\n        img.style.marginTop = -anchor.y + 'px';\n      }\n      if (size) {\n        img.style.width = size.x + 'px';\n        img.style.height = size.y + 'px';\n      }\n    },\n    _createImg: function _createImg(src, el) {\n      el = el || document.createElement('img');\n      el.src = src;\n      return el;\n    },\n    _getIconUrl: function _getIconUrl(name) {\n      return Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];\n    }\n  });\n\n  // @factory L.icon(options: Icon options)\n  // Creates an icon instance with the given options.\n  function icon(options) {\n    return new Icon(options);\n  }\n\n  /*\n   * @miniclass Icon.Default (Icon)\n   * @aka L.Icon.Default\n   * @section\n   *\n   * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when\n   * no icon is specified. Points to the blue marker image distributed with Leaflet\n   * releases.\n   *\n   * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`\n   * (which is a set of `Icon options`).\n   *\n   * If you want to _completely_ replace the default icon, override the\n   * `L.Marker.prototype.options.icon` with your own icon instead.\n   */\n\n  var IconDefault = Icon.extend({\n    options: {\n      iconUrl: 'marker-icon.png',\n      iconRetinaUrl: 'marker-icon-2x.png',\n      shadowUrl: 'marker-shadow.png',\n      iconSize: [25, 41],\n      iconAnchor: [12, 41],\n      popupAnchor: [1, -34],\n      tooltipAnchor: [16, -28],\n      shadowSize: [41, 41]\n    },\n    _getIconUrl: function _getIconUrl(name) {\n      if (typeof IconDefault.imagePath !== 'string') {\n        // Deprecated, backwards-compatibility only\n        IconDefault.imagePath = this._detectIconPath();\n      }\n\n      // @option imagePath: String\n      // `Icon.Default` will try to auto-detect the location of the\n      // blue icon images. If you are placing these images in a non-standard\n      // way, set this option to point to the right path.\n      return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);\n    },\n    _stripUrl: function _stripUrl(path) {\n      // separate function to use in tests\n      var strip = function strip(str, re, idx) {\n        var match = re.exec(str);\n        return match && match[idx];\n      };\n      path = strip(path, /^url\\((['\"])?(.+)\\1\\)$/, 2);\n      return path && strip(path, /^(.*)marker-icon\\.png$/, 1);\n    },\n    _detectIconPath: function _detectIconPath() {\n      var el = create$1('div', 'leaflet-default-icon-path', document.body);\n      var path = getStyle(el, 'background-image') || getStyle(el, 'backgroundImage'); // IE8\n\n      document.body.removeChild(el);\n      path = this._stripUrl(path);\n      if (path) {\n        return path;\n      }\n      var link = document.querySelector('link[href$=\"leaflet.css\"]');\n      if (!link) {\n        return '';\n      }\n      return link.href.substring(0, link.href.length - 'leaflet.css'.length - 1);\n    }\n  });\n\n  /*\n   * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n   */\n\n  /* @namespace Marker\n   * @section Interaction handlers\n   *\n   * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:\n   *\n   * ```js\n   * marker.dragging.disable();\n   * ```\n   *\n   * @property dragging: Handler\n   * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).\n   */\n\n  var MarkerDrag = Handler.extend({\n    initialize: function initialize(marker) {\n      this._marker = marker;\n    },\n    addHooks: function addHooks() {\n      var icon = this._marker._icon;\n      if (!this._draggable) {\n        this._draggable = new Draggable(icon, icon, true);\n      }\n      this._draggable.on({\n        dragstart: this._onDragStart,\n        predrag: this._onPreDrag,\n        drag: this._onDrag,\n        dragend: this._onDragEnd\n      }, this).enable();\n      addClass(icon, 'leaflet-marker-draggable');\n    },\n    removeHooks: function removeHooks() {\n      this._draggable.off({\n        dragstart: this._onDragStart,\n        predrag: this._onPreDrag,\n        drag: this._onDrag,\n        dragend: this._onDragEnd\n      }, this).disable();\n      if (this._marker._icon) {\n        removeClass(this._marker._icon, 'leaflet-marker-draggable');\n      }\n    },\n    moved: function moved() {\n      return this._draggable && this._draggable._moved;\n    },\n    _adjustPan: function _adjustPan(e) {\n      var marker = this._marker,\n        map = marker._map,\n        speed = this._marker.options.autoPanSpeed,\n        padding = this._marker.options.autoPanPadding,\n        iconPos = getPosition(marker._icon),\n        bounds = map.getPixelBounds(),\n        origin = map.getPixelOrigin();\n      var panBounds = toBounds(bounds.min._subtract(origin).add(padding), bounds.max._subtract(origin).subtract(padding));\n      if (!panBounds.contains(iconPos)) {\n        // Compute incremental movement\n        var movement = toPoint((Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x), (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)).multiplyBy(speed);\n        map.panBy(movement, {\n          animate: false\n        });\n        this._draggable._newPos._add(movement);\n        this._draggable._startPos._add(movement);\n        setPosition(marker._icon, this._draggable._newPos);\n        this._onDrag(e);\n        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n      }\n    },\n    _onDragStart: function _onDragStart() {\n      // @section Dragging events\n      // @event dragstart: Event\n      // Fired when the user starts dragging the marker.\n\n      // @event movestart: Event\n      // Fired when the marker starts moving (because of dragging).\n\n      this._oldLatLng = this._marker.getLatLng();\n\n      // When using ES6 imports it could not be set when `Popup` was not imported as well\n      this._marker.closePopup && this._marker.closePopup();\n      this._marker.fire('movestart').fire('dragstart');\n    },\n    _onPreDrag: function _onPreDrag(e) {\n      if (this._marker.options.autoPan) {\n        cancelAnimFrame(this._panRequest);\n        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n      }\n    },\n    _onDrag: function _onDrag(e) {\n      var marker = this._marker,\n        shadow = marker._shadow,\n        iconPos = getPosition(marker._icon),\n        latlng = marker._map.layerPointToLatLng(iconPos);\n\n      // update shadow position\n      if (shadow) {\n        setPosition(shadow, iconPos);\n      }\n      marker._latlng = latlng;\n      e.latlng = latlng;\n      e.oldLatLng = this._oldLatLng;\n\n      // @event drag: Event\n      // Fired repeatedly while the user drags the marker.\n      marker.fire('move', e).fire('drag', e);\n    },\n    _onDragEnd: function _onDragEnd(e) {\n      // @event dragend: DragEndEvent\n      // Fired when the user stops dragging the marker.\n\n      cancelAnimFrame(this._panRequest);\n\n      // @event moveend: Event\n      // Fired when the marker stops moving (because of dragging).\n      delete this._oldLatLng;\n      this._marker.fire('moveend').fire('dragend', e);\n    }\n  });\n\n  /*\r\n   * @class Marker\r\n   * @inherits Interactive layer\r\n   * @aka L.Marker\r\n   * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.marker([50.5, 30.5]).addTo(map);\r\n   * ```\r\n   */\n\n  var Marker = Layer.extend({\n    // @section\n    // @aka Marker options\n    options: {\n      // @option icon: Icon = *\n      // Icon instance to use for rendering the marker.\n      // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.\n      // If not specified, a common instance of `L.Icon.Default` is used.\n      icon: new IconDefault(),\n      // Option inherited from \"Interactive layer\" abstract class\n      interactive: true,\n      // @option keyboard: Boolean = true\n      // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.\n      keyboard: true,\n      // @option title: String = ''\n      // Text for the browser tooltip that appear on marker hover (no tooltip by default).\n      // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).\n      title: '',\n      // @option alt: String = 'Marker'\n      // Text for the `alt` attribute of the icon image.\n      // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).\n      alt: 'Marker',\n      // @option zIndexOffset: Number = 0\n      // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).\n      zIndexOffset: 0,\n      // @option opacity: Number = 1.0\n      // The opacity of the marker.\n      opacity: 1,\n      // @option riseOnHover: Boolean = false\n      // If `true`, the marker will get on top of others when you hover the mouse over it.\n      riseOnHover: false,\n      // @option riseOffset: Number = 250\n      // The z-index offset used for the `riseOnHover` feature.\n      riseOffset: 250,\n      // @option pane: String = 'markerPane'\n      // `Map pane` where the markers icon will be added.\n      pane: 'markerPane',\n      // @option shadowPane: String = 'shadowPane'\n      // `Map pane` where the markers shadow will be added.\n      shadowPane: 'shadowPane',\n      // @option bubblingMouseEvents: Boolean = false\n      // When `true`, a mouse event on this marker will trigger the same event on the map\n      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n      bubblingMouseEvents: false,\n      // @option autoPanOnFocus: Boolean = true\n      // When `true`, the map will pan whenever the marker is focused (via\n      // e.g. pressing `tab` on the keyboard) to ensure the marker is\n      // visible within the map's bounds\n      autoPanOnFocus: true,\n      // @section Draggable marker options\n      // @option draggable: Boolean = false\n      // Whether the marker is draggable with mouse/touch or not.\n      draggable: false,\n      // @option autoPan: Boolean = false\n      // Whether to pan the map when dragging this marker near its edge or not.\n      autoPan: false,\n      // @option autoPanPadding: Point = Point(50, 50)\n      // Distance (in pixels to the left/right and to the top/bottom) of the\n      // map edge to start panning the map.\n      autoPanPadding: [50, 50],\n      // @option autoPanSpeed: Number = 10\n      // Number of pixels the map should pan by.\n      autoPanSpeed: 10\n    },\n    /* @section\r\n     *\r\n     * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:\r\n     */\n\n    initialize: function initialize(latlng, options) {\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n    },\n    onAdd: function onAdd(map) {\n      this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;\n      if (this._zoomAnimated) {\n        map.on('zoomanim', this._animateZoom, this);\n      }\n      this._initIcon();\n      this.update();\n    },\n    onRemove: function onRemove(map) {\n      if (this.dragging && this.dragging.enabled()) {\n        this.options.draggable = true;\n        this.dragging.removeHooks();\n      }\n      delete this.dragging;\n      if (this._zoomAnimated) {\n        map.off('zoomanim', this._animateZoom, this);\n      }\n      this._removeIcon();\n      this._removeShadow();\n    },\n    getEvents: function getEvents() {\n      return {\n        zoom: this.update,\n        viewreset: this.update\n      };\n    },\n    // @method getLatLng: LatLng\n    // Returns the current geographical position of the marker.\n    getLatLng: function getLatLng() {\n      return this._latlng;\n    },\n    // @method setLatLng(latlng: LatLng): this\n    // Changes the marker position to the given point.\n    setLatLng: function setLatLng(latlng) {\n      var oldLatLng = this._latlng;\n      this._latlng = toLatLng(latlng);\n      this.update();\n\n      // @event move: Event\n      // Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n      return this.fire('move', {\n        oldLatLng: oldLatLng,\n        latlng: this._latlng\n      });\n    },\n    // @method setZIndexOffset(offset: Number): this\n    // Changes the [zIndex offset](#marker-zindexoffset) of the marker.\n    setZIndexOffset: function setZIndexOffset(offset) {\n      this.options.zIndexOffset = offset;\n      return this.update();\n    },\n    // @method getIcon: Icon\n    // Returns the current icon used by the marker\n    getIcon: function getIcon() {\n      return this.options.icon;\n    },\n    // @method setIcon(icon: Icon): this\n    // Changes the marker icon.\n    setIcon: function setIcon(icon) {\n      this.options.icon = icon;\n      if (this._map) {\n        this._initIcon();\n        this.update();\n      }\n      if (this._popup) {\n        this.bindPopup(this._popup, this._popup.options);\n      }\n      return this;\n    },\n    getElement: function getElement() {\n      return this._icon;\n    },\n    update: function update() {\n      if (this._icon && this._map) {\n        var pos = this._map.latLngToLayerPoint(this._latlng).round();\n        this._setPos(pos);\n      }\n      return this;\n    },\n    _initIcon: function _initIcon() {\n      var options = this.options,\n        classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\n      var icon = options.icon.createIcon(this._icon),\n        addIcon = false;\n\n      // if we're not reusing the icon, remove the old one and init new one\n      if (icon !== this._icon) {\n        if (this._icon) {\n          this._removeIcon();\n        }\n        addIcon = true;\n        if (options.title) {\n          icon.title = options.title;\n        }\n        if (icon.tagName === 'IMG') {\n          icon.alt = options.alt || '';\n        }\n      }\n      addClass(icon, classToAdd);\n      if (options.keyboard) {\n        icon.tabIndex = '0';\n        icon.setAttribute('role', 'button');\n      }\n      this._icon = icon;\n      if (options.riseOnHover) {\n        this.on({\n          mouseover: this._bringToFront,\n          mouseout: this._resetZIndex\n        });\n      }\n      if (this.options.autoPanOnFocus) {\n        on(icon, 'focus', this._panOnFocus, this);\n      }\n      var newShadow = options.icon.createShadow(this._shadow),\n        addShadow = false;\n      if (newShadow !== this._shadow) {\n        this._removeShadow();\n        addShadow = true;\n      }\n      if (newShadow) {\n        addClass(newShadow, classToAdd);\n        newShadow.alt = '';\n      }\n      this._shadow = newShadow;\n      if (options.opacity < 1) {\n        this._updateOpacity();\n      }\n      if (addIcon) {\n        this.getPane().appendChild(this._icon);\n      }\n      this._initInteraction();\n      if (newShadow && addShadow) {\n        this.getPane(options.shadowPane).appendChild(this._shadow);\n      }\n    },\n    _removeIcon: function _removeIcon() {\n      if (this.options.riseOnHover) {\n        this.off({\n          mouseover: this._bringToFront,\n          mouseout: this._resetZIndex\n        });\n      }\n      if (this.options.autoPanOnFocus) {\n        off(this._icon, 'focus', this._panOnFocus, this);\n      }\n      _remove(this._icon);\n      this.removeInteractiveTarget(this._icon);\n      this._icon = null;\n    },\n    _removeShadow: function _removeShadow() {\n      if (this._shadow) {\n        _remove(this._shadow);\n      }\n      this._shadow = null;\n    },\n    _setPos: function _setPos(pos) {\n      if (this._icon) {\n        setPosition(this._icon, pos);\n      }\n      if (this._shadow) {\n        setPosition(this._shadow, pos);\n      }\n      this._zIndex = pos.y + this.options.zIndexOffset;\n      this._resetZIndex();\n    },\n    _updateZIndex: function _updateZIndex(offset) {\n      if (this._icon) {\n        this._icon.style.zIndex = this._zIndex + offset;\n      }\n    },\n    _animateZoom: function _animateZoom(opt) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\n      this._setPos(pos);\n    },\n    _initInteraction: function _initInteraction() {\n      if (!this.options.interactive) {\n        return;\n      }\n      addClass(this._icon, 'leaflet-interactive');\n      this.addInteractiveTarget(this._icon);\n      if (MarkerDrag) {\n        var draggable = this.options.draggable;\n        if (this.dragging) {\n          draggable = this.dragging.enabled();\n          this.dragging.disable();\n        }\n        this.dragging = new MarkerDrag(this);\n        if (draggable) {\n          this.dragging.enable();\n        }\n      }\n    },\n    // @method setOpacity(opacity: Number): this\n    // Changes the opacity of the marker.\n    setOpacity: function setOpacity(opacity) {\n      this.options.opacity = opacity;\n      if (this._map) {\n        this._updateOpacity();\n      }\n      return this;\n    },\n    _updateOpacity: function _updateOpacity() {\n      var opacity = this.options.opacity;\n      if (this._icon) {\n        _setOpacity(this._icon, opacity);\n      }\n      if (this._shadow) {\n        _setOpacity(this._shadow, opacity);\n      }\n    },\n    _bringToFront: function _bringToFront() {\n      this._updateZIndex(this.options.riseOffset);\n    },\n    _resetZIndex: function _resetZIndex() {\n      this._updateZIndex(0);\n    },\n    _panOnFocus: function _panOnFocus() {\n      var map = this._map;\n      if (!map) {\n        return;\n      }\n      var iconOpts = this.options.icon.options;\n      var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);\n      var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);\n      map.panInside(this._latlng, {\n        paddingTopLeft: anchor,\n        paddingBottomRight: size.subtract(anchor)\n      });\n    },\n    _getPopupAnchor: function _getPopupAnchor() {\n      return this.options.icon.options.popupAnchor;\n    },\n    _getTooltipAnchor: function _getTooltipAnchor() {\n      return this.options.icon.options.tooltipAnchor;\n    }\n  });\n\n  // factory L.marker(latlng: LatLng, options? : Marker options)\n\n  // @factory L.marker(latlng: LatLng, options? : Marker options)\n  // Instantiates a Marker object given a geographical point and optionally an options object.\n  function marker(latlng, options) {\n    return new Marker(latlng, options);\n  }\n\n  /*\n   * @class Path\n   * @aka L.Path\n   * @inherits Interactive layer\n   *\n   * An abstract class that contains options and constants shared between vector\n   * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.\n   */\n\n  var Path = Layer.extend({\n    // @section\n    // @aka Path options\n    options: {\n      // @option stroke: Boolean = true\n      // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.\n      stroke: true,\n      // @option color: String = '#3388ff'\n      // Stroke color\n      color: '#3388ff',\n      // @option weight: Number = 3\n      // Stroke width in pixels\n      weight: 3,\n      // @option opacity: Number = 1.0\n      // Stroke opacity\n      opacity: 1,\n      // @option lineCap: String= 'round'\n      // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.\n      lineCap: 'round',\n      // @option lineJoin: String = 'round'\n      // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.\n      lineJoin: 'round',\n      // @option dashArray: String = null\n      // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n      dashArray: null,\n      // @option dashOffset: String = null\n      // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n      dashOffset: null,\n      // @option fill: Boolean = depends\n      // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.\n      fill: false,\n      // @option fillColor: String = *\n      // Fill color. Defaults to the value of the [`color`](#path-color) option\n      fillColor: null,\n      // @option fillOpacity: Number = 0.2\n      // Fill opacity.\n      fillOpacity: 0.2,\n      // @option fillRule: String = 'evenodd'\n      // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.\n      fillRule: 'evenodd',\n      // className: '',\n\n      // Option inherited from \"Interactive layer\" abstract class\n      interactive: true,\n      // @option bubblingMouseEvents: Boolean = true\n      // When `true`, a mouse event on this path will trigger the same event on the map\n      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n      bubblingMouseEvents: true\n    },\n    beforeAdd: function beforeAdd(map) {\n      // Renderer is set here because we need to call renderer.getEvents\n      // before this.getEvents.\n      this._renderer = map.getRenderer(this);\n    },\n    onAdd: function onAdd() {\n      this._renderer._initPath(this);\n      this._reset();\n      this._renderer._addPath(this);\n    },\n    onRemove: function onRemove() {\n      this._renderer._removePath(this);\n    },\n    // @method redraw(): this\n    // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.\n    redraw: function redraw() {\n      if (this._map) {\n        this._renderer._updatePath(this);\n      }\n      return this;\n    },\n    // @method setStyle(style: Path options): this\n    // Changes the appearance of a Path based on the options in the `Path options` object.\n    setStyle: function setStyle(style) {\n      setOptions(this, style);\n      if (this._renderer) {\n        this._renderer._updateStyle(this);\n        if (this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, 'weight')) {\n          this._updateBounds();\n        }\n      }\n      return this;\n    },\n    // @method bringToFront(): this\n    // Brings the layer to the top of all path layers.\n    bringToFront: function bringToFront() {\n      if (this._renderer) {\n        this._renderer._bringToFront(this);\n      }\n      return this;\n    },\n    // @method bringToBack(): this\n    // Brings the layer to the bottom of all path layers.\n    bringToBack: function bringToBack() {\n      if (this._renderer) {\n        this._renderer._bringToBack(this);\n      }\n      return this;\n    },\n    getElement: function getElement() {\n      return this._path;\n    },\n    _reset: function _reset() {\n      // defined in child classes\n      this._project();\n      this._update();\n    },\n    _clickTolerance: function _clickTolerance() {\n      // used when doing hit detection for Canvas layers\n      return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);\n    }\n  });\n\n  /*\n   * @class CircleMarker\n   * @aka L.CircleMarker\n   * @inherits Path\n   *\n   * A circle of a fixed size with radius specified in pixels. Extends `Path`.\n   */\n\n  var CircleMarker = Path.extend({\n    // @section\n    // @aka CircleMarker options\n    options: {\n      fill: true,\n      // @option radius: Number = 10\n      // Radius of the circle marker, in pixels\n      radius: 10\n    },\n    initialize: function initialize(latlng, options) {\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n      this._radius = this.options.radius;\n    },\n    // @method setLatLng(latLng: LatLng): this\n    // Sets the position of a circle marker to a new location.\n    setLatLng: function setLatLng(latlng) {\n      var oldLatLng = this._latlng;\n      this._latlng = toLatLng(latlng);\n      this.redraw();\n\n      // @event move: Event\n      // Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n      return this.fire('move', {\n        oldLatLng: oldLatLng,\n        latlng: this._latlng\n      });\n    },\n    // @method getLatLng(): LatLng\n    // Returns the current geographical position of the circle marker\n    getLatLng: function getLatLng() {\n      return this._latlng;\n    },\n    // @method setRadius(radius: Number): this\n    // Sets the radius of a circle marker. Units are in pixels.\n    setRadius: function setRadius(radius) {\n      this.options.radius = this._radius = radius;\n      return this.redraw();\n    },\n    // @method getRadius(): Number\n    // Returns the current radius of the circle\n    getRadius: function getRadius() {\n      return this._radius;\n    },\n    setStyle: function setStyle(options) {\n      var radius = options && options.radius || this._radius;\n      Path.prototype.setStyle.call(this, options);\n      this.setRadius(radius);\n      return this;\n    },\n    _project: function _project() {\n      this._point = this._map.latLngToLayerPoint(this._latlng);\n      this._updateBounds();\n    },\n    _updateBounds: function _updateBounds() {\n      var r = this._radius,\n        r2 = this._radiusY || r,\n        w = this._clickTolerance(),\n        p = [r + w, r2 + w];\n      this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));\n    },\n    _update: function _update() {\n      if (this._map) {\n        this._updatePath();\n      }\n    },\n    _updatePath: function _updatePath() {\n      this._renderer._updateCircle(this);\n    },\n    _empty: function _empty() {\n      return this._radius && !this._renderer._bounds.intersects(this._pxBounds);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function _containsPoint(p) {\n      return p.distanceTo(this._point) <= this._radius + this._clickTolerance();\n    }\n  });\n\n  // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)\n  // Instantiates a circle marker object given a geographical point, and an optional options object.\n  function circleMarker(latlng, options) {\n    return new CircleMarker(latlng, options);\n  }\n\n  /*\n   * @class Circle\n   * @aka L.Circle\n   * @inherits CircleMarker\n   *\n   * A class for drawing circle overlays on a map. Extends `CircleMarker`.\n   *\n   * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).\n   *\n   * @example\n   *\n   * ```js\n   * L.circle([50.5, 30.5], {radius: 200}).addTo(map);\n   * ```\n   */\n\n  var Circle = CircleMarker.extend({\n    initialize: function initialize(latlng, options, legacyOptions) {\n      if (typeof options === 'number') {\n        // Backwards compatibility with 0.7.x factory (latlng, radius, options?)\n        options = extend({}, legacyOptions, {\n          radius: options\n        });\n      }\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n      if (isNaN(this.options.radius)) {\n        throw new Error('Circle radius cannot be NaN');\n      }\n\n      // @section\n      // @aka Circle options\n      // @option radius: Number; Radius of the circle, in meters.\n      this._mRadius = this.options.radius;\n    },\n    // @method setRadius(radius: Number): this\n    // Sets the radius of a circle. Units are in meters.\n    setRadius: function setRadius(radius) {\n      this._mRadius = radius;\n      return this.redraw();\n    },\n    // @method getRadius(): Number\n    // Returns the current radius of a circle. Units are in meters.\n    getRadius: function getRadius() {\n      return this._mRadius;\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the `LatLngBounds` of the path.\n    getBounds: function getBounds() {\n      var half = [this._radius, this._radiusY || this._radius];\n      return new LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));\n    },\n    setStyle: Path.prototype.setStyle,\n    _project: function _project() {\n      var lng = this._latlng.lng,\n        lat = this._latlng.lat,\n        map = this._map,\n        crs = map.options.crs;\n      if (crs.distance === Earth.distance) {\n        var d = Math.PI / 180,\n          latR = this._mRadius / Earth.R / d,\n          top = map.project([lat + latR, lng]),\n          bottom = map.project([lat - latR, lng]),\n          p = top.add(bottom).divideBy(2),\n          lat2 = map.unproject(p).lat,\n          lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;\n        if (isNaN(lngR) || lngR === 0) {\n          lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425\n        }\n        this._point = p.subtract(map.getPixelOrigin());\n        this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;\n        this._radiusY = p.y - top.y;\n      } else {\n        var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));\n        this._point = map.latLngToLayerPoint(this._latlng);\n        this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;\n      }\n      this._updateBounds();\n    }\n  });\n\n  // @factory L.circle(latlng: LatLng, options?: Circle options)\n  // Instantiates a circle object given a geographical point, and an options object\n  // which contains the circle radius.\n  // @alternative\n  // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)\n  // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.\n  // Do not use in new applications or plugins.\n  function circle(latlng, options, legacyOptions) {\n    return new Circle(latlng, options, legacyOptions);\n  }\n\n  /*\n   * @class Polyline\n   * @aka L.Polyline\n   * @inherits Path\n   *\n   * A class for drawing polyline overlays on a map. Extends `Path`.\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polyline from an array of LatLng points\n   * var latlngs = [\n   * \t[45.51, -122.68],\n   * \t[37.77, -122.43],\n   * \t[34.04, -118.2]\n   * ];\n   *\n   * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polyline\n   * map.fitBounds(polyline.getBounds());\n   * ```\n   *\n   * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:\n   *\n   * ```js\n   * // create a red polyline from an array of arrays of LatLng points\n   * var latlngs = [\n   * \t[[45.51, -122.68],\n   * \t [37.77, -122.43],\n   * \t [34.04, -118.2]],\n   * \t[[40.78, -73.91],\n   * \t [41.83, -87.62],\n   * \t [32.76, -96.72]]\n   * ];\n   * ```\n   */\n\n  var Polyline = Path.extend({\n    // @section\n    // @aka Polyline options\n    options: {\n      // @option smoothFactor: Number = 1.0\n      // How much to simplify the polyline on each zoom level. More means\n      // better performance and smoother look, and less means more accurate representation.\n      smoothFactor: 1.0,\n      // @option noClip: Boolean = false\n      // Disable polyline clipping.\n      noClip: false\n    },\n    initialize: function initialize(latlngs, options) {\n      setOptions(this, options);\n      this._setLatLngs(latlngs);\n    },\n    // @method getLatLngs(): LatLng[]\n    // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.\n    getLatLngs: function getLatLngs() {\n      return this._latlngs;\n    },\n    // @method setLatLngs(latlngs: LatLng[]): this\n    // Replaces all the points in the polyline with the given array of geographical points.\n    setLatLngs: function setLatLngs(latlngs) {\n      this._setLatLngs(latlngs);\n      return this.redraw();\n    },\n    // @method isEmpty(): Boolean\n    // Returns `true` if the Polyline has no LatLngs.\n    isEmpty: function isEmpty() {\n      return !this._latlngs.length;\n    },\n    // @method closestLayerPoint(p: Point): Point\n    // Returns the point closest to `p` on the Polyline.\n    closestLayerPoint: function closestLayerPoint(p) {\n      var minDistance = Infinity,\n        minPoint = null,\n        closest = _sqClosestPointOnSegment,\n        p1,\n        p2;\n      for (var j = 0, jLen = this._parts.length; j < jLen; j++) {\n        var points = this._parts[j];\n        for (var i = 1, len = points.length; i < len; i++) {\n          p1 = points[i - 1];\n          p2 = points[i];\n          var sqDist = closest(p, p1, p2, true);\n          if (sqDist < minDistance) {\n            minDistance = sqDist;\n            minPoint = closest(p, p1, p2);\n          }\n        }\n      }\n      if (minPoint) {\n        minPoint.distance = Math.sqrt(minDistance);\n      }\n      return minPoint;\n    },\n    // @method getCenter(): LatLng\n    // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.\n    getCenter: function getCenter() {\n      // throws error when not yet added to map as this center calculation requires projected coordinates\n      if (!this._map) {\n        throw new Error('Must add layer to map before using getCenter()');\n      }\n      return polylineCenter(this._defaultShape(), this._map.options.crs);\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the `LatLngBounds` of the path.\n    getBounds: function getBounds() {\n      return this._bounds;\n    },\n    // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this\n    // Adds a given point to the polyline. By default, adds to the first ring of\n    // the polyline in case of a multi-polyline, but can be overridden by passing\n    // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).\n    addLatLng: function addLatLng(latlng, latlngs) {\n      latlngs = latlngs || this._defaultShape();\n      latlng = toLatLng(latlng);\n      latlngs.push(latlng);\n      this._bounds.extend(latlng);\n      return this.redraw();\n    },\n    _setLatLngs: function _setLatLngs(latlngs) {\n      this._bounds = new LatLngBounds();\n      this._latlngs = this._convertLatLngs(latlngs);\n    },\n    _defaultShape: function _defaultShape() {\n      return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];\n    },\n    // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way\n    _convertLatLngs: function _convertLatLngs(latlngs) {\n      var result = [],\n        flat = isFlat(latlngs);\n      for (var i = 0, len = latlngs.length; i < len; i++) {\n        if (flat) {\n          result[i] = toLatLng(latlngs[i]);\n          this._bounds.extend(result[i]);\n        } else {\n          result[i] = this._convertLatLngs(latlngs[i]);\n        }\n      }\n      return result;\n    },\n    _project: function _project() {\n      var pxBounds = new Bounds();\n      this._rings = [];\n      this._projectLatlngs(this._latlngs, this._rings, pxBounds);\n      if (this._bounds.isValid() && pxBounds.isValid()) {\n        this._rawPxBounds = pxBounds;\n        this._updateBounds();\n      }\n    },\n    _updateBounds: function _updateBounds() {\n      var w = this._clickTolerance(),\n        p = new Point(w, w);\n      if (!this._rawPxBounds) {\n        return;\n      }\n      this._pxBounds = new Bounds([this._rawPxBounds.min.subtract(p), this._rawPxBounds.max.add(p)]);\n    },\n    // recursively turns latlngs into a set of rings with projected coordinates\n    _projectLatlngs: function _projectLatlngs(latlngs, result, projectedBounds) {\n      var flat = latlngs[0] instanceof LatLng,\n        len = latlngs.length,\n        i,\n        ring;\n      if (flat) {\n        ring = [];\n        for (i = 0; i < len; i++) {\n          ring[i] = this._map.latLngToLayerPoint(latlngs[i]);\n          projectedBounds.extend(ring[i]);\n        }\n        result.push(ring);\n      } else {\n        for (i = 0; i < len; i++) {\n          this._projectLatlngs(latlngs[i], result, projectedBounds);\n        }\n      }\n    },\n    // clip polyline by renderer bounds so that we have less to render for performance\n    _clipPoints: function _clipPoints() {\n      var bounds = this._renderer._bounds;\n      this._parts = [];\n      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n        return;\n      }\n      if (this.options.noClip) {\n        this._parts = this._rings;\n        return;\n      }\n      var parts = this._parts,\n        i,\n        j,\n        k,\n        len,\n        len2,\n        segment,\n        points;\n      for (i = 0, k = 0, len = this._rings.length; i < len; i++) {\n        points = this._rings[i];\n        for (j = 0, len2 = points.length; j < len2 - 1; j++) {\n          segment = clipSegment(points[j], points[j + 1], bounds, j, true);\n          if (!segment) {\n            continue;\n          }\n          parts[k] = parts[k] || [];\n          parts[k].push(segment[0]);\n\n          // if segment goes out of screen, or it's the last one, it's the end of the line part\n          if (segment[1] !== points[j + 1] || j === len2 - 2) {\n            parts[k].push(segment[1]);\n            k++;\n          }\n        }\n      }\n    },\n    // simplify each clipped part of the polyline for performance\n    _simplifyPoints: function _simplifyPoints() {\n      var parts = this._parts,\n        tolerance = this.options.smoothFactor;\n      for (var i = 0, len = parts.length; i < len; i++) {\n        parts[i] = simplify(parts[i], tolerance);\n      }\n    },\n    _update: function _update() {\n      if (!this._map) {\n        return;\n      }\n      this._clipPoints();\n      this._simplifyPoints();\n      this._updatePath();\n    },\n    _updatePath: function _updatePath() {\n      this._renderer._updatePoly(this);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function _containsPoint(p, closed) {\n      var i,\n        j,\n        k,\n        len,\n        len2,\n        part,\n        w = this._clickTolerance();\n      if (!this._pxBounds || !this._pxBounds.contains(p)) {\n        return false;\n      }\n\n      // hit detection for polylines\n      for (i = 0, len = this._parts.length; i < len; i++) {\n        part = this._parts[i];\n        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n          if (!closed && j === 0) {\n            continue;\n          }\n          if (pointToSegmentDistance(p, part[k], part[j]) <= w) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n  });\n\n  // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)\n  // Instantiates a polyline object given an array of geographical points and\n  // optionally an options object. You can create a `Polyline` object with\n  // multiple separate lines (`MultiPolyline`) by passing an array of arrays\n  // of geographic points.\n  function polyline(latlngs, options) {\n    return new Polyline(latlngs, options);\n  }\n\n  // Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.\n  Polyline._flat = _flat;\n\n  /*\n   * @class Polygon\n   * @aka L.Polygon\n   * @inherits Polyline\n   *\n   * A class for drawing polygon overlays on a map. Extends `Polyline`.\n   *\n   * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.\n   *\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polygon from an array of LatLng points\n   * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];\n   *\n   * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polygon\n   * map.fitBounds(polygon.getBounds());\n   * ```\n   *\n   * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:\n   *\n   * ```js\n   * var latlngs = [\n   *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   * ];\n   * ```\n   *\n   * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.\n   *\n   * ```js\n   * var latlngs = [\n   *   [ // first polygon\n   *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   *   ],\n   *   [ // second polygon\n   *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]\n   *   ]\n   * ];\n   * ```\n   */\n\n  var Polygon = Polyline.extend({\n    options: {\n      fill: true\n    },\n    isEmpty: function isEmpty() {\n      return !this._latlngs.length || !this._latlngs[0].length;\n    },\n    // @method getCenter(): LatLng\n    // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.\n    getCenter: function getCenter() {\n      // throws error when not yet added to map as this center calculation requires projected coordinates\n      if (!this._map) {\n        throw new Error('Must add layer to map before using getCenter()');\n      }\n      return polygonCenter(this._defaultShape(), this._map.options.crs);\n    },\n    _convertLatLngs: function _convertLatLngs(latlngs) {\n      var result = Polyline.prototype._convertLatLngs.call(this, latlngs),\n        len = result.length;\n\n      // remove last point if it equals first one\n      if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {\n        result.pop();\n      }\n      return result;\n    },\n    _setLatLngs: function _setLatLngs(latlngs) {\n      Polyline.prototype._setLatLngs.call(this, latlngs);\n      if (isFlat(this._latlngs)) {\n        this._latlngs = [this._latlngs];\n      }\n    },\n    _defaultShape: function _defaultShape() {\n      return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];\n    },\n    _clipPoints: function _clipPoints() {\n      // polygons need a different clipping algorithm so we redefine that\n\n      var bounds = this._renderer._bounds,\n        w = this.options.weight,\n        p = new Point(w, w);\n\n      // increase clip padding by stroke width to avoid stroke on clip edges\n      bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));\n      this._parts = [];\n      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n        return;\n      }\n      if (this.options.noClip) {\n        this._parts = this._rings;\n        return;\n      }\n      for (var i = 0, len = this._rings.length, clipped; i < len; i++) {\n        clipped = clipPolygon(this._rings[i], bounds, true);\n        if (clipped.length) {\n          this._parts.push(clipped);\n        }\n      }\n    },\n    _updatePath: function _updatePath() {\n      this._renderer._updatePoly(this, true);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function _containsPoint(p) {\n      var inside = false,\n        part,\n        p1,\n        p2,\n        i,\n        j,\n        k,\n        len,\n        len2;\n      if (!this._pxBounds || !this._pxBounds.contains(p)) {\n        return false;\n      }\n\n      // ray casting algorithm for detecting if point is in polygon\n      for (i = 0, len = this._parts.length; i < len; i++) {\n        part = this._parts[i];\n        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n          p1 = part[j];\n          p2 = part[k];\n          if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {\n            inside = !inside;\n          }\n        }\n      }\n\n      // also check if it's on polygon stroke\n      return inside || Polyline.prototype._containsPoint.call(this, p, true);\n    }\n  });\n\n  // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)\n  function polygon(latlngs, options) {\n    return new Polygon(latlngs, options);\n  }\n\n  /*\r\n   * @class GeoJSON\r\n   * @aka L.GeoJSON\r\n   * @inherits FeatureGroup\r\n   *\r\n   * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse\r\n   * GeoJSON data and display it on the map. Extends `FeatureGroup`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.geoJSON(data, {\r\n   * \tstyle: function (feature) {\r\n   * \t\treturn {color: feature.properties.color};\r\n   * \t}\r\n   * }).bindPopup(function (layer) {\r\n   * \treturn layer.feature.properties.description;\r\n   * }).addTo(map);\r\n   * ```\r\n   */\n\n  var GeoJSON = FeatureGroup.extend({\n    /* @section\r\n     * @aka GeoJSON options\r\n     *\r\n     * @option pointToLayer: Function = *\r\n     * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally\r\n     * called when data is added, passing the GeoJSON point feature and its `LatLng`.\r\n     * The default is to spawn a default `Marker`:\r\n     * ```js\r\n     * function(geoJsonPoint, latlng) {\r\n     * \treturn L.marker(latlng);\r\n     * }\r\n     * ```\r\n     *\r\n     * @option style: Function = *\r\n     * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,\r\n     * called internally when data is added.\r\n     * The default value is to not override any defaults:\r\n     * ```js\r\n     * function (geoJsonFeature) {\r\n     * \treturn {}\r\n     * }\r\n     * ```\r\n     *\r\n     * @option onEachFeature: Function = *\r\n     * A `Function` that will be called once for each created `Feature`, after it has\r\n     * been created and styled. Useful for attaching events and popups to features.\r\n     * The default is to do nothing with the newly created layers:\r\n     * ```js\r\n     * function (feature, layer) {}\r\n     * ```\r\n     *\r\n     * @option filter: Function = *\r\n     * A `Function` that will be used to decide whether to include a feature or not.\r\n     * The default is to include all features:\r\n     * ```js\r\n     * function (geoJsonFeature) {\r\n     * \treturn true;\r\n     * }\r\n     * ```\r\n     * Note: dynamically changing the `filter` option will have effect only on newly\r\n     * added data. It will _not_ re-evaluate already included features.\r\n     *\r\n     * @option coordsToLatLng: Function = *\r\n     * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.\r\n     * The default is the `coordsToLatLng` static method.\r\n     *\r\n     * @option markersInheritOptions: Boolean = false\r\n     * Whether default Markers for \"Point\" type Features inherit from group options.\r\n     */\n\n    initialize: function initialize(geojson, options) {\n      setOptions(this, options);\n      this._layers = {};\n      if (geojson) {\n        this.addData(geojson);\n      }\n    },\n    // @method addData( <GeoJSON> data ): this\n    // Adds a GeoJSON object to the layer.\n    addData: function addData(geojson) {\n      var features = isArray(geojson) ? geojson : geojson.features,\n        i,\n        len,\n        feature;\n      if (features) {\n        for (i = 0, len = features.length; i < len; i++) {\n          // only add this if geometry or geometries are set and not null\n          feature = features[i];\n          if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\n            this.addData(feature);\n          }\n        }\n        return this;\n      }\n      var options = this.options;\n      if (options.filter && !options.filter(geojson)) {\n        return this;\n      }\n      var layer = geometryToLayer(geojson, options);\n      if (!layer) {\n        return this;\n      }\n      layer.feature = asFeature(geojson);\n      layer.defaultOptions = layer.options;\n      this.resetStyle(layer);\n      if (options.onEachFeature) {\n        options.onEachFeature(geojson, layer);\n      }\n      return this.addLayer(layer);\n    },\n    // @method resetStyle( <Path> layer? ): this\n    // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.\n    // If `layer` is omitted, the style of all features in the current layer is reset.\n    resetStyle: function resetStyle(layer) {\n      if (layer === undefined) {\n        return this.eachLayer(this.resetStyle, this);\n      }\n      // reset any custom styles\n      layer.options = extend({}, layer.defaultOptions);\n      this._setLayerStyle(layer, this.options.style);\n      return this;\n    },\n    // @method setStyle( <Function> style ): this\n    // Changes styles of GeoJSON vector layers with the given style function.\n    setStyle: function setStyle(style) {\n      return this.eachLayer(function (layer) {\n        this._setLayerStyle(layer, style);\n      }, this);\n    },\n    _setLayerStyle: function _setLayerStyle(layer, style) {\n      if (layer.setStyle) {\n        if (typeof style === 'function') {\n          style = style(layer.feature);\n        }\n        layer.setStyle(style);\n      }\n    }\n  });\n\n  // @section\n  // There are several static functions which can be called without instantiating L.GeoJSON:\n\n  // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer\n  // Creates a `Layer` from a given GeoJSON feature. Can use a custom\n  // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)\n  // functions if provided as options.\n  function geometryToLayer(geojson, options) {\n    var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\n      coords = geometry ? geometry.coordinates : null,\n      layers = [],\n      pointToLayer = options && options.pointToLayer,\n      _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,\n      latlng,\n      latlngs,\n      i,\n      len;\n    if (!coords && !geometry) {\n      return null;\n    }\n    switch (geometry.type) {\n      case 'Point':\n        latlng = _coordsToLatLng(coords);\n        return _pointToLayer(pointToLayer, geojson, latlng, options);\n      case 'MultiPoint':\n        for (i = 0, len = coords.length; i < len; i++) {\n          latlng = _coordsToLatLng(coords[i]);\n          layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));\n        }\n        return new FeatureGroup(layers);\n      case 'LineString':\n      case 'MultiLineString':\n        latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);\n        return new Polyline(latlngs, options);\n      case 'Polygon':\n      case 'MultiPolygon':\n        latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);\n        return new Polygon(latlngs, options);\n      case 'GeometryCollection':\n        for (i = 0, len = geometry.geometries.length; i < len; i++) {\n          var geoLayer = geometryToLayer({\n            geometry: geometry.geometries[i],\n            type: 'Feature',\n            properties: geojson.properties\n          }, options);\n          if (geoLayer) {\n            layers.push(geoLayer);\n          }\n        }\n        return new FeatureGroup(layers);\n      case 'FeatureCollection':\n        for (i = 0, len = geometry.features.length; i < len; i++) {\n          var featureLayer = geometryToLayer(geometry.features[i], options);\n          if (featureLayer) {\n            layers.push(featureLayer);\n          }\n        }\n        return new FeatureGroup(layers);\n      default:\n        throw new Error('Invalid GeoJSON object.');\n    }\n  }\n  function _pointToLayer(pointToLayerFn, geojson, latlng, options) {\n    return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);\n  }\n\n  // @function coordsToLatLng(coords: Array): LatLng\n  // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)\n  // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.\n  function coordsToLatLng(coords) {\n    return new LatLng(coords[1], coords[0], coords[2]);\n  }\n\n  // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array\n  // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.\n  // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).\n  // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.\n  function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {\n    var latlngs = [];\n    for (var i = 0, len = coords.length, latlng; i < len; i++) {\n      latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);\n      latlngs.push(latlng);\n    }\n    return latlngs;\n  }\n\n  // @function latLngToCoords(latlng: LatLng, precision?: Number|false): Array\n  // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.\n  function latLngToCoords(latlng, precision) {\n    latlng = toLatLng(latlng);\n    return latlng.alt !== undefined ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];\n  }\n\n  // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean, precision?: Number|false): Array\n  // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)\n  // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.\n  function latLngsToCoords(latlngs, levelsDeep, closed, precision) {\n    var coords = [];\n    for (var i = 0, len = latlngs.length; i < len; i++) {\n      // Check for flat arrays required to ensure unbalanced arrays are correctly converted in recursion\n      coords.push(levelsDeep ? latLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));\n    }\n    if (!levelsDeep && closed && coords.length > 0) {\n      coords.push(coords[0].slice());\n    }\n    return coords;\n  }\n  function getFeature(layer, newGeometry) {\n    return layer.feature ? extend({}, layer.feature, {\n      geometry: newGeometry\n    }) : asFeature(newGeometry);\n  }\n\n  // @function asFeature(geojson: Object): Object\n  // Normalize GeoJSON geometries/features into GeoJSON features.\n  function asFeature(geojson) {\n    if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {\n      return geojson;\n    }\n    return {\n      type: 'Feature',\n      properties: {},\n      geometry: geojson\n    };\n  }\n  var PointToGeoJSON = {\n    toGeoJSON: function toGeoJSON(precision) {\n      return getFeature(this, {\n        type: 'Point',\n        coordinates: latLngToCoords(this.getLatLng(), precision)\n      });\n    }\n  };\n\n  // @namespace Marker\n  // @section Other methods\n  // @method toGeoJSON(precision?: Number|false): Object\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).\n  Marker.include(PointToGeoJSON);\n\n  // @namespace CircleMarker\n  // @method toGeoJSON(precision?: Number|false): Object\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).\n  Circle.include(PointToGeoJSON);\n  CircleMarker.include(PointToGeoJSON);\n\n  // @namespace Polyline\n  // @method toGeoJSON(precision?: Number|false): Object\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).\n  Polyline.include({\n    toGeoJSON: function toGeoJSON(precision) {\n      var multi = !isFlat(this._latlngs);\n      var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);\n      return getFeature(this, {\n        type: (multi ? 'Multi' : '') + 'LineString',\n        coordinates: coords\n      });\n    }\n  });\n\n  // @namespace Polygon\n  // @method toGeoJSON(precision?: Number|false): Object\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).\n  Polygon.include({\n    toGeoJSON: function toGeoJSON(precision) {\n      var holes = !isFlat(this._latlngs),\n        multi = holes && !isFlat(this._latlngs[0]);\n      var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);\n      if (!holes) {\n        coords = [coords];\n      }\n      return getFeature(this, {\n        type: (multi ? 'Multi' : '') + 'Polygon',\n        coordinates: coords\n      });\n    }\n  });\n\n  // @namespace LayerGroup\n  LayerGroup.include({\n    toMultiPoint: function toMultiPoint(precision) {\n      var coords = [];\n      this.eachLayer(function (layer) {\n        coords.push(layer.toGeoJSON(precision).geometry.coordinates);\n      });\n      return getFeature(this, {\n        type: 'MultiPoint',\n        coordinates: coords\n      });\n    },\n    // @method toGeoJSON(precision?: Number|false): Object\n    // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n    // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).\n    toGeoJSON: function toGeoJSON(precision) {\n      var type = this.feature && this.feature.geometry && this.feature.geometry.type;\n      if (type === 'MultiPoint') {\n        return this.toMultiPoint(precision);\n      }\n      var isGeometryCollection = type === 'GeometryCollection',\n        jsons = [];\n      this.eachLayer(function (layer) {\n        if (layer.toGeoJSON) {\n          var json = layer.toGeoJSON(precision);\n          if (isGeometryCollection) {\n            jsons.push(json.geometry);\n          } else {\n            var feature = asFeature(json);\n            // Squash nested feature collections\n            if (feature.type === 'FeatureCollection') {\n              jsons.push.apply(jsons, feature.features);\n            } else {\n              jsons.push(feature);\n            }\n          }\n        }\n      });\n      if (isGeometryCollection) {\n        return getFeature(this, {\n          geometries: jsons,\n          type: 'GeometryCollection'\n        });\n      }\n      return {\n        type: 'FeatureCollection',\n        features: jsons\n      };\n    }\n  });\n\n  // @namespace GeoJSON\n  // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)\n  // Creates a GeoJSON layer. Optionally accepts an object in\n  // [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map\n  // (you can alternatively add it later with `addData` method) and an `options` object.\n  function geoJSON(geojson, options) {\n    return new GeoJSON(geojson, options);\n  }\n\n  // Backward compatibility.\n  var geoJson = geoJSON;\n\n  /*\r\n   * @class ImageOverlay\r\n   * @aka L.ImageOverlay\r\n   * @inherits Interactive layer\r\n   *\r\n   * Used to load and display a single image over specific bounds of the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var imageUrl = 'https://maps.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',\r\n   * \timageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];\r\n   * L.imageOverlay(imageUrl, imageBounds).addTo(map);\r\n   * ```\r\n   */\n\n  var ImageOverlay = Layer.extend({\n    // @section\n    // @aka ImageOverlay options\n    options: {\n      // @option opacity: Number = 1.0\n      // The opacity of the image overlay.\n      opacity: 1,\n      // @option alt: String = ''\n      // Text for the `alt` attribute of the image (useful for accessibility).\n      alt: '',\n      // @option interactive: Boolean = false\n      // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.\n      interactive: false,\n      // @option crossOrigin: Boolean|String = false\n      // Whether the crossOrigin attribute will be added to the image.\n      // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.\n      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n      crossOrigin: false,\n      // @option errorOverlayUrl: String = ''\n      // URL to the overlay image to show in place of the overlay that failed to load.\n      errorOverlayUrl: '',\n      // @option zIndex: Number = 1\n      // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.\n      zIndex: 1,\n      // @option className: String = ''\n      // A custom class name to assign to the image. Empty by default.\n      className: ''\n    },\n    initialize: function initialize(url, bounds, options) {\n      // (String, LatLngBounds, Object)\n      this._url = url;\n      this._bounds = toLatLngBounds(bounds);\n      setOptions(this, options);\n    },\n    onAdd: function onAdd() {\n      if (!this._image) {\n        this._initImage();\n        if (this.options.opacity < 1) {\n          this._updateOpacity();\n        }\n      }\n      if (this.options.interactive) {\n        addClass(this._image, 'leaflet-interactive');\n        this.addInteractiveTarget(this._image);\n      }\n      this.getPane().appendChild(this._image);\n      this._reset();\n    },\n    onRemove: function onRemove() {\n      _remove(this._image);\n      if (this.options.interactive) {\n        this.removeInteractiveTarget(this._image);\n      }\n    },\n    // @method setOpacity(opacity: Number): this\n    // Sets the opacity of the overlay.\n    setOpacity: function setOpacity(opacity) {\n      this.options.opacity = opacity;\n      if (this._image) {\n        this._updateOpacity();\n      }\n      return this;\n    },\n    setStyle: function setStyle(styleOpts) {\n      if (styleOpts.opacity) {\n        this.setOpacity(styleOpts.opacity);\n      }\n      return this;\n    },\n    // @method bringToFront(): this\n    // Brings the layer to the top of all overlays.\n    bringToFront: function bringToFront() {\n      if (this._map) {\n        toFront(this._image);\n      }\n      return this;\n    },\n    // @method bringToBack(): this\n    // Brings the layer to the bottom of all overlays.\n    bringToBack: function bringToBack() {\n      if (this._map) {\n        toBack(this._image);\n      }\n      return this;\n    },\n    // @method setUrl(url: String): this\n    // Changes the URL of the image.\n    setUrl: function setUrl(url) {\n      this._url = url;\n      if (this._image) {\n        this._image.src = url;\n      }\n      return this;\n    },\n    // @method setBounds(bounds: LatLngBounds): this\n    // Update the bounds that this ImageOverlay covers\n    setBounds: function setBounds(bounds) {\n      this._bounds = toLatLngBounds(bounds);\n      if (this._map) {\n        this._reset();\n      }\n      return this;\n    },\n    getEvents: function getEvents() {\n      var events = {\n        zoom: this._reset,\n        viewreset: this._reset\n      };\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n      return events;\n    },\n    // @method setZIndex(value: Number): this\n    // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.\n    setZIndex: function setZIndex(value) {\n      this.options.zIndex = value;\n      this._updateZIndex();\n      return this;\n    },\n    // @method getBounds(): LatLngBounds\n    // Get the bounds that this ImageOverlay covers\n    getBounds: function getBounds() {\n      return this._bounds;\n    },\n    // @method getElement(): HTMLElement\n    // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)\n    // used by this overlay.\n    getElement: function getElement() {\n      return this._image;\n    },\n    _initImage: function _initImage() {\n      var wasElementSupplied = this._url.tagName === 'IMG';\n      var img = this._image = wasElementSupplied ? this._url : create$1('img');\n      addClass(img, 'leaflet-image-layer');\n      if (this._zoomAnimated) {\n        addClass(img, 'leaflet-zoom-animated');\n      }\n      if (this.options.className) {\n        addClass(img, this.options.className);\n      }\n      img.onselectstart = falseFn;\n      img.onmousemove = falseFn;\n\n      // @event load: Event\n      // Fired when the ImageOverlay layer has loaded its image\n      img.onload = bind(this.fire, this, 'load');\n      img.onerror = bind(this._overlayOnError, this, 'error');\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n      if (this.options.zIndex) {\n        this._updateZIndex();\n      }\n      if (wasElementSupplied) {\n        this._url = img.src;\n        return;\n      }\n      img.src = this._url;\n      img.alt = this.options.alt;\n    },\n    _animateZoom: function _animateZoom(e) {\n      var scale = this._map.getZoomScale(e.zoom),\n        offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;\n      setTransform(this._image, offset, scale);\n    },\n    _reset: function _reset() {\n      var image = this._image,\n        bounds = new Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())),\n        size = bounds.getSize();\n      setPosition(image, bounds.min);\n      image.style.width = size.x + 'px';\n      image.style.height = size.y + 'px';\n    },\n    _updateOpacity: function _updateOpacity() {\n      _setOpacity(this._image, this.options.opacity);\n    },\n    _updateZIndex: function _updateZIndex() {\n      if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n        this._image.style.zIndex = this.options.zIndex;\n      }\n    },\n    _overlayOnError: function _overlayOnError() {\n      // @event error: Event\n      // Fired when the ImageOverlay layer fails to load its image\n      this.fire('error');\n      var errorUrl = this.options.errorOverlayUrl;\n      if (errorUrl && this._url !== errorUrl) {\n        this._url = errorUrl;\n        this._image.src = errorUrl;\n      }\n    },\n    // @method getCenter(): LatLng\n    // Returns the center of the ImageOverlay.\n    getCenter: function getCenter() {\n      return this._bounds.getCenter();\n    }\n  });\n\n  // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)\n  // Instantiates an image overlay object given the URL of the image and the\n  // geographical bounds it is tied to.\n  var imageOverlay = function imageOverlay(url, bounds, options) {\n    return new ImageOverlay(url, bounds, options);\n  };\n\n  /*\r\n   * @class VideoOverlay\r\n   * @aka L.VideoOverlay\r\n   * @inherits ImageOverlay\r\n   *\r\n   * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.\r\n   *\r\n   * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)\r\n   * HTML5 element.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',\r\n   * \tvideoBounds = [[ 32, -130], [ 13, -100]];\r\n   * L.videoOverlay(videoUrl, videoBounds ).addTo(map);\r\n   * ```\r\n   */\n\n  var VideoOverlay = ImageOverlay.extend({\n    // @section\n    // @aka VideoOverlay options\n    options: {\n      // @option autoplay: Boolean = true\n      // Whether the video starts playing automatically when loaded.\n      // On some browsers autoplay will only work with `muted: true`\n      autoplay: true,\n      // @option loop: Boolean = true\n      // Whether the video will loop back to the beginning when played.\n      loop: true,\n      // @option keepAspectRatio: Boolean = true\n      // Whether the video will save aspect ratio after the projection.\n      // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)\n      keepAspectRatio: true,\n      // @option muted: Boolean = false\n      // Whether the video starts on mute when loaded.\n      muted: false,\n      // @option playsInline: Boolean = true\n      // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.\n      playsInline: true\n    },\n    _initImage: function _initImage() {\n      var wasElementSupplied = this._url.tagName === 'VIDEO';\n      var vid = this._image = wasElementSupplied ? this._url : create$1('video');\n      addClass(vid, 'leaflet-image-layer');\n      if (this._zoomAnimated) {\n        addClass(vid, 'leaflet-zoom-animated');\n      }\n      if (this.options.className) {\n        addClass(vid, this.options.className);\n      }\n      vid.onselectstart = falseFn;\n      vid.onmousemove = falseFn;\n\n      // @event load: Event\n      // Fired when the video has finished loading the first frame\n      vid.onloadeddata = bind(this.fire, this, 'load');\n      if (wasElementSupplied) {\n        var sourceElements = vid.getElementsByTagName('source');\n        var sources = [];\n        for (var j = 0; j < sourceElements.length; j++) {\n          sources.push(sourceElements[j].src);\n        }\n        this._url = sourceElements.length > 0 ? sources : [vid.src];\n        return;\n      }\n      if (!isArray(this._url)) {\n        this._url = [this._url];\n      }\n      if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, 'objectFit')) {\n        vid.style['objectFit'] = 'fill';\n      }\n      vid.autoplay = !!this.options.autoplay;\n      vid.loop = !!this.options.loop;\n      vid.muted = !!this.options.muted;\n      vid.playsInline = !!this.options.playsInline;\n      for (var i = 0; i < this._url.length; i++) {\n        var source = create$1('source');\n        source.src = this._url[i];\n        vid.appendChild(source);\n      }\n    }\n\n    // @method getElement(): HTMLVideoElement\n    // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)\n    // used by this overlay.\n  });\n\n  // @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)\n  // Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the\n  // geographical bounds it is tied to.\n\n  function videoOverlay(video, bounds, options) {\n    return new VideoOverlay(video, bounds, options);\n  }\n\n  /*\n   * @class SVGOverlay\n   * @aka L.SVGOverlay\n   * @inherits ImageOverlay\n   *\n   * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.\n   *\n   * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.\n   *\n   * @example\n   *\n   * ```js\n   * var svgElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n   * svgElement.setAttribute('xmlns', \"http://www.w3.org/2000/svg\");\n   * svgElement.setAttribute('viewBox', \"0 0 200 200\");\n   * svgElement.innerHTML = '<rect width=\"200\" height=\"200\"/><rect x=\"75\" y=\"23\" width=\"50\" height=\"50\" style=\"fill:red\"/><rect x=\"75\" y=\"123\" width=\"50\" height=\"50\" style=\"fill:#0013ff\"/>';\n   * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];\n   * L.svgOverlay(svgElement, svgElementBounds).addTo(map);\n   * ```\n   */\n\n  var SVGOverlay = ImageOverlay.extend({\n    _initImage: function _initImage() {\n      var el = this._image = this._url;\n      addClass(el, 'leaflet-image-layer');\n      if (this._zoomAnimated) {\n        addClass(el, 'leaflet-zoom-animated');\n      }\n      if (this.options.className) {\n        addClass(el, this.options.className);\n      }\n      el.onselectstart = falseFn;\n      el.onmousemove = falseFn;\n    }\n\n    // @method getElement(): SVGElement\n    // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)\n    // used by this overlay.\n  });\n\n  // @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)\n  // Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.\n  // A viewBox attribute is required on the SVG element to zoom in and out properly.\n\n  function svgOverlay(el, bounds, options) {\n    return new SVGOverlay(el, bounds, options);\n  }\n\n  /*\r\n   * @class DivOverlay\r\n   * @inherits Interactive layer\r\n   * @aka L.DivOverlay\r\n   * Base model for L.Popup and L.Tooltip. Inherit from it for custom overlays like plugins.\r\n   */\n\n  // @namespace DivOverlay\n  var DivOverlay = Layer.extend({\n    // @section\n    // @aka DivOverlay options\n    options: {\n      // @option interactive: Boolean = false\n      // If true, the popup/tooltip will listen to the mouse events.\n      interactive: false,\n      // @option offset: Point = Point(0, 0)\n      // The offset of the overlay position.\n      offset: [0, 0],\n      // @option className: String = ''\n      // A custom CSS class name to assign to the overlay.\n      className: '',\n      // @option pane: String = undefined\n      // `Map pane` where the overlay will be added.\n      pane: undefined,\n      // @option content: String|HTMLElement|Function = ''\n      // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be\n      // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.\n      content: ''\n    },\n    initialize: function initialize(options, source) {\n      if (options && (options instanceof LatLng || isArray(options))) {\n        this._latlng = toLatLng(options);\n        setOptions(this, source);\n      } else {\n        setOptions(this, options);\n        this._source = source;\n      }\n      if (this.options.content) {\n        this._content = this.options.content;\n      }\n    },\n    // @method openOn(map: Map): this\n    // Adds the overlay to the map.\n    // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.\n    openOn: function openOn(map) {\n      map = arguments.length ? map : this._source._map; // experimental, not the part of public api\n      if (!map.hasLayer(this)) {\n        map.addLayer(this);\n      }\n      return this;\n    },\n    // @method close(): this\n    // Closes the overlay.\n    // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`\n    // and `layer.closePopup()`/`.closeTooltip()`.\n    close: function close() {\n      if (this._map) {\n        this._map.removeLayer(this);\n      }\n      return this;\n    },\n    // @method toggle(layer?: Layer): this\n    // Opens or closes the overlay bound to layer depending on its current state.\n    // Argument may be omitted only for overlay bound to layer.\n    // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.\n    toggle: function toggle(layer) {\n      if (this._map) {\n        this.close();\n      } else {\n        if (arguments.length) {\n          this._source = layer;\n        } else {\n          layer = this._source;\n        }\n        this._prepareOpen();\n\n        // open the overlay on the map\n        this.openOn(layer._map);\n      }\n      return this;\n    },\n    onAdd: function onAdd(map) {\n      this._zoomAnimated = map._zoomAnimated;\n      if (!this._container) {\n        this._initLayout();\n      }\n      if (map._fadeAnimated) {\n        _setOpacity(this._container, 0);\n      }\n      clearTimeout(this._removeTimeout);\n      this.getPane().appendChild(this._container);\n      this.update();\n      if (map._fadeAnimated) {\n        _setOpacity(this._container, 1);\n      }\n      this.bringToFront();\n      if (this.options.interactive) {\n        addClass(this._container, 'leaflet-interactive');\n        this.addInteractiveTarget(this._container);\n      }\n    },\n    onRemove: function onRemove(map) {\n      if (map._fadeAnimated) {\n        _setOpacity(this._container, 0);\n        this._removeTimeout = setTimeout(bind(_remove, undefined, this._container), 200);\n      } else {\n        _remove(this._container);\n      }\n      if (this.options.interactive) {\n        removeClass(this._container, 'leaflet-interactive');\n        this.removeInteractiveTarget(this._container);\n      }\n    },\n    // @namespace DivOverlay\n    // @method getLatLng: LatLng\n    // Returns the geographical point of the overlay.\n    getLatLng: function getLatLng() {\n      return this._latlng;\n    },\n    // @method setLatLng(latlng: LatLng): this\n    // Sets the geographical point where the overlay will open.\n    setLatLng: function setLatLng(latlng) {\n      this._latlng = toLatLng(latlng);\n      if (this._map) {\n        this._updatePosition();\n        this._adjustPan();\n      }\n      return this;\n    },\n    // @method getContent: String|HTMLElement\n    // Returns the content of the overlay.\n    getContent: function getContent() {\n      return this._content;\n    },\n    // @method setContent(htmlContent: String|HTMLElement|Function): this\n    // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.\n    // The function should return a `String` or `HTMLElement` to be used in the overlay.\n    setContent: function setContent(content) {\n      this._content = content;\n      this.update();\n      return this;\n    },\n    // @method getElement: String|HTMLElement\n    // Returns the HTML container of the overlay.\n    getElement: function getElement() {\n      return this._container;\n    },\n    // @method update: null\n    // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.\n    update: function update() {\n      if (!this._map) {\n        return;\n      }\n      this._container.style.visibility = 'hidden';\n      this._updateContent();\n      this._updateLayout();\n      this._updatePosition();\n      this._container.style.visibility = '';\n      this._adjustPan();\n    },\n    getEvents: function getEvents() {\n      var events = {\n        zoom: this._updatePosition,\n        viewreset: this._updatePosition\n      };\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n      return events;\n    },\n    // @method isOpen: Boolean\n    // Returns `true` when the overlay is visible on the map.\n    isOpen: function isOpen() {\n      return !!this._map && this._map.hasLayer(this);\n    },\n    // @method bringToFront: this\n    // Brings this overlay in front of other overlays (in the same map pane).\n    bringToFront: function bringToFront() {\n      if (this._map) {\n        toFront(this._container);\n      }\n      return this;\n    },\n    // @method bringToBack: this\n    // Brings this overlay to the back of other overlays (in the same map pane).\n    bringToBack: function bringToBack() {\n      if (this._map) {\n        toBack(this._container);\n      }\n      return this;\n    },\n    // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)\n    _prepareOpen: function _prepareOpen(latlng) {\n      var source = this._source;\n      if (!source._map) {\n        return false;\n      }\n      if (source instanceof FeatureGroup) {\n        source = null;\n        var layers = this._source._layers;\n        for (var id in layers) {\n          if (layers[id]._map) {\n            source = layers[id];\n            break;\n          }\n        }\n        if (!source) {\n          return false;\n        } // Unable to get source layer.\n\n        // set overlay source to this layer\n        this._source = source;\n      }\n      if (!latlng) {\n        if (source.getCenter) {\n          latlng = source.getCenter();\n        } else if (source.getLatLng) {\n          latlng = source.getLatLng();\n        } else if (source.getBounds) {\n          latlng = source.getBounds().getCenter();\n        } else {\n          throw new Error('Unable to get source layer LatLng.');\n        }\n      }\n      this.setLatLng(latlng);\n      if (this._map) {\n        // update the overlay (content, layout, etc...)\n        this.update();\n      }\n      return true;\n    },\n    _updateContent: function _updateContent() {\n      if (!this._content) {\n        return;\n      }\n      var node = this._contentNode;\n      var content = typeof this._content === 'function' ? this._content(this._source || this) : this._content;\n      if (typeof content === 'string') {\n        node.innerHTML = content;\n      } else {\n        while (node.hasChildNodes()) {\n          node.removeChild(node.firstChild);\n        }\n        node.appendChild(content);\n      }\n\n      // @namespace DivOverlay\n      // @section DivOverlay events\n      // @event contentupdate: Event\n      // Fired when the content of the overlay is updated\n      this.fire('contentupdate');\n    },\n    _updatePosition: function _updatePosition() {\n      if (!this._map) {\n        return;\n      }\n      var pos = this._map.latLngToLayerPoint(this._latlng),\n        offset = toPoint(this.options.offset),\n        anchor = this._getAnchor();\n      if (this._zoomAnimated) {\n        setPosition(this._container, pos.add(anchor));\n      } else {\n        offset = offset.add(pos).add(anchor);\n      }\n      var bottom = this._containerBottom = -offset.y,\n        left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;\n\n      // bottom position the overlay in case the height of the overlay changes (images loading etc)\n      this._container.style.bottom = bottom + 'px';\n      this._container.style.left = left + 'px';\n    },\n    _getAnchor: function _getAnchor() {\n      return [0, 0];\n    }\n  });\n  Map.include({\n    _initOverlay: function _initOverlay(OverlayClass, content, latlng, options) {\n      var overlay = content;\n      if (!(overlay instanceof OverlayClass)) {\n        overlay = new OverlayClass(options).setContent(content);\n      }\n      if (latlng) {\n        overlay.setLatLng(latlng);\n      }\n      return overlay;\n    }\n  });\n  Layer.include({\n    _initOverlay: function _initOverlay(OverlayClass, old, content, options) {\n      var overlay = content;\n      if (overlay instanceof OverlayClass) {\n        setOptions(overlay, options);\n        overlay._source = this;\n      } else {\n        overlay = old && !options ? old : new OverlayClass(options, this);\n        overlay.setContent(content);\n      }\n      return overlay;\n    }\n  });\n\n  /*\r\n   * @class Popup\r\n   * @inherits DivOverlay\r\n   * @aka L.Popup\r\n   * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to\r\n   * open popups while making sure that only one popup is open at one time\r\n   * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.\r\n   *\r\n   * @example\r\n   *\r\n   * If you want to just bind a popup to marker click and then open it, it's really easy:\r\n   *\r\n   * ```js\r\n   * marker.bindPopup(popupContent).openPopup();\r\n   * ```\r\n   * Path overlays like polylines also have a `bindPopup` method.\r\n   *\r\n   * A popup can be also standalone:\r\n   *\r\n   * ```js\r\n   * var popup = L.popup()\r\n   * \t.setLatLng(latlng)\r\n   * \t.setContent('<p>Hello world!<br />This is a nice popup.</p>')\r\n   * \t.openOn(map);\r\n   * ```\r\n   * or\r\n   * ```js\r\n   * var popup = L.popup(latlng, {content: '<p>Hello world!<br />This is a nice popup.</p>')\r\n   * \t.openOn(map);\r\n   * ```\r\n   */\n\n  // @namespace Popup\n  var Popup = DivOverlay.extend({\n    // @section\n    // @aka Popup options\n    options: {\n      // @option pane: String = 'popupPane'\n      // `Map pane` where the popup will be added.\n      pane: 'popupPane',\n      // @option offset: Point = Point(0, 7)\n      // The offset of the popup position.\n      offset: [0, 7],\n      // @option maxWidth: Number = 300\n      // Max width of the popup, in pixels.\n      maxWidth: 300,\n      // @option minWidth: Number = 50\n      // Min width of the popup, in pixels.\n      minWidth: 50,\n      // @option maxHeight: Number = null\n      // If set, creates a scrollable container of the given height\n      // inside a popup if its content exceeds it.\n      // The scrollable container can be styled using the\n      // `leaflet-popup-scrolled` CSS class selector.\n      maxHeight: null,\n      // @option autoPan: Boolean = true\n      // Set it to `false` if you don't want the map to do panning animation\n      // to fit the opened popup.\n      autoPan: true,\n      // @option autoPanPaddingTopLeft: Point = null\n      // The margin between the popup and the top left corner of the map\n      // view after autopanning was performed.\n      autoPanPaddingTopLeft: null,\n      // @option autoPanPaddingBottomRight: Point = null\n      // The margin between the popup and the bottom right corner of the map\n      // view after autopanning was performed.\n      autoPanPaddingBottomRight: null,\n      // @option autoPanPadding: Point = Point(5, 5)\n      // Equivalent of setting both top left and bottom right autopan padding to the same value.\n      autoPanPadding: [5, 5],\n      // @option keepInView: Boolean = false\n      // Set it to `true` if you want to prevent users from panning the popup\n      // off of the screen while it is open.\n      keepInView: false,\n      // @option closeButton: Boolean = true\n      // Controls the presence of a close button in the popup.\n      closeButton: true,\n      // @option autoClose: Boolean = true\n      // Set it to `false` if you want to override the default behavior of\n      // the popup closing when another popup is opened.\n      autoClose: true,\n      // @option closeOnEscapeKey: Boolean = true\n      // Set it to `false` if you want to override the default behavior of\n      // the ESC key for closing of the popup.\n      closeOnEscapeKey: true,\n      // @option closeOnClick: Boolean = *\n      // Set it if you want to override the default behavior of the popup closing when user clicks\n      // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.\n\n      // @option className: String = ''\n      // A custom CSS class name to assign to the popup.\n      className: ''\n    },\n    // @namespace Popup\n    // @method openOn(map: Map): this\n    // Alternative to `map.openPopup(popup)`.\n    // Adds the popup to the map and closes the previous one.\n    openOn: function openOn(map) {\n      map = arguments.length ? map : this._source._map; // experimental, not the part of public api\n\n      if (!map.hasLayer(this) && map._popup && map._popup.options.autoClose) {\n        map.removeLayer(map._popup);\n      }\n      map._popup = this;\n      return DivOverlay.prototype.openOn.call(this, map);\n    },\n    onAdd: function onAdd(map) {\n      DivOverlay.prototype.onAdd.call(this, map);\n\n      // @namespace Map\n      // @section Popup events\n      // @event popupopen: PopupEvent\n      // Fired when a popup is opened in the map\n      map.fire('popupopen', {\n        popup: this\n      });\n      if (this._source) {\n        // @namespace Layer\n        // @section Popup events\n        // @event popupopen: PopupEvent\n        // Fired when a popup bound to this layer is opened\n        this._source.fire('popupopen', {\n          popup: this\n        }, true);\n        // For non-path layers, we toggle the popup when clicking\n        // again the layer, so prevent the map to reopen it.\n        if (!(this._source instanceof Path)) {\n          this._source.on('preclick', stopPropagation);\n        }\n      }\n    },\n    onRemove: function onRemove(map) {\n      DivOverlay.prototype.onRemove.call(this, map);\n\n      // @namespace Map\n      // @section Popup events\n      // @event popupclose: PopupEvent\n      // Fired when a popup in the map is closed\n      map.fire('popupclose', {\n        popup: this\n      });\n      if (this._source) {\n        // @namespace Layer\n        // @section Popup events\n        // @event popupclose: PopupEvent\n        // Fired when a popup bound to this layer is closed\n        this._source.fire('popupclose', {\n          popup: this\n        }, true);\n        if (!(this._source instanceof Path)) {\n          this._source.off('preclick', stopPropagation);\n        }\n      }\n    },\n    getEvents: function getEvents() {\n      var events = DivOverlay.prototype.getEvents.call(this);\n      if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\n        events.preclick = this.close;\n      }\n      if (this.options.keepInView) {\n        events.moveend = this._adjustPan;\n      }\n      return events;\n    },\n    _initLayout: function _initLayout() {\n      var prefix = 'leaflet-popup',\n        container = this._container = create$1('div', prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-animated');\n      var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);\n      this._contentNode = create$1('div', prefix + '-content', wrapper);\n      disableClickPropagation(container);\n      disableScrollPropagation(this._contentNode);\n      on(container, 'contextmenu', stopPropagation);\n      this._tipContainer = create$1('div', prefix + '-tip-container', container);\n      this._tip = create$1('div', prefix + '-tip', this._tipContainer);\n      if (this.options.closeButton) {\n        var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);\n        closeButton.setAttribute('role', 'button'); // overrides the implicit role=link of <a> elements #7399\n        closeButton.setAttribute('aria-label', 'Close popup');\n        closeButton.href = '#close';\n        closeButton.innerHTML = '<span aria-hidden=\"true\">&#215;</span>';\n        on(closeButton, 'click', function (ev) {\n          preventDefault(ev);\n          this.close();\n        }, this);\n      }\n    },\n    _updateLayout: function _updateLayout() {\n      var container = this._contentNode,\n        style = container.style;\n      style.width = '';\n      style.whiteSpace = 'nowrap';\n      var width = container.offsetWidth;\n      width = Math.min(width, this.options.maxWidth);\n      width = Math.max(width, this.options.minWidth);\n      style.width = width + 1 + 'px';\n      style.whiteSpace = '';\n      style.height = '';\n      var height = container.offsetHeight,\n        maxHeight = this.options.maxHeight,\n        scrolledClass = 'leaflet-popup-scrolled';\n      if (maxHeight && height > maxHeight) {\n        style.height = maxHeight + 'px';\n        addClass(container, scrolledClass);\n      } else {\n        removeClass(container, scrolledClass);\n      }\n      this._containerWidth = this._container.offsetWidth;\n    },\n    _animateZoom: function _animateZoom(e) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),\n        anchor = this._getAnchor();\n      setPosition(this._container, pos.add(anchor));\n    },\n    _adjustPan: function _adjustPan() {\n      if (!this.options.autoPan) {\n        return;\n      }\n      if (this._map._panAnim) {\n        this._map._panAnim.stop();\n      }\n\n      // We can endlessly recurse if keepInView is set and the view resets.\n      // Let's guard against that by exiting early if we're responding to our own autopan.\n      if (this._autopanning) {\n        this._autopanning = false;\n        return;\n      }\n      var map = this._map,\n        marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,\n        containerHeight = this._container.offsetHeight + marginBottom,\n        containerWidth = this._containerWidth,\n        layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);\n      layerPos._add(getPosition(this._container));\n      var containerPos = map.layerPointToContainerPoint(layerPos),\n        padding = toPoint(this.options.autoPanPadding),\n        paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),\n        paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),\n        size = map.getSize(),\n        dx = 0,\n        dy = 0;\n      if (containerPos.x + containerWidth + paddingBR.x > size.x) {\n        // right\n        dx = containerPos.x + containerWidth - size.x + paddingBR.x;\n      }\n      if (containerPos.x - dx - paddingTL.x < 0) {\n        // left\n        dx = containerPos.x - paddingTL.x;\n      }\n      if (containerPos.y + containerHeight + paddingBR.y > size.y) {\n        // bottom\n        dy = containerPos.y + containerHeight - size.y + paddingBR.y;\n      }\n      if (containerPos.y - dy - paddingTL.y < 0) {\n        // top\n        dy = containerPos.y - paddingTL.y;\n      }\n\n      // @namespace Map\n      // @section Popup events\n      // @event autopanstart: Event\n      // Fired when the map starts autopanning when opening a popup.\n      if (dx || dy) {\n        // Track that we're autopanning, as this function will be re-ran on moveend\n        if (this.options.keepInView) {\n          this._autopanning = true;\n        }\n        map.fire('autopanstart').panBy([dx, dy]);\n      }\n    },\n    _getAnchor: function _getAnchor() {\n      // Where should we anchor the popup on the source layer?\n      return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);\n    }\n  });\n\n  // @namespace Popup\n  // @factory L.popup(options?: Popup options, source?: Layer)\n  // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.\n  // @alternative\n  // @factory L.popup(latlng: LatLng, options?: Popup options)\n  // Instantiates a `Popup` object given `latlng` where the popup will open and an optional `options` object that describes its appearance and location.\n  var popup = function popup(options, source) {\n    return new Popup(options, source);\n  };\n\n  /* @namespace Map\r\n   * @section Interaction Options\r\n   * @option closePopupOnClick: Boolean = true\r\n   * Set it to `false` if you don't want popups to close when user clicks the map.\r\n   */\n  Map.mergeOptions({\n    closePopupOnClick: true\n  });\n\n  // @namespace Map\n  // @section Methods for Layers and Controls\n  Map.include({\n    // @method openPopup(popup: Popup): this\n    // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).\n    // @alternative\n    // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this\n    // Creates a popup with the specified content and options and opens it in the given point on a map.\n    openPopup: function openPopup(popup, latlng, options) {\n      this._initOverlay(Popup, popup, latlng, options).openOn(this);\n      return this;\n    },\n    // @method closePopup(popup?: Popup): this\n    // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).\n    closePopup: function closePopup(popup) {\n      popup = arguments.length ? popup : this._popup;\n      if (popup) {\n        popup.close();\n      }\n      return this;\n    }\n  });\n\n  /*\r\n   * @namespace Layer\r\n   * @section Popup methods example\r\n   *\r\n   * All layers share a set of methods convenient for binding popups to it.\r\n   *\r\n   * ```js\r\n   * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);\r\n   * layer.openPopup();\r\n   * layer.closePopup();\r\n   * ```\r\n   *\r\n   * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.\r\n   */\n\n  // @section Popup methods\n  Layer.include({\n    // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this\n    // Binds a popup to the layer with the passed `content` and sets up the\n    // necessary event listeners. If a `Function` is passed it will receive\n    // the layer as the first argument and should return a `String` or `HTMLElement`.\n    bindPopup: function bindPopup(content, options) {\n      this._popup = this._initOverlay(Popup, this._popup, content, options);\n      if (!this._popupHandlersAdded) {\n        this.on({\n          click: this._openPopup,\n          keypress: this._onKeyPress,\n          remove: this.closePopup,\n          move: this._movePopup\n        });\n        this._popupHandlersAdded = true;\n      }\n      return this;\n    },\n    // @method unbindPopup(): this\n    // Removes the popup previously bound with `bindPopup`.\n    unbindPopup: function unbindPopup() {\n      if (this._popup) {\n        this.off({\n          click: this._openPopup,\n          keypress: this._onKeyPress,\n          remove: this.closePopup,\n          move: this._movePopup\n        });\n        this._popupHandlersAdded = false;\n        this._popup = null;\n      }\n      return this;\n    },\n    // @method openPopup(latlng?: LatLng): this\n    // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.\n    openPopup: function openPopup(latlng) {\n      if (this._popup) {\n        if (!(this instanceof FeatureGroup)) {\n          this._popup._source = this;\n        }\n        if (this._popup._prepareOpen(latlng || this._latlng)) {\n          // open the popup on the map\n          this._popup.openOn(this._map);\n        }\n      }\n      return this;\n    },\n    // @method closePopup(): this\n    // Closes the popup bound to this layer if it is open.\n    closePopup: function closePopup() {\n      if (this._popup) {\n        this._popup.close();\n      }\n      return this;\n    },\n    // @method togglePopup(): this\n    // Opens or closes the popup bound to this layer depending on its current state.\n    togglePopup: function togglePopup() {\n      if (this._popup) {\n        this._popup.toggle(this);\n      }\n      return this;\n    },\n    // @method isPopupOpen(): boolean\n    // Returns `true` if the popup bound to this layer is currently open.\n    isPopupOpen: function isPopupOpen() {\n      return this._popup ? this._popup.isOpen() : false;\n    },\n    // @method setPopupContent(content: String|HTMLElement|Popup): this\n    // Sets the content of the popup bound to this layer.\n    setPopupContent: function setPopupContent(content) {\n      if (this._popup) {\n        this._popup.setContent(content);\n      }\n      return this;\n    },\n    // @method getPopup(): Popup\n    // Returns the popup bound to this layer.\n    getPopup: function getPopup() {\n      return this._popup;\n    },\n    _openPopup: function _openPopup(e) {\n      if (!this._popup || !this._map) {\n        return;\n      }\n      // prevent map click\n      stop(e);\n      var target = e.layer || e.target;\n      if (this._popup._source === target && !(target instanceof Path)) {\n        // treat it like a marker and figure out\n        // if we should toggle it open/closed\n        if (this._map.hasLayer(this._popup)) {\n          this.closePopup();\n        } else {\n          this.openPopup(e.latlng);\n        }\n        return;\n      }\n      this._popup._source = target;\n      this.openPopup(e.latlng);\n    },\n    _movePopup: function _movePopup(e) {\n      this._popup.setLatLng(e.latlng);\n    },\n    _onKeyPress: function _onKeyPress(e) {\n      if (e.originalEvent.keyCode === 13) {\n        this._openPopup(e);\n      }\n    }\n  });\n\n  /*\n   * @class Tooltip\n   * @inherits DivOverlay\n   * @aka L.Tooltip\n   * Used to display small texts on top of map layers.\n   *\n   * @example\n   * If you want to just bind a tooltip to marker:\n   *\n   * ```js\n   * marker.bindTooltip(\"my tooltip text\").openTooltip();\n   * ```\n   * Path overlays like polylines also have a `bindTooltip` method.\n   *\n   * A tooltip can be also standalone:\n   *\n   * ```js\n   * var tooltip = L.tooltip()\n   * \t.setLatLng(latlng)\n   * \t.setContent('Hello world!<br />This is a nice tooltip.')\n   * \t.addTo(map);\n   * ```\n   * or\n   * ```js\n   * var tooltip = L.tooltip(latlng, {content: 'Hello world!<br />This is a nice tooltip.'})\n   * \t.addTo(map);\n   * ```\n   *\n   *\n   * Note about tooltip offset. Leaflet takes two options in consideration\n   * for computing tooltip offsetting:\n   * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.\n   *   Add a positive x offset to move the tooltip to the right, and a positive y offset to\n   *   move it to the bottom. Negatives will move to the left and top.\n   * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You\n   *   should adapt this value if you use a custom icon.\n   */\n\n  // @namespace Tooltip\n  var Tooltip = DivOverlay.extend({\n    // @section\n    // @aka Tooltip options\n    options: {\n      // @option pane: String = 'tooltipPane'\n      // `Map pane` where the tooltip will be added.\n      pane: 'tooltipPane',\n      // @option offset: Point = Point(0, 0)\n      // Optional offset of the tooltip position.\n      offset: [0, 0],\n      // @option direction: String = 'auto'\n      // Direction where to open the tooltip. Possible values are: `right`, `left`,\n      // `top`, `bottom`, `center`, `auto`.\n      // `auto` will dynamically switch between `right` and `left` according to the tooltip\n      // position on the map.\n      direction: 'auto',\n      // @option permanent: Boolean = false\n      // Whether to open the tooltip permanently or only on mouseover.\n      permanent: false,\n      // @option sticky: Boolean = false\n      // If true, the tooltip will follow the mouse instead of being fixed at the feature center.\n      sticky: false,\n      // @option opacity: Number = 0.9\n      // Tooltip container opacity.\n      opacity: 0.9\n    },\n    onAdd: function onAdd(map) {\n      DivOverlay.prototype.onAdd.call(this, map);\n      this.setOpacity(this.options.opacity);\n\n      // @namespace Map\n      // @section Tooltip events\n      // @event tooltipopen: TooltipEvent\n      // Fired when a tooltip is opened in the map.\n      map.fire('tooltipopen', {\n        tooltip: this\n      });\n      if (this._source) {\n        this.addEventParent(this._source);\n\n        // @namespace Layer\n        // @section Tooltip events\n        // @event tooltipopen: TooltipEvent\n        // Fired when a tooltip bound to this layer is opened.\n        this._source.fire('tooltipopen', {\n          tooltip: this\n        }, true);\n      }\n    },\n    onRemove: function onRemove(map) {\n      DivOverlay.prototype.onRemove.call(this, map);\n\n      // @namespace Map\n      // @section Tooltip events\n      // @event tooltipclose: TooltipEvent\n      // Fired when a tooltip in the map is closed.\n      map.fire('tooltipclose', {\n        tooltip: this\n      });\n      if (this._source) {\n        this.removeEventParent(this._source);\n\n        // @namespace Layer\n        // @section Tooltip events\n        // @event tooltipclose: TooltipEvent\n        // Fired when a tooltip bound to this layer is closed.\n        this._source.fire('tooltipclose', {\n          tooltip: this\n        }, true);\n      }\n    },\n    getEvents: function getEvents() {\n      var events = DivOverlay.prototype.getEvents.call(this);\n      if (!this.options.permanent) {\n        events.preclick = this.close;\n      }\n      return events;\n    },\n    _initLayout: function _initLayout() {\n      var prefix = 'leaflet-tooltip',\n        className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\n      this._contentNode = this._container = create$1('div', className);\n      this._container.setAttribute('role', 'tooltip');\n      this._container.setAttribute('id', 'leaflet-tooltip-' + stamp(this));\n    },\n    _updateLayout: function _updateLayout() {},\n    _adjustPan: function _adjustPan() {},\n    _setPosition: function _setPosition(pos) {\n      var subX,\n        subY,\n        map = this._map,\n        container = this._container,\n        centerPoint = map.latLngToContainerPoint(map.getCenter()),\n        tooltipPoint = map.layerPointToContainerPoint(pos),\n        direction = this.options.direction,\n        tooltipWidth = container.offsetWidth,\n        tooltipHeight = container.offsetHeight,\n        offset = toPoint(this.options.offset),\n        anchor = this._getAnchor();\n      if (direction === 'top') {\n        subX = tooltipWidth / 2;\n        subY = tooltipHeight;\n      } else if (direction === 'bottom') {\n        subX = tooltipWidth / 2;\n        subY = 0;\n      } else if (direction === 'center') {\n        subX = tooltipWidth / 2;\n        subY = tooltipHeight / 2;\n      } else if (direction === 'right') {\n        subX = 0;\n        subY = tooltipHeight / 2;\n      } else if (direction === 'left') {\n        subX = tooltipWidth;\n        subY = tooltipHeight / 2;\n      } else if (tooltipPoint.x < centerPoint.x) {\n        direction = 'right';\n        subX = 0;\n        subY = tooltipHeight / 2;\n      } else {\n        direction = 'left';\n        subX = tooltipWidth + (offset.x + anchor.x) * 2;\n        subY = tooltipHeight / 2;\n      }\n      pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);\n      removeClass(container, 'leaflet-tooltip-right');\n      removeClass(container, 'leaflet-tooltip-left');\n      removeClass(container, 'leaflet-tooltip-top');\n      removeClass(container, 'leaflet-tooltip-bottom');\n      addClass(container, 'leaflet-tooltip-' + direction);\n      setPosition(container, pos);\n    },\n    _updatePosition: function _updatePosition() {\n      var pos = this._map.latLngToLayerPoint(this._latlng);\n      this._setPosition(pos);\n    },\n    setOpacity: function setOpacity(opacity) {\n      this.options.opacity = opacity;\n      if (this._container) {\n        _setOpacity(this._container, opacity);\n      }\n    },\n    _animateZoom: function _animateZoom(e) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);\n      this._setPosition(pos);\n    },\n    _getAnchor: function _getAnchor() {\n      // Where should we anchor the tooltip on the source layer?\n      return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);\n    }\n  });\n\n  // @namespace Tooltip\n  // @factory L.tooltip(options?: Tooltip options, source?: Layer)\n  // Instantiates a `Tooltip` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.\n  // @alternative\n  // @factory L.tooltip(latlng: LatLng, options?: Tooltip options)\n  // Instantiates a `Tooltip` object given `latlng` where the tooltip will open and an optional `options` object that describes its appearance and location.\n  var tooltip = function tooltip(options, source) {\n    return new Tooltip(options, source);\n  };\n\n  // @namespace Map\n  // @section Methods for Layers and Controls\n  Map.include({\n    // @method openTooltip(tooltip: Tooltip): this\n    // Opens the specified tooltip.\n    // @alternative\n    // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this\n    // Creates a tooltip with the specified content and options and open it.\n    openTooltip: function openTooltip(tooltip, latlng, options) {\n      this._initOverlay(Tooltip, tooltip, latlng, options).openOn(this);\n      return this;\n    },\n    // @method closeTooltip(tooltip: Tooltip): this\n    // Closes the tooltip given as parameter.\n    closeTooltip: function closeTooltip(tooltip) {\n      tooltip.close();\n      return this;\n    }\n  });\n\n  /*\n   * @namespace Layer\n   * @section Tooltip methods example\n   *\n   * All layers share a set of methods convenient for binding tooltips to it.\n   *\n   * ```js\n   * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);\n   * layer.openTooltip();\n   * layer.closeTooltip();\n   * ```\n   */\n\n  // @section Tooltip methods\n  Layer.include({\n    // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this\n    // Binds a tooltip to the layer with the passed `content` and sets up the\n    // necessary event listeners. If a `Function` is passed it will receive\n    // the layer as the first argument and should return a `String` or `HTMLElement`.\n    bindTooltip: function bindTooltip(content, options) {\n      if (this._tooltip && this.isTooltipOpen()) {\n        this.unbindTooltip();\n      }\n      this._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);\n      this._initTooltipInteractions();\n      if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {\n        this.openTooltip();\n      }\n      return this;\n    },\n    // @method unbindTooltip(): this\n    // Removes the tooltip previously bound with `bindTooltip`.\n    unbindTooltip: function unbindTooltip() {\n      if (this._tooltip) {\n        this._initTooltipInteractions(true);\n        this.closeTooltip();\n        this._tooltip = null;\n      }\n      return this;\n    },\n    _initTooltipInteractions: function _initTooltipInteractions(remove) {\n      if (!remove && this._tooltipHandlersAdded) {\n        return;\n      }\n      var onOff = remove ? 'off' : 'on',\n        events = {\n          remove: this.closeTooltip,\n          move: this._moveTooltip\n        };\n      if (!this._tooltip.options.permanent) {\n        events.mouseover = this._openTooltip;\n        events.mouseout = this.closeTooltip;\n        events.click = this._openTooltip;\n        if (this._map) {\n          this._addFocusListeners();\n        } else {\n          events.add = this._addFocusListeners;\n        }\n      } else {\n        events.add = this._openTooltip;\n      }\n      if (this._tooltip.options.sticky) {\n        events.mousemove = this._moveTooltip;\n      }\n      this[onOff](events);\n      this._tooltipHandlersAdded = !remove;\n    },\n    // @method openTooltip(latlng?: LatLng): this\n    // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.\n    openTooltip: function openTooltip(latlng) {\n      if (this._tooltip) {\n        if (!(this instanceof FeatureGroup)) {\n          this._tooltip._source = this;\n        }\n        if (this._tooltip._prepareOpen(latlng)) {\n          // open the tooltip on the map\n          this._tooltip.openOn(this._map);\n          if (this.getElement) {\n            this._setAriaDescribedByOnLayer(this);\n          } else if (this.eachLayer) {\n            this.eachLayer(this._setAriaDescribedByOnLayer, this);\n          }\n        }\n      }\n      return this;\n    },\n    // @method closeTooltip(): this\n    // Closes the tooltip bound to this layer if it is open.\n    closeTooltip: function closeTooltip() {\n      if (this._tooltip) {\n        return this._tooltip.close();\n      }\n    },\n    // @method toggleTooltip(): this\n    // Opens or closes the tooltip bound to this layer depending on its current state.\n    toggleTooltip: function toggleTooltip() {\n      if (this._tooltip) {\n        this._tooltip.toggle(this);\n      }\n      return this;\n    },\n    // @method isTooltipOpen(): boolean\n    // Returns `true` if the tooltip bound to this layer is currently open.\n    isTooltipOpen: function isTooltipOpen() {\n      return this._tooltip.isOpen();\n    },\n    // @method setTooltipContent(content: String|HTMLElement|Tooltip): this\n    // Sets the content of the tooltip bound to this layer.\n    setTooltipContent: function setTooltipContent(content) {\n      if (this._tooltip) {\n        this._tooltip.setContent(content);\n      }\n      return this;\n    },\n    // @method getTooltip(): Tooltip\n    // Returns the tooltip bound to this layer.\n    getTooltip: function getTooltip() {\n      return this._tooltip;\n    },\n    _addFocusListeners: function _addFocusListeners() {\n      if (this.getElement) {\n        this._addFocusListenersOnLayer(this);\n      } else if (this.eachLayer) {\n        this.eachLayer(this._addFocusListenersOnLayer, this);\n      }\n    },\n    _addFocusListenersOnLayer: function _addFocusListenersOnLayer(layer) {\n      var el = typeof layer.getElement === 'function' && layer.getElement();\n      if (el) {\n        on(el, 'focus', function () {\n          this._tooltip._source = layer;\n          this.openTooltip();\n        }, this);\n        on(el, 'blur', this.closeTooltip, this);\n      }\n    },\n    _setAriaDescribedByOnLayer: function _setAriaDescribedByOnLayer(layer) {\n      var el = typeof layer.getElement === 'function' && layer.getElement();\n      if (el) {\n        el.setAttribute('aria-describedby', this._tooltip._container.id);\n      }\n    },\n    _openTooltip: function _openTooltip(e) {\n      if (!this._tooltip || !this._map) {\n        return;\n      }\n\n      // If the map is moving, we will show the tooltip after it's done.\n      if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {\n        this._openOnceFlag = true;\n        var that = this;\n        this._map.once('moveend', function () {\n          that._openOnceFlag = false;\n          that._openTooltip(e);\n        });\n        return;\n      }\n      this._tooltip._source = e.layer || e.target;\n      this.openTooltip(this._tooltip.options.sticky ? e.latlng : undefined);\n    },\n    _moveTooltip: function _moveTooltip(e) {\n      var latlng = e.latlng,\n        containerPoint,\n        layerPoint;\n      if (this._tooltip.options.sticky && e.originalEvent) {\n        containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);\n        layerPoint = this._map.containerPointToLayerPoint(containerPoint);\n        latlng = this._map.layerPointToLatLng(layerPoint);\n      }\n      this._tooltip.setLatLng(latlng);\n    }\n  });\n\n  /*\n   * @class DivIcon\n   * @aka L.DivIcon\n   * @inherits Icon\n   *\n   * Represents a lightweight icon for markers that uses a simple `<div>`\n   * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.\n   *\n   * @example\n   * ```js\n   * var myIcon = L.divIcon({className: 'my-div-icon'});\n   * // you can set .my-div-icon styles in CSS\n   *\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\n   * ```\n   *\n   * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.\n   */\n\n  var DivIcon = Icon.extend({\n    options: {\n      // @section\n      // @aka DivIcon options\n      iconSize: [12, 12],\n      // also can be set through CSS\n\n      // iconAnchor: (Point),\n      // popupAnchor: (Point),\n\n      // @option html: String|HTMLElement = ''\n      // Custom HTML code to put inside the div element, empty by default. Alternatively,\n      // an instance of `HTMLElement`.\n      html: false,\n      // @option bgPos: Point = [0, 0]\n      // Optional relative position of the background, in pixels\n      bgPos: null,\n      className: 'leaflet-div-icon'\n    },\n    createIcon: function createIcon(oldIcon) {\n      var div = oldIcon && oldIcon.tagName === 'DIV' ? oldIcon : document.createElement('div'),\n        options = this.options;\n      if (options.html instanceof Element) {\n        empty(div);\n        div.appendChild(options.html);\n      } else {\n        div.innerHTML = options.html !== false ? options.html : '';\n      }\n      if (options.bgPos) {\n        var bgPos = toPoint(options.bgPos);\n        div.style.backgroundPosition = -bgPos.x + 'px ' + -bgPos.y + 'px';\n      }\n      this._setIconStyles(div, 'icon');\n      return div;\n    },\n    createShadow: function createShadow() {\n      return null;\n    }\n  });\n\n  // @factory L.divIcon(options: DivIcon options)\n  // Creates a `DivIcon` instance with the given options.\n  function divIcon(options) {\n    return new DivIcon(options);\n  }\n  Icon.Default = IconDefault;\n\n  /*\n   * @class GridLayer\n   * @inherits Layer\n   * @aka L.GridLayer\n   *\n   * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.\n   * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.\n   *\n   *\n   * @section Synchronous usage\n   * @example\n   *\n   * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords){\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z\n   *         var ctx = tile.getContext('2d');\n   *\n   *         // return the tile so it can be rendered on screen\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section Asynchronous usage\n   * @example\n   *\n   * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords, done){\n   *         var error;\n   *\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // draw something asynchronously and pass the tile to the done() callback\n   *         setTimeout(function() {\n   *             done(error, tile);\n   *         }, 1000);\n   *\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section\n   */\n\n  var GridLayer = Layer.extend({\n    // @section\n    // @aka GridLayer options\n    options: {\n      // @option tileSize: Number|Point = 256\n      // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.\n      tileSize: 256,\n      // @option opacity: Number = 1.0\n      // Opacity of the tiles. Can be used in the `createTile()` function.\n      opacity: 1,\n      // @option updateWhenIdle: Boolean = (depends)\n      // Load new tiles only when panning ends.\n      // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.\n      // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the\n      // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.\n      updateWhenIdle: Browser.mobile,\n      // @option updateWhenZooming: Boolean = true\n      // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.\n      updateWhenZooming: true,\n      // @option updateInterval: Number = 200\n      // Tiles will not update more than once every `updateInterval` milliseconds when panning.\n      updateInterval: 200,\n      // @option zIndex: Number = 1\n      // The explicit zIndex of the tile layer.\n      zIndex: 1,\n      // @option bounds: LatLngBounds = undefined\n      // If set, tiles will only be loaded inside the set `LatLngBounds`.\n      bounds: null,\n      // @option minZoom: Number = 0\n      // The minimum zoom level down to which this layer will be displayed (inclusive).\n      minZoom: 0,\n      // @option maxZoom: Number = undefined\n      // The maximum zoom level up to which this layer will be displayed (inclusive).\n      maxZoom: undefined,\n      // @option maxNativeZoom: Number = undefined\n      // Maximum zoom number the tile source has available. If it is specified,\n      // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded\n      // from `maxNativeZoom` level and auto-scaled.\n      maxNativeZoom: undefined,\n      // @option minNativeZoom: Number = undefined\n      // Minimum zoom number the tile source has available. If it is specified,\n      // the tiles on all zoom levels lower than `minNativeZoom` will be loaded\n      // from `minNativeZoom` level and auto-scaled.\n      minNativeZoom: undefined,\n      // @option noWrap: Boolean = false\n      // Whether the layer is wrapped around the antimeridian. If `true`, the\n      // GridLayer will only be displayed once at low zoom levels. Has no\n      // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used\n      // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting\n      // tiles outside the CRS limits.\n      noWrap: false,\n      // @option pane: String = 'tilePane'\n      // `Map pane` where the grid layer will be added.\n      pane: 'tilePane',\n      // @option className: String = ''\n      // A custom class name to assign to the tile layer. Empty by default.\n      className: '',\n      // @option keepBuffer: Number = 2\n      // When panning the map, keep this many rows and columns of tiles before unloading them.\n      keepBuffer: 2\n    },\n    initialize: function initialize(options) {\n      setOptions(this, options);\n    },\n    onAdd: function onAdd() {\n      this._initContainer();\n      this._levels = {};\n      this._tiles = {};\n      this._resetView(); // implicit _update() call\n    },\n    beforeAdd: function beforeAdd(map) {\n      map._addZoomLimit(this);\n    },\n    onRemove: function onRemove(map) {\n      this._removeAllTiles();\n      _remove(this._container);\n      map._removeZoomLimit(this);\n      this._container = null;\n      this._tileZoom = undefined;\n    },\n    // @method bringToFront: this\n    // Brings the tile layer to the top of all tile layers.\n    bringToFront: function bringToFront() {\n      if (this._map) {\n        toFront(this._container);\n        this._setAutoZIndex(Math.max);\n      }\n      return this;\n    },\n    // @method bringToBack: this\n    // Brings the tile layer to the bottom of all tile layers.\n    bringToBack: function bringToBack() {\n      if (this._map) {\n        toBack(this._container);\n        this._setAutoZIndex(Math.min);\n      }\n      return this;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTML element that contains the tiles for this layer.\n    getContainer: function getContainer() {\n      return this._container;\n    },\n    // @method setOpacity(opacity: Number): this\n    // Changes the [opacity](#gridlayer-opacity) of the grid layer.\n    setOpacity: function setOpacity(opacity) {\n      this.options.opacity = opacity;\n      this._updateOpacity();\n      return this;\n    },\n    // @method setZIndex(zIndex: Number): this\n    // Changes the [zIndex](#gridlayer-zindex) of the grid layer.\n    setZIndex: function setZIndex(zIndex) {\n      this.options.zIndex = zIndex;\n      this._updateZIndex();\n      return this;\n    },\n    // @method isLoading: Boolean\n    // Returns `true` if any tile in the grid layer has not finished loading.\n    isLoading: function isLoading() {\n      return this._loading;\n    },\n    // @method redraw: this\n    // Causes the layer to clear all the tiles and request them again.\n    redraw: function redraw() {\n      if (this._map) {\n        this._removeAllTiles();\n        var tileZoom = this._clampZoom(this._map.getZoom());\n        if (tileZoom !== this._tileZoom) {\n          this._tileZoom = tileZoom;\n          this._updateLevels();\n        }\n        this._update();\n      }\n      return this;\n    },\n    getEvents: function getEvents() {\n      var events = {\n        viewprereset: this._invalidateAll,\n        viewreset: this._resetView,\n        zoom: this._resetView,\n        moveend: this._onMoveEnd\n      };\n      if (!this.options.updateWhenIdle) {\n        // update tiles on move, but not more often than once per given interval\n        if (!this._onMove) {\n          this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);\n        }\n        events.move = this._onMove;\n      }\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n      return events;\n    },\n    // @section Extension methods\n    // Layers extending `GridLayer` shall reimplement the following method.\n    // @method createTile(coords: Object, done?: Function): HTMLElement\n    // Called only internally, must be overridden by classes extending `GridLayer`.\n    // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback\n    // is specified, it must be called when the tile has finished loading and drawing.\n    createTile: function createTile() {\n      return document.createElement('div');\n    },\n    // @section\n    // @method getTileSize: Point\n    // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.\n    getTileSize: function getTileSize() {\n      var s = this.options.tileSize;\n      return s instanceof Point ? s : new Point(s, s);\n    },\n    _updateZIndex: function _updateZIndex() {\n      if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n        this._container.style.zIndex = this.options.zIndex;\n      }\n    },\n    _setAutoZIndex: function _setAutoZIndex(compare) {\n      // go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)\n\n      var layers = this.getPane().children,\n        edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min\n\n      for (var i = 0, len = layers.length, zIndex; i < len; i++) {\n        zIndex = layers[i].style.zIndex;\n        if (layers[i] !== this._container && zIndex) {\n          edgeZIndex = compare(edgeZIndex, +zIndex);\n        }\n      }\n      if (isFinite(edgeZIndex)) {\n        this.options.zIndex = edgeZIndex + compare(-1, 1);\n        this._updateZIndex();\n      }\n    },\n    _updateOpacity: function _updateOpacity() {\n      if (!this._map) {\n        return;\n      }\n\n      // IE doesn't inherit filter opacity properly, so we're forced to set it on tiles\n      if (Browser.ielt9) {\n        return;\n      }\n      _setOpacity(this._container, this.options.opacity);\n      var now = +new Date(),\n        nextFrame = false,\n        willPrune = false;\n      for (var key in this._tiles) {\n        var tile = this._tiles[key];\n        if (!tile.current || !tile.loaded) {\n          continue;\n        }\n        var fade = Math.min(1, (now - tile.loaded) / 200);\n        _setOpacity(tile.el, fade);\n        if (fade < 1) {\n          nextFrame = true;\n        } else {\n          if (tile.active) {\n            willPrune = true;\n          } else {\n            this._onOpaqueTile(tile);\n          }\n          tile.active = true;\n        }\n      }\n      if (willPrune && !this._noPrune) {\n        this._pruneTiles();\n      }\n      if (nextFrame) {\n        cancelAnimFrame(this._fadeFrame);\n        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n      }\n    },\n    _onOpaqueTile: falseFn,\n    _initContainer: function _initContainer() {\n      if (this._container) {\n        return;\n      }\n      this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));\n      this._updateZIndex();\n      if (this.options.opacity < 1) {\n        this._updateOpacity();\n      }\n      this.getPane().appendChild(this._container);\n    },\n    _updateLevels: function _updateLevels() {\n      var zoom = this._tileZoom,\n        maxZoom = this.options.maxZoom;\n      if (zoom === undefined) {\n        return undefined;\n      }\n      for (var z in this._levels) {\n        z = Number(z);\n        if (this._levels[z].el.children.length || z === zoom) {\n          this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);\n          this._onUpdateLevel(z);\n        } else {\n          _remove(this._levels[z].el);\n          this._removeTilesAtZoom(z);\n          this._onRemoveLevel(z);\n          delete this._levels[z];\n        }\n      }\n      var level = this._levels[zoom],\n        map = this._map;\n      if (!level) {\n        level = this._levels[zoom] = {};\n        level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);\n        level.el.style.zIndex = maxZoom;\n        level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();\n        level.zoom = zoom;\n        this._setZoomTransform(level, map.getCenter(), map.getZoom());\n\n        // force the browser to consider the newly added element for transition\n        falseFn(level.el.offsetWidth);\n        this._onCreateLevel(level);\n      }\n      this._level = level;\n      return level;\n    },\n    _onUpdateLevel: falseFn,\n    _onRemoveLevel: falseFn,\n    _onCreateLevel: falseFn,\n    _pruneTiles: function _pruneTiles() {\n      if (!this._map) {\n        return;\n      }\n      var key, tile;\n      var zoom = this._map.getZoom();\n      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n        this._removeAllTiles();\n        return;\n      }\n      for (key in this._tiles) {\n        tile = this._tiles[key];\n        tile.retain = tile.current;\n      }\n      for (key in this._tiles) {\n        tile = this._tiles[key];\n        if (tile.current && !tile.active) {\n          var coords = tile.coords;\n          if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\n            this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\n          }\n        }\n      }\n      for (key in this._tiles) {\n        if (!this._tiles[key].retain) {\n          this._removeTile(key);\n        }\n      }\n    },\n    _removeTilesAtZoom: function _removeTilesAtZoom(zoom) {\n      for (var key in this._tiles) {\n        if (this._tiles[key].coords.z !== zoom) {\n          continue;\n        }\n        this._removeTile(key);\n      }\n    },\n    _removeAllTiles: function _removeAllTiles() {\n      for (var key in this._tiles) {\n        this._removeTile(key);\n      }\n    },\n    _invalidateAll: function _invalidateAll() {\n      for (var z in this._levels) {\n        _remove(this._levels[z].el);\n        this._onRemoveLevel(Number(z));\n        delete this._levels[z];\n      }\n      this._removeAllTiles();\n      this._tileZoom = undefined;\n    },\n    _retainParent: function _retainParent(x, y, z, minZoom) {\n      var x2 = Math.floor(x / 2),\n        y2 = Math.floor(y / 2),\n        z2 = z - 1,\n        coords2 = new Point(+x2, +y2);\n      coords2.z = +z2;\n      var key = this._tileCoordsToKey(coords2),\n        tile = this._tiles[key];\n      if (tile && tile.active) {\n        tile.retain = true;\n        return true;\n      } else if (tile && tile.loaded) {\n        tile.retain = true;\n      }\n      if (z2 > minZoom) {\n        return this._retainParent(x2, y2, z2, minZoom);\n      }\n      return false;\n    },\n    _retainChildren: function _retainChildren(x, y, z, maxZoom) {\n      for (var i = 2 * x; i < 2 * x + 2; i++) {\n        for (var j = 2 * y; j < 2 * y + 2; j++) {\n          var coords = new Point(i, j);\n          coords.z = z + 1;\n          var key = this._tileCoordsToKey(coords),\n            tile = this._tiles[key];\n          if (tile && tile.active) {\n            tile.retain = true;\n            continue;\n          } else if (tile && tile.loaded) {\n            tile.retain = true;\n          }\n          if (z + 1 < maxZoom) {\n            this._retainChildren(i, j, z + 1, maxZoom);\n          }\n        }\n      }\n    },\n    _resetView: function _resetView(e) {\n      var animating = e && (e.pinch || e.flyTo);\n      this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);\n    },\n    _animateZoom: function _animateZoom(e) {\n      this._setView(e.center, e.zoom, true, e.noUpdate);\n    },\n    _clampZoom: function _clampZoom(zoom) {\n      var options = this.options;\n      if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {\n        return options.minNativeZoom;\n      }\n      if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {\n        return options.maxNativeZoom;\n      }\n      return zoom;\n    },\n    _setView: function _setView(center, zoom, noPrune, noUpdate) {\n      var tileZoom = Math.round(zoom);\n      if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) {\n        tileZoom = undefined;\n      } else {\n        tileZoom = this._clampZoom(tileZoom);\n      }\n      var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;\n      if (!noUpdate || tileZoomChanged) {\n        this._tileZoom = tileZoom;\n        if (this._abortLoading) {\n          this._abortLoading();\n        }\n        this._updateLevels();\n        this._resetGrid();\n        if (tileZoom !== undefined) {\n          this._update(center);\n        }\n        if (!noPrune) {\n          this._pruneTiles();\n        }\n\n        // Flag to prevent _updateOpacity from pruning tiles during\n        // a zoom anim or a pinch gesture\n        this._noPrune = !!noPrune;\n      }\n      this._setZoomTransforms(center, zoom);\n    },\n    _setZoomTransforms: function _setZoomTransforms(center, zoom) {\n      for (var i in this._levels) {\n        this._setZoomTransform(this._levels[i], center, zoom);\n      }\n    },\n    _setZoomTransform: function _setZoomTransform(level, center, zoom) {\n      var scale = this._map.getZoomScale(zoom, level.zoom),\n        translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();\n      if (Browser.any3d) {\n        setTransform(level.el, translate, scale);\n      } else {\n        setPosition(level.el, translate);\n      }\n    },\n    _resetGrid: function _resetGrid() {\n      var map = this._map,\n        crs = map.options.crs,\n        tileSize = this._tileSize = this.getTileSize(),\n        tileZoom = this._tileZoom;\n      var bounds = this._map.getPixelWorldBounds(this._tileZoom);\n      if (bounds) {\n        this._globalTileRange = this._pxBoundsToTileRange(bounds);\n      }\n      this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)];\n      this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)];\n    },\n    _onMoveEnd: function _onMoveEnd() {\n      if (!this._map || this._map._animatingZoom) {\n        return;\n      }\n      this._update();\n    },\n    _getTiledPixelBounds: function _getTiledPixelBounds(center) {\n      var map = this._map,\n        mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),\n        scale = map.getZoomScale(mapZoom, this._tileZoom),\n        pixelCenter = map.project(center, this._tileZoom).floor(),\n        halfSize = map.getSize().divideBy(scale * 2);\n      return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n    },\n    // Private method to load tiles in the grid's active zoom level according to map bounds\n    _update: function _update(center) {\n      var map = this._map;\n      if (!map) {\n        return;\n      }\n      var zoom = this._clampZoom(map.getZoom());\n      if (center === undefined) {\n        center = map.getCenter();\n      }\n      if (this._tileZoom === undefined) {\n        return;\n      } // if out of minzoom/maxzoom\n\n      var pixelBounds = this._getTiledPixelBounds(center),\n        tileRange = this._pxBoundsToTileRange(pixelBounds),\n        tileCenter = tileRange.getCenter(),\n        queue = [],\n        margin = this.options.keepBuffer,\n        noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin]));\n\n      // Sanity check: panic if the tile range contains Infinity somewhere.\n      if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {\n        throw new Error('Attempted to load an infinite number of tiles');\n      }\n      for (var key in this._tiles) {\n        var c = this._tiles[key].coords;\n        if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {\n          this._tiles[key].current = false;\n        }\n      }\n\n      // _update just loads more tiles. If the tile zoom level differs too much\n      // from the map's, let _setView reset levels and prune old tiles.\n      if (Math.abs(zoom - this._tileZoom) > 1) {\n        this._setView(center, zoom);\n        return;\n      }\n\n      // create a queue of coordinates to load tiles from\n      for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {\n        for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {\n          var coords = new Point(i, j);\n          coords.z = this._tileZoom;\n          if (!this._isValidTile(coords)) {\n            continue;\n          }\n          var tile = this._tiles[this._tileCoordsToKey(coords)];\n          if (tile) {\n            tile.current = true;\n          } else {\n            queue.push(coords);\n          }\n        }\n      }\n\n      // sort tile queue to load tiles in order of their distance to center\n      queue.sort(function (a, b) {\n        return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);\n      });\n      if (queue.length !== 0) {\n        // if it's the first batch of tiles to load\n        if (!this._loading) {\n          this._loading = true;\n          // @event loading: Event\n          // Fired when the grid layer starts loading tiles.\n          this.fire('loading');\n        }\n\n        // create DOM fragment to append tiles in one batch\n        var fragment = document.createDocumentFragment();\n        for (i = 0; i < queue.length; i++) {\n          this._addTile(queue[i], fragment);\n        }\n        this._level.el.appendChild(fragment);\n      }\n    },\n    _isValidTile: function _isValidTile(coords) {\n      var crs = this._map.options.crs;\n      if (!crs.infinite) {\n        // don't load tile if it's out of bounds and not wrapped\n        var bounds = this._globalTileRange;\n        if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {\n          return false;\n        }\n      }\n      if (!this.options.bounds) {\n        return true;\n      }\n\n      // don't load tile if it doesn't intersect the bounds in options\n      var tileBounds = this._tileCoordsToBounds(coords);\n      return toLatLngBounds(this.options.bounds).overlaps(tileBounds);\n    },\n    _keyToBounds: function _keyToBounds(key) {\n      return this._tileCoordsToBounds(this._keyToTileCoords(key));\n    },\n    _tileCoordsToNwSe: function _tileCoordsToNwSe(coords) {\n      var map = this._map,\n        tileSize = this.getTileSize(),\n        nwPoint = coords.scaleBy(tileSize),\n        sePoint = nwPoint.add(tileSize),\n        nw = map.unproject(nwPoint, coords.z),\n        se = map.unproject(sePoint, coords.z);\n      return [nw, se];\n    },\n    // converts tile coordinates to its geographical bounds\n    _tileCoordsToBounds: function _tileCoordsToBounds(coords) {\n      var bp = this._tileCoordsToNwSe(coords),\n        bounds = new LatLngBounds(bp[0], bp[1]);\n      if (!this.options.noWrap) {\n        bounds = this._map.wrapLatLngBounds(bounds);\n      }\n      return bounds;\n    },\n    // converts tile coordinates to key for the tile cache\n    _tileCoordsToKey: function _tileCoordsToKey(coords) {\n      return coords.x + ':' + coords.y + ':' + coords.z;\n    },\n    // converts tile cache key to coordinates\n    _keyToTileCoords: function _keyToTileCoords(key) {\n      var k = key.split(':'),\n        coords = new Point(+k[0], +k[1]);\n      coords.z = +k[2];\n      return coords;\n    },\n    _removeTile: function _removeTile(key) {\n      var tile = this._tiles[key];\n      if (!tile) {\n        return;\n      }\n      _remove(tile.el);\n      delete this._tiles[key];\n\n      // @event tileunload: TileEvent\n      // Fired when a tile is removed (e.g. when a tile goes off the screen).\n      this.fire('tileunload', {\n        tile: tile.el,\n        coords: this._keyToTileCoords(key)\n      });\n    },\n    _initTile: function _initTile(tile) {\n      addClass(tile, 'leaflet-tile');\n      var tileSize = this.getTileSize();\n      tile.style.width = tileSize.x + 'px';\n      tile.style.height = tileSize.y + 'px';\n      tile.onselectstart = falseFn;\n      tile.onmousemove = falseFn;\n\n      // update opacity on tiles in IE7-8 because of filter inheritance problems\n      if (Browser.ielt9 && this.options.opacity < 1) {\n        _setOpacity(tile, this.options.opacity);\n      }\n    },\n    _addTile: function _addTile(coords, container) {\n      var tilePos = this._getTilePos(coords),\n        key = this._tileCoordsToKey(coords);\n      var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));\n      this._initTile(tile);\n\n      // if createTile is defined with a second argument (\"done\" callback),\n      // we know that tile is async and will be ready later; otherwise\n      if (this.createTile.length < 2) {\n        // mark tile as ready, but delay one frame for opacity animation to happen\n        requestAnimFrame(bind(this._tileReady, this, coords, null, tile));\n      }\n      setPosition(tile, tilePos);\n\n      // save tile in cache\n      this._tiles[key] = {\n        el: tile,\n        coords: coords,\n        current: true\n      };\n      container.appendChild(tile);\n      // @event tileloadstart: TileEvent\n      // Fired when a tile is requested and starts loading.\n      this.fire('tileloadstart', {\n        tile: tile,\n        coords: coords\n      });\n    },\n    _tileReady: function _tileReady(coords, err, tile) {\n      if (err) {\n        // @event tileerror: TileErrorEvent\n        // Fired when there is an error loading a tile.\n        this.fire('tileerror', {\n          error: err,\n          tile: tile,\n          coords: coords\n        });\n      }\n      var key = this._tileCoordsToKey(coords);\n      tile = this._tiles[key];\n      if (!tile) {\n        return;\n      }\n      tile.loaded = +new Date();\n      if (this._map._fadeAnimated) {\n        _setOpacity(tile.el, 0);\n        cancelAnimFrame(this._fadeFrame);\n        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n      } else {\n        tile.active = true;\n        this._pruneTiles();\n      }\n      if (!err) {\n        addClass(tile.el, 'leaflet-tile-loaded');\n\n        // @event tileload: TileEvent\n        // Fired when a tile loads.\n        this.fire('tileload', {\n          tile: tile.el,\n          coords: coords\n        });\n      }\n      if (this._noTilesToLoad()) {\n        this._loading = false;\n        // @event load: Event\n        // Fired when the grid layer loaded all visible tiles.\n        this.fire('load');\n        if (Browser.ielt9 || !this._map._fadeAnimated) {\n          requestAnimFrame(this._pruneTiles, this);\n        } else {\n          // Wait a bit more than 0.2 secs (the duration of the tile fade-in)\n          // to trigger a pruning.\n          setTimeout(bind(this._pruneTiles, this), 250);\n        }\n      }\n    },\n    _getTilePos: function _getTilePos(coords) {\n      return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);\n    },\n    _wrapCoords: function _wrapCoords(coords) {\n      var newCoords = new Point(this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);\n      newCoords.z = coords.z;\n      return newCoords;\n    },\n    _pxBoundsToTileRange: function _pxBoundsToTileRange(bounds) {\n      var tileSize = this.getTileSize();\n      return new Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));\n    },\n    _noTilesToLoad: function _noTilesToLoad() {\n      for (var key in this._tiles) {\n        if (!this._tiles[key].loaded) {\n          return false;\n        }\n      }\n      return true;\n    }\n  });\n\n  // @factory L.gridLayer(options?: GridLayer options)\n  // Creates a new instance of GridLayer with the supplied options.\n  function gridLayer(options) {\n    return new GridLayer(options);\n  }\n\n  /*\r\n   * @class TileLayer\r\n   * @inherits GridLayer\r\n   * @aka L.TileLayer\r\n   * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'}).addTo(map);\n   * ```\r\n   *\r\n   * @section URL template\r\n   * @example\r\n   *\r\n   * A string of the following form:\r\n   *\r\n   * ```\r\n   * 'https://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'\r\n   * ```\r\n   *\r\n   * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add \"&commat;2x\" to the URL to load retina tiles.\r\n   *\r\n   * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:\r\n   *\r\n   * ```\r\n   * L.tileLayer('https://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});\r\n   * ```\r\n   */\n\n  var TileLayer = GridLayer.extend({\n    // @section\n    // @aka TileLayer options\n    options: {\n      // @option minZoom: Number = 0\n      // The minimum zoom level down to which this layer will be displayed (inclusive).\n      minZoom: 0,\n      // @option maxZoom: Number = 18\n      // The maximum zoom level up to which this layer will be displayed (inclusive).\n      maxZoom: 18,\n      // @option subdomains: String|String[] = 'abc'\n      // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.\n      subdomains: 'abc',\n      // @option errorTileUrl: String = ''\n      // URL to the tile image to show in place of the tile that failed to load.\n      errorTileUrl: '',\n      // @option zoomOffset: Number = 0\n      // The zoom number used in tile URLs will be offset with this value.\n      zoomOffset: 0,\n      // @option tms: Boolean = false\n      // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).\n      tms: false,\n      // @option zoomReverse: Boolean = false\n      // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)\n      zoomReverse: false,\n      // @option detectRetina: Boolean = false\n      // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.\n      detectRetina: false,\n      // @option crossOrigin: Boolean|String = false\n      // Whether the crossOrigin attribute will be added to the tiles.\n      // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.\n      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n      crossOrigin: false,\n      // @option referrerPolicy: Boolean|String = false\n      // Whether the referrerPolicy attribute will be added to the tiles.\n      // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.\n      // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer\n      // (e.g. to validate an API token).\n      // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.\n      referrerPolicy: false\n    },\n    initialize: function initialize(url, options) {\n      this._url = url;\n      options = setOptions(this, options);\n\n      // detecting retina displays, adjusting tileSize and zoom levels\n      if (options.detectRetina && Browser.retina && options.maxZoom > 0) {\n        options.tileSize = Math.floor(options.tileSize / 2);\n        if (!options.zoomReverse) {\n          options.zoomOffset++;\n          options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);\n        } else {\n          options.zoomOffset--;\n          options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);\n        }\n        options.minZoom = Math.max(0, options.minZoom);\n      } else if (!options.zoomReverse) {\n        // make sure maxZoom is gte minZoom\n        options.maxZoom = Math.max(options.minZoom, options.maxZoom);\n      } else {\n        // make sure minZoom is lte maxZoom\n        options.minZoom = Math.min(options.maxZoom, options.minZoom);\n      }\n      if (typeof options.subdomains === 'string') {\n        options.subdomains = options.subdomains.split('');\n      }\n      this.on('tileunload', this._onTileRemove);\n    },\n    // @method setUrl(url: String, noRedraw?: Boolean): this\n    // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).\n    // If the URL does not change, the layer will not be redrawn unless\n    // the noRedraw parameter is set to false.\n    setUrl: function setUrl(url, noRedraw) {\n      if (this._url === url && noRedraw === undefined) {\n        noRedraw = true;\n      }\n      this._url = url;\n      if (!noRedraw) {\n        this.redraw();\n      }\n      return this;\n    },\n    // @method createTile(coords: Object, done?: Function): HTMLElement\n    // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)\n    // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`\n    // callback is called when the tile has been loaded.\n    createTile: function createTile(coords, done) {\n      var tile = document.createElement('img');\n      on(tile, 'load', bind(this._tileOnLoad, this, done, tile));\n      on(tile, 'error', bind(this._tileOnError, this, done, tile));\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n\n      // for this new option we follow the documented behavior\n      // more closely by only setting the property when string\n      if (typeof this.options.referrerPolicy === 'string') {\n        tile.referrerPolicy = this.options.referrerPolicy;\n      }\n\n      // The alt attribute is set to the empty string,\n      // allowing screen readers to ignore the decorative image tiles.\n      // https://www.w3.org/WAI/tutorials/images/decorative/\n      // https://www.w3.org/TR/html-aria/#el-img-empty-alt\n      tile.alt = '';\n      tile.src = this.getTileUrl(coords);\n      return tile;\n    },\n    // @section Extension methods\n    // @uninheritable\n    // Layers extending `TileLayer` might reimplement the following method.\n    // @method getTileUrl(coords: Object): String\n    // Called only internally, returns the URL for a tile given its coordinates.\n    // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.\n    getTileUrl: function getTileUrl(coords) {\n      var data = {\n        r: Browser.retina ? '@2x' : '',\n        s: this._getSubdomain(coords),\n        x: coords.x,\n        y: coords.y,\n        z: this._getZoomForUrl()\n      };\n      if (this._map && !this._map.options.crs.infinite) {\n        var invertedY = this._globalTileRange.max.y - coords.y;\n        if (this.options.tms) {\n          data['y'] = invertedY;\n        }\n        data['-y'] = invertedY;\n      }\n      return template(this._url, extend(data, this.options));\n    },\n    _tileOnLoad: function _tileOnLoad(done, tile) {\n      // For https://github.com/Leaflet/Leaflet/issues/3332\n      if (Browser.ielt9) {\n        setTimeout(bind(done, this, null, tile), 0);\n      } else {\n        done(null, tile);\n      }\n    },\n    _tileOnError: function _tileOnError(done, tile, e) {\n      var errorUrl = this.options.errorTileUrl;\n      if (errorUrl && tile.getAttribute('src') !== errorUrl) {\n        tile.src = errorUrl;\n      }\n      done(e, tile);\n    },\n    _onTileRemove: function _onTileRemove(e) {\n      e.tile.onload = null;\n    },\n    _getZoomForUrl: function _getZoomForUrl() {\n      var zoom = this._tileZoom,\n        maxZoom = this.options.maxZoom,\n        zoomReverse = this.options.zoomReverse,\n        zoomOffset = this.options.zoomOffset;\n      if (zoomReverse) {\n        zoom = maxZoom - zoom;\n      }\n      return zoom + zoomOffset;\n    },\n    _getSubdomain: function _getSubdomain(tilePoint) {\n      var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\n      return this.options.subdomains[index];\n    },\n    // stops loading all tiles in the background layer\n    _abortLoading: function _abortLoading() {\n      var i, tile;\n      for (i in this._tiles) {\n        if (this._tiles[i].coords.z !== this._tileZoom) {\n          tile = this._tiles[i].el;\n          tile.onload = falseFn;\n          tile.onerror = falseFn;\n          if (!tile.complete) {\n            tile.src = emptyImageUrl;\n            var coords = this._tiles[i].coords;\n            _remove(tile);\n            delete this._tiles[i];\n            // @event tileabort: TileEvent\n            // Fired when a tile was loading but is now not wanted.\n            this.fire('tileabort', {\n              tile: tile,\n              coords: coords\n            });\n          }\n        }\n      }\n    },\n    _removeTile: function _removeTile(key) {\n      var tile = this._tiles[key];\n      if (!tile) {\n        return;\n      }\n\n      // Cancels any pending http requests associated with the tile\n      tile.el.setAttribute('src', emptyImageUrl);\n      return GridLayer.prototype._removeTile.call(this, key);\n    },\n    _tileReady: function _tileReady(coords, err, tile) {\n      if (!this._map || tile && tile.getAttribute('src') === emptyImageUrl) {\n        return;\n      }\n      return GridLayer.prototype._tileReady.call(this, coords, err, tile);\n    }\n  });\n\n  // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)\n  // Instantiates a tile layer object given a `URL template` and optionally an options object.\n\n  function tileLayer(url, options) {\n    return new TileLayer(url, options);\n  }\n\n  /*\r\n   * @class TileLayer.WMS\r\n   * @inherits TileLayer\r\n   * @aka L.TileLayer.WMS\r\n   * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var nexrad = L.tileLayer.wms(\"http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\", {\r\n   * \tlayers: 'nexrad-n0r-900913',\r\n   * \tformat: 'image/png',\r\n   * \ttransparent: true,\r\n   * \tattribution: \"Weather data © 2012 IEM Nexrad\"\r\n   * });\r\n   * ```\r\n   */\n\n  var TileLayerWMS = TileLayer.extend({\n    // @section\n    // @aka TileLayer.WMS options\n    // If any custom options not documented here are used, they will be sent to the\n    // WMS server as extra parameters in each request URL. This can be useful for\n    // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).\n    defaultWmsParams: {\n      service: 'WMS',\n      request: 'GetMap',\n      // @option layers: String = ''\n      // **(required)** Comma-separated list of WMS layers to show.\n      layers: '',\n      // @option styles: String = ''\n      // Comma-separated list of WMS styles.\n      styles: '',\n      // @option format: String = 'image/jpeg'\n      // WMS image format (use `'image/png'` for layers with transparency).\n      format: 'image/jpeg',\n      // @option transparent: Boolean = false\n      // If `true`, the WMS service will return images with transparency.\n      transparent: false,\n      // @option version: String = '1.1.1'\n      // Version of the WMS service to use\n      version: '1.1.1'\n    },\n    options: {\n      // @option crs: CRS = null\n      // Coordinate Reference System to use for the WMS requests, defaults to\n      // map CRS. Don't change this if you're not sure what it means.\n      crs: null,\n      // @option uppercase: Boolean = false\n      // If `true`, WMS request parameter keys will be uppercase.\n      uppercase: false\n    },\n    initialize: function initialize(url, options) {\n      this._url = url;\n      var wmsParams = extend({}, this.defaultWmsParams);\n\n      // all keys that are not TileLayer options go to WMS params\n      for (var i in options) {\n        if (!(i in this.options)) {\n          wmsParams[i] = options[i];\n        }\n      }\n      options = setOptions(this, options);\n      var realRetina = options.detectRetina && Browser.retina ? 2 : 1;\n      var tileSize = this.getTileSize();\n      wmsParams.width = tileSize.x * realRetina;\n      wmsParams.height = tileSize.y * realRetina;\n      this.wmsParams = wmsParams;\n    },\n    onAdd: function onAdd(map) {\n      this._crs = this.options.crs || map.options.crs;\n      this._wmsVersion = parseFloat(this.wmsParams.version);\n      var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\n      this.wmsParams[projectionKey] = this._crs.code;\n      TileLayer.prototype.onAdd.call(this, map);\n    },\n    getTileUrl: function getTileUrl(coords) {\n      var tileBounds = this._tileCoordsToNwSe(coords),\n        crs = this._crs,\n        bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),\n        min = bounds.min,\n        max = bounds.max,\n        bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(','),\n        url = TileLayer.prototype.getTileUrl.call(this, coords);\n      return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;\n    },\n    // @method setParams(params: Object, noRedraw?: Boolean): this\n    // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).\n    setParams: function setParams(params, noRedraw) {\n      extend(this.wmsParams, params);\n      if (!noRedraw) {\n        this.redraw();\n      }\n      return this;\n    }\n  });\n\n  // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)\n  // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.\n  function tileLayerWMS(url, options) {\n    return new TileLayerWMS(url, options);\n  }\n  TileLayer.WMS = TileLayerWMS;\n  tileLayer.wms = tileLayerWMS;\n\n  /*\n   * @class Renderer\n   * @inherits Layer\n   * @aka L.Renderer\n   *\n   * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the\n   * DOM container of the renderer, its bounds, and its zoom animation.\n   *\n   * A `Renderer` works as an implicit layer group for all `Path`s - the renderer\n   * itself can be added or removed to the map. All paths use a renderer, which can\n   * be implicit (the map will decide the type of renderer and use it automatically)\n   * or explicit (using the [`renderer`](#path-renderer) option of the path).\n   *\n   * Do not use this class directly, use `SVG` and `Canvas` instead.\n   *\n   * @event update: Event\n   * Fired when the renderer updates its bounds, center and zoom, for example when\n   * its map has moved\n   */\n\n  var Renderer = Layer.extend({\n    // @section\n    // @aka Renderer options\n    options: {\n      // @option padding: Number = 0.1\n      // How much to extend the clip area around the map view (relative to its size)\n      // e.g. 0.1 would be 10% of map view in each direction\n      padding: 0.1\n    },\n    initialize: function initialize(options) {\n      setOptions(this, options);\n      stamp(this);\n      this._layers = this._layers || {};\n    },\n    onAdd: function onAdd() {\n      if (!this._container) {\n        this._initContainer(); // defined by renderer implementations\n\n        // always keep transform-origin as 0 0\n        addClass(this._container, 'leaflet-zoom-animated');\n      }\n      this.getPane().appendChild(this._container);\n      this._update();\n      this.on('update', this._updatePaths, this);\n    },\n    onRemove: function onRemove() {\n      this.off('update', this._updatePaths, this);\n      this._destroyContainer();\n    },\n    getEvents: function getEvents() {\n      var events = {\n        viewreset: this._reset,\n        zoom: this._onZoom,\n        moveend: this._update,\n        zoomend: this._onZoomEnd\n      };\n      if (this._zoomAnimated) {\n        events.zoomanim = this._onAnimZoom;\n      }\n      return events;\n    },\n    _onAnimZoom: function _onAnimZoom(ev) {\n      this._updateTransform(ev.center, ev.zoom);\n    },\n    _onZoom: function _onZoom() {\n      this._updateTransform(this._map.getCenter(), this._map.getZoom());\n    },\n    _updateTransform: function _updateTransform(center, zoom) {\n      var scale = this._map.getZoomScale(zoom, this._zoom),\n        viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),\n        currentCenterPoint = this._map.project(this._center, zoom),\n        topLeftOffset = viewHalf.multiplyBy(-scale).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom));\n      if (Browser.any3d) {\n        setTransform(this._container, topLeftOffset, scale);\n      } else {\n        setPosition(this._container, topLeftOffset);\n      }\n    },\n    _reset: function _reset() {\n      this._update();\n      this._updateTransform(this._center, this._zoom);\n      for (var id in this._layers) {\n        this._layers[id]._reset();\n      }\n    },\n    _onZoomEnd: function _onZoomEnd() {\n      for (var id in this._layers) {\n        this._layers[id]._project();\n      }\n    },\n    _updatePaths: function _updatePaths() {\n      for (var id in this._layers) {\n        this._layers[id]._update();\n      }\n    },\n    _update: function _update() {\n      // Update pixel bounds of renderer container (for positioning/sizing/clipping later)\n      // Subclasses are responsible of firing the 'update' event.\n      var p = this.options.padding,\n        size = this._map.getSize(),\n        min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();\n      this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());\n      this._center = this._map.getCenter();\n      this._zoom = this._map.getZoom();\n    }\n  });\n\n  /*\n   * @class Canvas\n   * @inherits Renderer\n   * @aka L.Canvas\n   *\n   * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](https://caniuse.com/canvas), Canvas is not\n   * available in all web browsers, notably IE8, and overlapping geometries might\n   * not display properly in some edge cases.\n   *\n   * @example\n   *\n   * Use Canvas by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.canvas()\n   * });\n   * ```\n   *\n   * Use a Canvas renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.canvas({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */\n\n  var Canvas = Renderer.extend({\n    // @section\n    // @aka Canvas options\n    options: {\n      // @option tolerance: Number = 0\n      // How much to extend the click tolerance around a path/object on the map.\n      tolerance: 0\n    },\n    getEvents: function getEvents() {\n      var events = Renderer.prototype.getEvents.call(this);\n      events.viewprereset = this._onViewPreReset;\n      return events;\n    },\n    _onViewPreReset: function _onViewPreReset() {\n      // Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once\n      this._postponeUpdatePaths = true;\n    },\n    onAdd: function onAdd() {\n      Renderer.prototype.onAdd.call(this);\n\n      // Redraw vectors since canvas is cleared upon removal,\n      // in case of removing the renderer itself from the map.\n      this._draw();\n    },\n    _initContainer: function _initContainer() {\n      var container = this._container = document.createElement('canvas');\n      on(container, 'mousemove', this._onMouseMove, this);\n      on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);\n      on(container, 'mouseout', this._handleMouseOut, this);\n      container['_leaflet_disable_events'] = true;\n      this._ctx = container.getContext('2d');\n    },\n    _destroyContainer: function _destroyContainer() {\n      cancelAnimFrame(this._redrawRequest);\n      delete this._ctx;\n      _remove(this._container);\n      off(this._container);\n      delete this._container;\n    },\n    _updatePaths: function _updatePaths() {\n      if (this._postponeUpdatePaths) {\n        return;\n      }\n      var layer;\n      this._redrawBounds = null;\n      for (var id in this._layers) {\n        layer = this._layers[id];\n        layer._update();\n      }\n      this._redraw();\n    },\n    _update: function _update() {\n      if (this._map._animatingZoom && this._bounds) {\n        return;\n      }\n      Renderer.prototype._update.call(this);\n      var b = this._bounds,\n        container = this._container,\n        size = b.getSize(),\n        m = Browser.retina ? 2 : 1;\n      setPosition(container, b.min);\n\n      // set canvas size (also clearing it); use double size on retina\n      container.width = m * size.x;\n      container.height = m * size.y;\n      container.style.width = size.x + 'px';\n      container.style.height = size.y + 'px';\n      if (Browser.retina) {\n        this._ctx.scale(2, 2);\n      }\n\n      // translate so we use the same path coordinates after canvas element moves\n      this._ctx.translate(-b.min.x, -b.min.y);\n\n      // Tell paths to redraw themselves\n      this.fire('update');\n    },\n    _reset: function _reset() {\n      Renderer.prototype._reset.call(this);\n      if (this._postponeUpdatePaths) {\n        this._postponeUpdatePaths = false;\n        this._updatePaths();\n      }\n    },\n    _initPath: function _initPath(layer) {\n      this._updateDashArray(layer);\n      this._layers[stamp(layer)] = layer;\n      var order = layer._order = {\n        layer: layer,\n        prev: this._drawLast,\n        next: null\n      };\n      if (this._drawLast) {\n        this._drawLast.next = order;\n      }\n      this._drawLast = order;\n      this._drawFirst = this._drawFirst || this._drawLast;\n    },\n    _addPath: function _addPath(layer) {\n      this._requestRedraw(layer);\n    },\n    _removePath: function _removePath(layer) {\n      var order = layer._order;\n      var next = order.next;\n      var prev = order.prev;\n      if (next) {\n        next.prev = prev;\n      } else {\n        this._drawLast = prev;\n      }\n      if (prev) {\n        prev.next = next;\n      } else {\n        this._drawFirst = next;\n      }\n      delete layer._order;\n      delete this._layers[stamp(layer)];\n      this._requestRedraw(layer);\n    },\n    _updatePath: function _updatePath(layer) {\n      // Redraw the union of the layer's old pixel\n      // bounds and the new pixel bounds.\n      this._extendRedrawBounds(layer);\n      layer._project();\n      layer._update();\n      // The redraw will extend the redraw bounds\n      // with the new pixel bounds.\n      this._requestRedraw(layer);\n    },\n    _updateStyle: function _updateStyle(layer) {\n      this._updateDashArray(layer);\n      this._requestRedraw(layer);\n    },\n    _updateDashArray: function _updateDashArray(layer) {\n      if (typeof layer.options.dashArray === 'string') {\n        var parts = layer.options.dashArray.split(/[, ]+/),\n          dashArray = [],\n          dashValue,\n          i;\n        for (i = 0; i < parts.length; i++) {\n          dashValue = Number(parts[i]);\n          // Ignore dash array containing invalid lengths\n          if (isNaN(dashValue)) {\n            return;\n          }\n          dashArray.push(dashValue);\n        }\n        layer.options._dashArray = dashArray;\n      } else {\n        layer.options._dashArray = layer.options.dashArray;\n      }\n    },\n    _requestRedraw: function _requestRedraw(layer) {\n      if (!this._map) {\n        return;\n      }\n      this._extendRedrawBounds(layer);\n      this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);\n    },\n    _extendRedrawBounds: function _extendRedrawBounds(layer) {\n      if (layer._pxBounds) {\n        var padding = (layer.options.weight || 0) + 1;\n        this._redrawBounds = this._redrawBounds || new Bounds();\n        this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));\n        this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));\n      }\n    },\n    _redraw: function _redraw() {\n      this._redrawRequest = null;\n      if (this._redrawBounds) {\n        this._redrawBounds.min._floor();\n        this._redrawBounds.max._ceil();\n      }\n      this._clear(); // clear layers in redraw bounds\n      this._draw(); // draw layers\n\n      this._redrawBounds = null;\n    },\n    _clear: function _clear() {\n      var bounds = this._redrawBounds;\n      if (bounds) {\n        var size = bounds.getSize();\n        this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);\n      } else {\n        this._ctx.save();\n        this._ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this._ctx.clearRect(0, 0, this._container.width, this._container.height);\n        this._ctx.restore();\n      }\n    },\n    _draw: function _draw() {\n      var layer,\n        bounds = this._redrawBounds;\n      this._ctx.save();\n      if (bounds) {\n        var size = bounds.getSize();\n        this._ctx.beginPath();\n        this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);\n        this._ctx.clip();\n      }\n      this._drawing = true;\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n        if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {\n          layer._updatePath();\n        }\n      }\n      this._drawing = false;\n      this._ctx.restore(); // Restore state before clipping.\n    },\n    _updatePoly: function _updatePoly(layer, closed) {\n      if (!this._drawing) {\n        return;\n      }\n      var i,\n        j,\n        len2,\n        p,\n        parts = layer._parts,\n        len = parts.length,\n        ctx = this._ctx;\n      if (!len) {\n        return;\n      }\n      ctx.beginPath();\n      for (i = 0; i < len; i++) {\n        for (j = 0, len2 = parts[i].length; j < len2; j++) {\n          p = parts[i][j];\n          ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);\n        }\n        if (closed) {\n          ctx.closePath();\n        }\n      }\n      this._fillStroke(ctx, layer);\n\n      // TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\n    },\n    _updateCircle: function _updateCircle(layer) {\n      if (!this._drawing || layer._empty()) {\n        return;\n      }\n      var p = layer._point,\n        ctx = this._ctx,\n        r = Math.max(Math.round(layer._radius), 1),\n        s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;\n      if (s !== 1) {\n        ctx.save();\n        ctx.scale(1, s);\n      }\n      ctx.beginPath();\n      ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);\n      if (s !== 1) {\n        ctx.restore();\n      }\n      this._fillStroke(ctx, layer);\n    },\n    _fillStroke: function _fillStroke(ctx, layer) {\n      var options = layer.options;\n      if (options.fill) {\n        ctx.globalAlpha = options.fillOpacity;\n        ctx.fillStyle = options.fillColor || options.color;\n        ctx.fill(options.fillRule || 'evenodd');\n      }\n      if (options.stroke && options.weight !== 0) {\n        if (ctx.setLineDash) {\n          ctx.setLineDash(layer.options && layer.options._dashArray || []);\n        }\n        ctx.globalAlpha = options.opacity;\n        ctx.lineWidth = options.weight;\n        ctx.strokeStyle = options.color;\n        ctx.lineCap = options.lineCap;\n        ctx.lineJoin = options.lineJoin;\n        ctx.stroke();\n      }\n    },\n    // Canvas obviously doesn't have mouse events for individual drawn objects,\n    // so we emulate that by calculating what's under the mouse on mousemove/click manually\n\n    _onClick: function _onClick(e) {\n      var point = this._map.mouseEventToLayerPoint(e),\n        layer,\n        clickedLayer;\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n        if (layer.options.interactive && layer._containsPoint(point)) {\n          if (!(e.type === 'click' || e.type === 'preclick') || !this._map._draggableMoved(layer)) {\n            clickedLayer = layer;\n          }\n        }\n      }\n      this._fireEvent(clickedLayer ? [clickedLayer] : false, e);\n    },\n    _onMouseMove: function _onMouseMove(e) {\n      if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {\n        return;\n      }\n      var point = this._map.mouseEventToLayerPoint(e);\n      this._handleMouseHover(e, point);\n    },\n    _handleMouseOut: function _handleMouseOut(e) {\n      var layer = this._hoveredLayer;\n      if (layer) {\n        // if we're leaving the layer, fire mouseout\n        removeClass(this._container, 'leaflet-interactive');\n        this._fireEvent([layer], e, 'mouseout');\n        this._hoveredLayer = null;\n        this._mouseHoverThrottled = false;\n      }\n    },\n    _handleMouseHover: function _handleMouseHover(e, point) {\n      if (this._mouseHoverThrottled) {\n        return;\n      }\n      var layer, candidateHoveredLayer;\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n        if (layer.options.interactive && layer._containsPoint(point)) {\n          candidateHoveredLayer = layer;\n        }\n      }\n      if (candidateHoveredLayer !== this._hoveredLayer) {\n        this._handleMouseOut(e);\n        if (candidateHoveredLayer) {\n          addClass(this._container, 'leaflet-interactive'); // change cursor\n          this._fireEvent([candidateHoveredLayer], e, 'mouseover');\n          this._hoveredLayer = candidateHoveredLayer;\n        }\n      }\n      this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e);\n      this._mouseHoverThrottled = true;\n      setTimeout(bind(function () {\n        this._mouseHoverThrottled = false;\n      }, this), 32);\n    },\n    _fireEvent: function _fireEvent(layers, e, type) {\n      this._map._fireDOMEvent(e, type || e.type, layers);\n    },\n    _bringToFront: function _bringToFront(layer) {\n      var order = layer._order;\n      if (!order) {\n        return;\n      }\n      var next = order.next;\n      var prev = order.prev;\n      if (next) {\n        next.prev = prev;\n      } else {\n        // Already last\n        return;\n      }\n      if (prev) {\n        prev.next = next;\n      } else if (next) {\n        // Update first entry unless this is the\n        // single entry\n        this._drawFirst = next;\n      }\n      order.prev = this._drawLast;\n      this._drawLast.next = order;\n      order.next = null;\n      this._drawLast = order;\n      this._requestRedraw(layer);\n    },\n    _bringToBack: function _bringToBack(layer) {\n      var order = layer._order;\n      if (!order) {\n        return;\n      }\n      var next = order.next;\n      var prev = order.prev;\n      if (prev) {\n        prev.next = next;\n      } else {\n        // Already first\n        return;\n      }\n      if (next) {\n        next.prev = prev;\n      } else if (prev) {\n        // Update last entry unless this is the\n        // single entry\n        this._drawLast = prev;\n      }\n      order.prev = null;\n      order.next = this._drawFirst;\n      this._drawFirst.prev = order;\n      this._drawFirst = order;\n      this._requestRedraw(layer);\n    }\n  });\n\n  // @factory L.canvas(options?: Renderer options)\n  // Creates a Canvas renderer with the given options.\n  function canvas(options) {\n    return Browser.canvas ? new Canvas(options) : null;\n  }\n\n  /*\n   * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\n   */\n\n  var vmlCreate = function () {\n    try {\n      document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\n      return function (name) {\n        return document.createElement('<lvml:' + name + ' class=\"lvml\">');\n      };\n    } catch (e) {\n      // Do not return fn from catch block so `e` can be garbage collected\n      // See https://github.com/Leaflet/Leaflet/pull/7279\n    }\n    return function (name) {\n      return document.createElement('<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\n    };\n  }();\n\n  /*\n   * @class SVG\n   *\n   *\n   * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility\n   * with old versions of Internet Explorer.\n   */\n\n  // mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences\n  var vmlMixin = {\n    _initContainer: function _initContainer() {\n      this._container = create$1('div', 'leaflet-vml-container');\n    },\n    _update: function _update() {\n      if (this._map._animatingZoom) {\n        return;\n      }\n      Renderer.prototype._update.call(this);\n      this.fire('update');\n    },\n    _initPath: function _initPath(layer) {\n      var container = layer._container = vmlCreate('shape');\n      addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));\n      container.coordsize = '1 1';\n      layer._path = vmlCreate('path');\n      container.appendChild(layer._path);\n      this._updateStyle(layer);\n      this._layers[stamp(layer)] = layer;\n    },\n    _addPath: function _addPath(layer) {\n      var container = layer._container;\n      this._container.appendChild(container);\n      if (layer.options.interactive) {\n        layer.addInteractiveTarget(container);\n      }\n    },\n    _removePath: function _removePath(layer) {\n      var container = layer._container;\n      _remove(container);\n      layer.removeInteractiveTarget(container);\n      delete this._layers[stamp(layer)];\n    },\n    _updateStyle: function _updateStyle(layer) {\n      var stroke = layer._stroke,\n        fill = layer._fill,\n        options = layer.options,\n        container = layer._container;\n      container.stroked = !!options.stroke;\n      container.filled = !!options.fill;\n      if (options.stroke) {\n        if (!stroke) {\n          stroke = layer._stroke = vmlCreate('stroke');\n        }\n        container.appendChild(stroke);\n        stroke.weight = options.weight + 'px';\n        stroke.color = options.color;\n        stroke.opacity = options.opacity;\n        if (options.dashArray) {\n          stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(' ') : options.dashArray.replace(/( *, *)/g, ' ');\n        } else {\n          stroke.dashStyle = '';\n        }\n        stroke.endcap = options.lineCap.replace('butt', 'flat');\n        stroke.joinstyle = options.lineJoin;\n      } else if (stroke) {\n        container.removeChild(stroke);\n        layer._stroke = null;\n      }\n      if (options.fill) {\n        if (!fill) {\n          fill = layer._fill = vmlCreate('fill');\n        }\n        container.appendChild(fill);\n        fill.color = options.fillColor || options.color;\n        fill.opacity = options.fillOpacity;\n      } else if (fill) {\n        container.removeChild(fill);\n        layer._fill = null;\n      }\n    },\n    _updateCircle: function _updateCircle(layer) {\n      var p = layer._point.round(),\n        r = Math.round(layer._radius),\n        r2 = Math.round(layer._radiusY || r);\n      this._setPath(layer, layer._empty() ? 'M0 0' : 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + 65535 * 360);\n    },\n    _setPath: function _setPath(layer, path) {\n      layer._path.v = path;\n    },\n    _bringToFront: function _bringToFront(layer) {\n      toFront(layer._container);\n    },\n    _bringToBack: function _bringToBack(layer) {\n      toBack(layer._container);\n    }\n  };\n  var create = Browser.vml ? vmlCreate : svgCreate;\n\n  /*\n   * @class SVG\n   * @inherits Renderer\n   * @aka L.SVG\n   *\n   * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](https://caniuse.com/svg), SVG is not\n   * available in all web browsers, notably Android 2.x and 3.x.\n   *\n   * Although SVG is not available on IE7 and IE8, these browsers support\n   * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)\n   * (a now deprecated technology), and the SVG renderer will fall back to VML in\n   * this case.\n   *\n   * @example\n   *\n   * Use SVG by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.svg()\n   * });\n   * ```\n   *\n   * Use a SVG renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.svg({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */\n\n  var SVG = Renderer.extend({\n    _initContainer: function _initContainer() {\n      this._container = create('svg');\n\n      // makes it possible to click through svg root; we'll reset it back in individual paths\n      this._container.setAttribute('pointer-events', 'none');\n      this._rootGroup = create('g');\n      this._container.appendChild(this._rootGroup);\n    },\n    _destroyContainer: function _destroyContainer() {\n      _remove(this._container);\n      off(this._container);\n      delete this._container;\n      delete this._rootGroup;\n      delete this._svgSize;\n    },\n    _update: function _update() {\n      if (this._map._animatingZoom && this._bounds) {\n        return;\n      }\n      Renderer.prototype._update.call(this);\n      var b = this._bounds,\n        size = b.getSize(),\n        container = this._container;\n\n      // set size of svg-container if changed\n      if (!this._svgSize || !this._svgSize.equals(size)) {\n        this._svgSize = size;\n        container.setAttribute('width', size.x);\n        container.setAttribute('height', size.y);\n      }\n\n      // movement: update container viewBox so that we don't have to change coordinates of individual layers\n      setPosition(container, b.min);\n      container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));\n      this.fire('update');\n    },\n    // methods below are called by vector layers implementations\n\n    _initPath: function _initPath(layer) {\n      var path = layer._path = create('path');\n\n      // @namespace Path\n      // @option className: String = null\n      // Custom class name set on an element. Only for SVG renderer.\n      if (layer.options.className) {\n        addClass(path, layer.options.className);\n      }\n      if (layer.options.interactive) {\n        addClass(path, 'leaflet-interactive');\n      }\n      this._updateStyle(layer);\n      this._layers[stamp(layer)] = layer;\n    },\n    _addPath: function _addPath(layer) {\n      if (!this._rootGroup) {\n        this._initContainer();\n      }\n      this._rootGroup.appendChild(layer._path);\n      layer.addInteractiveTarget(layer._path);\n    },\n    _removePath: function _removePath(layer) {\n      _remove(layer._path);\n      layer.removeInteractiveTarget(layer._path);\n      delete this._layers[stamp(layer)];\n    },\n    _updatePath: function _updatePath(layer) {\n      layer._project();\n      layer._update();\n    },\n    _updateStyle: function _updateStyle(layer) {\n      var path = layer._path,\n        options = layer.options;\n      if (!path) {\n        return;\n      }\n      if (options.stroke) {\n        path.setAttribute('stroke', options.color);\n        path.setAttribute('stroke-opacity', options.opacity);\n        path.setAttribute('stroke-width', options.weight);\n        path.setAttribute('stroke-linecap', options.lineCap);\n        path.setAttribute('stroke-linejoin', options.lineJoin);\n        if (options.dashArray) {\n          path.setAttribute('stroke-dasharray', options.dashArray);\n        } else {\n          path.removeAttribute('stroke-dasharray');\n        }\n        if (options.dashOffset) {\n          path.setAttribute('stroke-dashoffset', options.dashOffset);\n        } else {\n          path.removeAttribute('stroke-dashoffset');\n        }\n      } else {\n        path.setAttribute('stroke', 'none');\n      }\n      if (options.fill) {\n        path.setAttribute('fill', options.fillColor || options.color);\n        path.setAttribute('fill-opacity', options.fillOpacity);\n        path.setAttribute('fill-rule', options.fillRule || 'evenodd');\n      } else {\n        path.setAttribute('fill', 'none');\n      }\n    },\n    _updatePoly: function _updatePoly(layer, closed) {\n      this._setPath(layer, pointsToPath(layer._parts, closed));\n    },\n    _updateCircle: function _updateCircle(layer) {\n      var p = layer._point,\n        r = Math.max(Math.round(layer._radius), 1),\n        r2 = Math.max(Math.round(layer._radiusY), 1) || r,\n        arc = 'a' + r + ',' + r2 + ' 0 1,0 ';\n\n      // drawing a circle with two half-arcs\n      var d = layer._empty() ? 'M0 0' : 'M' + (p.x - r) + ',' + p.y + arc + r * 2 + ',0 ' + arc + -r * 2 + ',0 ';\n      this._setPath(layer, d);\n    },\n    _setPath: function _setPath(layer, path) {\n      layer._path.setAttribute('d', path);\n    },\n    // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements\n    _bringToFront: function _bringToFront(layer) {\n      toFront(layer._path);\n    },\n    _bringToBack: function _bringToBack(layer) {\n      toBack(layer._path);\n    }\n  });\n  if (Browser.vml) {\n    SVG.include(vmlMixin);\n  }\n\n  // @namespace SVG\n  // @factory L.svg(options?: Renderer options)\n  // Creates a SVG renderer with the given options.\n  function svg(options) {\n    return Browser.svg || Browser.vml ? new SVG(options) : null;\n  }\n  Map.include({\n    // @namespace Map; @method getRenderer(layer: Path): Renderer\n    // Returns the instance of `Renderer` that should be used to render the given\n    // `Path`. It will ensure that the `renderer` options of the map and paths\n    // are respected, and that the renderers do exist on the map.\n    getRenderer: function getRenderer(layer) {\n      // @namespace Path; @option renderer: Renderer\n      // Use this specific instance of `Renderer` for this path. Takes\n      // precedence over the map's [default renderer](#map-renderer).\n      var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;\n      if (!renderer) {\n        renderer = this._renderer = this._createRenderer();\n      }\n      if (!this.hasLayer(renderer)) {\n        this.addLayer(renderer);\n      }\n      return renderer;\n    },\n    _getPaneRenderer: function _getPaneRenderer(name) {\n      if (name === 'overlayPane' || name === undefined) {\n        return false;\n      }\n      var renderer = this._paneRenderers[name];\n      if (renderer === undefined) {\n        renderer = this._createRenderer({\n          pane: name\n        });\n        this._paneRenderers[name] = renderer;\n      }\n      return renderer;\n    },\n    _createRenderer: function _createRenderer(options) {\n      // @namespace Map; @option preferCanvas: Boolean = false\n      // Whether `Path`s should be rendered on a `Canvas` renderer.\n      // By default, all `Path`s are rendered in a `SVG` renderer.\n      return this.options.preferCanvas && canvas(options) || svg(options);\n    }\n  });\n\n  /*\n   * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\n   */\n\n  /*\n   * @class Rectangle\n   * @aka L.Rectangle\n   * @inherits Polygon\n   *\n   * A class for drawing rectangle overlays on a map. Extends `Polygon`.\n   *\n   * @example\n   *\n   * ```js\n   * // define rectangle geographical bounds\n   * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];\n   *\n   * // create an orange rectangle\n   * L.rectangle(bounds, {color: \"#ff7800\", weight: 1}).addTo(map);\n   *\n   * // zoom the map to the rectangle bounds\n   * map.fitBounds(bounds);\n   * ```\n   *\n   */\n\n  var Rectangle = Polygon.extend({\n    initialize: function initialize(latLngBounds, options) {\n      Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\n    },\n    // @method setBounds(latLngBounds: LatLngBounds): this\n    // Redraws the rectangle with the passed bounds.\n    setBounds: function setBounds(latLngBounds) {\n      return this.setLatLngs(this._boundsToLatLngs(latLngBounds));\n    },\n    _boundsToLatLngs: function _boundsToLatLngs(latLngBounds) {\n      latLngBounds = toLatLngBounds(latLngBounds);\n      return [latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast()];\n    }\n  });\n\n  // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)\n  function rectangle(latLngBounds, options) {\n    return new Rectangle(latLngBounds, options);\n  }\n  SVG.create = create;\n  SVG.pointsToPath = pointsToPath;\n  GeoJSON.geometryToLayer = geometryToLayer;\n  GeoJSON.coordsToLatLng = coordsToLatLng;\n  GeoJSON.coordsToLatLngs = coordsToLatLngs;\n  GeoJSON.latLngToCoords = latLngToCoords;\n  GeoJSON.latLngsToCoords = latLngsToCoords;\n  GeoJSON.getFeature = getFeature;\n  GeoJSON.asFeature = asFeature;\n\n  /*\n   * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map\n   * (zoom to a selected bounding box), enabled by default.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n    // @option boxZoom: Boolean = true\n    // Whether the map can be zoomed to a rectangular area specified by\n    // dragging the mouse while pressing the shift key.\n    boxZoom: true\n  });\n  var BoxZoom = Handler.extend({\n    initialize: function initialize(map) {\n      this._map = map;\n      this._container = map._container;\n      this._pane = map._panes.overlayPane;\n      this._resetStateTimeout = 0;\n      map.on('unload', this._destroy, this);\n    },\n    addHooks: function addHooks() {\n      on(this._container, 'mousedown', this._onMouseDown, this);\n    },\n    removeHooks: function removeHooks() {\n      off(this._container, 'mousedown', this._onMouseDown, this);\n    },\n    moved: function moved() {\n      return this._moved;\n    },\n    _destroy: function _destroy() {\n      _remove(this._pane);\n      delete this._pane;\n    },\n    _resetState: function _resetState() {\n      this._resetStateTimeout = 0;\n      this._moved = false;\n    },\n    _clearDeferredResetState: function _clearDeferredResetState() {\n      if (this._resetStateTimeout !== 0) {\n        clearTimeout(this._resetStateTimeout);\n        this._resetStateTimeout = 0;\n      }\n    },\n    _onMouseDown: function _onMouseDown(e) {\n      if (!e.shiftKey || e.which !== 1 && e.button !== 1) {\n        return false;\n      }\n\n      // Clear the deferred resetState if it hasn't executed yet, otherwise it\n      // will interrupt the interaction and orphan a box element in the container.\n      this._clearDeferredResetState();\n      this._resetState();\n      disableTextSelection();\n      disableImageDrag();\n      this._startPoint = this._map.mouseEventToContainerPoint(e);\n      on(document, {\n        contextmenu: stop,\n        mousemove: this._onMouseMove,\n        mouseup: this._onMouseUp,\n        keydown: this._onKeyDown\n      }, this);\n    },\n    _onMouseMove: function _onMouseMove(e) {\n      if (!this._moved) {\n        this._moved = true;\n        this._box = create$1('div', 'leaflet-zoom-box', this._container);\n        addClass(this._container, 'leaflet-crosshair');\n        this._map.fire('boxzoomstart');\n      }\n      this._point = this._map.mouseEventToContainerPoint(e);\n      var bounds = new Bounds(this._point, this._startPoint),\n        size = bounds.getSize();\n      setPosition(this._box, bounds.min);\n      this._box.style.width = size.x + 'px';\n      this._box.style.height = size.y + 'px';\n    },\n    _finish: function _finish() {\n      if (this._moved) {\n        _remove(this._box);\n        removeClass(this._container, 'leaflet-crosshair');\n      }\n      enableTextSelection();\n      enableImageDrag();\n      off(document, {\n        contextmenu: stop,\n        mousemove: this._onMouseMove,\n        mouseup: this._onMouseUp,\n        keydown: this._onKeyDown\n      }, this);\n    },\n    _onMouseUp: function _onMouseUp(e) {\n      if (e.which !== 1 && e.button !== 1) {\n        return;\n      }\n      this._finish();\n      if (!this._moved) {\n        return;\n      }\n      // Postpone to next JS tick so internal click event handling\n      // still see it as \"moved\".\n      this._clearDeferredResetState();\n      this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);\n      var bounds = new LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));\n      this._map.fitBounds(bounds).fire('boxzoomend', {\n        boxZoomBounds: bounds\n      });\n    },\n    _onKeyDown: function _onKeyDown(e) {\n      if (e.keyCode === 27) {\n        this._finish();\n        this._clearDeferredResetState();\n        this._resetState();\n      }\n    }\n  });\n\n  // @section Handlers\n  // @property boxZoom: Handler\n  // Box (shift-drag with mouse) zoom handler.\n  Map.addInitHook('addHandler', 'boxZoom', BoxZoom);\n\n  /*\n   * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @option doubleClickZoom: Boolean|String = true\n    // Whether the map can be zoomed in by double clicking on it and\n    // zoomed out by double clicking while holding shift. If passed\n    // `'center'`, double-click zoom will zoom to the center of the\n    //  view regardless of where the mouse was.\n    doubleClickZoom: true\n  });\n  var DoubleClickZoom = Handler.extend({\n    addHooks: function addHooks() {\n      this._map.on('dblclick', this._onDoubleClick, this);\n    },\n    removeHooks: function removeHooks() {\n      this._map.off('dblclick', this._onDoubleClick, this);\n    },\n    _onDoubleClick: function _onDoubleClick(e) {\n      var map = this._map,\n        oldZoom = map.getZoom(),\n        delta = map.options.zoomDelta,\n        zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;\n      if (map.options.doubleClickZoom === 'center') {\n        map.setZoom(zoom);\n      } else {\n        map.setZoomAround(e.containerPoint, zoom);\n      }\n    }\n  });\n\n  // @section Handlers\n  //\n  // Map properties include interaction handlers that allow you to control\n  // interaction behavior in runtime, enabling or disabling certain features such\n  // as dragging or touch zoom (see `Handler` methods). For example:\n  //\n  // ```js\n  // map.doubleClickZoom.disable();\n  // ```\n  //\n  // @property doubleClickZoom: Handler\n  // Double click zoom handler.\n  Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);\n\n  /*\n   * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n    // @option dragging: Boolean = true\n    // Whether the map is draggable with mouse/touch or not.\n    dragging: true,\n    // @section Panning Inertia Options\n    // @option inertia: Boolean = *\n    // If enabled, panning of the map will have an inertia effect where\n    // the map builds momentum while dragging and continues moving in\n    // the same direction for some time. Feels especially nice on touch\n    // devices. Enabled by default.\n    inertia: true,\n    // @option inertiaDeceleration: Number = 3000\n    // The rate with which the inertial movement slows down, in pixels/second².\n    inertiaDeceleration: 3400,\n    // px/s^2\n\n    // @option inertiaMaxSpeed: Number = Infinity\n    // Max speed of the inertial movement, in pixels/second.\n    inertiaMaxSpeed: Infinity,\n    // px/s\n\n    // @option easeLinearity: Number = 0.2\n    easeLinearity: 0.2,\n    // TODO refactor, move to CRS\n    // @option worldCopyJump: Boolean = false\n    // With this option enabled, the map tracks when you pan to another \"copy\"\n    // of the world and seamlessly jumps to the original one so that all overlays\n    // like markers and vector layers are still visible.\n    worldCopyJump: false,\n    // @option maxBoundsViscosity: Number = 0.0\n    // If `maxBounds` is set, this option will control how solid the bounds\n    // are when dragging the map around. The default value of `0.0` allows the\n    // user to drag outside the bounds at normal speed, higher values will\n    // slow down map dragging outside bounds, and `1.0` makes the bounds fully\n    // solid, preventing the user from dragging outside the bounds.\n    maxBoundsViscosity: 0.0\n  });\n  var Drag = Handler.extend({\n    addHooks: function addHooks() {\n      if (!this._draggable) {\n        var map = this._map;\n        this._draggable = new Draggable(map._mapPane, map._container);\n        this._draggable.on({\n          dragstart: this._onDragStart,\n          drag: this._onDrag,\n          dragend: this._onDragEnd\n        }, this);\n        this._draggable.on('predrag', this._onPreDragLimit, this);\n        if (map.options.worldCopyJump) {\n          this._draggable.on('predrag', this._onPreDragWrap, this);\n          map.on('zoomend', this._onZoomEnd, this);\n          map.whenReady(this._onZoomEnd, this);\n        }\n      }\n      addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');\n      this._draggable.enable();\n      this._positions = [];\n      this._times = [];\n    },\n    removeHooks: function removeHooks() {\n      removeClass(this._map._container, 'leaflet-grab');\n      removeClass(this._map._container, 'leaflet-touch-drag');\n      this._draggable.disable();\n    },\n    moved: function moved() {\n      return this._draggable && this._draggable._moved;\n    },\n    moving: function moving() {\n      return this._draggable && this._draggable._moving;\n    },\n    _onDragStart: function _onDragStart() {\n      var map = this._map;\n      map._stop();\n      if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {\n        var bounds = toLatLngBounds(this._map.options.maxBounds);\n        this._offsetLimit = toBounds(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));\n        this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));\n      } else {\n        this._offsetLimit = null;\n      }\n      map.fire('movestart').fire('dragstart');\n      if (map.options.inertia) {\n        this._positions = [];\n        this._times = [];\n      }\n    },\n    _onDrag: function _onDrag(e) {\n      if (this._map.options.inertia) {\n        var time = this._lastTime = +new Date(),\n          pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;\n        this._positions.push(pos);\n        this._times.push(time);\n        this._prunePositions(time);\n      }\n      this._map.fire('move', e).fire('drag', e);\n    },\n    _prunePositions: function _prunePositions(time) {\n      while (this._positions.length > 1 && time - this._times[0] > 50) {\n        this._positions.shift();\n        this._times.shift();\n      }\n    },\n    _onZoomEnd: function _onZoomEnd() {\n      var pxCenter = this._map.getSize().divideBy(2),\n        pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n      this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n      this._worldWidth = this._map.getPixelWorldBounds().getSize().x;\n    },\n    _viscousLimit: function _viscousLimit(value, threshold) {\n      return value - (value - threshold) * this._viscosity;\n    },\n    _onPreDragLimit: function _onPreDragLimit() {\n      if (!this._viscosity || !this._offsetLimit) {\n        return;\n      }\n      var offset = this._draggable._newPos.subtract(this._draggable._startPos);\n      var limit = this._offsetLimit;\n      if (offset.x < limit.min.x) {\n        offset.x = this._viscousLimit(offset.x, limit.min.x);\n      }\n      if (offset.y < limit.min.y) {\n        offset.y = this._viscousLimit(offset.y, limit.min.y);\n      }\n      if (offset.x > limit.max.x) {\n        offset.x = this._viscousLimit(offset.x, limit.max.x);\n      }\n      if (offset.y > limit.max.y) {\n        offset.y = this._viscousLimit(offset.y, limit.max.y);\n      }\n      this._draggable._newPos = this._draggable._startPos.add(offset);\n    },\n    _onPreDragWrap: function _onPreDragWrap() {\n      // TODO refactor to be able to adjust map pane position after zoom\n      var worldWidth = this._worldWidth,\n        halfWidth = Math.round(worldWidth / 2),\n        dx = this._initialWorldOffset,\n        x = this._draggable._newPos.x,\n        newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n        newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n        newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n      this._draggable._absPos = this._draggable._newPos.clone();\n      this._draggable._newPos.x = newX;\n    },\n    _onDragEnd: function _onDragEnd(e) {\n      var map = this._map,\n        options = map.options,\n        noInertia = !options.inertia || e.noInertia || this._times.length < 2;\n      map.fire('dragend', e);\n      if (noInertia) {\n        map.fire('moveend');\n      } else {\n        this._prunePositions(+new Date());\n        var direction = this._lastPos.subtract(this._positions[0]),\n          duration = (this._lastTime - this._times[0]) / 1000,\n          ease = options.easeLinearity,\n          speedVector = direction.multiplyBy(ease / duration),\n          speed = speedVector.distanceTo([0, 0]),\n          limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n          limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n          decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n          offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n        if (!offset.x && !offset.y) {\n          map.fire('moveend');\n        } else {\n          offset = map._limitOffset(offset, map.options.maxBounds);\n          requestAnimFrame(function () {\n            map.panBy(offset, {\n              duration: decelerationDuration,\n              easeLinearity: ease,\n              noMoveStart: true,\n              animate: true\n            });\n          });\n        }\n      }\n    }\n  });\n\n  // @section Handlers\n  // @property dragging: Handler\n  // Map dragging handler (by both mouse and touch).\n  Map.addInitHook('addHandler', 'dragging', Drag);\n\n  /*\n   * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n   */\n\n  // @namespace Map\n  // @section Keyboard Navigation Options\n  Map.mergeOptions({\n    // @option keyboard: Boolean = true\n    // Makes the map focusable and allows users to navigate the map with keyboard\n    // arrows and `+`/`-` keys.\n    keyboard: true,\n    // @option keyboardPanDelta: Number = 80\n    // Amount of pixels to pan when pressing an arrow key.\n    keyboardPanDelta: 80\n  });\n  var Keyboard = Handler.extend({\n    keyCodes: {\n      left: [37],\n      right: [39],\n      down: [40],\n      up: [38],\n      zoomIn: [187, 107, 61, 171],\n      zoomOut: [189, 109, 54, 173]\n    },\n    initialize: function initialize(map) {\n      this._map = map;\n      this._setPanDelta(map.options.keyboardPanDelta);\n      this._setZoomDelta(map.options.zoomDelta);\n    },\n    addHooks: function addHooks() {\n      var container = this._map._container;\n\n      // make the container focusable by tabbing\n      if (container.tabIndex <= 0) {\n        container.tabIndex = '0';\n      }\n      on(container, {\n        focus: this._onFocus,\n        blur: this._onBlur,\n        mousedown: this._onMouseDown\n      }, this);\n      this._map.on({\n        focus: this._addHooks,\n        blur: this._removeHooks\n      }, this);\n    },\n    removeHooks: function removeHooks() {\n      this._removeHooks();\n      off(this._map._container, {\n        focus: this._onFocus,\n        blur: this._onBlur,\n        mousedown: this._onMouseDown\n      }, this);\n      this._map.off({\n        focus: this._addHooks,\n        blur: this._removeHooks\n      }, this);\n    },\n    _onMouseDown: function _onMouseDown() {\n      if (this._focused) {\n        return;\n      }\n      var body = document.body,\n        docEl = document.documentElement,\n        top = body.scrollTop || docEl.scrollTop,\n        left = body.scrollLeft || docEl.scrollLeft;\n      this._map._container.focus();\n      window.scrollTo(left, top);\n    },\n    _onFocus: function _onFocus() {\n      this._focused = true;\n      this._map.fire('focus');\n    },\n    _onBlur: function _onBlur() {\n      this._focused = false;\n      this._map.fire('blur');\n    },\n    _setPanDelta: function _setPanDelta(panDelta) {\n      var keys = this._panKeys = {},\n        codes = this.keyCodes,\n        i,\n        len;\n      for (i = 0, len = codes.left.length; i < len; i++) {\n        keys[codes.left[i]] = [-1 * panDelta, 0];\n      }\n      for (i = 0, len = codes.right.length; i < len; i++) {\n        keys[codes.right[i]] = [panDelta, 0];\n      }\n      for (i = 0, len = codes.down.length; i < len; i++) {\n        keys[codes.down[i]] = [0, panDelta];\n      }\n      for (i = 0, len = codes.up.length; i < len; i++) {\n        keys[codes.up[i]] = [0, -1 * panDelta];\n      }\n    },\n    _setZoomDelta: function _setZoomDelta(zoomDelta) {\n      var keys = this._zoomKeys = {},\n        codes = this.keyCodes,\n        i,\n        len;\n      for (i = 0, len = codes.zoomIn.length; i < len; i++) {\n        keys[codes.zoomIn[i]] = zoomDelta;\n      }\n      for (i = 0, len = codes.zoomOut.length; i < len; i++) {\n        keys[codes.zoomOut[i]] = -zoomDelta;\n      }\n    },\n    _addHooks: function _addHooks() {\n      on(document, 'keydown', this._onKeyDown, this);\n    },\n    _removeHooks: function _removeHooks() {\n      off(document, 'keydown', this._onKeyDown, this);\n    },\n    _onKeyDown: function _onKeyDown(e) {\n      if (e.altKey || e.ctrlKey || e.metaKey) {\n        return;\n      }\n      var key = e.keyCode,\n        map = this._map,\n        offset;\n      if (key in this._panKeys) {\n        if (!map._panAnim || !map._panAnim._inProgress) {\n          offset = this._panKeys[key];\n          if (e.shiftKey) {\n            offset = toPoint(offset).multiplyBy(3);\n          }\n          if (map.options.maxBounds) {\n            offset = map._limitOffset(toPoint(offset), map.options.maxBounds);\n          }\n          if (map.options.worldCopyJump) {\n            var newLatLng = map.wrapLatLng(map.unproject(map.project(map.getCenter()).add(offset)));\n            map.panTo(newLatLng);\n          } else {\n            map.panBy(offset);\n          }\n        }\n      } else if (key in this._zoomKeys) {\n        map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);\n      } else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {\n        map.closePopup();\n      } else {\n        return;\n      }\n      stop(e);\n    }\n  });\n\n  // @section Handlers\n  // @section Handlers\n  // @property keyboard: Handler\n  // Keyboard navigation handler.\n  Map.addInitHook('addHandler', 'keyboard', Keyboard);\n\n  /*\n   * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n    // @section Mouse wheel options\n    // @option scrollWheelZoom: Boolean|String = true\n    // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,\n    // it will zoom to the center of the view regardless of where the mouse was.\n    scrollWheelZoom: true,\n    // @option wheelDebounceTime: Number = 40\n    // Limits the rate at which a wheel can fire (in milliseconds). By default\n    // user can't zoom via wheel more often than once per 40 ms.\n    wheelDebounceTime: 40,\n    // @option wheelPxPerZoomLevel: Number = 60\n    // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))\n    // mean a change of one full zoom level. Smaller values will make wheel-zooming\n    // faster (and vice versa).\n    wheelPxPerZoomLevel: 60\n  });\n  var ScrollWheelZoom = Handler.extend({\n    addHooks: function addHooks() {\n      on(this._map._container, 'wheel', this._onWheelScroll, this);\n      this._delta = 0;\n    },\n    removeHooks: function removeHooks() {\n      off(this._map._container, 'wheel', this._onWheelScroll, this);\n    },\n    _onWheelScroll: function _onWheelScroll(e) {\n      var delta = getWheelDelta(e);\n      var debounce = this._map.options.wheelDebounceTime;\n      this._delta += delta;\n      this._lastMousePos = this._map.mouseEventToContainerPoint(e);\n      if (!this._startTime) {\n        this._startTime = +new Date();\n      }\n      var left = Math.max(debounce - (+new Date() - this._startTime), 0);\n      clearTimeout(this._timer);\n      this._timer = setTimeout(bind(this._performZoom, this), left);\n      stop(e);\n    },\n    _performZoom: function _performZoom() {\n      var map = this._map,\n        zoom = map.getZoom(),\n        snap = this._map.options.zoomSnap || 0;\n      map._stop(); // stop panning and fly animations if any\n\n      // map the delta with a sigmoid function to -4..4 range leaning on -1..1\n      var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),\n        d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,\n        d4 = snap ? Math.ceil(d3 / snap) * snap : d3,\n        delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;\n      this._delta = 0;\n      this._startTime = null;\n      if (!delta) {\n        return;\n      }\n      if (map.options.scrollWheelZoom === 'center') {\n        map.setZoom(zoom + delta);\n      } else {\n        map.setZoomAround(this._lastMousePos, zoom + delta);\n      }\n    }\n  });\n\n  // @section Handlers\n  // @property scrollWheelZoom: Handler\n  // Scroll wheel zoom handler.\n  Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);\n\n  /*\n   * L.Map.TapHold is used to simulate `contextmenu` event on long hold,\n   * which otherwise is not fired by mobile Safari.\n   */\n\n  var tapHoldDelay = 600;\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n    // @section Touch interaction options\n    // @option tapHold: Boolean\n    // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.\n    tapHold: Browser.touchNative && Browser.safari && Browser.mobile,\n    // @option tapTolerance: Number = 15\n    // The max number of pixels a user can shift his finger during touch\n    // for it to be considered a valid tap.\n    tapTolerance: 15\n  });\n  var TapHold = Handler.extend({\n    addHooks: function addHooks() {\n      on(this._map._container, 'touchstart', this._onDown, this);\n    },\n    removeHooks: function removeHooks() {\n      off(this._map._container, 'touchstart', this._onDown, this);\n    },\n    _onDown: function _onDown(e) {\n      clearTimeout(this._holdTimeout);\n      if (e.touches.length !== 1) {\n        return;\n      }\n      var first = e.touches[0];\n      this._startPos = this._newPos = new Point(first.clientX, first.clientY);\n      this._holdTimeout = setTimeout(bind(function () {\n        this._cancel();\n        if (!this._isTapValid()) {\n          return;\n        }\n\n        // prevent simulated mouse events https://w3c.github.io/touch-events/#mouse-events\n        on(document, 'touchend', preventDefault);\n        on(document, 'touchend touchcancel', this._cancelClickPrevent);\n        this._simulateEvent('contextmenu', first);\n      }, this), tapHoldDelay);\n      on(document, 'touchend touchcancel contextmenu', this._cancel, this);\n      on(document, 'touchmove', this._onMove, this);\n    },\n    _cancelClickPrevent: function cancelClickPrevent() {\n      off(document, 'touchend', preventDefault);\n      off(document, 'touchend touchcancel', cancelClickPrevent);\n    },\n    _cancel: function _cancel() {\n      clearTimeout(this._holdTimeout);\n      off(document, 'touchend touchcancel contextmenu', this._cancel, this);\n      off(document, 'touchmove', this._onMove, this);\n    },\n    _onMove: function _onMove(e) {\n      var first = e.touches[0];\n      this._newPos = new Point(first.clientX, first.clientY);\n    },\n    _isTapValid: function _isTapValid() {\n      return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n    },\n    _simulateEvent: function _simulateEvent(type, e) {\n      var simulatedEvent = new MouseEvent(type, {\n        bubbles: true,\n        cancelable: true,\n        view: window,\n        // detail: 1,\n        screenX: e.screenX,\n        screenY: e.screenY,\n        clientX: e.clientX,\n        clientY: e.clientY\n        // button: 2,\n        // buttons: 2\n      });\n      simulatedEvent._simulated = true;\n      e.target.dispatchEvent(simulatedEvent);\n    }\n  });\n\n  // @section Handlers\n  // @property tapHold: Handler\n  // Long tap handler to simulate `contextmenu` event (useful in mobile Safari).\n  Map.addInitHook('addHandler', 'tapHold', TapHold);\n\n  /*\n   * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n    // @section Touch interaction options\n    // @option touchZoom: Boolean|String = *\n    // Whether the map can be zoomed by touch-dragging with two fingers. If\n    // passed `'center'`, it will zoom to the center of the view regardless of\n    // where the touch events (fingers) were. Enabled for touch-capable web\n    // browsers.\n    touchZoom: Browser.touch,\n    // @option bounceAtZoomLimits: Boolean = true\n    // Set it to false if you don't want the map to zoom beyond min/max zoom\n    // and then bounce back when pinch-zooming.\n    bounceAtZoomLimits: true\n  });\n  var TouchZoom = Handler.extend({\n    addHooks: function addHooks() {\n      addClass(this._map._container, 'leaflet-touch-zoom');\n      on(this._map._container, 'touchstart', this._onTouchStart, this);\n    },\n    removeHooks: function removeHooks() {\n      removeClass(this._map._container, 'leaflet-touch-zoom');\n      off(this._map._container, 'touchstart', this._onTouchStart, this);\n    },\n    _onTouchStart: function _onTouchStart(e) {\n      var map = this._map;\n      if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {\n        return;\n      }\n      var p1 = map.mouseEventToContainerPoint(e.touches[0]),\n        p2 = map.mouseEventToContainerPoint(e.touches[1]);\n      this._centerPoint = map.getSize()._divideBy(2);\n      this._startLatLng = map.containerPointToLatLng(this._centerPoint);\n      if (map.options.touchZoom !== 'center') {\n        this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));\n      }\n      this._startDist = p1.distanceTo(p2);\n      this._startZoom = map.getZoom();\n      this._moved = false;\n      this._zooming = true;\n      map._stop();\n      on(document, 'touchmove', this._onTouchMove, this);\n      on(document, 'touchend touchcancel', this._onTouchEnd, this);\n      preventDefault(e);\n    },\n    _onTouchMove: function _onTouchMove(e) {\n      if (!e.touches || e.touches.length !== 2 || !this._zooming) {\n        return;\n      }\n      var map = this._map,\n        p1 = map.mouseEventToContainerPoint(e.touches[0]),\n        p2 = map.mouseEventToContainerPoint(e.touches[1]),\n        scale = p1.distanceTo(p2) / this._startDist;\n      this._zoom = map.getScaleZoom(scale, this._startZoom);\n      if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1)) {\n        this._zoom = map._limitZoom(this._zoom);\n      }\n      if (map.options.touchZoom === 'center') {\n        this._center = this._startLatLng;\n        if (scale === 1) {\n          return;\n        }\n      } else {\n        // Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng\n        var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);\n        if (scale === 1 && delta.x === 0 && delta.y === 0) {\n          return;\n        }\n        this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);\n      }\n      if (!this._moved) {\n        map._moveStart(true, false);\n        this._moved = true;\n      }\n      cancelAnimFrame(this._animRequest);\n      var moveFn = bind(map._move, map, this._center, this._zoom, {\n        pinch: true,\n        round: false\n      }, undefined);\n      this._animRequest = requestAnimFrame(moveFn, this, true);\n      preventDefault(e);\n    },\n    _onTouchEnd: function _onTouchEnd() {\n      if (!this._moved || !this._zooming) {\n        this._zooming = false;\n        return;\n      }\n      this._zooming = false;\n      cancelAnimFrame(this._animRequest);\n      off(document, 'touchmove', this._onTouchMove, this);\n      off(document, 'touchend touchcancel', this._onTouchEnd, this);\n\n      // Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.\n      if (this._map.options.zoomAnimation) {\n        this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);\n      } else {\n        this._map._resetView(this._center, this._map._limitZoom(this._zoom));\n      }\n    }\n  });\n\n  // @section Handlers\n  // @property touchZoom: Handler\n  // Touch zoom handler.\n  Map.addInitHook('addHandler', 'touchZoom', TouchZoom);\n  Map.BoxZoom = BoxZoom;\n  Map.DoubleClickZoom = DoubleClickZoom;\n  Map.Drag = Drag;\n  Map.Keyboard = Keyboard;\n  Map.ScrollWheelZoom = ScrollWheelZoom;\n  Map.TapHold = TapHold;\n  Map.TouchZoom = TouchZoom;\n  exports.Bounds = Bounds;\n  exports.Browser = Browser;\n  exports.CRS = CRS;\n  exports.Canvas = Canvas;\n  exports.Circle = Circle;\n  exports.CircleMarker = CircleMarker;\n  exports.Class = Class;\n  exports.Control = Control;\n  exports.DivIcon = DivIcon;\n  exports.DivOverlay = DivOverlay;\n  exports.DomEvent = DomEvent;\n  exports.DomUtil = DomUtil;\n  exports.Draggable = Draggable;\n  exports.Evented = Evented;\n  exports.FeatureGroup = FeatureGroup;\n  exports.GeoJSON = GeoJSON;\n  exports.GridLayer = GridLayer;\n  exports.Handler = Handler;\n  exports.Icon = Icon;\n  exports.ImageOverlay = ImageOverlay;\n  exports.LatLng = LatLng;\n  exports.LatLngBounds = LatLngBounds;\n  exports.Layer = Layer;\n  exports.LayerGroup = LayerGroup;\n  exports.LineUtil = LineUtil;\n  exports.Map = Map;\n  exports.Marker = Marker;\n  exports.Mixin = Mixin;\n  exports.Path = Path;\n  exports.Point = Point;\n  exports.PolyUtil = PolyUtil;\n  exports.Polygon = Polygon;\n  exports.Polyline = Polyline;\n  exports.Popup = Popup;\n  exports.PosAnimation = PosAnimation;\n  exports.Projection = index;\n  exports.Rectangle = Rectangle;\n  exports.Renderer = Renderer;\n  exports.SVG = SVG;\n  exports.SVGOverlay = SVGOverlay;\n  exports.TileLayer = TileLayer;\n  exports.Tooltip = Tooltip;\n  exports.Transformation = Transformation;\n  exports.Util = Util;\n  exports.VideoOverlay = VideoOverlay;\n  exports.bind = bind;\n  exports.bounds = toBounds;\n  exports.canvas = canvas;\n  exports.circle = circle;\n  exports.circleMarker = circleMarker;\n  exports.control = control;\n  exports.divIcon = divIcon;\n  exports.extend = extend;\n  exports.featureGroup = featureGroup;\n  exports.geoJSON = geoJSON;\n  exports.geoJson = geoJson;\n  exports.gridLayer = gridLayer;\n  exports.icon = icon;\n  exports.imageOverlay = imageOverlay;\n  exports.latLng = toLatLng;\n  exports.latLngBounds = toLatLngBounds;\n  exports.layerGroup = layerGroup;\n  exports.map = createMap;\n  exports.marker = marker;\n  exports.point = toPoint;\n  exports.polygon = polygon;\n  exports.polyline = polyline;\n  exports.popup = popup;\n  exports.rectangle = rectangle;\n  exports.setOptions = setOptions;\n  exports.stamp = stamp;\n  exports.svg = svg;\n  exports.svgOverlay = svgOverlay;\n  exports.tileLayer = tileLayer;\n  exports.tooltip = tooltip;\n  exports.transformation = toTransformation;\n  exports.version = version;\n  exports.videoOverlay = videoOverlay;\n  var oldL = window.L;\n  exports.noConflict = function () {\n    window.L = oldL;\n    return this;\n  };\n  // Always export us to window global (see #2364)\n  window.L = exports;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvbGVhZmxldC1zcmMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztFQUFBOzs7Ozs7RUFNQTtFQUNBO0VBQ08sU0FBU0EsTUFBTUEsQ0FBQ0MsSUFBSSxFQUFFO0lBQzVCLElBQUlDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxHQUFHLEVBQUVDLEdBQUc7SUFFbEIsS0FBS0YsQ0FBQyxHQUFHLENBQUMsRUFBRUMsR0FBRyxHQUFHRSxTQUFTLENBQUNDLE1BQU0sRUFBRUosQ0FBQyxHQUFHQyxHQUFHLEVBQUVELENBQUMsRUFBRSxFQUFFO01BQ2pERSxHQUFHLEdBQUdDLFNBQVMsQ0FBQ0gsQ0FBQyxDQUFDO01BQ2xCLEtBQUtELENBQUMsSUFBSUcsR0FBRyxFQUFFO1FBQ2RKLElBQUksQ0FBQ0MsQ0FBQyxDQUFDLEdBQUdHLEdBQUcsQ0FBQ0gsQ0FBQyxDQUFDO01BQ25CO0lBQ0E7SUFDQyxPQUFPRCxJQUFJO0VBQ1o7O0VBRUE7RUFDQTtFQUNPLElBQUlPLFFBQU0sR0FBR0MsTUFBTSxDQUFDQyxNQUFNLElBQUssWUFBWTtJQUNqRCxTQUFTQyxDQUFDQSxDQUFBLEVBQUc7SUFDYixPQUFPLFVBQVVDLEtBQUssRUFBRTtNQUN2QkQsQ0FBQyxDQUFDRSxTQUFTLEdBQUdELEtBQUs7TUFDbkIsT0FBTyxJQUFJRCxDQUFDLEVBQUU7SUFDaEIsQ0FBRTtFQUNGLENBQUMsRUFBRzs7RUFFSjtFQUNBO0VBQ0E7RUFDTyxTQUFTRyxJQUFJQSxDQUFDQyxFQUFFLEVBQUVDLEdBQUcsRUFBRTtJQUM3QixJQUFJQyxLQUFLLEdBQUdDLEtBQUssQ0FBQ0wsU0FBUyxDQUFDSSxLQUFLO0lBRWpDLElBQUlGLEVBQUUsQ0FBQ0QsSUFBSSxFQUFFO01BQ1osT0FBT0MsRUFBRSxDQUFDRCxJQUFJLENBQUNLLEtBQUssQ0FBQ0osRUFBRSxFQUFFRSxLQUFLLENBQUNHLElBQUksQ0FBQ2QsU0FB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VSxDQUFDLElBQUksQ0FBQ3UrQixPQUFPLEVBQUUsSUFBSSxDQUFDenZCLElBQUksQ0FBQy9QLFVBQVUsQ0FBQyxJQUFJLENBQUNELEtBQUssQ0FBQyxDQUFDO01BQ3ZFO0lBQ0E7RUFDQSxDQUFDLENBQUM7O0VBRUY7RUFDQTtFQUNBO0VBQ0F4QixHQUFHLENBQUNuZCxXQUFXLENBQUMsWUFBWSxFQUFFLFdBQVcsRUFBRW1wRCxTQUFTLENBQUM7RUMvSHJEaHNDLEdBQUcsQ0FBQ29sQyxPQUFPLEdBQUdBLE9BQU87RUFFckJwbEMsR0FBRyxDQUFDb21DLGVBQWUsR0FBR0EsZUFBZTtFQUVyQ3BtQyxHQUFHLENBQUMybUMsSUFBSSxHQUFHQSxJQUFJO0VBRWYzbUMsR0FBRyxDQUFDeW9DLFFBQVEsR0FBR0EsUUFBUTtFQUV2QnpvQyxHQUFHLENBQUNvcUMsZUFBZSxHQUFHQSxlQUFlO0VBRXJDcHFDLEdBQUcsQ0FBQ2lyQyxPQUFPLEdBQUdBLE9BQU87RUFFckJqckMsR0FBRyxDQUFDZ3NDLFNBQVMsR0FBR0EsU0FBUyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2NvcmUvVXRpbC5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9jb3JlL0NsYXNzLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2NvcmUvRXZlbnRzLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2dlb21ldHJ5L1BvaW50LmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2dlb21ldHJ5L0JvdW5kcy5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9nZW8vTGF0TG5nQm91bmRzLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2dlby9MYXRMbmcuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvZ2VvL2Nycy9DUlMuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvZ2VvL2Nycy9DUlMuRWFydGguanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvci5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbi5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9nZW8vY3JzL0NSUy5FUFNHMzg1Ny5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci92ZWN0b3IvU1ZHLlV0aWwuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvY29yZS9Ccm93c2VyLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2RvbS9Eb21FdmVudC5Qb2ludGVyLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2RvbS9Eb21FdmVudC5Eb3VibGVUYXAuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvZG9tL0RvbVV0aWwuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvZG9tL0RvbUV2ZW50LmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2RvbS9Qb3NBbmltYXRpb24uanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvbWFwL01hcC5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9jb250cm9sL0NvbnRyb2wuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvY29udHJvbC9Db250cm9sLkxheWVycy5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9jb250cm9sL0NvbnRyb2wuWm9vbS5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9jb250cm9sL0NvbnRyb2wuU2NhbGUuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvY29udHJvbC9Db250cm9sLkF0dHJpYnV0aW9uLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2NvbnRyb2wvaW5kZXguanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvY29yZS9IYW5kbGVyLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2NvcmUvaW5kZXguanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvZG9tL0RyYWdnYWJsZS5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9nZW9tZXRyeS9Qb2x5VXRpbC5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9nZW9tZXRyeS9MaW5lVXRpbC5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9nZW8vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLkxvbkxhdC5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9nZW8vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLk1lcmNhdG9yLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2dlby9wcm9qZWN0aW9uL2luZGV4LmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2dlby9jcnMvQ1JTLkVQU0czMzk1LmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2dlby9jcnMvQ1JTLkVQU0c0MzI2LmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2dlby9jcnMvQ1JTLlNpbXBsZS5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9nZW8vY3JzL2luZGV4LmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL0xheWVyLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL0xheWVyR3JvdXAuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvbGF5ZXIvRmVhdHVyZUdyb3VwLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL21hcmtlci9JY29uLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL21hcmtlci9JY29uLkRlZmF1bHQuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvbGF5ZXIvbWFya2VyL01hcmtlci5EcmFnLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL21hcmtlci9NYXJrZXIuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvbGF5ZXIvdmVjdG9yL1BhdGguanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvbGF5ZXIvdmVjdG9yL0NpcmNsZU1hcmtlci5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci92ZWN0b3IvQ2lyY2xlLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL3ZlY3Rvci9Qb2x5bGluZS5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci92ZWN0b3IvUG9seWdvbi5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci9HZW9KU09OLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL0ltYWdlT3ZlcmxheS5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci9WaWRlb092ZXJsYXkuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvbGF5ZXIvU1ZHT3ZlcmxheS5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci9EaXZPdmVybGF5LmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL1BvcHVwLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL1Rvb2x0aXAuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvbGF5ZXIvbWFya2VyL0Rpdkljb24uanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvbGF5ZXIvbWFya2VyL2luZGV4LmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL3RpbGUvR3JpZExheWVyLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLldNUy5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci90aWxlL2luZGV4LmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL3ZlY3Rvci9SZW5kZXJlci5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci92ZWN0b3IvQ2FudmFzLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL3ZlY3Rvci9TVkcuVk1MLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL3ZlY3Rvci9TVkcuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvbGF5ZXIvdmVjdG9yL1JlbmRlcmVyLmdldFJlbmRlcmVyLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL3ZlY3Rvci9SZWN0YW5nbGUuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvbGF5ZXIvdmVjdG9yL2luZGV4LmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL2luZGV4LmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL21hcC9oYW5kbGVyL01hcC5Cb3hab29tLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL21hcC9oYW5kbGVyL01hcC5Eb3VibGVDbGlja1pvb20uanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvbWFwL2hhbmRsZXIvTWFwLkRyYWcuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvbWFwL2hhbmRsZXIvTWFwLktleWJvYXJkLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL21hcC9oYW5kbGVyL01hcC5TY3JvbGxXaGVlbFpvb20uanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvbWFwL2hhbmRsZXIvTWFwLlRhcEhvbGQuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvbWFwL2hhbmRsZXIvTWFwLlRvdWNoWm9vbS5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9tYXAvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQG5hbWVzcGFjZSBVdGlsXHJcbiAqXHJcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKi9cclxuXHJcbi8vIEBmdW5jdGlvbiBleHRlbmQoZGVzdDogT2JqZWN0LCBzcmM/OiBPYmplY3QpOiBPYmplY3RcclxuLy8gTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBgc3JjYCBvYmplY3QgKG9yIG11bHRpcGxlIG9iamVjdHMpIGludG8gYGRlc3RgIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgbGF0dGVyLiBIYXMgYW4gYEwuZXh0ZW5kYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChkZXN0KSB7XHJcblx0dmFyIGksIGosIGxlbiwgc3JjO1xyXG5cclxuXHRmb3IgKGogPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcclxuXHRcdHNyYyA9IGFyZ3VtZW50c1tqXTtcclxuXHRcdGZvciAoaSBpbiBzcmMpIHtcclxuXHRcdFx0ZGVzdFtpXSA9IHNyY1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGRlc3Q7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjcmVhdGUocHJvdG86IE9iamVjdCwgcHJvcGVydGllcz86IE9iamVjdCk6IE9iamVjdFxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbT2JqZWN0LmNyZWF0ZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZSlcclxuZXhwb3J0IHZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XHJcblx0ZnVuY3Rpb24gRigpIHt9XHJcblx0cmV0dXJuIGZ1bmN0aW9uIChwcm90bykge1xyXG5cdFx0Ri5wcm90b3R5cGUgPSBwcm90bztcclxuXHRcdHJldHVybiBuZXcgRigpO1xyXG5cdH07XHJcbn0pKCk7XHJcblxyXG4vLyBAZnVuY3Rpb24gYmluZChmbjogRnVuY3Rpb24sIOKApik6IEZ1bmN0aW9uXHJcbi8vIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gYm91bmQgdG8gdGhlIGFyZ3VtZW50cyBwYXNzZWQsIGxpa2UgW0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kKS5cclxuLy8gSGFzIGEgYEwuYmluZCgpYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIGJpbmQoZm4sIG9iaikge1xyXG5cdHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcclxuXHJcblx0aWYgKGZuLmJpbmQpIHtcclxuXHRcdHJldHVybiBmbi5iaW5kLmFwcGx5KGZuLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG5cdH1cclxuXHJcblx0dmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmxlbmd0aCA/IGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkgOiBhcmd1bWVudHMpO1xyXG5cdH07XHJcbn1cclxuXHJcbi8vIEBwcm9wZXJ0eSBsYXN0SWQ6IE51bWJlclxyXG4vLyBMYXN0IHVuaXF1ZSBJRCB1c2VkIGJ5IFtgc3RhbXAoKWBdKCN1dGlsLXN0YW1wKVxyXG5leHBvcnQgdmFyIGxhc3RJZCA9IDA7XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RhbXAob2JqOiBPYmplY3QpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgdW5pcXVlIElEIG9mIGFuIG9iamVjdCwgYXNzaWduaW5nIGl0IG9uZSBpZiBpdCBkb2Vzbid0IGhhdmUgaXQuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdGFtcChvYmopIHtcclxuXHRpZiAoISgnX2xlYWZsZXRfaWQnIGluIG9iaikpIHtcclxuXHRcdG9ialsnX2xlYWZsZXRfaWQnXSA9ICsrbGFzdElkO1xyXG5cdH1cclxuXHRyZXR1cm4gb2JqLl9sZWFmbGV0X2lkO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdGhyb3R0bGUoZm46IEZ1bmN0aW9uLCB0aW1lOiBOdW1iZXIsIGNvbnRleHQ6IE9iamVjdCk6IEZ1bmN0aW9uXHJcbi8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBleGVjdXRlcyBmdW5jdGlvbiBgZm5gIHdpdGggdGhlIGdpdmVuIHNjb3BlIGBjb250ZXh0YFxyXG4vLyAoc28gdGhhdCB0aGUgYHRoaXNgIGtleXdvcmQgcmVmZXJzIHRvIGBjb250ZXh0YCBpbnNpZGUgYGZuYCdzIGNvZGUpLiBUaGUgZnVuY3Rpb25cclxuLy8gYGZuYCB3aWxsIGJlIGNhbGxlZCBubyBtb3JlIHRoYW4gb25lIHRpbWUgcGVyIGdpdmVuIGFtb3VudCBvZiBgdGltZWAuIFRoZSBhcmd1bWVudHNcclxuLy8gcmVjZWl2ZWQgYnkgdGhlIGJvdW5kIGZ1bmN0aW9uIHdpbGwgYmUgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBiaW5kaW5nIHRoZVxyXG4vLyBmdW5jdGlvbiwgZm9sbG93ZWQgYnkgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBpbnZva2luZyB0aGUgYm91bmQgZnVuY3Rpb24uXHJcbi8vIEhhcyBhbiBgTC50aHJvdHRsZWAgc2hvcnRjdXQuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aHJvdHRsZShmbiwgdGltZSwgY29udGV4dCkge1xyXG5cdHZhciBsb2NrLCBhcmdzLCB3cmFwcGVyRm4sIGxhdGVyO1xyXG5cclxuXHRsYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIHJlc2V0IGxvY2sgYW5kIGNhbGwgaWYgcXVldWVkXHJcblx0XHRsb2NrID0gZmFsc2U7XHJcblx0XHRpZiAoYXJncykge1xyXG5cdFx0XHR3cmFwcGVyRm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblx0XHRcdGFyZ3MgPSBmYWxzZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHR3cmFwcGVyRm4gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAobG9jaykge1xyXG5cdFx0XHQvLyBjYWxsZWQgdG9vIHNvb24sIHF1ZXVlIHRvIGNhbGwgbGF0ZXJcclxuXHRcdFx0YXJncyA9IGFyZ3VtZW50cztcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBjYWxsIGFuZCBsb2NrIHVudGlsIGxhdGVyXHJcblx0XHRcdGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHNldFRpbWVvdXQobGF0ZXIsIHRpbWUpO1xyXG5cdFx0XHRsb2NrID0gdHJ1ZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gd3JhcHBlckZuO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gd3JhcE51bShudW06IE51bWJlciwgcmFuZ2U6IE51bWJlcltdLCBpbmNsdWRlTWF4PzogQm9vbGVhbik6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgYG51bWAgbW9kdWxvIGByYW5nZWAgaW4gc3VjaCBhIHdheSBzbyBpdCBsaWVzIHdpdGhpblxyXG4vLyBgcmFuZ2VbMF1gIGFuZCBgcmFuZ2VbMV1gLiBUaGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSBhbHdheXMgc21hbGxlciB0aGFuXHJcbi8vIGByYW5nZVsxXWAgdW5sZXNzIGBpbmNsdWRlTWF4YCBpcyBzZXQgdG8gYHRydWVgLlxyXG5leHBvcnQgZnVuY3Rpb24gd3JhcE51bSh4LCByYW5nZSwgaW5jbHVkZU1heCkge1xyXG5cdHZhciBtYXggPSByYW5nZVsxXSxcclxuXHQgICAgbWluID0gcmFuZ2VbMF0sXHJcblx0ICAgIGQgPSBtYXggLSBtaW47XHJcblx0cmV0dXJuIHggPT09IG1heCAmJiBpbmNsdWRlTWF4ID8geCA6ICgoeCAtIG1pbikgJSBkICsgZCkgJSBkICsgbWluO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZmFsc2VGbigpOiBGdW5jdGlvblxyXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggYWx3YXlzIHJldHVybnMgYGZhbHNlYC5cclxuZXhwb3J0IGZ1bmN0aW9uIGZhbHNlRm4oKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuLy8gQGZ1bmN0aW9uIGZvcm1hdE51bShudW06IE51bWJlciwgcHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCByb3VuZGVkIHdpdGggc3BlY2lmaWVkIGBwcmVjaXNpb25gLlxyXG4vLyBUaGUgZGVmYXVsdCBgcHJlY2lzaW9uYCB2YWx1ZSBpcyA2IGRlY2ltYWwgcGxhY2VzLlxyXG4vLyBgZmFsc2VgIGNhbiBiZSBwYXNzZWQgdG8gc2tpcCBhbnkgcHJvY2Vzc2luZyAoY2FuIGJlIHVzZWZ1bCB0byBhdm9pZCByb3VuZC1vZmYgZXJyb3JzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdE51bShudW0sIHByZWNpc2lvbikge1xyXG5cdGlmIChwcmVjaXNpb24gPT09IGZhbHNlKSB7IHJldHVybiBudW07IH1cclxuXHR2YXIgcG93ID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gNiA6IHByZWNpc2lvbik7XHJcblx0cmV0dXJuIE1hdGgucm91bmQobnVtICogcG93KSAvIHBvdztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRyaW0oc3RyOiBTdHJpbmcpOiBTdHJpbmdcclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW1N0cmluZy5wcm90b3R5cGUudHJpbV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL1RyaW0pXHJcbmV4cG9ydCBmdW5jdGlvbiB0cmltKHN0cikge1xyXG5cdHJldHVybiBzdHIudHJpbSA/IHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHI6IFN0cmluZyk6IFN0cmluZ1tdXHJcbi8vIFRyaW1zIGFuZCBzcGxpdHMgdGhlIHN0cmluZyBvbiB3aGl0ZXNwYWNlIGFuZCByZXR1cm5zIHRoZSBhcnJheSBvZiBwYXJ0cy5cclxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0V29yZHMoc3RyKSB7XHJcblx0cmV0dXJuIHRyaW0oc3RyKS5zcGxpdCgvXFxzKy8pO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmo6IE9iamVjdCwgb3B0aW9uczogT2JqZWN0KTogT2JqZWN0XHJcbi8vIE1lcmdlcyB0aGUgZ2l2ZW4gcHJvcGVydGllcyB0byB0aGUgYG9wdGlvbnNgIG9mIHRoZSBgb2JqYCBvYmplY3QsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIG9wdGlvbnMuIFNlZSBgQ2xhc3Mgb3B0aW9uc2AuIEhhcyBhbiBgTC5zZXRPcHRpb25zYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldE9wdGlvbnMob2JqLCBvcHRpb25zKSB7XHJcblx0aWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCAnb3B0aW9ucycpKSB7XHJcblx0XHRvYmoub3B0aW9ucyA9IG9iai5vcHRpb25zID8gY3JlYXRlKG9iai5vcHRpb25zKSA6IHt9O1xyXG5cdH1cclxuXHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuXHRcdG9iai5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcclxuXHR9XHJcblx0cmV0dXJuIG9iai5vcHRpb25zO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0UGFyYW1TdHJpbmcob2JqOiBPYmplY3QsIGV4aXN0aW5nVXJsPzogU3RyaW5nLCB1cHBlcmNhc2U/OiBCb29sZWFuKTogU3RyaW5nXHJcbi8vIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgcGFyYW1ldGVyIFVSTCBzdHJpbmcsIGUuZy4gYHthOiBcImZvb1wiLCBiOiBcImJhclwifWBcclxuLy8gdHJhbnNsYXRlcyB0byBgJz9hPWZvbyZiPWJhcidgLiBJZiBgZXhpc3RpbmdVcmxgIGlzIHNldCwgdGhlIHBhcmFtZXRlcnMgd2lsbFxyXG4vLyBiZSBhcHBlbmRlZCBhdCB0aGUgZW5kLiBJZiBgdXBwZXJjYXNlYCBpcyBgdHJ1ZWAsIHRoZSBwYXJhbWV0ZXIgbmFtZXMgd2lsbFxyXG4vLyBiZSB1cHBlcmNhc2VkIChlLmcuIGAnP0E9Zm9vJkI9YmFyJ2ApXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJhbVN0cmluZyhvYmosIGV4aXN0aW5nVXJsLCB1cHBlcmNhc2UpIHtcclxuXHR2YXIgcGFyYW1zID0gW107XHJcblx0Zm9yICh2YXIgaSBpbiBvYmopIHtcclxuXHRcdHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudCh1cHBlcmNhc2UgPyBpLnRvVXBwZXJDYXNlKCkgOiBpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pKTtcclxuXHR9XHJcblx0cmV0dXJuICgoIWV4aXN0aW5nVXJsIHx8IGV4aXN0aW5nVXJsLmluZGV4T2YoJz8nKSA9PT0gLTEpID8gJz8nIDogJyYnKSArIHBhcmFtcy5qb2luKCcmJyk7XHJcbn1cclxuXHJcbnZhciB0ZW1wbGF0ZVJlID0gL1xceyAqKFtcXHdfIC1dKykgKlxcfS9nO1xyXG5cclxuLy8gQGZ1bmN0aW9uIHRlbXBsYXRlKHN0cjogU3RyaW5nLCBkYXRhOiBPYmplY3QpOiBTdHJpbmdcclxuLy8gU2ltcGxlIHRlbXBsYXRpbmcgZmFjaWxpdHksIGFjY2VwdHMgYSB0ZW1wbGF0ZSBzdHJpbmcgb2YgdGhlIGZvcm0gYCdIZWxsbyB7YX0sIHtifSdgXHJcbi8vIGFuZCBhIGRhdGEgb2JqZWN0IGxpa2UgYHthOiAnZm9vJywgYjogJ2Jhcid9YCwgcmV0dXJucyBldmFsdWF0ZWQgc3RyaW5nXHJcbi8vIGAoJ0hlbGxvIGZvbywgYmFyJylgLiBZb3UgY2FuIGFsc28gc3BlY2lmeSBmdW5jdGlvbnMgaW5zdGVhZCBvZiBzdHJpbmdzIGZvclxyXG4vLyBkYXRhIHZhbHVlcyDigJQgdGhleSB3aWxsIGJlIGV2YWx1YXRlZCBwYXNzaW5nIGBkYXRhYCBhcyBhbiBhcmd1bWVudC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlKHN0ciwgZGF0YSkge1xyXG5cdHJldHVybiBzdHIucmVwbGFjZSh0ZW1wbGF0ZVJlLCBmdW5jdGlvbiAoc3RyLCBrZXkpIHtcclxuXHRcdHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcclxuXHJcblx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbHVlIHByb3ZpZGVkIGZvciB2YXJpYWJsZSAnICsgc3RyKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHR2YWx1ZSA9IHZhbHVlKGRhdGEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH0pO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gaXNBcnJheShvYmopOiBCb29sZWFuXHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5pc0FycmF5XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5KVxyXG5leHBvcnQgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcclxuXHRyZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nKTtcclxufTtcclxuXHJcbi8vIEBmdW5jdGlvbiBpbmRleE9mKGFycmF5OiBBcnJheSwgZWw6IE9iamVjdCk6IE51bWJlclxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbQXJyYXkucHJvdG90eXBlLmluZGV4T2ZdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2YpXHJcbmV4cG9ydCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCBlbCkge1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChhcnJheVtpXSA9PT0gZWwpIHsgcmV0dXJuIGk7IH1cclxuXHR9XHJcblx0cmV0dXJuIC0xO1xyXG59XHJcblxyXG4vLyBAcHJvcGVydHkgZW1wdHlJbWFnZVVybDogU3RyaW5nXHJcbi8vIERhdGEgVVJJIHN0cmluZyBjb250YWluaW5nIGEgYmFzZTY0LWVuY29kZWQgZW1wdHkgR0lGIGltYWdlLlxyXG4vLyBVc2VkIGFzIGEgaGFjayB0byBmcmVlIG1lbW9yeSBmcm9tIHVudXNlZCBpbWFnZXMgb24gV2ViS2l0LXBvd2VyZWRcclxuLy8gbW9iaWxlIGRldmljZXMgKGJ5IHNldHRpbmcgaW1hZ2UgYHNyY2AgdG8gdGhpcyBzdHJpbmcpLlxyXG5leHBvcnQgdmFyIGVtcHR5SW1hZ2VVcmwgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBRC9BQ3dBQUFBQUFRQUJBQUFDQURzPSc7XHJcblxyXG4vLyBpbnNwaXJlZCBieSBodHRwczovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cclxuXHJcbmZ1bmN0aW9uIGdldFByZWZpeGVkKG5hbWUpIHtcclxuXHRyZXR1cm4gd2luZG93Wyd3ZWJraXQnICsgbmFtZV0gfHwgd2luZG93Wydtb3onICsgbmFtZV0gfHwgd2luZG93WydtcycgKyBuYW1lXTtcclxufVxyXG5cclxudmFyIGxhc3RUaW1lID0gMDtcclxuXHJcbi8vIGZhbGxiYWNrIGZvciBJRSA3LThcclxuZnVuY3Rpb24gdGltZW91dERlZmVyKGZuKSB7XHJcblx0dmFyIHRpbWUgPSArbmV3IERhdGUoKSxcclxuXHQgICAgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKHRpbWUgLSBsYXN0VGltZSkpO1xyXG5cclxuXHRsYXN0VGltZSA9IHRpbWUgKyB0aW1lVG9DYWxsO1xyXG5cdHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgdGltZVRvQ2FsbCk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgcmVxdWVzdEZuID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBnZXRQcmVmaXhlZCgnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHwgdGltZW91dERlZmVyO1xyXG5leHBvcnQgdmFyIGNhbmNlbEZuID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdDYW5jZWxBbmltYXRpb25GcmFtZScpIHx8XHJcblx0XHRnZXRQcmVmaXhlZCgnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHwgZnVuY3Rpb24gKGlkKSB7IHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpOyB9O1xyXG5cclxuLy8gQGZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0LCBpbW1lZGlhdGU/OiBCb29sZWFuKTogTnVtYmVyXHJcbi8vIFNjaGVkdWxlcyBgZm5gIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGJyb3dzZXIgcmVwYWludHMuIGBmbmAgaXMgYm91bmQgdG9cclxuLy8gYGNvbnRleHRgIGlmIGdpdmVuLiBXaGVuIGBpbW1lZGlhdGVgIGlzIHNldCwgYGZuYCBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgaWZcclxuLy8gdGhlIGJyb3dzZXIgZG9lc24ndCBoYXZlIG5hdGl2ZSBzdXBwb3J0IGZvclxyXG4vLyBbYHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L3JlcXVlc3RBbmltYXRpb25GcmFtZSksXHJcbi8vIG90aGVyd2lzZSBpdCdzIGRlbGF5ZWQuIFJldHVybnMgYSByZXF1ZXN0IElEIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxyXG5leHBvcnQgZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZShmbiwgY29udGV4dCwgaW1tZWRpYXRlKSB7XHJcblx0aWYgKGltbWVkaWF0ZSAmJiByZXF1ZXN0Rm4gPT09IHRpbWVvdXREZWZlcikge1xyXG5cdFx0Zm4uY2FsbChjb250ZXh0KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIHJlcXVlc3RGbi5jYWxsKHdpbmRvdywgYmluZChmbiwgY29udGV4dCkpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNhbmNlbEFuaW1GcmFtZShpZDogTnVtYmVyKTogdW5kZWZpbmVkXHJcbi8vIENhbmNlbHMgYSBwcmV2aW91cyBgcmVxdWVzdEFuaW1GcmFtZWAuIFNlZSBhbHNvIFt3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS93aW5kb3cvY2FuY2VsQW5pbWF0aW9uRnJhbWUpLlxyXG5leHBvcnQgZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKGlkKSB7XHJcblx0aWYgKGlkKSB7XHJcblx0XHRjYW5jZWxGbi5jYWxsKHdpbmRvdywgaWQpO1xyXG5cdH1cclxufVxyXG4iLCJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4vVXRpbCc7XHJcblxyXG4vLyBAY2xhc3MgQ2xhc3NcclxuLy8gQGFrYSBMLkNsYXNzXHJcblxyXG4vLyBAc2VjdGlvblxyXG4vLyBAdW5pbmhlcml0YWJsZVxyXG5cclxuLy8gVGhhbmtzIHRvIEpvaG4gUmVzaWcgYW5kIERlYW4gRWR3YXJkcyBmb3IgaW5zcGlyYXRpb24hXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQ2xhc3MoKSB7fVxyXG5cclxuQ2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBleHRlbmQocHJvcHM6IE9iamVjdCk6IEZ1bmN0aW9uXHJcblx0Ly8gW0V4dGVuZHMgdGhlIGN1cnJlbnQgY2xhc3NdKCNjbGFzcy1pbmhlcml0YW5jZSkgZ2l2ZW4gdGhlIHByb3BlcnRpZXMgdG8gYmUgaW5jbHVkZWQuXHJcblx0Ly8gUmV0dXJucyBhIEphdmFzY3JpcHQgZnVuY3Rpb24gdGhhdCBpcyBhIGNsYXNzIGNvbnN0cnVjdG9yICh0byBiZSBjYWxsZWQgd2l0aCBgbmV3YCkuXHJcblx0dmFyIE5ld0NsYXNzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzKTtcclxuXHJcblx0XHQvLyBjYWxsIHRoZSBjb25zdHJ1Y3RvclxyXG5cdFx0aWYgKHRoaXMuaW5pdGlhbGl6ZSkge1xyXG5cdFx0XHR0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjYWxsIGFsbCBjb25zdHJ1Y3RvciBob29rc1xyXG5cdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblx0fTtcclxuXHJcblx0dmFyIHBhcmVudFByb3RvID0gTmV3Q2xhc3MuX19zdXBlcl9fID0gdGhpcy5wcm90b3R5cGU7XHJcblxyXG5cdHZhciBwcm90byA9IFV0aWwuY3JlYXRlKHBhcmVudFByb3RvKTtcclxuXHRwcm90by5jb25zdHJ1Y3RvciA9IE5ld0NsYXNzO1xyXG5cclxuXHROZXdDbGFzcy5wcm90b3R5cGUgPSBwcm90bztcclxuXHJcblx0Ly8gaW5oZXJpdCBwYXJlbnQncyBzdGF0aWNzXHJcblx0Zm9yICh2YXIgaSBpbiB0aGlzKSB7XHJcblx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIGkpICYmIGkgIT09ICdwcm90b3R5cGUnICYmIGkgIT09ICdfX3N1cGVyX18nKSB7XHJcblx0XHRcdE5ld0NsYXNzW2ldID0gdGhpc1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIG1peCBzdGF0aWMgcHJvcGVydGllcyBpbnRvIHRoZSBjbGFzc1xyXG5cdGlmIChwcm9wcy5zdGF0aWNzKSB7XHJcblx0XHRVdGlsLmV4dGVuZChOZXdDbGFzcywgcHJvcHMuc3RhdGljcyk7XHJcblx0fVxyXG5cclxuXHQvLyBtaXggaW5jbHVkZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0aWYgKHByb3BzLmluY2x1ZGVzKSB7XHJcblx0XHRjaGVja0RlcHJlY2F0ZWRNaXhpbkV2ZW50cyhwcm9wcy5pbmNsdWRlcyk7XHJcblx0XHRVdGlsLmV4dGVuZC5hcHBseShudWxsLCBbcHJvdG9dLmNvbmNhdChwcm9wcy5pbmNsdWRlcykpO1xyXG5cdH1cclxuXHJcblx0Ly8gbWl4IGdpdmVuIHByb3BlcnRpZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0VXRpbC5leHRlbmQocHJvdG8sIHByb3BzKTtcclxuXHRkZWxldGUgcHJvdG8uc3RhdGljcztcclxuXHRkZWxldGUgcHJvdG8uaW5jbHVkZXM7XHJcblxyXG5cdC8vIG1lcmdlIG9wdGlvbnNcclxuXHRpZiAocHJvdG8ub3B0aW9ucykge1xyXG5cdFx0cHJvdG8ub3B0aW9ucyA9IHBhcmVudFByb3RvLm9wdGlvbnMgPyBVdGlsLmNyZWF0ZShwYXJlbnRQcm90by5vcHRpb25zKSA6IHt9O1xyXG5cdFx0VXRpbC5leHRlbmQocHJvdG8ub3B0aW9ucywgcHJvcHMub3B0aW9ucyk7XHJcblx0fVxyXG5cclxuXHRwcm90by5faW5pdEhvb2tzID0gW107XHJcblxyXG5cdC8vIGFkZCBtZXRob2QgZm9yIGNhbGxpbmcgYWxsIGhvb2tzXHJcblx0cHJvdG8uY2FsbEluaXRIb29rcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faW5pdEhvb2tzQ2FsbGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChwYXJlbnRQcm90by5jYWxsSW5pdEhvb2tzKSB7XHJcblx0XHRcdHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MuY2FsbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0SG9va3NDYWxsZWQgPSB0cnVlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm90by5faW5pdEhvb2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHByb3RvLl9pbml0SG9va3NbaV0uY2FsbCh0aGlzKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gTmV3Q2xhc3M7XHJcbn07XHJcblxyXG5cclxuLy8gQGZ1bmN0aW9uIGluY2x1ZGUocHJvcGVydGllczogT2JqZWN0KTogdGhpc1xyXG4vLyBbSW5jbHVkZXMgYSBtaXhpbl0oI2NsYXNzLWluY2x1ZGVzKSBpbnRvIHRoZSBjdXJyZW50IGNsYXNzLlxyXG5DbGFzcy5pbmNsdWRlID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcblx0dmFyIHBhcmVudE9wdGlvbnMgPSB0aGlzLnByb3RvdHlwZS5vcHRpb25zO1xyXG5cdFV0aWwuZXh0ZW5kKHRoaXMucHJvdG90eXBlLCBwcm9wcyk7XHJcblx0aWYgKHByb3BzLm9wdGlvbnMpIHtcclxuXHRcdHRoaXMucHJvdG90eXBlLm9wdGlvbnMgPSBwYXJlbnRPcHRpb25zO1xyXG5cdFx0dGhpcy5tZXJnZU9wdGlvbnMocHJvcHMub3B0aW9ucyk7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25zOiBPYmplY3QpOiB0aGlzXHJcbi8vIFtNZXJnZXMgYG9wdGlvbnNgXSgjY2xhc3Mtb3B0aW9ucykgaW50byB0aGUgZGVmYXVsdHMgb2YgdGhlIGNsYXNzLlxyXG5DbGFzcy5tZXJnZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFV0aWwuZXh0ZW5kKHRoaXMucHJvdG90eXBlLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZEluaXRIb29rKGZuOiBGdW5jdGlvbik6IHRoaXNcclxuLy8gQWRkcyBhIFtjb25zdHJ1Y3RvciBob29rXSgjY2xhc3MtY29uc3RydWN0b3ItaG9va3MpIHRvIHRoZSBjbGFzcy5cclxuQ2xhc3MuYWRkSW5pdEhvb2sgPSBmdW5jdGlvbiAoZm4pIHsgLy8gKEZ1bmN0aW9uKSB8fCAoU3RyaW5nLCBhcmdzLi4uKVxyXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcblx0dmFyIGluaXQgPSB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXNbZm5dLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cdH07XHJcblxyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgPSB0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzIHx8IFtdO1xyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MucHVzaChpbml0KTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbmZ1bmN0aW9uIGNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzKGluY2x1ZGVzKSB7XHJcblx0LyogZ2xvYmFsIEw6IHRydWUgKi9cclxuXHRpZiAodHlwZW9mIEwgPT09ICd1bmRlZmluZWQnIHx8ICFMIHx8ICFMLk1peGluKSB7IHJldHVybjsgfVxyXG5cclxuXHRpbmNsdWRlcyA9IFV0aWwuaXNBcnJheShpbmNsdWRlcykgPyBpbmNsdWRlcyA6IFtpbmNsdWRlc107XHJcblxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgaW5jbHVkZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChpbmNsdWRlc1tpXSA9PT0gTC5NaXhpbi5FdmVudHMpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCdEZXByZWNhdGVkIGluY2x1ZGUgb2YgTC5NaXhpbi5FdmVudHM6ICcgK1xyXG5cdFx0XHRcdCd0aGlzIHByb3BlcnR5IHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXMsICcgK1xyXG5cdFx0XHRcdCdwbGVhc2UgaW5oZXJpdCBmcm9tIEwuRXZlbnRlZCBpbnN0ZWFkLicsIG5ldyBFcnJvcigpLnN0YWNrKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwiaW1wb3J0IHtDbGFzc30gZnJvbSAnLi9DbGFzcyc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBFdmVudGVkXHJcbiAqIEBha2EgTC5FdmVudGVkXHJcbiAqIEBpbmhlcml0cyBDbGFzc1xyXG4gKlxyXG4gKiBBIHNldCBvZiBtZXRob2RzIHNoYXJlZCBiZXR3ZWVuIGV2ZW50LXBvd2VyZWQgY2xhc3NlcyAobGlrZSBgTWFwYCBhbmQgYE1hcmtlcmApLiBHZW5lcmFsbHksIGV2ZW50cyBhbGxvdyB5b3UgdG8gZXhlY3V0ZSBzb21lIGZ1bmN0aW9uIHdoZW4gc29tZXRoaW5nIGhhcHBlbnMgd2l0aCBhbiBvYmplY3QgKGUuZy4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBtYXAsIGNhdXNpbmcgdGhlIG1hcCB0byBmaXJlIGAnY2xpY2snYCBldmVudCkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcC5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAqIFx0YWxlcnQoZS5sYXRsbmcpO1xyXG4gKiB9ICk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBMZWFmbGV0IGRlYWxzIHdpdGggZXZlbnQgbGlzdGVuZXJzIGJ5IHJlZmVyZW5jZSwgc28gaWYgeW91IHdhbnQgdG8gYWRkIGEgbGlzdGVuZXIgYW5kIHRoZW4gcmVtb3ZlIGl0LCBkZWZpbmUgaXQgYXMgYSBmdW5jdGlvbjpcclxuICpcclxuICogYGBganNcclxuICogZnVuY3Rpb24gb25DbGljayhlKSB7IC4uLiB9XHJcbiAqXHJcbiAqIG1hcC5vbignY2xpY2snLCBvbkNsaWNrKTtcclxuICogbWFwLm9mZignY2xpY2snLCBvbkNsaWNrKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBFdmVudHMgPSB7XHJcblx0LyogQG1ldGhvZCBvbih0eXBlOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQgKiBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBldmVudCB0eXBlIG9mIHRoZSBvYmplY3QuIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0ZW5lciAob2JqZWN0IHRoZSB0aGlzIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWwgc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9uKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcblx0ICogQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5cdCAqL1xyXG5cdG9uOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0Ly8gdHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXHJcblx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0Ly8gd2UgZG9uJ3QgcHJvY2VzcyBzcGFjZS1zZXBhcmF0ZWQgZXZlbnRzIGhlcmUgZm9yIHBlcmZvcm1hbmNlO1xyXG5cdFx0XHRcdC8vIGl0J3MgYSBob3QgcGF0aCBzaW5jZSBMYXllciB1c2VzIHRoZSBvbihvYmopIHN5bnRheFxyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyB0eXBlcyBjYW4gYmUgYSBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIHdvcmRzXHJcblx0XHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvKiBAbWV0aG9kIG9mZih0eXBlOiBTdHJpbmcsIGZuPzogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXIgZnVuY3Rpb24uIElmIG5vIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgaXQgd2lsbCByZW1vdmUgYWxsIHRoZSBsaXN0ZW5lcnMgb2YgdGhhdCBwYXJ0aWN1bGFyIGV2ZW50IGZyb20gdGhlIG9iamVjdC4gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBgb25gLCB5b3UgbXVzdCBwYXNzIHRoZSBzYW1lIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb2ZmKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvZmY6IHRoaXNcclxuXHQgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgdG8gYWxsIGV2ZW50cyBvbiB0aGUgb2JqZWN0LiBUaGlzIGluY2x1ZGVzIGltcGxpY2l0bHkgYXR0YWNoZWQgZXZlbnRzLlxyXG5cdCAqL1xyXG5cdG9mZjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGlmIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50c1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0dGhpcy5fb2ZmKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0eXBlcyA9IFV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHR2YXIgcmVtb3ZlQWxsID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMTtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0aWYgKHJlbW92ZUFsbCkge1xyXG5cdFx0XHRcdFx0dGhpcy5fb2ZmKHR5cGVzW2ldKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5fb2ZmKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gYXR0YWNoIGxpc3RlbmVyICh3aXRob3V0IHN5bnRhY3RpYyBzdWdhciBub3cpXHJcblx0X29uOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQsIF9vbmNlKSB7XHJcblx0XHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdGNvbnNvbGUud2Fybignd3JvbmcgbGlzdGVuZXIgdHlwZTogJyArIHR5cGVvZiBmbik7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjaGVjayBpZiBmbiBhbHJlYWR5IHRoZXJlXHJcblx0XHRpZiAodGhpcy5fbGlzdGVucyh0eXBlLCBmbiwgY29udGV4dCkgIT09IGZhbHNlKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG5cdFx0XHQvLyBMZXNzIG1lbW9yeSBmb290cHJpbnQuXHJcblx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5ld0xpc3RlbmVyID0ge2ZuOiBmbiwgY3R4OiBjb250ZXh0fTtcclxuXHRcdGlmIChfb25jZSkge1xyXG5cdFx0XHRuZXdMaXN0ZW5lci5vbmNlID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XHJcblx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSB0aGlzLl9ldmVudHNbdHlwZV0gfHwgW107XHJcblx0XHR0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChuZXdMaXN0ZW5lcik7XHJcblx0fSxcclxuXHJcblx0X29mZjogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzLFxyXG5cdFx0ICAgIGksXHJcblx0XHQgICAgbGVuO1xyXG5cclxuXHRcdGlmICghdGhpcy5fZXZlbnRzKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRpZiAoIWxpc3RlbmVycykge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHsgLy8gcmVtb3ZlIGFsbFxyXG5cdFx0XHRpZiAodGhpcy5fZmlyaW5nQ291bnQpIHtcclxuXHRcdFx0XHQvLyBTZXQgYWxsIHJlbW92ZWQgbGlzdGVuZXJzIHRvIG5vb3BcclxuXHRcdFx0XHQvLyBzbyB0aGV5IGFyZSBub3QgY2FsbGVkIGlmIHJlbW92ZSBoYXBwZW5zIGluIGZpcmVcclxuXHRcdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRcdGxpc3RlbmVyc1tpXS5mbiA9IFV0aWwuZmFsc2VGbjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBmb3IgYSB0eXBlIGlmIGZ1bmN0aW9uIGlzbid0IHNwZWNpZmllZFxyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oJ3dyb25nIGxpc3RlbmVyIHR5cGU6ICcgKyB0eXBlb2YgZm4pO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZmluZCBmbiBhbmQgcmVtb3ZlIGl0XHJcblx0XHR2YXIgaW5kZXggPSB0aGlzLl9saXN0ZW5zKHR5cGUsIGZuLCBjb250ZXh0KTtcclxuXHRcdGlmIChpbmRleCAhPT0gZmFsc2UpIHtcclxuXHRcdFx0dmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2luZGV4XTtcclxuXHRcdFx0aWYgKHRoaXMuX2ZpcmluZ0NvdW50KSB7XHJcblx0XHRcdFx0Ly8gc2V0IHRoZSByZW1vdmVkIGxpc3RlbmVyIHRvIG5vb3Agc28gdGhhdCdzIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG5cdFx0XHRcdGxpc3RlbmVyLmZuID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdFx0XHQvKiBjb3B5IGFycmF5IGluIGNhc2UgZXZlbnRzIGFyZSBiZWluZyBmaXJlZCAqL1xyXG5cdFx0XHRcdHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmlyZSh0eXBlOiBTdHJpbmcsIGRhdGE/OiBPYmplY3QsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gRmlyZXMgYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLiBZb3UgY2FuIG9wdGlvbmFsbHkgcHJvdmlkZSBhIGRhdGFcclxuXHQvLyBvYmplY3Qg4oCUIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgbGlzdGVuZXIgZnVuY3Rpb24gd2lsbCBjb250YWluIGl0c1xyXG5cdC8vIHByb3BlcnRpZXMuIFRoZSBldmVudCBjYW4gb3B0aW9uYWxseSBiZSBwcm9wYWdhdGVkIHRvIGV2ZW50IHBhcmVudHMuXHJcblx0ZmlyZTogZnVuY3Rpb24gKHR5cGUsIGRhdGEsIHByb3BhZ2F0ZSkge1xyXG5cdFx0aWYgKCF0aGlzLmxpc3RlbnModHlwZSwgcHJvcGFnYXRlKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBldmVudCA9IFV0aWwuZXh0ZW5kKHt9LCBkYXRhLCB7XHJcblx0XHRcdHR5cGU6IHR5cGUsXHJcblx0XHRcdHRhcmdldDogdGhpcyxcclxuXHRcdFx0c291cmNlVGFyZ2V0OiBkYXRhICYmIGRhdGEuc291cmNlVGFyZ2V0IHx8IHRoaXNcclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9ldmVudHMpIHtcclxuXHRcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdFx0aWYgKGxpc3RlbmVycykge1xyXG5cdFx0XHRcdHRoaXMuX2ZpcmluZ0NvdW50ID0gKHRoaXMuX2ZpcmluZ0NvdW50ICsgMSkgfHwgMTtcclxuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgbCA9IGxpc3RlbmVyc1tpXTtcclxuXHRcdFx0XHRcdC8vIG9mZiBvdmVyd3JpdGVzIGwuZm4sIHNvIHdlIG5lZWQgdG8gY29weSBmbiB0byBhIHZhclxyXG5cdFx0XHRcdFx0dmFyIGZuID0gbC5mbjtcclxuXHRcdFx0XHRcdGlmIChsLm9uY2UpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5vZmYodHlwZSwgZm4sIGwuY3R4KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGZuLmNhbGwobC5jdHggfHwgdGhpcywgZXZlbnQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5fZmlyaW5nQ291bnQtLTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuXHRcdFx0Ly8gcHJvcGFnYXRlIHRoZSBldmVudCB0byBwYXJlbnRzIChzZXQgd2l0aCBhZGRFdmVudFBhcmVudClcclxuXHRcdFx0dGhpcy5fcHJvcGFnYXRlRXZlbnQoZXZlbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGlzdGVucyh0eXBlOiBTdHJpbmcsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiBCb29sZWFuXHJcblx0Ly8gQG1ldGhvZCBsaXN0ZW5zKHR5cGU6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0LCBwcm9wYWdhdGU/OiBCb29sZWFuKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIGEgcGFydGljdWxhciBldmVudCB0eXBlIGhhcyBhbnkgbGlzdGVuZXJzIGF0dGFjaGVkIHRvIGl0LlxyXG5cdC8vIFRoZSB2ZXJpZmljYXRpb24gY2FuIG9wdGlvbmFsbHkgYmUgcHJvcGFnYXRlZCwgaXQgd2lsbCByZXR1cm4gYHRydWVgIGlmIHBhcmVudHMgaGF2ZSB0aGUgbGlzdGVuZXIgYXR0YWNoZWQgdG8gaXQuXHJcblx0bGlzdGVuczogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0LCBwcm9wYWdhdGUpIHtcclxuXHRcdGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCdcInN0cmluZ1wiIHR5cGUgYXJndW1lbnQgZXhwZWN0ZWQnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyB3ZSBkb24ndCBvdmVyd3JpdGUgdGhlIGlucHV0IGBmbmAgdmFsdWUsIGJlY2F1c2Ugd2UgbmVlZCB0byB1c2UgaXQgZm9yIHByb3BhZ2F0aW9uXHJcblx0XHR2YXIgX2ZuID0gZm47XHJcblx0XHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdHByb3BhZ2F0ZSA9ICEhZm47XHJcblx0XHRcdF9mbiA9IHVuZGVmaW5lZDtcclxuXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdGlmIChsaXN0ZW5lcnMgJiYgbGlzdGVuZXJzLmxlbmd0aCkge1xyXG5cdFx0XHRpZiAodGhpcy5fbGlzdGVucyh0eXBlLCBfZm4sIGNvbnRleHQpICE9PSBmYWxzZSkge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG5cdFx0XHQvLyBhbHNvIGNoZWNrIHBhcmVudHMgZm9yIGxpc3RlbmVycyBpZiBldmVudCBwcm9wYWdhdGVzXHJcblx0XHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHNbaWRdLmxpc3RlbnModHlwZSwgZm4sIGNvbnRleHQsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8vIHJldHVybnMgdGhlIGluZGV4IChudW1iZXIpIG9yIGZhbHNlXHJcblx0X2xpc3RlbnM6IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdFx0aWYgKCF0aGlzLl9ldmVudHMpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV0gfHwgW107XHJcblx0XHRpZiAoIWZuKSB7XHJcblx0XHRcdHJldHVybiAhIWxpc3RlbmVycy5sZW5ndGg7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbnRleHQgPT09IHRoaXMpIHtcclxuXHRcdFx0Ly8gTGVzcyBtZW1vcnkgZm9vdHByaW50LlxyXG5cdFx0XHRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0aWYgKGxpc3RlbmVyc1tpXS5mbiA9PT0gZm4gJiYgbGlzdGVuZXJzW2ldLmN0eCA9PT0gY29udGV4dCkge1xyXG5cdFx0XHRcdHJldHVybiBpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb25jZSjigKYpOiB0aGlzXHJcblx0Ly8gQmVoYXZlcyBhcyBbYG9uKOKApilgXSgjZXZlbnRlZC1vbiksIGV4Y2VwdCB0aGUgbGlzdGVuZXIgd2lsbCBvbmx5IGdldCBmaXJlZCBvbmNlIGFuZCB0aGVuIHJlbW92ZWQuXHJcblx0b25jZTogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdC8vIHR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xyXG5cdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdC8vIHdlIGRvbid0IHByb2Nlc3Mgc3BhY2Utc2VwYXJhdGVkIGV2ZW50cyBoZXJlIGZvciBwZXJmb3JtYW5jZTtcclxuXHRcdFx0XHQvLyBpdCdzIGEgaG90IHBhdGggc2luY2UgTGF5ZXIgdXNlcyB0aGUgb24ob2JqKSBzeW50YXhcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlLCB0eXBlc1t0eXBlXSwgZm4sIHRydWUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCB3b3Jkc1xyXG5cdFx0XHR0eXBlcyA9IFV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlc1tpXSwgZm4sIGNvbnRleHQsIHRydWUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRFdmVudFBhcmVudChvYmo6IEV2ZW50ZWQpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBldmVudCBwYXJlbnQgLSBhbiBgRXZlbnRlZGAgdGhhdCB3aWxsIHJlY2VpdmUgcHJvcGFnYXRlZCBldmVudHNcclxuXHRhZGRFdmVudFBhcmVudDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dGhpcy5fZXZlbnRQYXJlbnRzID0gdGhpcy5fZXZlbnRQYXJlbnRzIHx8IHt9O1xyXG5cdFx0dGhpcy5fZXZlbnRQYXJlbnRzW1V0aWwuc3RhbXAob2JqKV0gPSBvYmo7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUV2ZW50UGFyZW50KG9iajogRXZlbnRlZCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFuIGV2ZW50IHBhcmVudCwgc28gaXQgd2lsbCBzdG9wIHJlY2VpdmluZyBwcm9wYWdhdGVkIGV2ZW50c1xyXG5cdHJlbW92ZUV2ZW50UGFyZW50OiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudFBhcmVudHNbVXRpbC5zdGFtcChvYmopXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9wcm9wYWdhdGVFdmVudDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHR0aGlzLl9ldmVudFBhcmVudHNbaWRdLmZpcmUoZS50eXBlLCBVdGlsLmV4dGVuZCh7XHJcblx0XHRcdFx0bGF5ZXI6IGUudGFyZ2V0LFxyXG5cdFx0XHRcdHByb3BhZ2F0ZWRGcm9tOiBlLnRhcmdldFxyXG5cdFx0XHR9LCBlKSwgdHJ1ZSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuLy8gYWxpYXNlczsgd2Ugc2hvdWxkIGRpdGNoIHRob3NlIGV2ZW50dWFsbHlcclxuXHJcbi8vIEBtZXRob2QgYWRkRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb24o4oCmKWBdKCNldmVudGVkLW9uKVxyXG5FdmVudHMuYWRkRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5vbjtcclxuXHJcbi8vIEBtZXRob2QgcmVtb3ZlRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb2ZmKOKApilgXSgjZXZlbnRlZC1vZmYpXHJcblxyXG4vLyBAbWV0aG9kIGNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9mZigpYF0oI2V2ZW50ZWQtb2ZmKVxyXG5FdmVudHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5jbGVhckFsbEV2ZW50TGlzdGVuZXJzID0gRXZlbnRzLm9mZjtcclxuXHJcbi8vIEBtZXRob2QgYWRkT25lVGltZUV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9uY2Uo4oCmKWBdKCNldmVudGVkLW9uY2UpXHJcbkV2ZW50cy5hZGRPbmVUaW1lRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5vbmNlO1xyXG5cclxuLy8gQG1ldGhvZCBmaXJlRXZlbnQo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYGZpcmUo4oCmKWBdKCNldmVudGVkLWZpcmUpXHJcbkV2ZW50cy5maXJlRXZlbnQgPSBFdmVudHMuZmlyZTtcclxuXHJcbi8vIEBtZXRob2QgaGFzRXZlbnRMaXN0ZW5lcnMo4oCmKTogQm9vbGVhblxyXG4vLyBBbGlhcyB0byBbYGxpc3RlbnMo4oCmKWBdKCNldmVudGVkLWxpc3RlbnMpXHJcbkV2ZW50cy5oYXNFdmVudExpc3RlbmVycyA9IEV2ZW50cy5saXN0ZW5zO1xyXG5cclxuZXhwb3J0IHZhciBFdmVudGVkID0gQ2xhc3MuZXh0ZW5kKEV2ZW50cyk7XHJcbiIsImltcG9ydCB7aXNBcnJheSwgZm9ybWF0TnVtfSBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFBvaW50XHJcbiAqIEBha2EgTC5Qb2ludFxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgcG9pbnQgd2l0aCBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyBpbiBwaXhlbHMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwb2ludCA9IEwucG9pbnQoMjAwLCAzMDApO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyBhbmQgb3B0aW9ucyB0aGF0IGFjY2VwdCBgUG9pbnRgIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlc2UgbGluZXMgYXJlIGVxdWl2YWxlbnQ6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcC5wYW5CeShbMjAwLCAzMDBdKTtcclxuICogbWFwLnBhbkJ5KEwucG9pbnQoMjAwLCAzMDApKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgUG9pbnRgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gUG9pbnQoeCwgeSwgcm91bmQpIHtcclxuXHQvLyBAcHJvcGVydHkgeDogTnVtYmVyOyBUaGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XHJcblx0dGhpcy54ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh4KSA6IHgpO1xyXG5cdC8vIEBwcm9wZXJ0eSB5OiBOdW1iZXI7IFRoZSBgeWAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcclxuXHR0aGlzLnkgPSAocm91bmQgPyBNYXRoLnJvdW5kKHkpIDogeSk7XHJcbn1cclxuXHJcbnZhciB0cnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gKHYpIHtcclxuXHRyZXR1cm4gdiA+IDAgPyBNYXRoLmZsb29yKHYpIDogTWF0aC5jZWlsKHYpO1xyXG59O1xyXG5cclxuUG9pbnQucHJvdG90eXBlID0ge1xyXG5cclxuXHQvLyBAbWV0aG9kIGNsb25lKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkKG90aGVyUG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYWRkaXRpb24gb2YgdGhlIGN1cnJlbnQgYW5kIHRoZSBnaXZlbiBwb2ludHMuXHJcblx0YWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdC8vIG5vbi1kZXN0cnVjdGl2ZSwgcmV0dXJucyBhIG5ldyBwb2ludFxyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fYWRkKHRvUG9pbnQocG9pbnQpKTtcclxuXHR9LFxyXG5cclxuXHRfYWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdC8vIGRlc3RydWN0aXZlLCB1c2VkIGRpcmVjdGx5IGZvciBwZXJmb3JtYW5jZSBpbiBzaXR1YXRpb25zIHdoZXJlIGl0J3Mgc2FmZSB0byBtb2RpZnkgZXhpc3RpbmcgcG9pbnRcclxuXHRcdHRoaXMueCArPSBwb2ludC54O1xyXG5cdFx0dGhpcy55ICs9IHBvaW50Lnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHN1YnRyYWN0KG90aGVyUG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2Ygc3VidHJhY3Rpb24gb2YgdGhlIGdpdmVuIHBvaW50IGZyb20gdGhlIGN1cnJlbnQuXHJcblx0c3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fc3VidHJhY3QodG9Qb2ludChwb2ludCkpO1xyXG5cdH0sXHJcblxyXG5cdF9zdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR0aGlzLnggLT0gcG9pbnQueDtcclxuXHRcdHRoaXMueSAtPSBwb2ludC55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXZpZGVCeShudW06IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IHRoZSBnaXZlbiBudW1iZXIuXHJcblx0ZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2RpdmlkZUJ5KG51bSk7XHJcblx0fSxcclxuXHJcblx0X2RpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHR0aGlzLnggLz0gbnVtO1xyXG5cdFx0dGhpcy55IC89IG51bTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbXVsdGlwbHlCeShudW06IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIG11bHRpcGxpY2F0aW9uIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IHRoZSBnaXZlbiBudW1iZXIuXHJcblx0bXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fbXVsdGlwbHlCeShudW0pO1xyXG5cdH0sXHJcblxyXG5cdF9tdWx0aXBseUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHR0aGlzLnggKj0gbnVtO1xyXG5cdFx0dGhpcy55ICo9IG51bTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG5cdC8vIE11bHRpcGx5IGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgY3VycmVudCBwb2ludCBieSBlYWNoIGNvb3JkaW5hdGUgb2ZcclxuXHQvLyBgc2NhbGVgLiBJbiBsaW5lYXIgYWxnZWJyYSB0ZXJtcywgbXVsdGlwbHkgdGhlIHBvaW50IGJ5IHRoZVxyXG5cdC8vIFtzY2FsaW5nIG1hdHJpeF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2NhbGluZ18lMjhnZW9tZXRyeSUyOSNNYXRyaXhfcmVwcmVzZW50YXRpb24pXHJcblx0Ly8gZGVmaW5lZCBieSBgc2NhbGVgLlxyXG5cdHNjYWxlQnk6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKiBwb2ludC54LCB0aGlzLnkgKiBwb2ludC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVuc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEludmVyc2Ugb2YgYHNjYWxlQnlgLiBEaXZpZGUgZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5XHJcblx0Ly8gZWFjaCBjb29yZGluYXRlIG9mIGBzY2FsZWAuXHJcblx0dW5zY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54IC8gcG9pbnQueCwgdGhpcy55IC8gcG9pbnQueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByb3VuZCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggcm91bmRlZCBjb29yZGluYXRlcy5cclxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTtcclxuXHR9LFxyXG5cclxuXHRfcm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmxvb3IoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGZsb29yZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgZG93bikuXHJcblx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2Zsb29yKCk7XHJcblx0fSxcclxuXHJcblx0X2Zsb29yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNlaWwoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGNlaWxlZCBjb29yZGluYXRlcyAocm91bmRlZCB1cCkuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fY2VpbCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jZWlsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0cnVuYygpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggdHJ1bmNhdGVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIHRvd2FyZHMgemVybykuXHJcblx0dHJ1bmM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3RydW5jKCk7XHJcblx0fSxcclxuXHJcblx0X3RydW5jOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSB0cnVuYyh0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gdHJ1bmModGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2VUbyhvdGhlclBvaW50OiBQb2ludCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGNhcnRlc2lhbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHR2YXIgeCA9IHBvaW50LnggLSB0aGlzLngsXHJcblx0XHQgICAgeSA9IHBvaW50LnkgLSB0aGlzLnk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gcG9pbnQgaGFzIHRoZSBzYW1lIGNvb3JkaW5hdGVzLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHJldHVybiBwb2ludC54ID09PSB0aGlzLnggJiZcclxuXHRcdCAgICAgICBwb2ludC55ID09PSB0aGlzLnk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGNvb3JkaW5hdGVzIG9mIHRoZSBnaXZlbiBwb2ludCBhcmUgbGVzcyB0aGFuIHRoZSBjb3JyZXNwb25kaW5nIGN1cnJlbnQgcG9pbnQgY29vcmRpbmF0ZXMgKGluIGFic29sdXRlIHZhbHVlcykuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMocG9pbnQueCkgPD0gTWF0aC5hYnModGhpcy54KSAmJlxyXG5cdFx0ICAgICAgIE1hdGguYWJzKHBvaW50LnkpIDw9IE1hdGguYWJzKHRoaXMueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b1N0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gJ1BvaW50KCcgK1xyXG5cdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy54KSArICcsICcgK1xyXG5cdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy55KSArICcpJztcclxuXHR9XHJcbn07XHJcblxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KHg6IE51bWJlciwgeTogTnVtYmVyLCByb3VuZD86IEJvb2xlYW4pXHJcbi8vIENyZWF0ZXMgYSBQb2ludCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMuIElmIG9wdGlvbmFsIGByb3VuZGAgaXMgc2V0IHRvIHRydWUsIHJvdW5kcyB0aGUgYHhgIGFuZCBgeWAgdmFsdWVzLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBOdW1iZXJbXSlcclxuLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW3gsIHldYCBpbnN0ZWFkLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBPYmplY3QpXHJcbi8vIEV4cGVjdHMgYSBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHt4OiBOdW1iZXIsIHk6IE51bWJlcn1gIGluc3RlYWQuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b1BvaW50KHgsIHksIHJvdW5kKSB7XHJcblx0aWYgKHggaW5zdGFuY2VvZiBQb2ludCkge1xyXG5cdFx0cmV0dXJuIHg7XHJcblx0fVxyXG5cdGlmIChpc0FycmF5KHgpKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHhbMF0sIHhbMV0pO1xyXG5cdH1cclxuXHRpZiAoeCA9PT0gdW5kZWZpbmVkIHx8IHggPT09IG51bGwpIHtcclxuXHRcdHJldHVybiB4O1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmICd4JyBpbiB4ICYmICd5JyBpbiB4KSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHgueCwgeC55KTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBQb2ludCh4LCB5LCByb3VuZCk7XHJcbn1cclxuIiwiaW1wb3J0IHtQb2ludCwgdG9Qb2ludH0gZnJvbSAnLi9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQm91bmRzXHJcbiAqIEBha2EgTC5Cb3VuZHNcclxuICpcclxuICogUmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGFyZWEgaW4gcGl4ZWwgY29vcmRpbmF0ZXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwMSA9IEwucG9pbnQoMTAsIDEwKSxcclxuICogcDIgPSBMLnBvaW50KDQwLCA2MCksXHJcbiAqIGJvdW5kcyA9IEwuYm91bmRzKHAxLCBwMik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IGBCb3VuZHNgIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBvdGhlckJvdW5kcy5pbnRlcnNlY3RzKFtbMTAsIDEwXSwgWzQwLCA2MF1dKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgQm91bmRzYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEJvdW5kcyhhLCBiKSB7XHJcblx0aWYgKCFhKSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgcG9pbnRzID0gYiA/IFthLCBiXSA6IGE7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHRoaXMuZXh0ZW5kKHBvaW50c1tpXSk7XHJcblx0fVxyXG59XHJcblxyXG5Cb3VuZHMucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKHBvaW50OiBQb2ludCk6IHRoaXNcclxuXHQvLyBFeHRlbmRzIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnQuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKG90aGVyQm91bmRzOiBCb3VuZHMpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gYm91bmRzXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgbWluMiwgbWF4MjtcclxuXHRcdGlmICghb2JqKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIFBvaW50IHx8IHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8ICd4JyBpbiBvYmopIHtcclxuXHRcdFx0bWluMiA9IG1heDIgPSB0b1BvaW50KG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSB0b0JvdW5kcyhvYmopO1xyXG5cdFx0XHRtaW4yID0gb2JqLm1pbjtcclxuXHRcdFx0bWF4MiA9IG9iai5tYXg7XHJcblxyXG5cdFx0XHRpZiAoIW1pbjIgfHwgIW1heDIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbWluOiBQb2ludFxyXG5cdFx0Ly8gVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cdFx0Ly8gQHByb3BlcnR5IG1heDogUG9pbnRcclxuXHRcdC8vIFRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcblx0XHRpZiAoIXRoaXMubWluICYmICF0aGlzLm1heCkge1xyXG5cdFx0XHR0aGlzLm1pbiA9IG1pbjIuY2xvbmUoKTtcclxuXHRcdFx0dGhpcy5tYXggPSBtYXgyLmNsb25lKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm1pbi54ID0gTWF0aC5taW4obWluMi54LCB0aGlzLm1pbi54KTtcclxuXHRcdFx0dGhpcy5tYXgueCA9IE1hdGgubWF4KG1heDIueCwgdGhpcy5tYXgueCk7XHJcblx0XHRcdHRoaXMubWluLnkgPSBNYXRoLm1pbihtaW4yLnksIHRoaXMubWluLnkpO1xyXG5cdFx0XHR0aGlzLm1heC55ID0gTWF0aC5tYXgobWF4Mi55LCB0aGlzLm1heC55KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKHJvdW5kPzogQm9vbGVhbik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAocm91bmQpIHtcclxuXHRcdHJldHVybiB0b1BvaW50KFxyXG5cdFx0ICAgICAgICAodGhpcy5taW4ueCArIHRoaXMubWF4LngpIC8gMixcclxuXHRcdCAgICAgICAgKHRoaXMubWluLnkgKyB0aGlzLm1heC55KSAvIDIsIHJvdW5kKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdHRvbUxlZnQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tbGVmdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldEJvdHRvbUxlZnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0b1BvaW50KHRoaXMubWluLngsIHRoaXMubWF4LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0VG9wUmlnaHQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSB0b3AtcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRUb3BSaWdodDogZnVuY3Rpb24gKCkgeyAvLyAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5tYXgueCwgdGhpcy5taW4ueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRUb3BMZWZ0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgdG9wLWxlZnQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWluYF0oI2JvdW5kcy1taW4pKS5cclxuXHRnZXRUb3BMZWZ0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5taW47IC8vIGxlZnQsIHRvcFxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm90dG9tUmlnaHQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWF4YF0oI2JvdW5kcy1tYXgpKS5cclxuXHRnZXRCb3R0b21SaWdodDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF4OyAvLyByaWdodCwgYm90dG9tXHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gYm91bmRzXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF4LnN1YnRyYWN0KHRoaXMubWluKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gb25lLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMocG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIFBvaW50KSB7XHJcblx0XHRcdG9iaiA9IHRvUG9pbnQob2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iaiA9IHRvQm91bmRzKG9iaik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIEJvdW5kcykge1xyXG5cdFx0XHRtaW4gPSBvYmoubWluO1xyXG5cdFx0XHRtYXggPSBvYmoubWF4O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWluID0gbWF4ID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAobWluLnggPj0gdGhpcy5taW4ueCkgJiZcclxuXHRcdCAgICAgICAobWF4LnggPD0gdGhpcy5tYXgueCkgJiZcclxuXHRcdCAgICAgICAobWluLnkgPj0gdGhpcy5taW4ueSkgJiZcclxuXHRcdCAgICAgICAobWF4LnkgPD0gdGhpcy5tYXgueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuXHQvLyBpbnRlcnNlY3QgaWYgdGhleSBoYXZlIGF0IGxlYXN0IG9uZSBwb2ludCBpbiBjb21tb24uXHJcblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcblx0XHRib3VuZHMgPSB0b0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuXHRcdCAgICB4SW50ZXJzZWN0cyA9IChtYXgyLnggPj0gbWluLngpICYmIChtaW4yLnggPD0gbWF4LngpLFxyXG5cdFx0ICAgIHlJbnRlcnNlY3RzID0gKG1heDIueSA+PSBtaW4ueSkgJiYgKG1pbjIueSA8PSBtYXgueSk7XHJcblxyXG5cdFx0cmV0dXJuIHhJbnRlcnNlY3RzICYmIHlJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuXHQvLyBvdmVybGFwIGlmIHRoZWlyIGludGVyc2VjdGlvbiBpcyBhbiBhcmVhLlxyXG5cdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cclxuXHRcdGJvdW5kcyA9IHRvQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMubWF4LFxyXG5cdFx0ICAgIG1pbjIgPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIHhPdmVybGFwcyA9IChtYXgyLnggPiBtaW4ueCkgJiYgKG1pbjIueCA8IG1heC54KSxcclxuXHRcdCAgICB5T3ZlcmxhcHMgPSAobWF4Mi55ID4gbWluLnkpICYmIChtaW4yLnkgPCBtYXgueSk7XHJcblxyXG5cdFx0cmV0dXJuIHhPdmVybGFwcyAmJiB5T3ZlcmxhcHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpc1ZhbGlkKCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYm91bmRzIGFyZSBwcm9wZXJseSBpbml0aWFsaXplZC5cclxuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISEodGhpcy5taW4gJiYgdGhpcy5tYXgpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAbWV0aG9kIHBhZChidWZmZXJSYXRpbzogTnVtYmVyKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyBib3VuZHMgY3JlYXRlZCBieSBleHRlbmRpbmcgb3IgcmV0cmFjdGluZyB0aGUgY3VycmVudCBib3VuZHMgYnkgYSBnaXZlbiByYXRpbyBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHQvLyBGb3IgZXhhbXBsZSwgYSByYXRpbyBvZiAwLjUgZXh0ZW5kcyB0aGUgYm91bmRzIGJ5IDUwJSBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHQvLyBOZWdhdGl2ZSB2YWx1ZXMgd2lsbCByZXRyYWN0IHRoZSBib3VuZHMuXHJcblx0cGFkOiBmdW5jdGlvbiAoYnVmZmVyUmF0aW8pIHtcclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdG1heCA9IHRoaXMubWF4LFxyXG5cdFx0aGVpZ2h0QnVmZmVyID0gTWF0aC5hYnMobWluLnggLSBtYXgueCkgKiBidWZmZXJSYXRpbyxcclxuXHRcdHdpZHRoQnVmZmVyID0gTWF0aC5hYnMobWluLnkgLSBtYXgueSkgKiBidWZmZXJSYXRpbztcclxuXHJcblxyXG5cdFx0cmV0dXJuIHRvQm91bmRzKFxyXG5cdFx0XHR0b1BvaW50KG1pbi54IC0gaGVpZ2h0QnVmZmVyLCBtaW4ueSAtIHdpZHRoQnVmZmVyKSxcclxuXHRcdFx0dG9Qb2ludChtYXgueCArIGhlaWdodEJ1ZmZlciwgbWF4LnkgKyB3aWR0aEJ1ZmZlcikpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaXMgZXF1aXZhbGVudCB0byB0aGUgZ2l2ZW4gYm91bmRzLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0Ym91bmRzID0gdG9Cb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5taW4uZXF1YWxzKGJvdW5kcy5nZXRUb3BMZWZ0KCkpICYmXHJcblx0XHRcdHRoaXMubWF4LmVxdWFscyhib3VuZHMuZ2V0Qm90dG9tUmlnaHQoKSk7XHJcblx0fSxcclxufTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmJvdW5kcyhjb3JuZXIxOiBQb2ludCwgY29ybmVyMjogUG9pbnQpXHJcbi8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdHdvIGNvcm5lcnMgY29vcmRpbmF0ZSBwYWlycy5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwuYm91bmRzKHBvaW50czogUG9pbnRbXSlcclxuLy8gQ3JlYXRlcyBhIEJvdW5kcyBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgb2YgcG9pbnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9Cb3VuZHMoYSwgYikge1xyXG5cdGlmICghYSB8fCBhIGluc3RhbmNlb2YgQm91bmRzKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBCb3VuZHMoYSwgYik7XHJcbn1cclxuIiwiaW1wb3J0IHtMYXRMbmcsIHRvTGF0TG5nfSBmcm9tICcuL0xhdExuZyc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTGF0TG5nQm91bmRzXHJcbiAqIEBha2EgTC5MYXRMbmdCb3VuZHNcclxuICpcclxuICogUmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGdlb2dyYXBoaWNhbCBhcmVhIG9uIGEgbWFwLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgY29ybmVyMSA9IEwubGF0TG5nKDQwLjcxMiwgLTc0LjIyNyksXHJcbiAqIGNvcm5lcjIgPSBMLmxhdExuZyg0MC43NzQsIC03NC4xMjUpLFxyXG4gKiBib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhjb3JuZXIxLCBjb3JuZXIyKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nQm91bmRzIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAuZml0Qm91bmRzKFtcclxuICogXHRbNDAuNzEyLCAtNzQuMjI3XSxcclxuICogXHRbNDAuNzc0LCAtNzQuMTI1XVxyXG4gKiBdKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIENhdXRpb246IGlmIHRoZSBhcmVhIGNyb3NzZXMgdGhlIGFudGltZXJpZGlhbiAob2Z0ZW4gY29uZnVzZWQgd2l0aCB0aGUgSW50ZXJuYXRpb25hbCBEYXRlIExpbmUpLCB5b3UgbXVzdCBzcGVjaWZ5IGNvcm5lcnMgX291dHNpZGVfIHRoZSBbLTE4MCwgMTgwXSBkZWdyZWVzIGxvbmdpdHVkZSByYW5nZS5cclxuICpcclxuICogTm90ZSB0aGF0IGBMYXRMbmdCb3VuZHNgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gTGF0TG5nQm91bmRzKGNvcm5lcjEsIGNvcm5lcjIpIHsgLy8gKExhdExuZywgTGF0TG5nKSBvciAoTGF0TG5nW10pXHJcblx0aWYgKCFjb3JuZXIxKSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgbGF0bG5ncyA9IGNvcm5lcjIgPyBbY29ybmVyMSwgY29ybmVyMl0gOiBjb3JuZXIxO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dGhpcy5leHRlbmQobGF0bG5nc1tpXSk7XHJcblx0fVxyXG59XHJcblxyXG5MYXRMbmdCb3VuZHMucHJvdG90eXBlID0ge1xyXG5cclxuXHQvLyBAbWV0aG9kIGV4dGVuZChsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludFxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGV4dGVuZChvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG5cdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIGJvdW5kc1xyXG5cdGV4dGVuZDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiwgbmUyO1xyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmcpIHtcclxuXHRcdFx0c3cyID0gb2JqO1xyXG5cdFx0XHRuZTIgPSBvYmo7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuXHRcdFx0c3cyID0gb2JqLl9zb3V0aFdlc3Q7XHJcblx0XHRcdG5lMiA9IG9iai5fbm9ydGhFYXN0O1xyXG5cclxuXHRcdFx0aWYgKCFzdzIgfHwgIW5lMikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBvYmogPyB0aGlzLmV4dGVuZCh0b0xhdExuZyhvYmopIHx8IHRvTGF0TG5nQm91bmRzKG9iaikpIDogdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXN3ICYmICFuZSkge1xyXG5cdFx0XHR0aGlzLl9zb3V0aFdlc3QgPSBuZXcgTGF0TG5nKHN3Mi5sYXQsIHN3Mi5sbmcpO1xyXG5cdFx0XHR0aGlzLl9ub3J0aEVhc3QgPSBuZXcgTGF0TG5nKG5lMi5sYXQsIG5lMi5sbmcpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cubGF0ID0gTWF0aC5taW4oc3cyLmxhdCwgc3cubGF0KTtcclxuXHRcdFx0c3cubG5nID0gTWF0aC5taW4oc3cyLmxuZywgc3cubG5nKTtcclxuXHRcdFx0bmUubGF0ID0gTWF0aC5tYXgobmUyLmxhdCwgbmUubGF0KTtcclxuXHRcdFx0bmUubG5nID0gTWF0aC5tYXgobmUyLmxuZywgbmUubG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhZChidWZmZXJSYXRpbzogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBib3VuZHMgY3JlYXRlZCBieSBleHRlbmRpbmcgb3IgcmV0cmFjdGluZyB0aGUgY3VycmVudCBib3VuZHMgYnkgYSBnaXZlbiByYXRpbyBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHQvLyBGb3IgZXhhbXBsZSwgYSByYXRpbyBvZiAwLjUgZXh0ZW5kcyB0aGUgYm91bmRzIGJ5IDUwJSBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHQvLyBOZWdhdGl2ZSB2YWx1ZXMgd2lsbCByZXRyYWN0IHRoZSBib3VuZHMuXHJcblx0cGFkOiBmdW5jdGlvbiAoYnVmZmVyUmF0aW8pIHtcclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBoZWlnaHRCdWZmZXIgPSBNYXRoLmFicyhzdy5sYXQgLSBuZS5sYXQpICogYnVmZmVyUmF0aW8sXHJcblx0XHQgICAgd2lkdGhCdWZmZXIgPSBNYXRoLmFicyhzdy5sbmcgLSBuZS5sbmcpICogYnVmZmVyUmF0aW87XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIG5ldyBMYXRMbmcoc3cubGF0IC0gaGVpZ2h0QnVmZmVyLCBzdy5sbmcgLSB3aWR0aEJ1ZmZlciksXHJcblx0XHQgICAgICAgIG5ldyBMYXRMbmcobmUubGF0ICsgaGVpZ2h0QnVmZmVyLCBuZS5sbmcgKyB3aWR0aEJ1ZmZlcikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcoXHJcblx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubGF0ICsgdGhpcy5fbm9ydGhFYXN0LmxhdCkgLyAyLFxyXG5cdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxuZyArIHRoaXMuX25vcnRoRWFzdC5sbmcpIC8gMik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aFdlc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgc291dGgtd2VzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldFNvdXRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoRWFzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Tm9ydGhFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGhXZXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXROb3J0aFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0Tm9ydGgoKSwgdGhpcy5nZXRXZXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U291dGhFYXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRTb3V0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0V2VzdCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSB3ZXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0V2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0U291dGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWFzdCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBlYXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0RWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0Tm9ydGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMgKGxhdGxuZzogTGF0TG5nKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7IC8vIChMYXRMbmdCb3VuZHMpIG9yIChMYXRMbmcpIC0+IEJvb2xlYW5cclxuXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBMYXRMbmcgfHwgJ2xhdCcgaW4gb2JqKSB7XHJcblx0XHRcdG9iaiA9IHRvTGF0TG5nKG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSB0b0xhdExuZ0JvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHN3MiA9IG9iai5nZXRTb3V0aFdlc3QoKTtcclxuXHRcdFx0bmUyID0gb2JqLmdldE5vcnRoRWFzdCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cyID0gbmUyID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAoc3cyLmxhdCA+PSBzdy5sYXQpICYmIChuZTIubGF0IDw9IG5lLmxhdCkgJiZcclxuXHRcdCAgICAgICAoc3cyLmxuZyA+PSBzdy5sbmcpICYmIChuZTIubG5nIDw9IG5lLmxuZyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgaW50ZXJzZWN0IGlmIHRoZXkgaGF2ZSBhdCBsZWFzdCBvbmUgcG9pbnQgaW4gY29tbW9uLlxyXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZTIgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblxyXG5cdFx0ICAgIGxhdEludGVyc2VjdHMgPSAobmUyLmxhdCA+PSBzdy5sYXQpICYmIChzdzIubGF0IDw9IG5lLmxhdCksXHJcblx0XHQgICAgbG5nSW50ZXJzZWN0cyA9IChuZTIubG5nID49IHN3LmxuZykgJiYgKHN3Mi5sbmcgPD0gbmUubG5nKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0SW50ZXJzZWN0cyAmJiBsbmdJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgbGF0T3ZlcmxhcHMgPSAobmUyLmxhdCA+IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPCBuZS5sYXQpLFxyXG5cdFx0ICAgIGxuZ092ZXJsYXBzID0gKG5lMi5sbmcgPiBzdy5sbmcpICYmIChzdzIubG5nIDwgbmUubG5nKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0T3ZlcmxhcHMgJiYgbG5nT3ZlcmxhcHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0JCb3hTdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyB3aXRoIGJvdW5kaW5nIGJveCBjb29yZGluYXRlcyBpbiBhICdzb3V0aHdlc3RfbG5nLHNvdXRod2VzdF9sYXQsbm9ydGhlYXN0X2xuZyxub3J0aGVhc3RfbGF0JyBmb3JtYXQuIFVzZWZ1bCBmb3Igc2VuZGluZyByZXF1ZXN0cyB0byB3ZWIgc2VydmljZXMgdGhhdCByZXR1cm4gZ2VvIGRhdGEuXHJcblx0dG9CQm94U3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gW3RoaXMuZ2V0V2VzdCgpLCB0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpLCB0aGlzLmdldE5vcnRoKCldLmpvaW4oJywnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzLCBtYXhNYXJnaW4/OiBOdW1iZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpcyBlcXVpdmFsZW50ICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpIHRvIHRoZSBnaXZlbiBib3VuZHMuIFRoZSBtYXJnaW4gb2YgZXJyb3IgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyBgbWF4TWFyZ2luYCB0byBhIHNtYWxsIG51bWJlci5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChib3VuZHMsIG1heE1hcmdpbikge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmVxdWFscyhib3VuZHMuZ2V0U291dGhXZXN0KCksIG1heE1hcmdpbikgJiZcclxuXHRcdCAgICAgICB0aGlzLl9ub3J0aEVhc3QuZXF1YWxzKGJvdW5kcy5nZXROb3J0aEVhc3QoKSwgbWF4TWFyZ2luKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGlzVmFsaWQoKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBib3VuZHMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkLlxyXG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhISh0aGlzLl9zb3V0aFdlc3QgJiYgdGhpcy5fbm9ydGhFYXN0KTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBUT0RPIEludGVybmF0aW9uYWwgZGF0ZSBsaW5lP1xyXG5cclxuLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMoY29ybmVyMTogTGF0TG5nLCBjb3JuZXIyOiBMYXRMbmcpXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgYnkgZGVmaW5pbmcgdHdvIGRpYWdvbmFsbHkgb3Bwb3NpdGUgY29ybmVycyBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nQm91bmRzKGxhdGxuZ3M6IExhdExuZ1tdKVxyXG4vLyBDcmVhdGVzIGEgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGRlZmluZWQgYnkgdGhlIGdlb2dyYXBoaWNhbCBwb2ludHMgaXQgY29udGFpbnMuIFZlcnkgdXNlZnVsIGZvciB6b29taW5nIHRoZSBtYXAgdG8gZml0IGEgcGFydGljdWxhciBzZXQgb2YgbG9jYXRpb25zIHdpdGggW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0xhdExuZ0JvdW5kcyhhLCBiKSB7XHJcblx0aWYgKGEgaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhhLCBiKTtcclxufVxyXG4iLCJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7RWFydGh9IGZyb20gJy4vY3JzL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7dG9MYXRMbmdCb3VuZHN9IGZyb20gJy4vTGF0TG5nQm91bmRzJztcclxuXHJcbi8qIEBjbGFzcyBMYXRMbmdcclxuICogQGFrYSBMLkxhdExuZ1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggYSBjZXJ0YWluIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiB2YXIgbGF0bG5nID0gTC5sYXRMbmcoNTAuNSwgMzAuNSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSBhbmQgc2ltcGxlIG9iamVjdCBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlc2UgbGluZXMgYXJlIGVxdWl2YWxlbnQ6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBtYXAucGFuVG8oWzUwLCAzMF0pO1xyXG4gKiBtYXAucGFuVG8oe2xvbjogMzAsIGxhdDogNTB9KTtcclxuICogbWFwLnBhblRvKHtsYXQ6IDUwLCBsbmc6IDMwfSk7XHJcbiAqIG1hcC5wYW5UbyhMLmxhdExuZyg1MCwgMzApKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgTGF0TG5nYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIExhdExuZyhsYXQsIGxuZywgYWx0KSB7XHJcblx0aWYgKGlzTmFOKGxhdCkgfHwgaXNOYU4obG5nKSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExhdExuZyBvYmplY3Q6ICgnICsgbGF0ICsgJywgJyArIGxuZyArICcpJyk7XHJcblx0fVxyXG5cclxuXHQvLyBAcHJvcGVydHkgbGF0OiBOdW1iZXJcclxuXHQvLyBMYXRpdHVkZSBpbiBkZWdyZWVzXHJcblx0dGhpcy5sYXQgPSArbGF0O1xyXG5cclxuXHQvLyBAcHJvcGVydHkgbG5nOiBOdW1iZXJcclxuXHQvLyBMb25naXR1ZGUgaW4gZGVncmVlc1xyXG5cdHRoaXMubG5nID0gK2xuZztcclxuXHJcblx0Ly8gQHByb3BlcnR5IGFsdDogTnVtYmVyXHJcblx0Ly8gQWx0aXR1ZGUgaW4gbWV0ZXJzIChvcHRpb25hbClcclxuXHRpZiAoYWx0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHRoaXMuYWx0ID0gK2FsdDtcclxuXHR9XHJcbn1cclxuXHJcbkxhdExuZy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJMYXRMbmc6IExhdExuZywgbWF4TWFyZ2luPzogTnVtYmVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBgTGF0TG5nYCBwb2ludCBpcyBhdCB0aGUgc2FtZSBwb3NpdGlvbiAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKS4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKG9iaiwgbWF4TWFyZ2luKSB7XHJcblx0XHRpZiAoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRvYmogPSB0b0xhdExuZyhvYmopO1xyXG5cclxuXHRcdHZhciBtYXJnaW4gPSBNYXRoLm1heChcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sYXQgLSBvYmoubGF0KSxcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sbmcgLSBvYmoubG5nKSk7XHJcblxyXG5cdFx0cmV0dXJuIG1hcmdpbiA8PSAobWF4TWFyZ2luID09PSB1bmRlZmluZWQgPyAxLjBFLTkgOiBtYXhNYXJnaW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgKGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMpLlxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHRyZXR1cm4gJ0xhdExuZygnICtcclxuXHRcdCAgICAgICAgVXRpbC5mb3JtYXROdW0odGhpcy5sYXQsIHByZWNpc2lvbikgKyAnLCAnICtcclxuXHRcdCAgICAgICAgVXRpbC5mb3JtYXROdW0odGhpcy5sbmcsIHByZWNpc2lvbikgKyAnKSc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZVRvKG90aGVyTGF0TG5nOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSAoaW4gbWV0ZXJzKSB0byB0aGUgZ2l2ZW4gYExhdExuZ2AgY2FsY3VsYXRlZCB1c2luZyB0aGUgW1NwaGVyaWNhbCBMYXcgb2YgQ29zaW5lc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BoZXJpY2FsX2xhd19vZl9jb3NpbmVzKS5cclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAob3RoZXIpIHtcclxuXHRcdHJldHVybiBFYXJ0aC5kaXN0YW5jZSh0aGlzLCB0b0xhdExuZyhvdGhlcikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdgIG9iamVjdCB3aXRoIHRoZSBsb25naXR1ZGUgd3JhcHBlZCBzbyBpdCdzIGFsd2F5cyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuXHR3cmFwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gRWFydGgud3JhcExhdExuZyh0aGlzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvQm91bmRzKHNpemVJbk1ldGVyczogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBhIG5ldyBgTGF0TG5nQm91bmRzYCBvYmplY3QgaW4gd2hpY2ggZWFjaCBib3VuZGFyeSBpcyBgc2l6ZUluTWV0ZXJzLzJgIG1ldGVycyBhcGFydCBmcm9tIHRoZSBgTGF0TG5nYC5cclxuXHR0b0JvdW5kczogZnVuY3Rpb24gKHNpemVJbk1ldGVycykge1xyXG5cdFx0dmFyIGxhdEFjY3VyYWN5ID0gMTgwICogc2l6ZUluTWV0ZXJzIC8gNDAwNzUwMTcsXHJcblx0XHQgICAgbG5nQWNjdXJhY3kgPSBsYXRBY2N1cmFjeSAvIE1hdGguY29zKChNYXRoLlBJIC8gMTgwKSAqIHRoaXMubGF0KTtcclxuXHJcblx0XHRyZXR1cm4gdG9MYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIFt0aGlzLmxhdCAtIGxhdEFjY3VyYWN5LCB0aGlzLmxuZyAtIGxuZ0FjY3VyYWN5XSxcclxuXHRcdCAgICAgICAgW3RoaXMubGF0ICsgbGF0QWNjdXJhY3ksIHRoaXMubG5nICsgbG5nQWNjdXJhY3ldKTtcclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5sYXQsIHRoaXMubG5nLCB0aGlzLmFsdCk7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhsYXRpdHVkZTogTnVtYmVyLCBsb25naXR1ZGU6IE51bWJlciwgYWx0aXR1ZGU/OiBOdW1iZXIpOiBMYXRMbmdcclxuLy8gQ3JlYXRlcyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggdGhlIGdpdmVuIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgKGFuZCBvcHRpb25hbGx5IGFsdGl0dWRlKS5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IEFycmF5KTogTGF0TG5nXHJcbi8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFtOdW1iZXIsIE51bWJlcl1gIG9yIGBbTnVtYmVyLCBOdW1iZXIsIE51bWJlcl1gIGluc3RlYWQuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmcoY29vcmRzOiBPYmplY3QpOiBMYXRMbmdcclxuLy8gRXhwZWN0cyBhbiBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHtsYXQ6IE51bWJlciwgbG5nOiBOdW1iZXJ9YCBvciBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlciwgYWx0OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvTGF0TG5nKGEsIGIsIGMpIHtcclxuXHRpZiAoYSBpbnN0YW5jZW9mIExhdExuZykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdGlmIChVdGlsLmlzQXJyYXkoYSkgJiYgdHlwZW9mIGFbMF0gIT09ICdvYmplY3QnKSB7XHJcblx0XHRpZiAoYS5sZW5ndGggPT09IDMpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSwgYVsyXSk7XHJcblx0XHR9XHJcblx0XHRpZiAoYS5sZW5ndGggPT09IDIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0aWYgKGEgPT09IHVuZGVmaW5lZCB8fCBhID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAnbGF0JyBpbiBhKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhhLmxhdCwgJ2xuZycgaW4gYSA/IGEubG5nIDogYS5sb24sIGEuYWx0KTtcclxuXHR9XHJcblx0aWYgKGIgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTGF0TG5nKGEsIGIsIGMpO1xyXG59XHJcbiIsIlxyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL0xhdExuZyc7XHJcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi9MYXRMbmdCb3VuZHMnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkJhc2VcclxuICogT2JqZWN0IHRoYXQgZGVmaW5lcyBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW1zIGZvciBwcm9qZWN0aW5nXHJcbiAqIGdlb2dyYXBoaWNhbCBwb2ludHMgaW50byBwaXhlbCAoc2NyZWVuKSBjb29yZGluYXRlcyBhbmQgYmFjayAoYW5kIHRvXHJcbiAqIGNvb3JkaW5hdGVzIGluIG90aGVyIHVuaXRzIGZvciBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS4gU2VlXHJcbiAqIFtzcGF0aWFsIHJlZmVyZW5jZSBzeXN0ZW1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NwYXRpYWxfcmVmZXJlbmNlX3N5c3RlbSkuXHJcbiAqXHJcbiAqIExlYWZsZXQgZGVmaW5lcyB0aGUgbW9zdCB1c3VhbCBDUlNzIGJ5IGRlZmF1bHQuIElmIHlvdSB3YW50IHRvIHVzZSBhXHJcbiAqIENSUyBub3QgZGVmaW5lZCBieSBkZWZhdWx0LCB0YWtlIGEgbG9vayBhdCB0aGVcclxuICogW1Byb2o0TGVhZmxldF0oaHR0cHM6Ly9naXRodWIuY29tL2thcnRlbmEvUHJvajRMZWFmbGV0KSBwbHVnaW4uXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB0aGUgQ1JTIGluc3RhbmNlcyBkbyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogYW5kIGNhbid0IGJlIGluc3RhbnRpYXRlZC4gQWxzbywgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIHRoZW0sXHJcbiAqIGFuZCBtZXRob2RzIGNhbid0IGJlIGFkZGVkIHRvIHRoZW0gd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgQ1JTID0ge1xyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9Qb2ludChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBwaXhlbCBjb29yZGluYXRlcyBmb3IgYSBnaXZlbiB6b29tLlxyXG5cdGxhdExuZ1RvUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdGlvbi5wcm9qZWN0KGxhdGxuZyksXHJcblx0XHQgICAgc2NhbGUgPSB0aGlzLnNjYWxlKHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uLl90cmFuc2Zvcm0ocHJvamVjdGVkUG9pbnQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50LCB6b29tOiBOdW1iZXIpOiBMYXRMbmdcclxuXHQvLyBUaGUgaW52ZXJzZSBvZiBgbGF0TG5nVG9Qb2ludGAuIFByb2plY3RzIHBpeGVsIGNvb3JkaW5hdGVzIG9uIGEgZ2l2ZW5cclxuXHQvLyB6b29tIGludG8gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG5cdHBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKSxcclxuXHRcdCAgICB1bnRyYW5zZm9ybWVkUG9pbnQgPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHBvaW50LCBzY2FsZSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QodW50cmFuc2Zvcm1lZFBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIGNvb3JkaW5hdGVzIGluIHVuaXRzIGFjY2VwdGVkIGZvclxyXG5cdC8vIHRoaXMgQ1JTIChlLmcuIG1ldGVycyBmb3IgRVBTRzozODU3LCBmb3IgcGFzc2luZyBpdCB0byBXTVMgc2VydmljZXMpLlxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcHJvamVjdGVkIGNvb3JkaW5hdGUgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBMYXRMbmcuXHJcblx0Ly8gVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLlxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnVucHJvamVjdChwb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzY2FsZSh6b29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSB1c2VkIHdoZW4gdHJhbnNmb3JtaW5nIHByb2plY3RlZCBjb29yZGluYXRlcyBpbnRvXHJcblx0Ly8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgcGFydGljdWxhciB6b29tLiBGb3IgZXhhbXBsZSwgaXQgcmV0dXJuc1xyXG5cdC8vIGAyNTYgKiAyXnpvb21gIGZvciBNZXJjYXRvci1iYXNlZCBDUlMuXHJcblx0c2NhbGU6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRyZXR1cm4gMjU2ICogTWF0aC5wb3coMiwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tKHNjYWxlOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBJbnZlcnNlIG9mIGBzY2FsZSgpYCwgcmV0dXJucyB0aGUgem9vbSBsZXZlbCBjb3JyZXNwb25kaW5nIHRvIGEgc2NhbGVcclxuXHQvLyBmYWN0b3Igb2YgYHNjYWxlYC5cclxuXHR6b29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcclxuXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSAvIDI1NikgLyBNYXRoLkxOMjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFByb2plY3RlZEJvdW5kcyh6b29tOiBOdW1iZXIpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uJ3MgYm91bmRzIHNjYWxlZCBhbmQgdHJhbnNmb3JtZWQgZm9yIHRoZSBwcm92aWRlZCBgem9vbWAuXHJcblx0Z2V0UHJvamVjdGVkQm91bmRzOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0aWYgKHRoaXMuaW5maW5pdGUpIHsgcmV0dXJuIG51bGw7IH1cclxuXHJcblx0XHR2YXIgYiA9IHRoaXMucHJvamVjdGlvbi5ib3VuZHMsXHJcblx0XHQgICAgcyA9IHRoaXMuc2NhbGUoem9vbSksXHJcblx0XHQgICAgbWluID0gdGhpcy50cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0oYi5taW4sIHMpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWF4LCBzKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhtaW4sIG1heCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuXHJcblx0Ly8gQHByb3BlcnR5IGNvZGU6IFN0cmluZ1xyXG5cdC8vIFN0YW5kYXJkIGNvZGUgbmFtZSBvZiB0aGUgQ1JTIHBhc3NlZCBpbnRvIFdNUyBzZXJ2aWNlcyAoZS5nLiBgJ0VQU0c6Mzg1NydgKVxyXG5cdC8vXHJcblx0Ly8gQHByb3BlcnR5IHdyYXBMbmc6IE51bWJlcltdXHJcblx0Ly8gQW4gYXJyYXkgb2YgdHdvIG51bWJlcnMgZGVmaW5pbmcgd2hldGhlciB0aGUgbG9uZ2l0dWRlIChob3Jpem9udGFsKSBjb29yZGluYXRlXHJcblx0Ly8gYXhpcyB3cmFwcyBhcm91bmQgYSBnaXZlbiByYW5nZSBhbmQgaG93LiBEZWZhdWx0cyB0byBgWy0xODAsIDE4MF1gIGluIG1vc3RcclxuXHQvLyBnZW9ncmFwaGljYWwgQ1JTcy4gSWYgYHVuZGVmaW5lZGAsIHRoZSBsb25naXR1ZGUgYXhpcyBkb2VzIG5vdCB3cmFwIGFyb3VuZC5cclxuXHQvL1xyXG5cdC8vIEBwcm9wZXJ0eSB3cmFwTGF0OiBOdW1iZXJbXVxyXG5cdC8vIExpa2UgYHdyYXBMbmdgLCBidXQgZm9yIHRoZSBsYXRpdHVkZSAodmVydGljYWwpIGF4aXMuXHJcblxyXG5cdC8vIHdyYXBMbmc6IFttaW4sIG1heF0sXHJcblx0Ly8gd3JhcExhdDogW21pbiwgbWF4XSxcclxuXHJcblx0Ly8gQHByb3BlcnR5IGluZmluaXRlOiBCb29sZWFuXHJcblx0Ly8gSWYgdHJ1ZSwgdGhlIGNvb3JkaW5hdGUgc3BhY2Ugd2lsbCBiZSB1bmJvdW5kZWQgKGluZmluaXRlIGluIGJvdGggYXhlcylcclxuXHRpbmZpbml0ZTogZmFsc2UsXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZyhsYXRsbmc6IExhdExuZyk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBsYXQgYW5kIGxuZyBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuXHQvLyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZSBDUlMncyBib3VuZHMuXHJcblx0d3JhcExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGxuZyA9IHRoaXMud3JhcExuZyA/IFV0aWwud3JhcE51bShsYXRsbmcubG5nLCB0aGlzLndyYXBMbmcsIHRydWUpIDogbGF0bG5nLmxuZyxcclxuXHRcdCAgICBsYXQgPSB0aGlzLndyYXBMYXQgPyBVdGlsLndyYXBOdW0obGF0bG5nLmxhdCwgdGhpcy53cmFwTGF0LCB0cnVlKSA6IGxhdGxuZy5sYXQsXHJcblx0XHQgICAgYWx0ID0gbGF0bG5nLmFsdDtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhsYXQsIGxuZywgYWx0KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmdCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ0JvdW5kc2Agd2l0aCB0aGUgc2FtZSBzaXplIGFzIHRoZSBnaXZlbiBvbmUsIGVuc3VyaW5nXHJcblx0Ly8gdGhhdCBpdHMgY2VudGVyIGlzIHdpdGhpbiB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdC8vIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuTGF0TG5nQm91bmRzYCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0d3JhcExhdExuZ0JvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0dmFyIGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLndyYXBMYXRMbmcoY2VudGVyKSxcclxuXHRcdCAgICBsYXRTaGlmdCA9IGNlbnRlci5sYXQgLSBuZXdDZW50ZXIubGF0LFxyXG5cdFx0ICAgIGxuZ1NoaWZ0ID0gY2VudGVyLmxuZyAtIG5ld0NlbnRlci5sbmc7XHJcblxyXG5cdFx0aWYgKGxhdFNoaWZ0ID09PSAwICYmIGxuZ1NoaWZ0ID09PSAwKSB7XHJcblx0XHRcdHJldHVybiBib3VuZHM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHN3ID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cdFx0ICAgIG5ld1N3ID0gbmV3IExhdExuZyhzdy5sYXQgLSBsYXRTaGlmdCwgc3cubG5nIC0gbG5nU2hpZnQpLFxyXG5cdFx0ICAgIG5ld05lID0gbmV3IExhdExuZyhuZS5sYXQgLSBsYXRTaGlmdCwgbmUubG5nIC0gbG5nU2hpZnQpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKG5ld1N3LCBuZXdOZSk7XHJcblx0fVxyXG59O1xyXG4iLCJpbXBvcnQge0NSU30gZnJvbSAnLi9DUlMnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogQG5hbWVzcGFjZSBDUlNcbiAqIEBjcnMgTC5DUlMuRWFydGhcbiAqXG4gKiBTZXJ2ZXMgYXMgdGhlIGJhc2UgZm9yIENSUyB0aGF0IGFyZSBnbG9iYWwgc3VjaCB0aGF0IHRoZXkgY292ZXIgdGhlIGVhcnRoLlxuICogQ2FuIG9ubHkgYmUgdXNlZCBhcyB0aGUgYmFzZSBmb3Igb3RoZXIgQ1JTIGFuZCBjYW5ub3QgYmUgdXNlZCBkaXJlY3RseSxcbiAqIHNpbmNlIGl0IGRvZXMgbm90IGhhdmUgYSBgY29kZWAsIGBwcm9qZWN0aW9uYCBvciBgdHJhbnNmb3JtYXRpb25gLiBgZGlzdGFuY2UoKWAgcmV0dXJuc1xuICogbWV0ZXJzLlxuICovXG5cbmV4cG9ydCB2YXIgRWFydGggPSBVdGlsLmV4dGVuZCh7fSwgQ1JTLCB7XG5cdHdyYXBMbmc6IFstMTgwLCAxODBdLFxuXG5cdC8vIE1lYW4gRWFydGggUmFkaXVzLCBhcyByZWNvbW1lbmRlZCBmb3IgdXNlIGJ5XG5cdC8vIHRoZSBJbnRlcm5hdGlvbmFsIFVuaW9uIG9mIEdlb2Rlc3kgYW5kIEdlb3BoeXNpY3MsXG5cdC8vIHNlZSBodHRwczovL3Jvc2V0dGFjb2RlLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhXG5cdFI6IDYzNzEwMDAsXG5cblx0Ly8gZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIHBvaW50cyB1c2luZyBzcGhlcmljYWwgbGF3IG9mIGNvc2luZXMgYXBwcm94aW1hdGlvblxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcblx0XHR2YXIgcmFkID0gTWF0aC5QSSAvIDE4MCxcblx0XHQgICAgbGF0MSA9IGxhdGxuZzEubGF0ICogcmFkLFxuXHRcdCAgICBsYXQyID0gbGF0bG5nMi5sYXQgKiByYWQsXG5cdFx0ICAgIHNpbkRMYXQgPSBNYXRoLnNpbigobGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdCkgKiByYWQgLyAyKSxcblx0XHQgICAgc2luRExvbiA9IE1hdGguc2luKChsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nKSAqIHJhZCAvIDIpLFxuXHRcdCAgICBhID0gc2luRExhdCAqIHNpbkRMYXQgKyBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpICogc2luRExvbiAqIHNpbkRMb24sXG5cdFx0ICAgIGMgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xuXHRcdHJldHVybiB0aGlzLlIgKiBjO1xuXHR9XG59KTtcbiIsImltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvclxyXG4gKlxyXG4gKiBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgdGhlIG1vc3QgY29tbW9uIHByb2plY3Rpb24gZm9yIG9ubGluZSBtYXBzLFxyXG4gKiB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzXHJcbiAqIGEgc3BoZXJlLiBVc2VkIGJ5IHRoZSBgRVBTRzozODU3YCBDUlMuXHJcbiAqL1xyXG5cclxudmFyIGVhcnRoUmFkaXVzID0gNjM3ODEzNztcclxuXHJcbmV4cG9ydCB2YXIgU3BoZXJpY2FsTWVyY2F0b3IgPSB7XHJcblxyXG5cdFI6IGVhcnRoUmFkaXVzLFxyXG5cdE1BWF9MQVRJVFVERTogODUuMDUxMTI4Nzc5OCxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuTUFYX0xBVElUVURFLFxyXG5cdFx0ICAgIGxhdCA9IE1hdGgubWF4KE1hdGgubWluKG1heCwgbGF0bG5nLmxhdCksIC1tYXgpLFxyXG5cdFx0ICAgIHNpbiA9IE1hdGguc2luKGxhdCAqIGQpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQoXHJcblx0XHRcdHRoaXMuUiAqIGxhdGxuZy5sbmcgKiBkLFxyXG5cdFx0XHR0aGlzLlIgKiBNYXRoLmxvZygoMSArIHNpbikgLyAoMSAtIHNpbikpIC8gMik7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhcclxuXHRcdFx0KDIgKiBNYXRoLmF0YW4oTWF0aC5leHAocG9pbnQueSAvIHRoaXMuUikpIC0gKE1hdGguUEkgLyAyKSkgKiBkLFxyXG5cdFx0XHRwb2ludC54ICogZCAvIHRoaXMuUik7XHJcblx0fSxcclxuXHJcblx0Ym91bmRzOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGQgPSBlYXJ0aFJhZGl1cyAqIE1hdGguUEk7XHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhbLWQsIC1kXSwgW2QsIGRdKTtcclxuXHR9KSgpXHJcbn07XHJcbiIsImltcG9ydCB7UG9pbnR9IGZyb20gJy4vUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgVHJhbnNmb3JtYXRpb25cclxuICogQGFrYSBMLlRyYW5zZm9ybWF0aW9uXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uOiBhIHNldCBvZiBjb2VmZmljaWVudHMgYGFgLCBgYmAsIGBjYCwgYGRgXHJcbiAqIGZvciB0cmFuc2Zvcm1pbmcgYSBwb2ludCBvZiBhIGZvcm0gYCh4LCB5KWAgaW50byBgKGEqeCArIGIsIGMqeSArIGQpYCBhbmQgZG9pbmdcclxuICogdGhlIHJldmVyc2UuIFVzZWQgYnkgTGVhZmxldCBpbiBpdHMgcHJvamVjdGlvbnMgY29kZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHRyYW5zZm9ybWF0aW9uID0gTC50cmFuc2Zvcm1hdGlvbigyLCA1LCAtMSwgMTApLFxyXG4gKiBcdHAgPSBMLnBvaW50KDEsIDIpLFxyXG4gKiBcdHAyID0gdHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKHApLCAvLyAgTC5wb2ludCg3LCA4KVxyXG4gKiBcdHAzID0gdHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0ocDIpOyAvLyAgTC5wb2ludCgxLCAyKVxyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuLy8gZmFjdG9yeSBuZXcgTC5UcmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcbi8vIENyZWF0ZXMgYSBgVHJhbnNmb3JtYXRpb25gIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcbmV4cG9ydCBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKSB7XHJcblx0aWYgKFV0aWwuaXNBcnJheShhKSkge1xyXG5cdFx0Ly8gdXNlIGFycmF5IHByb3BlcnRpZXNcclxuXHRcdHRoaXMuX2EgPSBhWzBdO1xyXG5cdFx0dGhpcy5fYiA9IGFbMV07XHJcblx0XHR0aGlzLl9jID0gYVsyXTtcclxuXHRcdHRoaXMuX2QgPSBhWzNdO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHR0aGlzLl9hID0gYTtcclxuXHR0aGlzLl9iID0gYjtcclxuXHR0aGlzLl9jID0gYztcclxuXHR0aGlzLl9kID0gZDtcclxufVxyXG5cclxuVHJhbnNmb3JtYXRpb24ucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgdHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSB0cmFuc2Zvcm1lZCBwb2ludCwgb3B0aW9uYWxseSBtdWx0aXBsaWVkIGJ5IHRoZSBnaXZlbiBzY2FsZS5cclxuXHQvLyBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0dHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7IC8vIChQb2ludCwgTnVtYmVyKSAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIHRoaXMuX3RyYW5zZm9ybShwb2ludC5jbG9uZSgpLCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gZGVzdHJ1Y3RpdmUgdHJhbnNmb3JtIChmYXN0ZXIpXHJcblx0X3RyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cG9pbnQueCA9IHNjYWxlICogKHRoaXMuX2EgKiBwb2ludC54ICsgdGhpcy5fYik7XHJcblx0XHRwb2ludC55ID0gc2NhbGUgKiAodGhpcy5fYyAqIHBvaW50LnkgKyB0aGlzLl9kKTtcclxuXHRcdHJldHVybiBwb2ludDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVudHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJldmVyc2UgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGdpdmVuIHBvaW50LCBvcHRpb25hbGx5IGRpdmlkZWRcclxuXHQvLyBieSB0aGUgZ2l2ZW4gc2NhbGUuIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuXHR1bnRyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdCAgICAgICAgKHBvaW50LnggLyBzY2FsZSAtIHRoaXMuX2IpIC8gdGhpcy5fYSxcclxuXHRcdCAgICAgICAgKHBvaW50LnkgLyBzY2FsZSAtIHRoaXMuX2QpIC8gdGhpcy5fYyk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuXHJcbi8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBUcmFuc2Zvcm1hdGlvbiBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29lZmZpY2llbnRzLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oY29lZmZpY2llbnRzOiBBcnJheSk6IFRyYW5zZm9ybWF0aW9uXHJcbi8vIEV4cGVjdHMgYW4gY29lZmZpY2llbnRzIGFycmF5IG9mIHRoZSBmb3JtXHJcbi8vIGBbYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyXWAuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdG9UcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKSB7XHJcblx0cmV0dXJuIG5ldyBUcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKTtcclxufVxyXG4iLCJpbXBvcnQge0VhcnRofSBmcm9tICcuL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7U3BoZXJpY2FsTWVyY2F0b3J9IGZyb20gJy4uL3Byb2plY3Rpb24vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvcic7XHJcbmltcG9ydCB7dG9UcmFuc2Zvcm1hdGlvbn0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24nO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0czODU3XHJcbiAqXHJcbiAqIFRoZSBtb3N0IGNvbW1vbiBDUlMgZm9yIG9ubGluZSBtYXBzLCB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbFxyXG4gKiB0aWxlIHByb3ZpZGVycy4gVXNlcyBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi4gU2V0IGluIGJ5IGRlZmF1bHQgaW5cclxuICogTWFwJ3MgYGNyc2Agb3B0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRVBTRzM4NTcgPSBVdGlsLmV4dGVuZCh7fSwgRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzozODU3JyxcclxuXHRwcm9qZWN0aW9uOiBTcGhlcmljYWxNZXJjYXRvcixcclxuXHJcblx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIFNwaGVyaWNhbE1lcmNhdG9yLlIpO1xyXG5cdFx0cmV0dXJuIHRvVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG5cdH0oKSlcclxufSk7XHJcblxyXG5leHBvcnQgdmFyIEVQU0c5MDA5MTMgPSBVdGlsLmV4dGVuZCh7fSwgRVBTRzM4NTcsIHtcclxuXHRjb2RlOiAnRVBTRzo5MDA5MTMnXHJcbn0pO1xyXG4iLCJpbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuXG4vLyBAbmFtZXNwYWNlIFNWRzsgQHNlY3Rpb25cbi8vIFRoZXJlIGFyZSBzZXZlcmFsIHN0YXRpYyBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5TVkc6XG5cbi8vIEBmdW5jdGlvbiBjcmVhdGUobmFtZTogU3RyaW5nKTogU1ZHRWxlbWVudFxuLy8gUmV0dXJucyBhIGluc3RhbmNlIG9mIFtTVkdFbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvU1ZHRWxlbWVudCksXG4vLyBjb3JyZXNwb25kaW5nIHRvIHRoZSBjbGFzcyBuYW1lIHBhc3NlZC4gRm9yIGV4YW1wbGUsIHVzaW5nICdsaW5lJyB3aWxsIHJldHVyblxuLy8gYW4gaW5zdGFuY2Ugb2YgW1NWR0xpbmVFbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvU1ZHTGluZUVsZW1lbnQpLlxuZXhwb3J0IGZ1bmN0aW9uIHN2Z0NyZWF0ZShuYW1lKSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbmFtZSk7XG59XG5cbi8vIEBmdW5jdGlvbiBwb2ludHNUb1BhdGgocmluZ3M6IFBvaW50W10sIGNsb3NlZDogQm9vbGVhbik6IFN0cmluZ1xuLy8gR2VuZXJhdGVzIGEgU1ZHIHBhdGggc3RyaW5nIGZvciBtdWx0aXBsZSByaW5ncywgd2l0aCBlYWNoIHJpbmcgdHVybmluZ1xuLy8gaW50byBcIk0uLkwuLkwuLlwiIGluc3RydWN0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIHBvaW50c1RvUGF0aChyaW5ncywgY2xvc2VkKSB7XG5cdHZhciBzdHIgPSAnJyxcblx0aSwgaiwgbGVuLCBsZW4yLCBwb2ludHMsIHA7XG5cblx0Zm9yIChpID0gMCwgbGVuID0gcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRwb2ludHMgPSByaW5nc1tpXTtcblxuXHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG5cdFx0XHRwID0gcG9pbnRzW2pdO1xuXHRcdFx0c3RyICs9IChqID8gJ0wnIDogJ00nKSArIHAueCArICcgJyArIHAueTtcblx0XHR9XG5cblx0XHQvLyBjbG9zZXMgdGhlIHJpbmcgZm9yIHBvbHlnb25zOyBcInhcIiBpcyBWTUwgc3ludGF4XG5cdFx0c3RyICs9IGNsb3NlZCA/IChCcm93c2VyLnN2ZyA/ICd6JyA6ICd4JykgOiAnJztcblx0fVxuXG5cdC8vIFNWRyBjb21wbGFpbnMgYWJvdXQgZW1wdHkgcGF0aCBzdHJpbmdzXG5cdHJldHVybiBzdHIgfHwgJ00wIDAnO1xufVxuXG5cblxuXG4iLCJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4vVXRpbCc7XHJcbmltcG9ydCB7c3ZnQ3JlYXRlfSBmcm9tICcuLi9sYXllci92ZWN0b3IvU1ZHLlV0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBCcm93c2VyXHJcbiAqIEBha2EgTC5Ccm93c2VyXHJcbiAqXHJcbiAqIEEgbmFtZXNwYWNlIHdpdGggc3RhdGljIHByb3BlcnRpZXMgZm9yIGJyb3dzZXIvZmVhdHVyZSBkZXRlY3Rpb24gdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGlmIChMLkJyb3dzZXIuaWVsdDkpIHtcclxuICogICBhbGVydCgnVXBncmFkZSB5b3VyIGJyb3dzZXIsIGR1ZGUhJyk7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5cclxudmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cclxuLy8gQHByb3BlcnR5IGllOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyAobm90IEVkZ2UpLlxyXG52YXIgaWUgPSAnQWN0aXZlWE9iamVjdCcgaW4gd2luZG93O1xyXG5cclxuLy8gQHByb3BlcnR5IGllbHQ5OiBCb29sZWFuOyBgdHJ1ZWAgZm9yIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIGxlc3MgdGhhbiA5LlxyXG52YXIgaWVsdDkgPSBpZSAmJiAhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcjtcclxuXHJcbi8vIEBwcm9wZXJ0eSBlZGdlOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBFZGdlIHdlYiBicm93c2VyLlxyXG52YXIgZWRnZSA9ICdtc0xhdW5jaFVyaScgaW4gbmF2aWdhdG9yICYmICEoJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpO1xyXG5cclxuLy8gQHByb3BlcnR5IHdlYmtpdDogQm9vbGVhbjtcclxuLy8gYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgbGlrZSBDaHJvbWUgYW5kIFNhZmFyaSAoaW5jbHVkaW5nIG1vYmlsZSB2ZXJzaW9ucykuXHJcbnZhciB3ZWJraXQgPSB1c2VyQWdlbnRDb250YWlucygnd2Via2l0Jyk7XHJcblxyXG4vLyBAcHJvcGVydHkgYW5kcm9pZDogQm9vbGVhblxyXG4vLyAqKkRlcHJlY2F0ZWQuKiogYHRydWVgIGZvciBhbnkgYnJvd3NlciBydW5uaW5nIG9uIGFuIEFuZHJvaWQgcGxhdGZvcm0uXHJcbnZhciBhbmRyb2lkID0gdXNlckFnZW50Q29udGFpbnMoJ2FuZHJvaWQnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBhbmRyb2lkMjM6IEJvb2xlYW47ICoqRGVwcmVjYXRlZC4qKiBgdHJ1ZWAgZm9yIGJyb3dzZXJzIHJ1bm5pbmcgb24gQW5kcm9pZCAyIG9yIEFuZHJvaWQgMy5cclxudmFyIGFuZHJvaWQyMyA9IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkIDInKSB8fCB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCAzJyk7XHJcblxyXG4vKiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE3OTYxMjY2IGZvciBkZXRhaWxzIG9uIGRldGVjdGluZyBzdG9jayBBbmRyb2lkICovXHJcbnZhciB3ZWJraXRWZXIgPSBwYXJzZUludCgvV2ViS2l0XFwvKFswLTldKyl8JC8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KVsxXSwgMTApOyAvLyBhbHNvIG1hdGNoZXMgQXBwbGVXZWJLaXRcclxuLy8gQHByb3BlcnR5IGFuZHJvaWRTdG9jazogQm9vbGVhbjsgKipEZXByZWNhdGVkLioqIGB0cnVlYCBmb3IgdGhlIEFuZHJvaWQgc3RvY2sgYnJvd3NlciAoaS5lLiBub3QgQ2hyb21lKVxyXG52YXIgYW5kcm9pZFN0b2NrID0gYW5kcm9pZCAmJiB1c2VyQWdlbnRDb250YWlucygnR29vZ2xlJykgJiYgd2Via2l0VmVyIDwgNTM3ICYmICEoJ0F1ZGlvTm9kZScgaW4gd2luZG93KTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBvcGVyYTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlclxyXG52YXIgb3BlcmEgPSAhIXdpbmRvdy5vcGVyYTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBjaHJvbWU6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIENocm9tZSBicm93c2VyLlxyXG52YXIgY2hyb21lID0gIWVkZ2UgJiYgdXNlckFnZW50Q29udGFpbnMoJ2Nocm9tZScpO1xyXG5cclxuLy8gQHByb3BlcnR5IGdlY2tvOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIGxpa2UgRmlyZWZveC5cclxudmFyIGdlY2tvID0gdXNlckFnZW50Q29udGFpbnMoJ2dlY2tvJykgJiYgIXdlYmtpdCAmJiAhb3BlcmEgJiYgIWllO1xyXG5cclxuLy8gQHByb3BlcnR5IHNhZmFyaTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgU2FmYXJpIGJyb3dzZXIuXHJcbnZhciBzYWZhcmkgPSAhY2hyb21lICYmIHVzZXJBZ2VudENvbnRhaW5zKCdzYWZhcmknKTtcclxuXHJcbnZhciBwaGFudG9tID0gdXNlckFnZW50Q29udGFpbnMoJ3BoYW50b20nKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBvcGVyYTEyOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3JtcyAodmVyc2lvbiAxMiBvciBsYXRlcikuXHJcbnZhciBvcGVyYTEyID0gJ09UcmFuc2l0aW9uJyBpbiBzdHlsZTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB3aW46IEJvb2xlYW47IGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBXaW5kb3dzIHBsYXRmb3JtXHJcbnZhciB3aW4gPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignV2luJykgPT09IDA7XHJcblxyXG4vLyBAcHJvcGVydHkgaWUzZDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxudmFyIGllM2QgPSBpZSAmJiAoJ3RyYW5zaXRpb24nIGluIHN0eWxlKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB3ZWJraXQzZDogQm9vbGVhbjsgYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxudmFyIHdlYmtpdDNkID0gKCdXZWJLaXRDU1NNYXRyaXgnIGluIHdpbmRvdykgJiYgKCdtMTEnIGluIG5ldyB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KCkpICYmICFhbmRyb2lkMjM7XHJcblxyXG4vLyBAcHJvcGVydHkgZ2Vja28zZDogQm9vbGVhbjsgYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG52YXIgZ2Vja28zZCA9ICdNb3pQZXJzcGVjdGl2ZScgaW4gc3R5bGU7XHJcblxyXG4vLyBAcHJvcGVydHkgYW55M2Q6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxudmFyIGFueTNkID0gIXdpbmRvdy5MX0RJU0FCTEVfM0QgJiYgKGllM2QgfHwgd2Via2l0M2QgfHwgZ2Vja28zZCkgJiYgIW9wZXJhMTIgJiYgIXBoYW50b207XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBydW5uaW5nIGluIGEgbW9iaWxlIGRldmljZS5cclxudmFyIG1vYmlsZSA9IHR5cGVvZiBvcmllbnRhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgfHwgdXNlckFnZW50Q29udGFpbnMoJ21vYmlsZScpO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZS5cclxudmFyIG1vYmlsZVdlYmtpdCA9IG1vYmlsZSAmJiB3ZWJraXQ7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0M2Q6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZSBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG52YXIgbW9iaWxlV2Via2l0M2QgPSBtb2JpbGUgJiYgd2Via2l0M2Q7XHJcblxyXG4vLyBAcHJvcGVydHkgbXNQb2ludGVyOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgaW1wbGVtZW50aW5nIHRoZSBNaWNyb3NvZnQgdG91Y2ggZXZlbnRzIG1vZGVsIChub3RhYmx5IElFMTApLlxyXG52YXIgbXNQb2ludGVyID0gIXdpbmRvdy5Qb2ludGVyRXZlbnQgJiYgd2luZG93Lk1TUG9pbnRlckV2ZW50O1xyXG5cclxuLy8gQHByb3BlcnR5IHBvaW50ZXI6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBbcG9pbnRlciBldmVudHNdKGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZG40MzMyNDQlMjh2PXZzLjg1JTI5LmFzcHgpLlxyXG52YXIgcG9pbnRlciA9ICEhKHdpbmRvdy5Qb2ludGVyRXZlbnQgfHwgbXNQb2ludGVyKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB0b3VjaE5hdGl2ZTogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFt0b3VjaCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Ub3VjaF9ldmVudHMpLlxyXG4vLyAqKlRoaXMgZG9lcyBub3QgbmVjZXNzYXJpbHkgbWVhbioqIHRoYXQgdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIGNvbXB1dGVyIHdpdGhcclxuLy8gYSB0b3VjaHNjcmVlbiwgaXQgb25seSBtZWFucyB0aGF0IHRoZSBicm93c2VyIGlzIGNhcGFibGUgb2YgdW5kZXJzdGFuZGluZ1xyXG4vLyB0b3VjaCBldmVudHMuXHJcbnZhciB0b3VjaE5hdGl2ZSA9ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fCAhIXdpbmRvdy5Ub3VjaEV2ZW50O1xyXG5cclxuLy8gQHByb3BlcnR5IHRvdWNoOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgZWl0aGVyIFt0b3VjaF0oI2Jyb3dzZXItdG91Y2gpIG9yIFtwb2ludGVyXSgjYnJvd3Nlci1wb2ludGVyKSBldmVudHMuXHJcbi8vIE5vdGU6IHBvaW50ZXIgZXZlbnRzIHdpbGwgYmUgcHJlZmVycmVkIChpZiBhdmFpbGFibGUpLCBhbmQgcHJvY2Vzc2VkIGZvciBhbGwgYHRvdWNoKmAgbGlzdGVuZXJzLlxyXG52YXIgdG91Y2ggPSAhd2luZG93LkxfTk9fVE9VQ0ggJiYgKHRvdWNoTmF0aXZlIHx8IHBvaW50ZXIpO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZU9wZXJhOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIGluIGEgbW9iaWxlIGRldmljZS5cclxudmFyIG1vYmlsZU9wZXJhID0gbW9iaWxlICYmIG9wZXJhO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZUdlY2tvOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbnZhciBtb2JpbGVHZWNrbyA9IG1vYmlsZSAmJiBnZWNrbztcclxuXHJcbi8vIEBwcm9wZXJ0eSByZXRpbmE6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBicm93c2VycyBvbiBhIGhpZ2gtcmVzb2x1dGlvbiBcInJldGluYVwiIHNjcmVlbiBvciBvbiBhbnkgc2NyZWVuIHdoZW4gYnJvd3NlcidzIGRpc3BsYXkgem9vbSBpcyBtb3JlIHRoYW4gMTAwJS5cclxudmFyIHJldGluYSA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAod2luZG93LnNjcmVlbi5kZXZpY2VYRFBJIC8gd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSSkpID4gMTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBwYXNzaXZlRXZlbnRzOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IHBhc3NpdmUgZXZlbnRzLlxyXG52YXIgcGFzc2l2ZUV2ZW50cyA9IChmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHN1cHBvcnRzUGFzc2l2ZU9wdGlvbiA9IGZhbHNlO1xyXG5cdHRyeSB7XHJcblx0XHR2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGdldHRlci1yZXR1cm5cclxuXHRcdFx0XHRzdXBwb3J0c1Bhc3NpdmVPcHRpb24gPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZUV2ZW50U3VwcG9ydCcsIFV0aWwuZmFsc2VGbiwgb3B0cyk7XHJcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmVFdmVudFN1cHBvcnQnLCBVdGlsLmZhbHNlRm4sIG9wdHMpO1xyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdC8vIEVycm9ycyBjYW4gc2FmZWx5IGJlIGlnbm9yZWQgc2luY2UgdGhpcyBpcyBvbmx5IGEgYnJvd3NlciBzdXBwb3J0IHRlc3QuXHJcblx0fVxyXG5cdHJldHVybiBzdXBwb3J0c1Bhc3NpdmVPcHRpb247XHJcbn0oKSk7XHJcblxyXG4vLyBAcHJvcGVydHkgY2FudmFzOiBCb29sZWFuXHJcbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXHJcbnZhciBjYW52YXMgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQ7XHJcbn0oKSk7XHJcblxyXG4vLyBAcHJvcGVydHkgc3ZnOiBCb29sZWFuXHJcbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXHJcbnZhciBzdmcgPSAhIShkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiYgc3ZnQ3JlYXRlKCdzdmcnKS5jcmVhdGVTVkdSZWN0KTtcclxuXHJcbnZhciBpbmxpbmVTdmcgPSAhIXN2ZyAmJiAoZnVuY3Rpb24gKCkge1xyXG5cdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRkaXYuaW5uZXJIVE1MID0gJzxzdmcvPic7XHJcblx0cmV0dXJuIChkaXYuZmlyc3RDaGlsZCAmJiBkaXYuZmlyc3RDaGlsZC5uYW1lc3BhY2VVUkkpID09PSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xyXG59KSgpO1xyXG5cclxuLy8gQHByb3BlcnR5IHZtbDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSkuXHJcbnZhciB2bWwgPSAhc3ZnICYmIChmdW5jdGlvbiAoKSB7XHJcblx0dHJ5IHtcclxuXHRcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdGRpdi5pbm5lckhUTUwgPSAnPHY6c2hhcGUgYWRqPVwiMVwiLz4nO1xyXG5cclxuXHRcdHZhciBzaGFwZSA9IGRpdi5maXJzdENoaWxkO1xyXG5cdFx0c2hhcGUuc3R5bGUuYmVoYXZpb3IgPSAndXJsKCNkZWZhdWx0I1ZNTCknO1xyXG5cclxuXHRcdHJldHVybiBzaGFwZSAmJiAodHlwZW9mIHNoYXBlLmFkaiA9PT0gJ29iamVjdCcpO1xyXG5cclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG59KCkpO1xyXG5cclxuXHJcbi8vIEBwcm9wZXJ0eSBtYWM6IEJvb2xlYW47IGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBNYWMgcGxhdGZvcm1cclxudmFyIG1hYyA9IG5hdmlnYXRvci5wbGF0Zm9ybS5pbmRleE9mKCdNYWMnKSA9PT0gMDtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtYWM6IEJvb2xlYW47IGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBMaW51eCBwbGF0Zm9ybVxyXG52YXIgbGludXggPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignTGludXgnKSA9PT0gMDtcclxuXHJcbmZ1bmN0aW9uIHVzZXJBZ2VudENvbnRhaW5zKHN0cikge1xyXG5cdHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzdHIpID49IDA7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0aWU6IGllLFxyXG5cdGllbHQ5OiBpZWx0OSxcclxuXHRlZGdlOiBlZGdlLFxyXG5cdHdlYmtpdDogd2Via2l0LFxyXG5cdGFuZHJvaWQ6IGFuZHJvaWQsXHJcblx0YW5kcm9pZDIzOiBhbmRyb2lkMjMsXHJcblx0YW5kcm9pZFN0b2NrOiBhbmRyb2lkU3RvY2ssXHJcblx0b3BlcmE6IG9wZXJhLFxyXG5cdGNocm9tZTogY2hyb21lLFxyXG5cdGdlY2tvOiBnZWNrbyxcclxuXHRzYWZhcmk6IHNhZmFyaSxcclxuXHRwaGFudG9tOiBwaGFudG9tLFxyXG5cdG9wZXJhMTI6IG9wZXJhMTIsXHJcblx0d2luOiB3aW4sXHJcblx0aWUzZDogaWUzZCxcclxuXHR3ZWJraXQzZDogd2Via2l0M2QsXHJcblx0Z2Vja28zZDogZ2Vja28zZCxcclxuXHRhbnkzZDogYW55M2QsXHJcblx0bW9iaWxlOiBtb2JpbGUsXHJcblx0bW9iaWxlV2Via2l0OiBtb2JpbGVXZWJraXQsXHJcblx0bW9iaWxlV2Via2l0M2Q6IG1vYmlsZVdlYmtpdDNkLFxyXG5cdG1zUG9pbnRlcjogbXNQb2ludGVyLFxyXG5cdHBvaW50ZXI6IHBvaW50ZXIsXHJcblx0dG91Y2g6IHRvdWNoLFxyXG5cdHRvdWNoTmF0aXZlOiB0b3VjaE5hdGl2ZSxcclxuXHRtb2JpbGVPcGVyYTogbW9iaWxlT3BlcmEsXHJcblx0bW9iaWxlR2Vja286IG1vYmlsZUdlY2tvLFxyXG5cdHJldGluYTogcmV0aW5hLFxyXG5cdHBhc3NpdmVFdmVudHM6IHBhc3NpdmVFdmVudHMsXHJcblx0Y2FudmFzOiBjYW52YXMsXHJcblx0c3ZnOiBzdmcsXHJcblx0dm1sOiB2bWwsXHJcblx0aW5saW5lU3ZnOiBpbmxpbmVTdmcsXHJcblx0bWFjOiBtYWMsXHJcblx0bGludXg6IGxpbnV4XHJcbn07XHJcbiIsImltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4vRG9tRXZlbnQnO1xuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCB7ZmFsc2VGbn0gZnJvbSAnLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEV4dGVuZHMgTC5Eb21FdmVudCB0byBwcm92aWRlIHRvdWNoIHN1cHBvcnQgZm9yIEludGVybmV0IEV4cGxvcmVyIGFuZCBXaW5kb3dzLWJhc2VkIGRldmljZXMuXG4gKi9cblxudmFyIFBPSU5URVJfRE9XTiA9ICAgQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgICA6ICdwb2ludGVyZG93bic7XG52YXIgUE9JTlRFUl9NT1ZFID0gICBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJNb3ZlJyAgIDogJ3BvaW50ZXJtb3ZlJztcbnZhciBQT0lOVEVSX1VQID0gICAgIEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlclVwJyAgICAgOiAncG9pbnRlcnVwJztcbnZhciBQT0lOVEVSX0NBTkNFTCA9IEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckNhbmNlbCcgOiAncG9pbnRlcmNhbmNlbCc7XG52YXIgcEV2ZW50ID0ge1xuXHR0b3VjaHN0YXJ0ICA6IFBPSU5URVJfRE9XTixcblx0dG91Y2htb3ZlICAgOiBQT0lOVEVSX01PVkUsXG5cdHRvdWNoZW5kICAgIDogUE9JTlRFUl9VUCxcblx0dG91Y2hjYW5jZWwgOiBQT0lOVEVSX0NBTkNFTFxufTtcbnZhciBoYW5kbGUgPSB7XG5cdHRvdWNoc3RhcnQgIDogX29uUG9pbnRlclN0YXJ0LFxuXHR0b3VjaG1vdmUgICA6IF9oYW5kbGVQb2ludGVyLFxuXHR0b3VjaGVuZCAgICA6IF9oYW5kbGVQb2ludGVyLFxuXHR0b3VjaGNhbmNlbCA6IF9oYW5kbGVQb2ludGVyXG59O1xudmFyIF9wb2ludGVycyA9IHt9O1xudmFyIF9wb2ludGVyRG9jTGlzdGVuZXIgPSBmYWxzZTtcblxuLy8gUHJvdmlkZXMgYSB0b3VjaCBldmVudHMgd3JhcHBlciBmb3IgKG1zKXBvaW50ZXIgZXZlbnRzLlxuLy8gcmVmIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyBodHRwczovL3d3dy53My5vcmcvQnVncy9QdWJsaWMvc2hvd19idWcuY2dpP2lkPTIyODkwXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyKSB7XG5cdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcblx0XHRfYWRkUG9pbnRlckRvY0xpc3RlbmVyKCk7XG5cdH1cblx0aWYgKCFoYW5kbGVbdHlwZV0pIHtcblx0XHRjb25zb2xlLndhcm4oJ3dyb25nIGV2ZW50IHNwZWNpZmllZDonLCB0eXBlKTtcblx0XHRyZXR1cm4gZmFsc2VGbjtcblx0fVxuXHRoYW5kbGVyID0gaGFuZGxlW3R5cGVdLmJpbmQodGhpcywgaGFuZGxlcik7XG5cdG9iai5hZGRFdmVudExpc3RlbmVyKHBFdmVudFt0eXBlXSwgaGFuZGxlciwgZmFsc2UpO1xuXHRyZXR1cm4gaGFuZGxlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIpIHtcblx0aWYgKCFwRXZlbnRbdHlwZV0pIHtcblx0XHRjb25zb2xlLndhcm4oJ3dyb25nIGV2ZW50IHNwZWNpZmllZDonLCB0eXBlKTtcblx0XHRyZXR1cm47XG5cdH1cblx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIocEV2ZW50W3R5cGVdLCBoYW5kbGVyLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyRG93bihlKSB7XG5cdF9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xufVxuXG5mdW5jdGlvbiBfZ2xvYmFsUG9pbnRlck1vdmUoZSkge1xuXHRpZiAoX3BvaW50ZXJzW2UucG9pbnRlcklkXSkge1xuXHRcdF9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyVXAoZSkge1xuXHRkZWxldGUgX3BvaW50ZXJzW2UucG9pbnRlcklkXTtcbn1cblxuZnVuY3Rpb24gX2FkZFBvaW50ZXJEb2NMaXN0ZW5lcigpIHtcblx0Ly8gbmVlZCB0byBrZWVwIHRyYWNrIG9mIHdoYXQgcG9pbnRlcnMgYW5kIGhvdyBtYW55IGFyZSBhY3RpdmUgdG8gcHJvdmlkZSBlLnRvdWNoZXMgZW11bGF0aW9uXG5cdGlmICghX3BvaW50ZXJEb2NMaXN0ZW5lcikge1xuXHRcdC8vIHdlIGxpc3RlbiBkb2N1bWVudCBhcyBhbnkgZHJhZ3MgdGhhdCBlbmQgYnkgbW92aW5nIHRoZSB0b3VjaCBvZmYgdGhlIHNjcmVlbiBnZXQgZmlyZWQgdGhlcmVcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfRE9XTiwgX2dsb2JhbFBvaW50ZXJEb3duLCB0cnVlKTtcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfTU9WRSwgX2dsb2JhbFBvaW50ZXJNb3ZlLCB0cnVlKTtcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfVVAsIF9nbG9iYWxQb2ludGVyVXAsIHRydWUpO1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9DQU5DRUwsIF9nbG9iYWxQb2ludGVyVXAsIHRydWUpO1xuXG5cdFx0X3BvaW50ZXJEb2NMaXN0ZW5lciA9IHRydWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gX2hhbmRsZVBvaW50ZXIoaGFuZGxlciwgZSkge1xuXHRpZiAoZS5wb2ludGVyVHlwZSA9PT0gKGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UgfHwgJ21vdXNlJykpIHsgcmV0dXJuOyB9XG5cblx0ZS50b3VjaGVzID0gW107XG5cdGZvciAodmFyIGkgaW4gX3BvaW50ZXJzKSB7XG5cdFx0ZS50b3VjaGVzLnB1c2goX3BvaW50ZXJzW2ldKTtcblx0fVxuXHRlLmNoYW5nZWRUb3VjaGVzID0gW2VdO1xuXG5cdGhhbmRsZXIoZSk7XG59XG5cbmZ1bmN0aW9uIF9vblBvaW50ZXJTdGFydChoYW5kbGVyLCBlKSB7XG5cdC8vIElFMTAgc3BlY2lmaWM6IE1zVG91Y2ggbmVlZHMgcHJldmVudERlZmF1bHQuIFNlZSAjMjAwMFxuXHRpZiAoZS5NU1BPSU5URVJfVFlQRV9UT1VDSCAmJiBlLnBvaW50ZXJUeXBlID09PSBlLk1TUE9JTlRFUl9UWVBFX1RPVUNIKSB7XG5cdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdH1cblx0X2hhbmRsZVBvaW50ZXIoaGFuZGxlciwgZSk7XG59XG4iLCJpbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuL0RvbUV2ZW50JztcclxuXHJcbi8qXHJcbiAqIEV4dGVuZHMgdGhlIGV2ZW50IGhhbmRsaW5nIGNvZGUgd2l0aCBkb3VibGUgdGFwIHN1cHBvcnQgZm9yIG1vYmlsZSBicm93c2Vycy5cclxuICpcclxuICogTm90ZTogY3VycmVudGx5IG1vc3QgYnJvd3NlcnMgZmlyZSBuYXRpdmUgZGJsY2xpY2ssIHdpdGggb25seSBhIGZldyBleGNlcHRpb25zXHJcbiAqIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvNzAxMiNpc3N1ZWNvbW1lbnQtNTk1MDg3Mzg2KVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1ha2VEYmxjbGljayhldmVudCkge1xyXG5cdC8vIGluIG1vZGVybiBicm93c2VycyBgdHlwZWAgY2Fubm90IGJlIGp1c3Qgb3ZlcnJpZGRlbjpcclxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9FcnJvcnMvR2V0dGVyX29ubHlcclxuXHR2YXIgbmV3RXZlbnQgPSB7fSxcclxuXHQgICAgcHJvcCwgaTtcclxuXHRmb3IgKGkgaW4gZXZlbnQpIHtcclxuXHRcdHByb3AgPSBldmVudFtpXTtcclxuXHRcdG5ld0V2ZW50W2ldID0gcHJvcCAmJiBwcm9wLmJpbmQgPyBwcm9wLmJpbmQoZXZlbnQpIDogcHJvcDtcclxuXHR9XHJcblx0ZXZlbnQgPSBuZXdFdmVudDtcclxuXHRuZXdFdmVudC50eXBlID0gJ2RibGNsaWNrJztcclxuXHRuZXdFdmVudC5kZXRhaWwgPSAyO1xyXG5cdG5ld0V2ZW50LmlzVHJ1c3RlZCA9IGZhbHNlO1xyXG5cdG5ld0V2ZW50Ll9zaW11bGF0ZWQgPSB0cnVlOyAvLyBmb3IgZGVidWcgcHVycG9zZXNcclxuXHRyZXR1cm4gbmV3RXZlbnQ7XHJcbn1cclxuXHJcbnZhciBkZWxheSA9IDIwMDtcclxuZXhwb3J0IGZ1bmN0aW9uIGFkZERvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlcikge1xyXG5cdC8vIE1vc3QgYnJvd3NlcnMgaGFuZGxlIGRvdWJsZSB0YXAgbmF0aXZlbHlcclxuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBoYW5kbGVyKTtcclxuXHJcblx0Ly8gT24gc29tZSBwbGF0Zm9ybXMgdGhlIGJyb3dzZXIgZG9lc24ndCBmaXJlIG5hdGl2ZSBkYmxjbGlja3MgZm9yIHRvdWNoIGV2ZW50cy5cclxuXHQvLyBJdCBzZWVtcyB0aGF0IGluIGFsbCBzdWNoIGNhc2VzIGBkZXRhaWxgIHByb3BlcnR5IG9mIGBjbGlja2AgZXZlbnQgaXMgYWx3YXlzIGAxYC5cclxuXHQvLyBTbyBoZXJlIHdlIHJlbHkgb24gdGhhdCBmYWN0IHRvIGF2b2lkIGV4Y2Vzc2l2ZSAnZGJsY2xpY2snIHNpbXVsYXRpb24gd2hlbiBub3QgbmVlZGVkLlxyXG5cdHZhciBsYXN0ID0gMCxcclxuXHQgICAgZGV0YWlsO1xyXG5cdGZ1bmN0aW9uIHNpbURibGNsaWNrKGUpIHtcclxuXHRcdGlmIChlLmRldGFpbCAhPT0gMSkge1xyXG5cdFx0XHRkZXRhaWwgPSBlLmRldGFpbDsgLy8ga2VlcCBpbiBzeW5jIHRvIGF2b2lkIGZhbHNlIGRibGNsaWNrIGluIHNvbWUgY2FzZXNcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8XHJcblx0XHRcdChlLnNvdXJjZUNhcGFiaWxpdGllcyAmJiAhZS5zb3VyY2VDYXBhYmlsaXRpZXMuZmlyZXNUb3VjaEV2ZW50cykpIHtcclxuXHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBXaGVuIGNsaWNraW5nIG9uIGFuIDxpbnB1dD4sIHRoZSBicm93c2VyIGdlbmVyYXRlcyBhIGNsaWNrIG9uIGl0c1xyXG5cdFx0Ly8gPGxhYmVsPiAoYW5kIHZpY2UgdmVyc2EpIHRyaWdnZXJpbmcgdHdvIGNsaWNrcyBpbiBxdWljayBzdWNjZXNzaW9uLlxyXG5cdFx0Ly8gVGhpcyBpZ25vcmVzIGNsaWNrcyBvbiBlbGVtZW50cyB3aGljaCBhcmUgYSBsYWJlbCB3aXRoIGEgJ2ZvcidcclxuXHRcdC8vIGF0dHJpYnV0ZSAob3IgY2hpbGRyZW4gb2Ygc3VjaCBhIGxhYmVsKSwgYnV0IG5vdCBjaGlsZHJlbiBvZlxyXG5cdFx0Ly8gYSA8aW5wdXQ+LlxyXG5cdFx0dmFyIHBhdGggPSBEb21FdmVudC5nZXRQcm9wYWdhdGlvblBhdGgoZSk7XHJcblx0XHRpZiAocGF0aC5zb21lKGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0XHRyZXR1cm4gZWwgaW5zdGFuY2VvZiBIVE1MTGFiZWxFbGVtZW50ICYmIGVsLmF0dHJpYnV0ZXMuZm9yO1xyXG5cdFx0fSkgJiZcclxuXHRcdFx0IXBhdGguc29tZShmdW5jdGlvbiAoZWwpIHtcclxuXHRcdFx0XHRyZXR1cm4gKFxyXG5cdFx0XHRcdFx0ZWwgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50IHx8XHJcblx0XHRcdFx0XHRlbCBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50XHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fSlcclxuXHRcdCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5vdyA9IERhdGUubm93KCk7XHJcblx0XHRpZiAobm93IC0gbGFzdCA8PSBkZWxheSkge1xyXG5cdFx0XHRkZXRhaWwrKztcclxuXHRcdFx0aWYgKGRldGFpbCA9PT0gMikge1xyXG5cdFx0XHRcdGhhbmRsZXIobWFrZURibGNsaWNrKGUpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZGV0YWlsID0gMTtcclxuXHRcdH1cclxuXHRcdGxhc3QgPSBub3c7XHJcblx0fVxyXG5cclxuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzaW1EYmxjbGljayk7XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHRkYmxjbGljazogaGFuZGxlcixcclxuXHRcdHNpbURibGNsaWNrOiBzaW1EYmxjbGlja1xyXG5cdH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXJzKSB7XHJcblx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgaGFuZGxlcnMuZGJsY2xpY2spO1xyXG5cdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXJzLnNpbURibGNsaWNrKTtcclxufVxyXG4iLCJpbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIERvbVV0aWxcclxuICpcclxuICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRoZSBbRE9NXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRG9jdW1lbnRfT2JqZWN0X01vZGVsKVxyXG4gKiB0cmVlLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICpcclxuICogTW9zdCBmdW5jdGlvbnMgZXhwZWN0aW5nIG9yIHJldHVybmluZyBhIGBIVE1MRWxlbWVudGAgYWxzbyB3b3JrIGZvclxyXG4gKiBTVkcgZWxlbWVudHMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCBjbGFzc2VzIHJlZmVyIHRvIENTUyBjbGFzc2VzXHJcbiAqIGluIEhUTUwgYW5kIFNWRyBjbGFzc2VzIGluIFNWRy5cclxuICovXHJcblxyXG5cclxuLy8gQHByb3BlcnR5IFRSQU5TRk9STTogU3RyaW5nXHJcbi8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2Zvcm0gc3R5bGUgbmFtZSAoZS5nLiBgJ3dlYmtpdFRyYW5zZm9ybSdgIGZvciBXZWJLaXQpLlxyXG5leHBvcnQgdmFyIFRSQU5TRk9STSA9IHRlc3RQcm9wKFxyXG5cdFsndHJhbnNmb3JtJywgJ3dlYmtpdFRyYW5zZm9ybScsICdPVHJhbnNmb3JtJywgJ01velRyYW5zZm9ybScsICdtc1RyYW5zZm9ybSddKTtcclxuXHJcbi8vIHdlYmtpdFRyYW5zaXRpb24gY29tZXMgZmlyc3QgYmVjYXVzZSBzb21lIGJyb3dzZXIgdmVyc2lvbnMgdGhhdCBkcm9wIHZlbmRvciBwcmVmaXggZG9uJ3QgZG9cclxuLy8gdGhlIHNhbWUgZm9yIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50LCBpbiBwYXJ0aWN1bGFyIHRoZSBBbmRyb2lkIDQuMSBzdG9jayBicm93c2VyXHJcblxyXG4vLyBAcHJvcGVydHkgVFJBTlNJVElPTjogU3RyaW5nXHJcbi8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2l0aW9uIHN0eWxlIG5hbWUuXHJcbmV4cG9ydCB2YXIgVFJBTlNJVElPTiA9IHRlc3RQcm9wKFxyXG5cdFsnd2Via2l0VHJhbnNpdGlvbicsICd0cmFuc2l0aW9uJywgJ09UcmFuc2l0aW9uJywgJ01velRyYW5zaXRpb24nLCAnbXNUcmFuc2l0aW9uJ10pO1xyXG5cclxuLy8gQHByb3BlcnR5IFRSQU5TSVRJT05fRU5EOiBTdHJpbmdcclxuLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zaXRpb25lbmQgZXZlbnQgbmFtZS5cclxuZXhwb3J0IHZhciBUUkFOU0lUSU9OX0VORCA9XHJcblx0VFJBTlNJVElPTiA9PT0gJ3dlYmtpdFRyYW5zaXRpb24nIHx8IFRSQU5TSVRJT04gPT09ICdPVHJhbnNpdGlvbicgPyBUUkFOU0lUSU9OICsgJ0VuZCcgOiAndHJhbnNpdGlvbmVuZCc7XHJcblxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldChpZDogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuLy8gUmV0dXJucyBhbiBlbGVtZW50IGdpdmVuIGl0cyBET00gaWQsIG9yIHJldHVybnMgdGhlIGVsZW1lbnQgaXRzZWxmXHJcbi8vIGlmIGl0IHdhcyBwYXNzZWQgZGlyZWN0bHkuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXQoaWQpIHtcclxuXHRyZXR1cm4gdHlwZW9mIGlkID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IGlkO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0U3R5bGUoZWw6IEhUTUxFbGVtZW50LCBzdHlsZUF0dHJpYjogU3RyaW5nKTogU3RyaW5nXHJcbi8vIFJldHVybnMgdGhlIHZhbHVlIGZvciBhIGNlcnRhaW4gc3R5bGUgYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQsXHJcbi8vIGluY2x1ZGluZyBjb21wdXRlZCB2YWx1ZXMgb3IgdmFsdWVzIHNldCB0aHJvdWdoIENTUy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0eWxlKGVsLCBzdHlsZSkge1xyXG5cdHZhciB2YWx1ZSA9IGVsLnN0eWxlW3N0eWxlXSB8fCAoZWwuY3VycmVudFN0eWxlICYmIGVsLmN1cnJlbnRTdHlsZVtzdHlsZV0pO1xyXG5cclxuXHRpZiAoKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gJ2F1dG8nKSAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldykge1xyXG5cdFx0dmFyIGNzcyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpO1xyXG5cdFx0dmFsdWUgPSBjc3MgPyBjc3Nbc3R5bGVdIDogbnVsbDtcclxuXHR9XHJcblx0cmV0dXJuIHZhbHVlID09PSAnYXV0bycgPyBudWxsIDogdmFsdWU7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjcmVhdGUodGFnTmFtZTogU3RyaW5nLCBjbGFzc05hbWU/OiBTdHJpbmcsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuLy8gQ3JlYXRlcyBhbiBIVE1MIGVsZW1lbnQgd2l0aCBgdGFnTmFtZWAsIHNldHMgaXRzIGNsYXNzIHRvIGBjbGFzc05hbWVgLCBhbmQgb3B0aW9uYWxseSBhcHBlbmRzIGl0IHRvIGBjb250YWluZXJgIGVsZW1lbnQuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUodGFnTmFtZSwgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcclxuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xyXG5cdGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCAnJztcclxuXHJcblx0aWYgKGNvbnRhaW5lcikge1xyXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcclxuXHR9XHJcblx0cmV0dXJuIGVsO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVtb3ZlKGVsOiBIVE1MRWxlbWVudClcclxuLy8gUmVtb3ZlcyBgZWxgIGZyb20gaXRzIHBhcmVudCBlbGVtZW50XHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmUoZWwpIHtcclxuXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRpZiAocGFyZW50KSB7XHJcblx0XHRwYXJlbnQucmVtb3ZlQ2hpbGQoZWwpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGVtcHR5KGVsOiBIVE1MRWxlbWVudClcclxuLy8gUmVtb3ZlcyBhbGwgb2YgYGVsYCdzIGNoaWxkcmVuIGVsZW1lbnRzIGZyb20gYGVsYFxyXG5leHBvcnQgZnVuY3Rpb24gZW1wdHkoZWwpIHtcclxuXHR3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xyXG5cdFx0ZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdG9Gcm9udChlbDogSFRNTEVsZW1lbnQpXHJcbi8vIE1ha2VzIGBlbGAgdGhlIGxhc3QgY2hpbGQgb2YgaXRzIHBhcmVudCwgc28gaXQgcmVuZGVycyBpbiBmcm9udCBvZiB0aGUgb3RoZXIgY2hpbGRyZW4uXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0Zyb250KGVsKSB7XHJcblx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcblx0aWYgKHBhcmVudCAmJiBwYXJlbnQubGFzdENoaWxkICE9PSBlbCkge1xyXG5cdFx0cGFyZW50LmFwcGVuZENoaWxkKGVsKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0b0JhY2soZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBNYWtlcyBgZWxgIHRoZSBmaXJzdCBjaGlsZCBvZiBpdHMgcGFyZW50LCBzbyBpdCByZW5kZXJzIGJlaGluZCB0aGUgb3RoZXIgY2hpbGRyZW4uXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0JhY2soZWwpIHtcclxuXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRpZiAocGFyZW50ICYmIHBhcmVudC5maXJzdENoaWxkICE9PSBlbCkge1xyXG5cdFx0cGFyZW50Lmluc2VydEJlZm9yZShlbCwgcGFyZW50LmZpcnN0Q2hpbGQpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGhhc0NsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKTogQm9vbGVhblxyXG4vLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZSBjb250YWlucyBgbmFtZWAuXHJcbmV4cG9ydCBmdW5jdGlvbiBoYXNDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKTtcclxuXHR9XHJcblx0dmFyIGNsYXNzTmFtZSA9IGdldENsYXNzKGVsKTtcclxuXHRyZXR1cm4gY2xhc3NOYW1lLmxlbmd0aCA+IDAgJiYgbmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIG5hbWUgKyAnKFxcXFxzfCQpJykudGVzdChjbGFzc05hbWUpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gYWRkQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbi8vIEFkZHMgYG5hbWVgIHRvIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxyXG5leHBvcnQgZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHZhciBjbGFzc2VzID0gVXRpbC5zcGxpdFdvcmRzKG5hbWUpO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0ZWwuY2xhc3NMaXN0LmFkZChjbGFzc2VzW2ldKTtcclxuXHRcdH1cclxuXHR9IGVsc2UgaWYgKCFoYXNDbGFzcyhlbCwgbmFtZSkpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSBnZXRDbGFzcyhlbCk7XHJcblx0XHRzZXRDbGFzcyhlbCwgKGNsYXNzTmFtZSA/IGNsYXNzTmFtZSArICcgJyA6ICcnKSArIG5hbWUpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4vLyBSZW1vdmVzIGBuYW1lYCBmcm9tIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdGVsLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHNldENsYXNzKGVsLCBVdGlsLnRyaW0oKCcgJyArIGdldENsYXNzKGVsKSArICcgJykucmVwbGFjZSgnICcgKyBuYW1lICsgJyAnLCAnICcpKSk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbi8vIFNldHMgdGhlIGVsZW1lbnQncyBjbGFzcy5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldENsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSB1bmRlZmluZWQpIHtcclxuXHRcdGVsLmNsYXNzTmFtZSA9IG5hbWU7XHJcblx0fSBlbHNlIHtcclxuXHRcdC8vIGluIGNhc2Ugb2YgU1ZHIGVsZW1lbnRcclxuXHRcdGVsLmNsYXNzTmFtZS5iYXNlVmFsID0gbmFtZTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRDbGFzcyhlbDogSFRNTEVsZW1lbnQpOiBTdHJpbmdcclxuLy8gUmV0dXJucyB0aGUgZWxlbWVudCdzIGNsYXNzLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xhc3MoZWwpIHtcclxuXHQvLyBDaGVjayBpZiB0aGUgZWxlbWVudCBpcyBhbiBTVkdFbGVtZW50SW5zdGFuY2UgYW5kIHVzZSB0aGUgY29ycmVzcG9uZGluZ0VsZW1lbnQgaW5zdGVhZFxyXG5cdC8vIChSZXF1aXJlZCBmb3IgbGlua2VkIFNWRyBlbGVtZW50cyBpbiBJRTExLilcclxuXHRpZiAoZWwuY29ycmVzcG9uZGluZ0VsZW1lbnQpIHtcclxuXHRcdGVsID0gZWwuY29ycmVzcG9uZGluZ0VsZW1lbnQ7XHJcblx0fVxyXG5cdHJldHVybiBlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkID8gZWwuY2xhc3NOYW1lIDogZWwuY2xhc3NOYW1lLmJhc2VWYWw7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRPcGFjaXR5KGVsOiBIVE1MRWxlbWVudCwgb3BhY2l0eTogTnVtYmVyKVxyXG4vLyBTZXQgdGhlIG9wYWNpdHkgb2YgYW4gZWxlbWVudCAoaW5jbHVkaW5nIG9sZCBJRSBzdXBwb3J0KS5cclxuLy8gYG9wYWNpdHlgIG11c3QgYmUgYSBudW1iZXIgZnJvbSBgMGAgdG8gYDFgLlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0T3BhY2l0eShlbCwgdmFsdWUpIHtcclxuXHRpZiAoJ29wYWNpdHknIGluIGVsLnN0eWxlKSB7XHJcblx0XHRlbC5zdHlsZS5vcGFjaXR5ID0gdmFsdWU7XHJcblx0fSBlbHNlIGlmICgnZmlsdGVyJyBpbiBlbC5zdHlsZSkge1xyXG5cdFx0X3NldE9wYWNpdHlJRShlbCwgdmFsdWUpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gX3NldE9wYWNpdHlJRShlbCwgdmFsdWUpIHtcclxuXHR2YXIgZmlsdGVyID0gZmFsc2UsXHJcblx0ICAgIGZpbHRlck5hbWUgPSAnRFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEnO1xyXG5cclxuXHQvLyBmaWx0ZXJzIGNvbGxlY3Rpb24gdGhyb3dzIGFuIGVycm9yIGlmIHdlIHRyeSB0byByZXRyaWV2ZSBhIGZpbHRlciB0aGF0IGRvZXNuJ3QgZXhpc3RcclxuXHR0cnkge1xyXG5cdFx0ZmlsdGVyID0gZWwuZmlsdGVycy5pdGVtKGZpbHRlck5hbWUpO1xyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdC8vIGRvbid0IHNldCBvcGFjaXR5IHRvIDEgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IHNldCBhbiBvcGFjaXR5LFxyXG5cdFx0Ly8gaXQgaXNuJ3QgbmVlZGVkIGFuZCBicmVha3MgdHJhbnNwYXJlbnQgcG5ncy5cclxuXHRcdGlmICh2YWx1ZSA9PT0gMSkgeyByZXR1cm47IH1cclxuXHR9XHJcblxyXG5cdHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCk7XHJcblxyXG5cdGlmIChmaWx0ZXIpIHtcclxuXHRcdGZpbHRlci5FbmFibGVkID0gKHZhbHVlICE9PSAxMDApO1xyXG5cdFx0ZmlsdGVyLk9wYWNpdHkgPSB2YWx1ZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZWwuc3R5bGUuZmlsdGVyICs9ICcgcHJvZ2lkOicgKyBmaWx0ZXJOYW1lICsgJyhvcGFjaXR5PScgKyB2YWx1ZSArICcpJztcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0ZXN0UHJvcChwcm9wczogU3RyaW5nW10pOiBTdHJpbmd8ZmFsc2VcclxuLy8gR29lcyB0aHJvdWdoIHRoZSBhcnJheSBvZiBzdHlsZSBuYW1lcyBhbmQgcmV0dXJucyB0aGUgZmlyc3QgbmFtZVxyXG4vLyB0aGF0IGlzIGEgdmFsaWQgc3R5bGUgbmFtZSBmb3IgYW4gZWxlbWVudC4gSWYgbm8gc3VjaCBuYW1lIGlzIGZvdW5kLFxyXG4vLyBpdCByZXR1cm5zIGZhbHNlLiBVc2VmdWwgZm9yIHZlbmRvci1wcmVmaXhlZCBzdHlsZXMgbGlrZSBgdHJhbnNmb3JtYC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzKSB7XHJcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAocHJvcHNbaV0gaW4gc3R5bGUpIHtcclxuXHRcdFx0cmV0dXJuIHByb3BzW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWw6IEhUTUxFbGVtZW50LCBvZmZzZXQ6IFBvaW50LCBzY2FsZT86IE51bWJlcilcclxuLy8gUmVzZXRzIHRoZSAzRCBDU1MgdHJhbnNmb3JtIG9mIGBlbGAgc28gaXQgaXMgdHJhbnNsYXRlZCBieSBgb2Zmc2V0YCBwaXhlbHNcclxuLy8gYW5kIG9wdGlvbmFsbHkgc2NhbGVkIGJ5IGBzY2FsZWAuIERvZXMgbm90IGhhdmUgYW4gZWZmZWN0IGlmIHRoZVxyXG4vLyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCAzRCBDU1MgdHJhbnNmb3Jtcy5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFRyYW5zZm9ybShlbCwgb2Zmc2V0LCBzY2FsZSkge1xyXG5cdHZhciBwb3MgPSBvZmZzZXQgfHwgbmV3IFBvaW50KDAsIDApO1xyXG5cclxuXHRlbC5zdHlsZVtUUkFOU0ZPUk1dID1cclxuXHRcdChCcm93c2VyLmllM2QgP1xyXG5cdFx0XHQndHJhbnNsYXRlKCcgKyBwb3MueCArICdweCwnICsgcG9zLnkgKyAncHgpJyA6XHJcblx0XHRcdCd0cmFuc2xhdGUzZCgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4LDApJykgK1xyXG5cdFx0KHNjYWxlID8gJyBzY2FsZSgnICsgc2NhbGUgKyAnKScgOiAnJyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRQb3NpdGlvbihlbDogSFRNTEVsZW1lbnQsIHBvc2l0aW9uOiBQb2ludClcclxuLy8gU2V0cyB0aGUgcG9zaXRpb24gb2YgYGVsYCB0byBjb29yZGluYXRlcyBzcGVjaWZpZWQgYnkgYHBvc2l0aW9uYCxcclxuLy8gdXNpbmcgQ1NTIHRyYW5zbGF0ZSBvciB0b3AvbGVmdCBwb3NpdGlvbmluZyBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXJcclxuLy8gKHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5IHRvIHBvc2l0aW9uIGl0cyBsYXllcnMpLlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0UG9zaXRpb24oZWwsIHBvaW50KSB7XHJcblxyXG5cdC8qZXNsaW50LWRpc2FibGUgKi9cclxuXHRlbC5fbGVhZmxldF9wb3MgPSBwb2ludDtcclxuXHQvKiBlc2xpbnQtZW5hYmxlICovXHJcblxyXG5cdGlmIChCcm93c2VyLmFueTNkKSB7XHJcblx0XHRzZXRUcmFuc2Zvcm0oZWwsIHBvaW50KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZWwuc3R5bGUubGVmdCA9IHBvaW50LnggKyAncHgnO1xyXG5cdFx0ZWwuc3R5bGUudG9wID0gcG9pbnQueSArICdweCc7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWw6IEhUTUxFbGVtZW50KTogUG9pbnRcclxuLy8gUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgYW4gZWxlbWVudCBwcmV2aW91c2x5IHBvc2l0aW9uZWQgd2l0aCBzZXRQb3NpdGlvbi5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsKSB7XHJcblx0Ly8gdGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGZvciBlbGVtZW50cyBwcmV2aW91c2x5IHBvc2l0aW9uZWQgdXNpbmcgc2V0UG9zaXRpb24sXHJcblx0Ly8gc28gaXQncyBzYWZlIHRvIGNhY2hlIHRoZSBwb3NpdGlvbiBmb3IgcGVyZm9ybWFuY2VcclxuXHJcblx0cmV0dXJuIGVsLl9sZWFmbGV0X3BvcyB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBkaXNhYmxlVGV4dFNlbGVjdGlvbigpXHJcbi8vIFByZXZlbnRzIHRoZSB1c2VyIGZyb20gZ2VuZXJhdGluZyBgc2VsZWN0c3RhcnRgIERPTSBldmVudHMsIHVzdWFsbHkgZ2VuZXJhdGVkXHJcbi8vIHdoZW4gdGhlIHVzZXIgZHJhZ3MgdGhlIG1vdXNlIHRocm91Z2ggYSBwYWdlIHdpdGggdGV4dC4gVXNlZCBpbnRlcm5hbGx5XHJcbi8vIGJ5IExlYWZsZXQgdG8gb3ZlcnJpZGUgdGhlIGJlaGF2aW91ciBvZiBhbnkgY2xpY2stYW5kLWRyYWcgaW50ZXJhY3Rpb24gb25cclxuLy8gdGhlIG1hcC4gQWZmZWN0cyBkcmFnIGludGVyYWN0aW9ucyBvbiB0aGUgd2hvbGUgZG9jdW1lbnQuXHJcblxyXG4vLyBAZnVuY3Rpb24gZW5hYmxlVGV4dFNlbGVjdGlvbigpXHJcbi8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbmBdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxuZXhwb3J0IHZhciBkaXNhYmxlVGV4dFNlbGVjdGlvbjtcclxuZXhwb3J0IHZhciBlbmFibGVUZXh0U2VsZWN0aW9uO1xyXG52YXIgX3VzZXJTZWxlY3Q7XHJcbmlmICgnb25zZWxlY3RzdGFydCcgaW4gZG9jdW1lbnQpIHtcclxuXHRkaXNhYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbUV2ZW50Lm9uKHdpbmRvdywgJ3NlbGVjdHN0YXJ0JywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdH07XHJcblx0ZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbUV2ZW50Lm9mZih3aW5kb3csICdzZWxlY3RzdGFydCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHR9O1xyXG59IGVsc2Uge1xyXG5cdHZhciB1c2VyU2VsZWN0UHJvcGVydHkgPSB0ZXN0UHJvcChcclxuXHRcdFsndXNlclNlbGVjdCcsICdXZWJraXRVc2VyU2VsZWN0JywgJ09Vc2VyU2VsZWN0JywgJ01velVzZXJTZWxlY3QnLCAnbXNVc2VyU2VsZWN0J10pO1xyXG5cclxuXHRkaXNhYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuXHRcdFx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cdFx0XHRfdXNlclNlbGVjdCA9IHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV07XHJcblx0XHRcdHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSAnbm9uZSc7XHJcblx0XHR9XHJcblx0fTtcclxuXHRlbmFibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9IF91c2VyU2VsZWN0O1xyXG5cdFx0XHRfdXNlclNlbGVjdCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZUltYWdlRHJhZygpXHJcbi8vIEFzIFtgTC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLCBidXRcclxuLy8gZm9yIGBkcmFnc3RhcnRgIERPTSBldmVudHMsIHVzdWFsbHkgZ2VuZXJhdGVkIHdoZW4gdGhlIHVzZXIgZHJhZ3MgYW4gaW1hZ2UuXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlSW1hZ2VEcmFnKCkge1xyXG5cdERvbUV2ZW50Lm9uKHdpbmRvdywgJ2RyYWdzdGFydCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGVuYWJsZUltYWdlRHJhZygpXHJcbi8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLlxyXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlSW1hZ2VEcmFnKCkge1xyXG5cdERvbUV2ZW50Lm9mZih3aW5kb3csICdkcmFnc3RhcnQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcbn1cclxuXHJcbnZhciBfb3V0bGluZUVsZW1lbnQsIF9vdXRsaW5lU3R5bGU7XHJcbi8vIEBmdW5jdGlvbiBwcmV2ZW50T3V0bGluZShlbDogSFRNTEVsZW1lbnQpXHJcbi8vIE1ha2VzIHRoZSBbb3V0bGluZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQ1NTL291dGxpbmUpXHJcbi8vIG9mIHRoZSBlbGVtZW50IGBlbGAgaW52aXNpYmxlLiBVc2VkIGludGVybmFsbHkgYnkgTGVhZmxldCB0byBwcmV2ZW50XHJcbi8vIGZvY3VzYWJsZSBlbGVtZW50cyBmcm9tIGRpc3BsYXlpbmcgYW4gb3V0bGluZSB3aGVuIHRoZSB1c2VyIHBlcmZvcm1zIGFcclxuLy8gZHJhZyBpbnRlcmFjdGlvbiBvbiB0aGVtLlxyXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudE91dGxpbmUoZWxlbWVudCkge1xyXG5cdHdoaWxlIChlbGVtZW50LnRhYkluZGV4ID09PSAtMSkge1xyXG5cdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcclxuXHR9XHJcblx0aWYgKCFlbGVtZW50LnN0eWxlKSB7IHJldHVybjsgfVxyXG5cdHJlc3RvcmVPdXRsaW5lKCk7XHJcblx0X291dGxpbmVFbGVtZW50ID0gZWxlbWVudDtcclxuXHRfb3V0bGluZVN0eWxlID0gZWxlbWVudC5zdHlsZS5vdXRsaW5lU3R5bGU7XHJcblx0ZWxlbWVudC5zdHlsZS5vdXRsaW5lU3R5bGUgPSAnbm9uZSc7XHJcblx0RG9tRXZlbnQub24od2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKClcclxuLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLnByZXZlbnRPdXRsaW5lYF0oKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKCkge1xyXG5cdGlmICghX291dGxpbmVFbGVtZW50KSB7IHJldHVybjsgfVxyXG5cdF9vdXRsaW5lRWxlbWVudC5zdHlsZS5vdXRsaW5lU3R5bGUgPSBfb3V0bGluZVN0eWxlO1xyXG5cdF9vdXRsaW5lRWxlbWVudCA9IHVuZGVmaW5lZDtcclxuXHRfb3V0bGluZVN0eWxlID0gdW5kZWZpbmVkO1xyXG5cdERvbUV2ZW50Lm9mZih3aW5kb3csICdrZXlkb3duJywgcmVzdG9yZU91dGxpbmUpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0U2l6ZWRQYXJlbnROb2RlKGVsOiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbi8vIEZpbmRzIHRoZSBjbG9zZXN0IHBhcmVudCBub2RlIHdoaWNoIHNpemUgKHdpZHRoIGFuZCBoZWlnaHQpIGlzIG5vdCBudWxsLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2l6ZWRQYXJlbnROb2RlKGVsZW1lbnQpIHtcclxuXHRkbyB7XHJcblx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG5cdH0gd2hpbGUgKCghZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAhZWxlbWVudC5vZmZzZXRIZWlnaHQpICYmIGVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkpO1xyXG5cdHJldHVybiBlbGVtZW50O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0U2NhbGUoZWw6IEhUTUxFbGVtZW50KTogT2JqZWN0XHJcbi8vIENvbXB1dGVzIHRoZSBDU1Mgc2NhbGUgY3VycmVudGx5IGFwcGxpZWQgb24gdGhlIGVsZW1lbnQuXHJcbi8vIFJldHVybnMgYW4gb2JqZWN0IHdpdGggYHhgIGFuZCBgeWAgbWVtYmVycyBhcyBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBzY2FsZXMgcmVzcGVjdGl2ZWx5LFxyXG4vLyBhbmQgYGJvdW5kaW5nQ2xpZW50UmVjdGAgYXMgdGhlIHJlc3VsdCBvZiBbYGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvZ2V0Qm91bmRpbmdDbGllbnRSZWN0KS5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjYWxlKGVsZW1lbnQpIHtcclxuXHR2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIFJlYWQtb25seSBpbiBvbGQgYnJvd3NlcnMuXHJcblxyXG5cdHJldHVybiB7XHJcblx0XHR4OiByZWN0LndpZHRoIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxLFxyXG5cdFx0eTogcmVjdC5oZWlnaHQgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxLFxyXG5cdFx0Ym91bmRpbmdDbGllbnRSZWN0OiByZWN0XHJcblx0fTtcclxufVxyXG4iLCJpbXBvcnQge1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0IHthZGRQb2ludGVyTGlzdGVuZXIsIHJlbW92ZVBvaW50ZXJMaXN0ZW5lcn0gZnJvbSAnLi9Eb21FdmVudC5Qb2ludGVyJztcclxuaW1wb3J0IHthZGREb3VibGVUYXBMaXN0ZW5lciwgcmVtb3ZlRG91YmxlVGFwTGlzdGVuZXJ9IGZyb20gJy4vRG9tRXZlbnQuRG91YmxlVGFwJztcclxuaW1wb3J0IHtnZXRTY2FsZX0gZnJvbSAnLi9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgRG9tRXZlbnRcclxuICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRoZSBbRE9NIGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0V2ZW50KSwgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqL1xyXG5cclxuLy8gSW5zcGlyZWQgYnkgSm9obiBSZXNpZywgRGVhbiBFZHdhcmRzIGFuZCBZVUkgYWRkRXZlbnQgaW1wbGVtZW50YXRpb25zLlxyXG5cclxuLy8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4vLyBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBET00gZXZlbnQgdHlwZSBvZiB0aGVcclxuLy8gZWxlbWVudCBgZWxgLiBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgY29udGV4dCBvZiB0aGUgbGlzdGVuZXJcclxuLy8gKG9iamVjdCB0aGUgYHRoaXNgIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWxcclxuLy8gc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgZXZlbnRNYXA6IE9iamVjdCwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5leHBvcnQgZnVuY3Rpb24gb24ob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0aWYgKHR5cGVzICYmIHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0YWRkT25lKG9iaiwgdHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0dHlwZXMgPSBVdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRhZGRPbmUob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbnZhciBldmVudHNLZXkgPSAnX2xlYWZsZXRfZXZlbnRzJztcclxuXHJcbi8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLlxyXG4vLyBOb3RlIHRoYXQgaWYgeW91IHBhc3NlZCBhIGN1c3RvbSBjb250ZXh0IHRvIG9uLCB5b3UgbXVzdCBwYXNzIHRoZSBzYW1lXHJcbi8vIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgZXZlbnRNYXA6IE9iamVjdCwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nKTogdGhpc1xyXG4vLyBSZW1vdmVzIGFsbCBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVycyBvZiBnaXZlbiB0eXBlcy5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuLy8gUmVtb3ZlcyBhbGwgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lcnMgZnJvbSBnaXZlbiBIVE1MRWxlbWVudFxyXG5leHBvcnQgZnVuY3Rpb24gb2ZmKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XHJcblx0XHRiYXRjaFJlbW92ZShvYmopO1xyXG5cdFx0ZGVsZXRlIG9ialtldmVudHNLZXldO1xyXG5cclxuXHR9IGVsc2UgaWYgKHR5cGVzICYmIHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0cmVtb3ZlT25lKG9iaiwgdHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIHtcclxuXHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xyXG5cdFx0XHRiYXRjaFJlbW92ZShvYmosIGZ1bmN0aW9uICh0eXBlKSB7XHJcblx0XHRcdFx0cmV0dXJuIFV0aWwuaW5kZXhPZih0eXBlcywgdHlwZSkgIT09IC0xO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHJlbW92ZU9uZShvYmosIHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBiYXRjaFJlbW92ZShvYmosIGZpbHRlckZuKSB7XHJcblx0Zm9yICh2YXIgaWQgaW4gb2JqW2V2ZW50c0tleV0pIHtcclxuXHRcdHZhciB0eXBlID0gaWQuc3BsaXQoL1xcZC8pWzBdO1xyXG5cdFx0aWYgKCFmaWx0ZXJGbiB8fCBmaWx0ZXJGbih0eXBlKSkge1xyXG5cdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlLCBudWxsLCBudWxsLCBpZCk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG52YXIgbW91c2VTdWJzdCA9IHtcclxuXHRtb3VzZWVudGVyOiAnbW91c2VvdmVyJyxcclxuXHRtb3VzZWxlYXZlOiAnbW91c2VvdXQnLFxyXG5cdHdoZWVsOiAhKCdvbndoZWVsJyBpbiB3aW5kb3cpICYmICdtb3VzZXdoZWVsJ1xyXG59O1xyXG5cclxuZnVuY3Rpb24gYWRkT25lKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHR2YXIgaWQgPSB0eXBlICsgVXRpbC5zdGFtcChmbikgKyAoY29udGV4dCA/ICdfJyArIFV0aWwuc3RhbXAoY29udGV4dCkgOiAnJyk7XHJcblxyXG5cdGlmIChvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF0pIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIGZuLmNhbGwoY29udGV4dCB8fCBvYmosIGUgfHwgd2luZG93LmV2ZW50KTtcclxuXHR9O1xyXG5cclxuXHR2YXIgb3JpZ2luYWxIYW5kbGVyID0gaGFuZGxlcjtcclxuXHJcblx0aWYgKCFCcm93c2VyLnRvdWNoTmF0aXZlICYmIEJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdC8vIE5lZWRzIERvbUV2ZW50LlBvaW50ZXIuanNcclxuXHRcdGhhbmRsZXIgPSBhZGRQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyKTtcclxuXHJcblx0fSBlbHNlIGlmIChCcm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSkge1xyXG5cdFx0aGFuZGxlciA9IGFkZERvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlcik7XHJcblxyXG5cdH0gZWxzZSBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcgfHwgdHlwZSA9PT0gJ3RvdWNobW92ZScgfHwgdHlwZSA9PT0gJ3doZWVsJyB8fCAgdHlwZSA9PT0gJ21vdXNld2hlZWwnKSB7XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKG1vdXNlU3Vic3RbdHlwZV0gfHwgdHlwZSwgaGFuZGxlciwgQnJvd3Nlci5wYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdtb3VzZWVudGVyJyB8fCB0eXBlID09PSAnbW91c2VsZWF2ZScpIHtcclxuXHRcdFx0aGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0ZSA9IGUgfHwgd2luZG93LmV2ZW50O1xyXG5cdFx0XHRcdGlmIChpc0V4dGVybmFsVGFyZ2V0KG9iaiwgZSkpIHtcclxuXHRcdFx0XHRcdG9yaWdpbmFsSGFuZGxlcihlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKG1vdXNlU3Vic3RbdHlwZV0sIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBvcmlnaW5hbEhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIHtcclxuXHRcdG9iai5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcblx0fVxyXG5cclxuXHRvYmpbZXZlbnRzS2V5XSA9IG9ialtldmVudHNLZXldIHx8IHt9O1xyXG5cdG9ialtldmVudHNLZXldW2lkXSA9IGhhbmRsZXI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZU9uZShvYmosIHR5cGUsIGZuLCBjb250ZXh0LCBpZCkge1xyXG5cdGlkID0gaWQgfHwgdHlwZSArIFV0aWwuc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBVdGlsLnN0YW1wKGNvbnRleHQpIDogJycpO1xyXG5cdHZhciBoYW5kbGVyID0gb2JqW2V2ZW50c0tleV0gJiYgb2JqW2V2ZW50c0tleV1baWRdO1xyXG5cclxuXHRpZiAoIWhhbmRsZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0aWYgKCFCcm93c2VyLnRvdWNoTmF0aXZlICYmIEJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdHJlbW92ZVBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIpO1xyXG5cclxuXHR9IGVsc2UgaWYgKEJyb3dzZXIudG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpKSB7XHJcblx0XHRyZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIpO1xyXG5cclxuXHR9IGVsc2UgaWYgKCdyZW1vdmVFdmVudExpc3RlbmVyJyBpbiBvYmopIHtcclxuXHJcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihtb3VzZVN1YnN0W3R5cGVdIHx8IHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHRcdG9iai5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcblx0fVxyXG5cclxuXHRvYmpbZXZlbnRzS2V5XVtpZF0gPSBudWxsO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGV2OiBET01FdmVudCk6IHRoaXNcclxuLy8gU3RvcCB0aGUgZ2l2ZW4gZXZlbnQgZnJvbSBwcm9wYWdhdGlvbiB0byBwYXJlbnQgZWxlbWVudHMuIFVzZWQgaW5zaWRlIHRoZSBsaXN0ZW5lciBmdW5jdGlvbnM6XHJcbi8vIGBgYGpzXHJcbi8vIEwuRG9tRXZlbnQub24oZGl2LCAnY2xpY2snLCBmdW5jdGlvbiAoZXYpIHtcclxuLy8gXHRMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbihldik7XHJcbi8vIH0pO1xyXG4vLyBgYGBcclxuZXhwb3J0IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihlKSB7XHJcblxyXG5cdGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xyXG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHR9IGVsc2UgaWYgKGUub3JpZ2luYWxFdmVudCkgeyAgLy8gSW4gY2FzZSBvZiBMZWFmbGV0IGV2ZW50LlxyXG5cdFx0ZS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkID0gdHJ1ZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG4vLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCd3aGVlbCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihlbCkge1xyXG5cdGFkZE9uZShlbCwgJ3doZWVsJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuLy8gQWRkcyBgc3RvcFByb3BhZ2F0aW9uYCB0byB0aGUgZWxlbWVudCdzIGAnY2xpY2snYCwgYCdkYmxjbGljaydgLCBgJ2NvbnRleHRtZW51J2AsXHJcbi8vIGAnbW91c2Vkb3duJ2AgYW5kIGAndG91Y2hzdGFydCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsKSB7XHJcblx0b24oZWwsICdtb3VzZWRvd24gdG91Y2hzdGFydCBkYmxjbGljayBjb250ZXh0bWVudScsIHN0b3BQcm9wYWdhdGlvbik7XHJcblx0ZWxbJ19sZWFmbGV0X2Rpc2FibGVfY2xpY2snXSA9IHRydWU7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldjogRE9NRXZlbnQpOiB0aGlzXHJcbi8vIFByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiB0aGUgRE9NIEV2ZW50IGBldmAgZnJvbSBoYXBwZW5pbmcgKHN1Y2ggYXNcclxuLy8gZm9sbG93aW5nIGEgbGluayBpbiB0aGUgaHJlZiBvZiB0aGUgYSBlbGVtZW50LCBvciBkb2luZyBhIFBPU1QgcmVxdWVzdFxyXG4vLyB3aXRoIHBhZ2UgcmVsb2FkIHdoZW4gYSBgPGZvcm0+YCBpcyBzdWJtaXR0ZWQpLlxyXG4vLyBVc2UgaXQgaW5zaWRlIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGUpIHtcclxuXHRpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xyXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlLnJldHVyblZhbHVlID0gZmFsc2U7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RvcChldjogRE9NRXZlbnQpOiB0aGlzXHJcbi8vIERvZXMgYHN0b3BQcm9wYWdhdGlvbmAgYW5kIGBwcmV2ZW50RGVmYXVsdGAgYXQgdGhlIHNhbWUgdGltZS5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0b3AoZSkge1xyXG5cdHByZXZlbnREZWZhdWx0KGUpO1xyXG5cdHN0b3BQcm9wYWdhdGlvbihlKTtcclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFByb3BhZ2F0aW9uUGF0aChldjogRE9NRXZlbnQpOiBBcnJheVxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbYEV2ZW50LmNvbXBvc2VkUGF0aCgpYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50L2NvbXBvc2VkUGF0aCkuXHJcbi8vIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgYEhUTUxFbGVtZW50YHMgdGhhdCB0aGUgZ2l2ZW4gRE9NIGV2ZW50XHJcbi8vIHNob3VsZCBwcm9wYWdhdGUgdG8gKGlmIG5vdCBzdG9wcGVkKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb3BhZ2F0aW9uUGF0aChldikge1xyXG5cdGlmIChldi5jb21wb3NlZFBhdGgpIHtcclxuXHRcdHJldHVybiBldi5jb21wb3NlZFBhdGgoKTtcclxuXHR9XHJcblxyXG5cdHZhciBwYXRoID0gW107XHJcblx0dmFyIGVsID0gZXYudGFyZ2V0O1xyXG5cclxuXHR3aGlsZSAoZWwpIHtcclxuXHRcdHBhdGgucHVzaChlbCk7XHJcblx0XHRlbCA9IGVsLnBhcmVudE5vZGU7XHJcblx0fVxyXG5cdHJldHVybiBwYXRoO1xyXG59XHJcblxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZXY6IERPTUV2ZW50LCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IFBvaW50XHJcbi8vIEdldHMgbm9ybWFsaXplZCBtb3VzZSBwb3NpdGlvbiBmcm9tIGEgRE9NIGV2ZW50IHJlbGF0aXZlIHRvIHRoZVxyXG4vLyBgY29udGFpbmVyYCAoYm9yZGVyIGV4Y2x1ZGVkKSBvciB0byB0aGUgd2hvbGUgcGFnZSBpZiBub3Qgc3BlY2lmaWVkLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihlLCBjb250YWluZXIpIHtcclxuXHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChlLmNsaWVudFgsIGUuY2xpZW50WSk7XHJcblx0fVxyXG5cclxuXHR2YXIgc2NhbGUgPSBnZXRTY2FsZShjb250YWluZXIpLFxyXG5cdCAgICBvZmZzZXQgPSBzY2FsZS5ib3VuZGluZ0NsaWVudFJlY3Q7IC8vIGxlZnQgYW5kIHRvcCAgdmFsdWVzIGFyZSBpbiBwYWdlIHNjYWxlIChsaWtlIHRoZSBldmVudCBjbGllbnRYL1kpXHJcblxyXG5cdHJldHVybiBuZXcgUG9pbnQoXHJcblx0XHQvLyBvZmZzZXQubGVmdC90b3AgdmFsdWVzIGFyZSBpbiBwYWdlIHNjYWxlIChsaWtlIGNsaWVudFgvWSksXHJcblx0XHQvLyB3aGVyZWFzIGNsaWVudExlZnQvVG9wIChib3JkZXIgd2lkdGgpIHZhbHVlcyBhcmUgdGhlIG9yaWdpbmFsIHZhbHVlcyAoYmVmb3JlIENTUyBzY2FsZSBhcHBsaWVzKS5cclxuXHRcdChlLmNsaWVudFggLSBvZmZzZXQubGVmdCkgLyBzY2FsZS54IC0gY29udGFpbmVyLmNsaWVudExlZnQsXHJcblx0XHQoZS5jbGllbnRZIC0gb2Zmc2V0LnRvcCkgLyBzY2FsZS55IC0gY29udGFpbmVyLmNsaWVudFRvcFxyXG5cdCk7XHJcbn1cclxuXHJcblxyXG4vLyAgZXhjZXB0ICwgU2FmYXJpIGFuZFxyXG4vLyBXZSBuZWVkIGRvdWJsZSB0aGUgc2Nyb2xsIHBpeGVscyAoc2VlICM3NDAzIGFuZCAjNDUzOCkgZm9yIGFsbCBCcm93c2Vyc1xyXG4vLyBleGNlcHQgT1NYIChNYWMpIC0+IDN4LCBDaHJvbWUgcnVubmluZyBvbiBMaW51eCAxeFxyXG5cclxudmFyIHdoZWVsUHhGYWN0b3IgPVxyXG5cdChCcm93c2VyLmxpbnV4ICYmIEJyb3dzZXIuY2hyb21lKSA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDpcclxuXHRCcm93c2VyLm1hYyA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICogMyA6XHJcblx0d2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAwID8gMiAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcclxuLy8gQGZ1bmN0aW9uIGdldFdoZWVsRGVsdGEoZXY6IERPTUV2ZW50KTogTnVtYmVyXHJcbi8vIEdldHMgbm9ybWFsaXplZCB3aGVlbCBkZWx0YSBmcm9tIGEgd2hlZWwgRE9NIGV2ZW50LCBpbiB2ZXJ0aWNhbFxyXG4vLyBwaXhlbHMgc2Nyb2xsZWQgKG5lZ2F0aXZlIGlmIHNjcm9sbGluZyBkb3duKS5cclxuLy8gRXZlbnRzIGZyb20gcG9pbnRpbmcgZGV2aWNlcyB3aXRob3V0IHByZWNpc2Ugc2Nyb2xsaW5nIGFyZSBtYXBwZWQgdG9cclxuLy8gYSBiZXN0IGd1ZXNzIG9mIDYwIHBpeGVscy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFdoZWVsRGVsdGEoZSkge1xyXG5cdHJldHVybiAoQnJvd3Nlci5lZGdlKSA/IGUud2hlZWxEZWx0YVkgLyAyIDogLy8gRG9uJ3QgdHJ1c3Qgd2luZG93LWdlb21ldHJ5LWJhc2VkIGRlbHRhXHJcblx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMCkgPyAtZS5kZWx0YVkgLyB3aGVlbFB4RmFjdG9yIDogLy8gUGl4ZWxzXHJcblx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMSkgPyAtZS5kZWx0YVkgKiAyMCA6IC8vIExpbmVzXHJcblx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMikgPyAtZS5kZWx0YVkgKiA2MCA6IC8vIFBhZ2VzXHJcblx0ICAgICAgIChlLmRlbHRhWCB8fCBlLmRlbHRhWikgPyAwIDpcdC8vIFNraXAgaG9yaXpvbnRhbC9kZXB0aCB3aGVlbCBldmVudHNcclxuXHQgICAgICAgZS53aGVlbERlbHRhID8gKGUud2hlZWxEZWx0YVkgfHwgZS53aGVlbERlbHRhKSAvIDIgOiAvLyBMZWdhY3kgSUUgcGl4ZWxzXHJcblx0ICAgICAgIChlLmRldGFpbCAmJiBNYXRoLmFicyhlLmRldGFpbCkgPCAzMjc2NSkgPyAtZS5kZXRhaWwgKiAyMCA6IC8vIExlZ2FjeSBNb3ogbGluZXNcclxuXHQgICAgICAgZS5kZXRhaWwgPyBlLmRldGFpbCAvIC0zMjc2NSAqIDYwIDogLy8gTGVnYWN5IE1veiBwYWdlc1xyXG5cdCAgICAgICAwO1xyXG59XHJcblxyXG4vLyBjaGVjayBpZiBlbGVtZW50IHJlYWxseSBsZWZ0L2VudGVyZWQgdGhlIGV2ZW50IHRhcmdldCAoZm9yIG1vdXNlZW50ZXIvbW91c2VsZWF2ZSlcclxuZXhwb3J0IGZ1bmN0aW9uIGlzRXh0ZXJuYWxUYXJnZXQoZWwsIGUpIHtcclxuXHJcblx0dmFyIHJlbGF0ZWQgPSBlLnJlbGF0ZWRUYXJnZXQ7XHJcblxyXG5cdGlmICghcmVsYXRlZCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHR0cnkge1xyXG5cdFx0d2hpbGUgKHJlbGF0ZWQgJiYgKHJlbGF0ZWQgIT09IGVsKSkge1xyXG5cdFx0XHRyZWxhdGVkID0gcmVsYXRlZC5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cdH0gY2F0Y2ggKGVycikge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHRyZXR1cm4gKHJlbGF0ZWQgIT09IGVsKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BMLkRvbUV2ZW50Lm9uYF0oI2RvbWV2ZW50LW9uKVxyXG5leHBvcnQge29uIGFzIGFkZExpc3RlbmVyfTtcclxuXHJcbi8vIEBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgTC5Eb21FdmVudC5vZmZgXSgjZG9tZXZlbnQtb2ZmKVxyXG5leHBvcnQge29mZiBhcyByZW1vdmVMaXN0ZW5lcn07XHJcbiIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcbmltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi4vY29yZS9FdmVudHMnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XG5cblxuLypcbiAqIEBjbGFzcyBQb3NBbmltYXRpb25cbiAqIEBha2EgTC5Qb3NBbmltYXRpb25cbiAqIEBpbmhlcml0cyBFdmVudGVkXG4gKiBVc2VkIGludGVybmFsbHkgZm9yIHBhbm5pbmcgYW5pbWF0aW9ucywgdXRpbGl6aW5nIENTUzMgVHJhbnNpdGlvbnMgZm9yIG1vZGVybiBicm93c2VycyBhbmQgYSB0aW1lciBmYWxsYmFjayBmb3IgSUU2LTkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiB2YXIgbXlQb3NpdGlvbk1hcmtlciA9IEwubWFya2VyKFs0OC44NjQ3MTYsIDIuMjk0Njk0XSkuYWRkVG8obWFwKTtcbiAqXG4gKiBteVBvc2l0aW9uTWFya2VyLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gKiBcdHZhciBwb3MgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KG15UG9zaXRpb25NYXJrZXIuZ2V0TGF0TG5nKCkpO1xuICogXHRwb3MueSAtPSAyNTtcbiAqIFx0dmFyIGZ4ID0gbmV3IEwuUG9zQW5pbWF0aW9uKCk7XG4gKlxuICogXHRmeC5vbmNlKCdlbmQnLGZ1bmN0aW9uKCkge1xuICogXHRcdHBvcy55ICs9IDI1O1xuICogXHRcdGZ4LnJ1bihteVBvc2l0aW9uTWFya2VyLl9pY29uLCBwb3MsIDAuOCk7XG4gKiBcdH0pO1xuICpcbiAqIFx0ZngucnVuKG15UG9zaXRpb25NYXJrZXIuX2ljb24sIHBvcywgMC4zKTtcbiAqIH0pO1xuICpcbiAqIGBgYFxuICpcbiAqIEBjb25zdHJ1Y3RvciBMLlBvc0FuaW1hdGlvbigpXG4gKiBDcmVhdGVzIGEgYFBvc0FuaW1hdGlvbmAgb2JqZWN0LlxuICpcbiAqL1xuXG5leHBvcnQgdmFyIFBvc0FuaW1hdGlvbiA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuXHQvLyBAbWV0aG9kIHJ1bihlbDogSFRNTEVsZW1lbnQsIG5ld1BvczogUG9pbnQsIGR1cmF0aW9uPzogTnVtYmVyLCBlYXNlTGluZWFyaXR5PzogTnVtYmVyKVxuXHQvLyBSdW4gYW4gYW5pbWF0aW9uIG9mIGEgZ2l2ZW4gZWxlbWVudCB0byBhIG5ldyBwb3NpdGlvbiwgb3B0aW9uYWxseSBzZXR0aW5nXG5cdC8vIGR1cmF0aW9uIGluIHNlY29uZHMgKGAwLjI1YCBieSBkZWZhdWx0KSBhbmQgZWFzaW5nIGxpbmVhcml0eSBmYWN0b3IgKDNyZFxuXHQvLyBhcmd1bWVudCBvZiB0aGUgW2N1YmljIGJlemllciBjdXJ2ZV0oaHR0cHM6Ly9jdWJpYy1iZXppZXIuY29tLyMwLDAsLjUsMSksXG5cdC8vIGAwLjVgIGJ5IGRlZmF1bHQpLlxuXHRydW46IGZ1bmN0aW9uIChlbCwgbmV3UG9zLCBkdXJhdGlvbiwgZWFzZUxpbmVhcml0eSkge1xuXHRcdHRoaXMuc3RvcCgpO1xuXG5cdFx0dGhpcy5fZWwgPSBlbDtcblx0XHR0aGlzLl9pblByb2dyZXNzID0gdHJ1ZTtcblx0XHR0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDAuMjU7XG5cdFx0dGhpcy5fZWFzZU91dFBvd2VyID0gMSAvIE1hdGgubWF4KGVhc2VMaW5lYXJpdHkgfHwgMC41LCAwLjIpO1xuXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSBEb21VdGlsLmdldFBvc2l0aW9uKGVsKTtcblx0XHR0aGlzLl9vZmZzZXQgPSBuZXdQb3Muc3VidHJhY3QodGhpcy5fc3RhcnRQb3MpO1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXG5cdFx0Ly8gQGV2ZW50IHN0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBzdGFydHNcblx0XHR0aGlzLmZpcmUoJ3N0YXJ0Jyk7XG5cblx0XHR0aGlzLl9hbmltYXRlKCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzdG9wKClcblx0Ly8gU3RvcHMgdGhlIGFuaW1hdGlvbiAoaWYgY3VycmVudGx5IHJ1bm5pbmcpLlxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9pblByb2dyZXNzKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fc3RlcCh0cnVlKTtcblx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuXHR9LFxuXG5cdF9hbmltYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gYW5pbWF0aW9uIGxvb3Bcblx0XHR0aGlzLl9hbmltSWQgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fYW5pbWF0ZSwgdGhpcyk7XG5cdFx0dGhpcy5fc3RlcCgpO1xuXHR9LFxuXG5cdF9zdGVwOiBmdW5jdGlvbiAocm91bmQpIHtcblx0XHR2YXIgZWxhcHNlZCA9ICgrbmV3IERhdGUoKSkgLSB0aGlzLl9zdGFydFRpbWUsXG5cdFx0ICAgIGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24gKiAxMDAwO1xuXG5cdFx0aWYgKGVsYXBzZWQgPCBkdXJhdGlvbikge1xuXHRcdFx0dGhpcy5fcnVuRnJhbWUodGhpcy5fZWFzZU91dChlbGFwc2VkIC8gZHVyYXRpb24pLCByb3VuZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3J1bkZyYW1lKDEpO1xuXHRcdFx0dGhpcy5fY29tcGxldGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3J1bkZyYW1lOiBmdW5jdGlvbiAocHJvZ3Jlc3MsIHJvdW5kKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZCh0aGlzLl9vZmZzZXQubXVsdGlwbHlCeShwcm9ncmVzcykpO1xuXHRcdGlmIChyb3VuZCkge1xuXHRcdFx0cG9zLl9yb3VuZCgpO1xuXHRcdH1cblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2VsLCBwb3MpO1xuXG5cdFx0Ly8gQGV2ZW50IHN0ZXA6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyB0aGUgYW5pbWF0aW9uLlxuXHRcdHRoaXMuZmlyZSgnc3RlcCcpO1xuXHR9LFxuXG5cdF9jb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1JZCk7XG5cblx0XHR0aGlzLl9pblByb2dyZXNzID0gZmFsc2U7XG5cdFx0Ly8gQGV2ZW50IGVuZDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gZW5kcy5cblx0XHR0aGlzLmZpcmUoJ2VuZCcpO1xuXHR9LFxuXG5cdF9lYXNlT3V0OiBmdW5jdGlvbiAodCkge1xuXHRcdHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIHRoaXMuX2Vhc2VPdXRQb3dlcik7XG5cdH1cbn0pO1xuIiwiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4uL2NvcmUvRXZlbnRzJztcclxuaW1wb3J0IHtFUFNHMzg1N30gZnJvbSAnLi4vZ2VvL2Nycy9DUlMuRVBTRzM4NTcnO1xyXG5pbXBvcnQge1BvaW50LCB0b1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCB7Qm91bmRzLCB0b0JvdW5kc30gZnJvbSAnLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtMYXRMbmcsIHRvTGF0TG5nfSBmcm9tICcuLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0IHtMYXRMbmdCb3VuZHMsIHRvTGF0TG5nQm91bmRzfSBmcm9tICcuLi9nZW8vTGF0TG5nQm91bmRzJztcclxuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCB7UG9zQW5pbWF0aW9ufSBmcm9tICcuLi9kb20vUG9zQW5pbWF0aW9uJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBNYXBcclxuICogQGFrYSBMLk1hcFxyXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxyXG4gKlxyXG4gKiBUaGUgY2VudHJhbCBjbGFzcyBvZiB0aGUgQVBJIOKAlCBpdCBpcyB1c2VkIHRvIGNyZWF0ZSBhIG1hcCBvbiBhIHBhZ2UgYW5kIG1hbmlwdWxhdGUgaXQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIC8vIGluaXRpYWxpemUgdGhlIG1hcCBvbiB0aGUgXCJtYXBcIiBkaXYgd2l0aCBhIGdpdmVuIGNlbnRlciBhbmQgem9vbVxyXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcclxuICogXHRjZW50ZXI6IFs1MS41MDUsIC0wLjA5XSxcclxuICogXHR6b29tOiAxM1xyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBNYXAgPSBFdmVudGVkLmV4dGVuZCh7XHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBzZWN0aW9uIE1hcCBTdGF0ZSBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gTC5DUlMuRVBTRzM4NTdcclxuXHRcdC8vIFRoZSBbQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtXSgjY3JzKSB0byB1c2UuIERvbid0IGNoYW5nZSB0aGlzIGlmIHlvdSdyZSBub3RcclxuXHRcdC8vIHN1cmUgd2hhdCBpdCBtZWFucy5cclxuXHRcdGNyczogRVBTRzM4NTcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjZW50ZXI6IExhdExuZyA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gSW5pdGlhbCBnZW9ncmFwaGljIGNlbnRlciBvZiB0aGUgbWFwXHJcblx0XHRjZW50ZXI6IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb206IE51bWJlciA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gSW5pdGlhbCBtYXAgem9vbSBsZXZlbFxyXG5cdFx0em9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gKlxyXG5cdFx0Ly8gTWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcblx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuXHRcdC8vIHRoZSBsb3dlc3Qgb2YgdGhlaXIgYG1pblpvb21gIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcblx0XHRtaW5ab29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAqXHJcblx0XHQvLyBNYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC5cclxuXHRcdC8vIElmIG5vdCBzcGVjaWZpZWQgYW5kIGF0IGxlYXN0IG9uZSBgR3JpZExheWVyYCBvciBgVGlsZUxheWVyYCBpcyBpbiB0aGUgbWFwLFxyXG5cdFx0Ly8gdGhlIGhpZ2hlc3Qgb2YgdGhlaXIgYG1heFpvb21gIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcblx0XHRtYXhab29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBsYXllcnM6IExheWVyW10gPSBbXVxyXG5cdFx0Ly8gQXJyYXkgb2YgbGF5ZXJzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwIGluaXRpYWxseVxyXG5cdFx0bGF5ZXJzOiBbXSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heEJvdW5kczogTGF0TG5nQm91bmRzID0gbnVsbFxyXG5cdFx0Ly8gV2hlbiB0aGlzIG9wdGlvbiBpcyBzZXQsIHRoZSBtYXAgcmVzdHJpY3RzIHRoZSB2aWV3IHRvIHRoZSBnaXZlblxyXG5cdFx0Ly8gZ2VvZ3JhcGhpY2FsIGJvdW5kcywgYm91bmNpbmcgdGhlIHVzZXIgYmFjayBpZiB0aGUgdXNlciB0cmllcyB0byBwYW5cclxuXHRcdC8vIG91dHNpZGUgdGhlIHZpZXcuIFRvIHNldCB0aGUgcmVzdHJpY3Rpb24gZHluYW1pY2FsbHksIHVzZVxyXG5cdFx0Ly8gW2BzZXRNYXhCb3VuZHNgXSgjbWFwLXNldG1heGJvdW5kcykgbWV0aG9kLlxyXG5cdFx0bWF4Qm91bmRzOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXIgPSAqXHJcblx0XHQvLyBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIGRyYXdpbmcgdmVjdG9yIGxheWVycyBvbiB0aGUgbWFwLiBgTC5TVkdgXHJcblx0XHQvLyBvciBgTC5DYW52YXNgIGJ5IGRlZmF1bHQgZGVwZW5kaW5nIG9uIGJyb3dzZXIgc3VwcG9ydC5cclxuXHRcdHJlbmRlcmVyOiB1bmRlZmluZWQsXHJcblxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIEFuaW1hdGlvbiBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIHpvb21BbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXAgem9vbSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcclxuXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdHpvb21BbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tQW5pbWF0aW9uVGhyZXNob2xkOiBOdW1iZXIgPSA0XHJcblx0XHQvLyBXb24ndCBhbmltYXRlIHpvb20gaWYgdGhlIHpvb20gZGlmZmVyZW5jZSBleGNlZWRzIHRoaXMgdmFsdWUuXHJcblx0XHR6b29tQW5pbWF0aW9uVGhyZXNob2xkOiA0LFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZmFkZUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHRpbGUgZmFkZSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcclxuXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdGZhZGVBbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXJrZXJab29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciBtYXJrZXJzIGFuaW1hdGUgdGhlaXIgem9vbSB3aXRoIHRoZSB6b29tIGFuaW1hdGlvbiwgaWYgZGlzYWJsZWRcclxuXHRcdC8vIHRoZXkgd2lsbCBkaXNhcHBlYXIgZm9yIHRoZSBsZW5ndGggb2YgdGhlIGFuaW1hdGlvbi4gQnkgZGVmYXVsdCBpdCdzXHJcblx0XHQvLyBlbmFibGVkIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdG1hcmtlclpvb21BbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFuc2Zvcm0zRExpbWl0OiBOdW1iZXIgPSAyXjIzXHJcblx0XHQvLyBEZWZpbmVzIHRoZSBtYXhpbXVtIHNpemUgb2YgYSBDU1MgdHJhbnNsYXRpb24gdHJhbnNmb3JtLiBUaGUgZGVmYXVsdFxyXG5cdFx0Ly8gdmFsdWUgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIHVubGVzcyBhIHdlYiBicm93c2VyIHBvc2l0aW9ucyBsYXllcnMgaW5cclxuXHRcdC8vIHRoZSB3cm9uZyBwbGFjZSBhZnRlciBkb2luZyBhIGxhcmdlIGBwYW5CeWAuXHJcblx0XHR0cmFuc2Zvcm0zRExpbWl0OiA4Mzg4NjA4LCAvLyBQcmVjaXNpb24gbGltaXQgb2YgYSAzMi1iaXQgZmxvYXRcclxuXHJcblx0XHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIHpvb21TbmFwOiBOdW1iZXIgPSAxXHJcblx0XHQvLyBGb3JjZXMgdGhlIG1hcCdzIHpvb20gbGV2ZWwgdG8gYWx3YXlzIGJlIGEgbXVsdGlwbGUgb2YgdGhpcywgcGFydGljdWxhcmx5XHJcblx0XHQvLyByaWdodCBhZnRlciBhIFtgZml0Qm91bmRzKClgXSgjbWFwLWZpdGJvdW5kcykgb3IgYSBwaW5jaC16b29tLlxyXG5cdFx0Ly8gQnkgZGVmYXVsdCwgdGhlIHpvb20gbGV2ZWwgc25hcHMgdG8gdGhlIG5lYXJlc3QgaW50ZWdlcjsgbG93ZXIgdmFsdWVzXHJcblx0XHQvLyAoZS5nLiBgMC41YCBvciBgMC4xYCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuIEEgdmFsdWUgb2YgYDBgXHJcblx0XHQvLyBtZWFucyB0aGUgem9vbSBsZXZlbCB3aWxsIG5vdCBiZSBzbmFwcGVkIGFmdGVyIGBmaXRCb3VuZHNgIG9yIGEgcGluY2gtem9vbS5cclxuXHRcdHpvb21TbmFwOiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbURlbHRhOiBOdW1iZXIgPSAxXHJcblx0XHQvLyBDb250cm9scyBob3cgbXVjaCB0aGUgbWFwJ3Mgem9vbSBsZXZlbCB3aWxsIGNoYW5nZSBhZnRlciBhXHJcblx0XHQvLyBbYHpvb21JbigpYF0oI21hcC16b29taW4pLCBbYHpvb21PdXQoKWBdKCNtYXAtem9vbW91dCksIHByZXNzaW5nIGArYFxyXG5cdFx0Ly8gb3IgYC1gIG9uIHRoZSBrZXlib2FyZCwgb3IgdXNpbmcgdGhlIFt6b29tIGNvbnRyb2xzXSgjY29udHJvbC16b29tKS5cclxuXHRcdC8vIFZhbHVlcyBzbWFsbGVyIHRoYW4gYDFgIChlLmcuIGAwLjVgKSBhbGxvdyBmb3IgZ3JlYXRlciBncmFudWxhcml0eS5cclxuXHRcdHpvb21EZWx0YTogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRyYWNrUmVzaXplOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFwIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBicm93c2VyIHdpbmRvdyByZXNpemUgdG8gdXBkYXRlIGl0c2VsZi5cclxuXHRcdHRyYWNrUmVzaXplOiB0cnVlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7IC8vIChIVE1MRWxlbWVudCBvciBTdHJpbmcsIE9iamVjdClcclxuXHRcdG9wdGlvbnMgPSBVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0Ly8gTWFrZSBzdXJlIHRvIGFzc2lnbiBpbnRlcm5hbCBmbGFncyBhdCB0aGUgYmVnaW5uaW5nLFxyXG5cdFx0Ly8gdG8gYXZvaWQgaW5jb25zaXN0ZW50IHN0YXRlIGluIHNvbWUgZWRnZSBjYXNlcy5cclxuXHRcdHRoaXMuX2hhbmRsZXJzID0gW107XHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHRcdHRoaXMuX3pvb21Cb3VuZExheWVycyA9IHt9O1xyXG5cdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuX2luaXRDb250YWluZXIoaWQpO1xyXG5cdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cclxuXHRcdC8vIGhhY2sgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzE5ODBcclxuXHRcdHRoaXMuX29uUmVzaXplID0gVXRpbC5iaW5kKHRoaXMuX29uUmVzaXplLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9pbml0RXZlbnRzKCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XHJcblx0XHRcdHRoaXMuc2V0TWF4Qm91bmRzKG9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5fem9vbSA9IHRoaXMuX2xpbWl0Wm9vbShvcHRpb25zLnpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmNlbnRlciAmJiBvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLnNldFZpZXcodG9MYXRMbmcob3B0aW9ucy5jZW50ZXIpLCBvcHRpb25zLnpvb20sIHtyZXNldDogdHJ1ZX0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cclxuXHRcdC8vIGRvbid0IGFuaW1hdGUgb24gYnJvd3NlcnMgd2l0aG91dCBoYXJkd2FyZS1hY2NlbGVyYXRlZCB0cmFuc2l0aW9ucyBvciBvbGQgQW5kcm9pZC9PcGVyYVxyXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gRG9tVXRpbC5UUkFOU0lUSU9OICYmIEJyb3dzZXIuYW55M2QgJiYgIUJyb3dzZXIubW9iaWxlT3BlcmEgJiZcclxuXHRcdFx0XHR0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbjtcclxuXHJcblx0XHQvLyB6b29tIHRyYW5zaXRpb25zIHJ1biB3aXRoIHRoZSBzYW1lIGR1cmF0aW9uIGZvciBhbGwgbGF5ZXJzLCBzbyBpZiBvbmUgb2YgdHJhbnNpdGlvbmVuZCBldmVudHNcclxuXHRcdC8vIGhhcHBlbnMgYWZ0ZXIgc3RhcnRpbmcgem9vbSBhbmltYXRpb24gKHByb3BhZ2F0aW5nIHRvIHRoZSBtYXAgcGFuZSksIHdlIGtub3cgdGhhdCBpdCBlbmRlZCBnbG9iYWxseVxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHR0aGlzLl9jcmVhdGVBbmltUHJveHkoKTtcclxuXHRcdFx0RG9tRXZlbnQub24odGhpcy5fcHJveHksIERvbVV0aWwuVFJBTlNJVElPTl9FTkQsIHRoaXMuX2NhdGNoVHJhbnNpdGlvbkVuZCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYWRkTGF5ZXJzKHRoaXMub3B0aW9ucy5sYXllcnMpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBtb2RpZnlpbmcgbWFwIHN0YXRlXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VmlldyhjZW50ZXI6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgKGdlb2dyYXBoaWNhbCBjZW50ZXIgYW5kIHpvb20pIHdpdGggdGhlIGdpdmVuXHJcblx0Ly8gYW5pbWF0aW9uIG9wdGlvbnMuXHJcblx0c2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogdGhpcy5fbGltaXRab29tKHpvb20pO1xyXG5cdFx0Y2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIodG9MYXRMbmcoY2VudGVyKSwgem9vbSwgdGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiAhb3B0aW9ucy5yZXNldCAmJiBvcHRpb25zICE9PSB0cnVlKSB7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRvcHRpb25zLnpvb20gPSBVdGlsLmV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlfSwgb3B0aW9ucy56b29tKTtcclxuXHRcdFx0XHRvcHRpb25zLnBhbiA9IFV0aWwuZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGUsIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9ufSwgb3B0aW9ucy5wYW4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB0cnkgYW5pbWF0aW5nIHBhbiBvciB6b29tXHJcblx0XHRcdHZhciBtb3ZlZCA9ICh0aGlzLl96b29tICE9PSB6b29tKSA/XHJcblx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRab29tICYmIHRoaXMuX3RyeUFuaW1hdGVkWm9vbShjZW50ZXIsIHpvb20sIG9wdGlvbnMuem9vbSkgOlxyXG5cdFx0XHRcdHRoaXMuX3RyeUFuaW1hdGVkUGFuKGNlbnRlciwgb3B0aW9ucy5wYW4pO1xyXG5cclxuXHRcdFx0aWYgKG1vdmVkKSB7XHJcblx0XHRcdFx0Ly8gcHJldmVudCByZXNpemUgaGFuZGxlciBjYWxsLCB0aGUgdmlldyB3aWxsIHJlZnJlc2ggYWZ0ZXIgYW5pbWF0aW9uIGFueXdheVxyXG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9zaXplVGltZXIpO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYW5pbWF0aW9uIGRpZG4ndCBzdGFydCwganVzdCByZXNldCB0aGUgbWFwIHZpZXdcclxuXHRcdHRoaXMuX3Jlc2V0VmlldyhjZW50ZXIsIHpvb20sIG9wdGlvbnMucGFuICYmIG9wdGlvbnMucGFuLm5vTW92ZVN0YXJ0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpvb20oem9vbTogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB6b29tIG9mIHRoZSBtYXAuXHJcblx0c2V0Wm9vbTogZnVuY3Rpb24gKHpvb20sIG9wdGlvbnMpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHpvb21JbihkZWx0YT86IE51bWJlciwgb3B0aW9ucz86IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBJbmNyZWFzZXMgdGhlIHpvb20gb2YgdGhlIG1hcCBieSBgZGVsdGFgIChbYHpvb21EZWx0YWBdKCNtYXAtem9vbWRlbHRhKSBieSBkZWZhdWx0KS5cclxuXHR6b29tSW46IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG5cdFx0ZGVsdGEgPSBkZWx0YSB8fCAoQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tRGVsdGEgOiAxKTtcclxuXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSArIGRlbHRhLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHpvb21PdXQoZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gRGVjcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcblx0em9vbU91dDogZnVuY3Rpb24gKGRlbHRhLCBvcHRpb25zKSB7XHJcblx0XHRkZWx0YSA9IGRlbHRhIHx8IChCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tIC0gZGVsdGEsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gWm9vbXMgdGhlIG1hcCB3aGlsZSBrZWVwaW5nIGEgc3BlY2lmaWVkIGdlb2dyYXBoaWNhbCBwb2ludCBvbiB0aGUgbWFwXHJcblx0Ly8gc3RhdGlvbmFyeSAoZS5nLiB1c2VkIGludGVybmFsbHkgZm9yIHNjcm9sbCB6b29tIGFuZCBkb3VibGUtY2xpY2sgem9vbSkuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tQXJvdW5kKG9mZnNldDogUG9pbnQsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBwaXhlbCBvbiB0aGUgbWFwIChyZWxhdGl2ZSB0byB0aGUgdG9wLWxlZnQgY29ybmVyKSBzdGF0aW9uYXJ5LlxyXG5cdHNldFpvb21Bcm91bmQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIG9wdGlvbnMpIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgY29udGFpbmVyUG9pbnQgPSBsYXRsbmcgaW5zdGFuY2VvZiBQb2ludCA/IGxhdGxuZyA6IHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmcpLFxyXG5cclxuXHRcdCAgICBjZW50ZXJPZmZzZXQgPSBjb250YWluZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZikubXVsdGlwbHlCeSgxIC0gMSAvIHNjYWxlKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodmlld0hhbGYuYWRkKGNlbnRlck9mZnNldCkpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcobmV3Q2VudGVyLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRCb3VuZHNDZW50ZXJab29tOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0XHRib3VuZHMgPSBib3VuZHMuZ2V0Qm91bmRzID8gYm91bmRzLmdldEJvdW5kcygpIDogdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgcGFkZGluZ1RMID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdUb3BMZWZ0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nQm90dG9tUmlnaHQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLmdldEJvdW5kc1pvb20oYm91bmRzLCBmYWxzZSwgcGFkZGluZ1RMLmFkZChwYWRkaW5nQlIpKTtcclxuXHJcblx0XHR6b29tID0gKHR5cGVvZiBvcHRpb25zLm1heFpvb20gPT09ICdudW1iZXInKSA/IE1hdGgubWluKG9wdGlvbnMubWF4Wm9vbSwgem9vbSkgOiB6b29tO1xyXG5cclxuXHRcdGlmICh6b29tID09PSBJbmZpbml0eSkge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGNlbnRlcjogYm91bmRzLmdldENlbnRlcigpLFxyXG5cdFx0XHRcdHpvb206IHpvb21cclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcGFkZGluZ09mZnNldCA9IHBhZGRpbmdCUi5zdWJ0cmFjdChwYWRkaW5nVEwpLmRpdmlkZUJ5KDIpLFxyXG5cclxuXHRcdCAgICBzd1BvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSksXHJcblx0XHQgICAgbmVQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG5cdFx0ICAgIGNlbnRlciA9IHRoaXMudW5wcm9qZWN0KHN3UG9pbnQuYWRkKG5lUG9pbnQpLmRpdmlkZUJ5KDIpLmFkZChwYWRkaW5nT2Zmc2V0KSwgem9vbSk7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0Y2VudGVyOiBjZW50ZXIsXHJcblx0XHRcdHpvb206IHpvb21cclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXRCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBjb250YWlucyB0aGUgZ2l2ZW4gZ2VvZ3JhcGhpY2FsIGJvdW5kcyB3aXRoIHRoZVxyXG5cdC8vIG1heGltdW0gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuXHRmaXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICghYm91bmRzLmlzVmFsaWQoKSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kcyBhcmUgbm90IHZhbGlkLicpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpdFdvcmxkKG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBtb3N0bHkgY29udGFpbnMgdGhlIHdob2xlIHdvcmxkIHdpdGggdGhlIG1heGltdW1cclxuXHQvLyB6b29tIGxldmVsIHBvc3NpYmxlLlxyXG5cdGZpdFdvcmxkOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZml0Qm91bmRzKFtbLTkwLCAtMTgwXSwgWzkwLCAxODBdXSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5UbyhsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0byBhIGdpdmVuIGNlbnRlci5cclxuXHRwYW5UbzogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykgeyAvLyAoTGF0TG5nKVxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhjZW50ZXIsIHRoaXMuX3pvb20sIHtwYW46IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhbkJ5KG9mZnNldDogUG9pbnQsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgYnkgYSBnaXZlbiBudW1iZXIgb2YgcGl4ZWxzIChhbmltYXRlZCkuXHJcblx0cGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQsIG9wdGlvbnMpIHtcclxuXHRcdG9mZnNldCA9IHRvUG9pbnQob2Zmc2V0KS5yb3VuZCgpO1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gSWYgd2UgcGFuIHRvbyBmYXIsIENocm9tZSBnZXRzIGlzc3VlcyB3aXRoIHRpbGVzXHJcblx0XHQvLyBhbmQgbWFrZXMgdGhlbSBkaXNhcHBlYXIgb3IgYXBwZWFyIGluIHRoZSB3cm9uZyBwbGFjZSAoc2xpZ2h0bHkgb2Zmc2V0KSAjMjYwMlxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkge1xyXG5cdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy51bnByb2plY3QodGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLmFkZChvZmZzZXQpKSwgdGhpcy5nZXRab29tKCkpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX3BhbkFuaW0pIHtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbSA9IG5ldyBQb3NBbmltYXRpb24oKTtcclxuXHJcblx0XHRcdHRoaXMuX3BhbkFuaW0ub24oe1xyXG5cdFx0XHRcdCdzdGVwJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uU3RlcCxcclxuXHRcdFx0XHQnZW5kJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uRW5kXHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGRvbid0IGZpcmUgbW92ZXN0YXJ0IGlmIGFuaW1hdGluZyBpbmVydGlhXHJcblx0XHRpZiAoIW9wdGlvbnMubm9Nb3ZlU3RhcnQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBhbmltYXRlIHBhbiB1bmxlc3MgYW5pbWF0ZTogZmFsc2Ugc3BlY2lmaWVkXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSBmYWxzZSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXBhbi1hbmltJyk7XHJcblxyXG5cdFx0XHR2YXIgbmV3UG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCkucm91bmQoKTtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbS5ydW4odGhpcy5fbWFwUGFuZSwgbmV3UG9zLCBvcHRpb25zLmR1cmF0aW9uIHx8IDAuMjUsIG9wdGlvbnMuZWFzZUxpbmVhcml0eSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9yYXdQYW5CeShvZmZzZXQpO1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmUnKS5maXJlKCdtb3ZlZW5kJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmbHlUbyhsYXRsbmc6IExhdExuZywgem9vbT86IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIChnZW9ncmFwaGljYWwgY2VudGVyIGFuZCB6b29tKSBwZXJmb3JtaW5nIGEgc21vb3RoXHJcblx0Ly8gcGFuLXpvb20gYW5pbWF0aW9uLlxyXG5cdGZseVRvOiBmdW5jdGlvbiAodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCAhQnJvd3Nlci5hbnkzZCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc3RvcCgpO1xyXG5cclxuXHRcdHZhciBmcm9tID0gdGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLFxyXG5cdFx0ICAgIHRvID0gdGhpcy5wcm9qZWN0KHRhcmdldENlbnRlciksXHJcblx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIHN0YXJ0Wm9vbSA9IHRoaXMuX3pvb207XHJcblxyXG5cdFx0dGFyZ2V0Q2VudGVyID0gdG9MYXRMbmcodGFyZ2V0Q2VudGVyKTtcclxuXHRcdHRhcmdldFpvb20gPSB0YXJnZXRab29tID09PSB1bmRlZmluZWQgPyBzdGFydFpvb20gOiB0YXJnZXRab29tO1xyXG5cclxuXHRcdHZhciB3MCA9IE1hdGgubWF4KHNpemUueCwgc2l6ZS55KSxcclxuXHRcdCAgICB3MSA9IHcwICogdGhpcy5nZXRab29tU2NhbGUoc3RhcnRab29tLCB0YXJnZXRab29tKSxcclxuXHRcdCAgICB1MSA9ICh0by5kaXN0YW5jZVRvKGZyb20pKSB8fCAxLFxyXG5cdFx0ICAgIHJobyA9IDEuNDIsXHJcblx0XHQgICAgcmhvMiA9IHJobyAqIHJobztcclxuXHJcblx0XHRmdW5jdGlvbiByKGkpIHtcclxuXHRcdFx0dmFyIHMxID0gaSA/IC0xIDogMSxcclxuXHRcdFx0ICAgIHMyID0gaSA/IHcxIDogdzAsXHJcblx0XHRcdCAgICB0MSA9IHcxICogdzEgLSB3MCAqIHcwICsgczEgKiByaG8yICogcmhvMiAqIHUxICogdTEsXHJcblx0XHRcdCAgICBiMSA9IDIgKiBzMiAqIHJobzIgKiB1MSxcclxuXHRcdFx0ICAgIGIgPSB0MSAvIGIxLFxyXG5cdFx0XHQgICAgc3EgPSBNYXRoLnNxcnQoYiAqIGIgKyAxKSAtIGI7XHJcblxyXG5cdFx0XHQgICAgLy8gd29ya2Fyb3VuZCBmb3IgZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uIGJ1ZyB3aGVuIHNxID0gMCwgbG9nID0gLUluZmluaXRlLFxyXG5cdFx0XHQgICAgLy8gdGh1cyB0cmlnZ2VyaW5nIGFuIGluZmluaXRlIGxvb3AgaW4gZmx5VG9cclxuXHRcdFx0ICAgIHZhciBsb2cgPSBzcSA8IDAuMDAwMDAwMDAxID8gLTE4IDogTWF0aC5sb2coc3EpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGxvZztcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBzaW5oKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSAtIE1hdGguZXhwKC1uKSkgLyAyOyB9XHJcblx0XHRmdW5jdGlvbiBjb3NoKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSArIE1hdGguZXhwKC1uKSkgLyAyOyB9XHJcblx0XHRmdW5jdGlvbiB0YW5oKG4pIHsgcmV0dXJuIHNpbmgobikgLyBjb3NoKG4pOyB9XHJcblxyXG5cdFx0dmFyIHIwID0gcigwKTtcclxuXHJcblx0XHRmdW5jdGlvbiB3KHMpIHsgcmV0dXJuIHcwICogKGNvc2gocjApIC8gY29zaChyMCArIHJobyAqIHMpKTsgfVxyXG5cdFx0ZnVuY3Rpb24gdShzKSB7IHJldHVybiB3MCAqIChjb3NoKHIwKSAqIHRhbmgocjAgKyByaG8gKiBzKSAtIHNpbmgocjApKSAvIHJobzI7IH1cclxuXHJcblx0XHRmdW5jdGlvbiBlYXNlT3V0KHQpIHsgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgMS41KTsgfVxyXG5cclxuXHRcdHZhciBzdGFydCA9IERhdGUubm93KCksXHJcblx0XHQgICAgUyA9IChyKDEpIC0gcjApIC8gcmhvLFxyXG5cdFx0ICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiA/IDEwMDAgKiBvcHRpb25zLmR1cmF0aW9uIDogMTAwMCAqIFMgKiAwLjg7XHJcblxyXG5cdFx0ZnVuY3Rpb24gZnJhbWUoKSB7XHJcblx0XHRcdHZhciB0ID0gKERhdGUubm93KCkgLSBzdGFydCkgLyBkdXJhdGlvbixcclxuXHRcdFx0ICAgIHMgPSBlYXNlT3V0KHQpICogUztcclxuXHJcblx0XHRcdGlmICh0IDw9IDEpIHtcclxuXHRcdFx0XHR0aGlzLl9mbHlUb0ZyYW1lID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZyYW1lLCB0aGlzKTtcclxuXHJcblx0XHRcdFx0dGhpcy5fbW92ZShcclxuXHRcdFx0XHRcdHRoaXMudW5wcm9qZWN0KGZyb20uYWRkKHRvLnN1YnRyYWN0KGZyb20pLm11bHRpcGx5QnkodShzKSAvIHUxKSksIHN0YXJ0Wm9vbSksXHJcblx0XHRcdFx0XHR0aGlzLmdldFNjYWxlWm9vbSh3MCAvIHcocyksIHN0YXJ0Wm9vbSksXHJcblx0XHRcdFx0XHR7Zmx5VG86IHRydWV9KTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpc1xyXG5cdFx0XHRcdFx0Ll9tb3ZlKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSlcclxuXHRcdFx0XHRcdC5fbW92ZUVuZCh0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21vdmVTdGFydCh0cnVlLCBvcHRpb25zLm5vTW92ZVN0YXJ0KTtcclxuXHJcblx0XHRmcmFtZS5jYWxsKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmbHlUb0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCB3aXRoIGEgc21vb3RoIGFuaW1hdGlvbiBsaWtlIFtgZmx5VG9gXSgjbWFwLWZseXRvKSxcclxuXHQvLyBidXQgdGFrZXMgYSBib3VuZHMgcGFyYW1ldGVyIGxpa2UgW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcblx0Zmx5VG9Cb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcblx0XHRyZXR1cm4gdGhpcy5mbHlUbyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNYXhCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXHJcblx0Ly8gUmVzdHJpY3RzIHRoZSBtYXAgdmlldyB0byB0aGUgZ2l2ZW4gYm91bmRzIChzZWUgdGhlIFttYXhCb3VuZHNdKCNtYXAtbWF4Ym91bmRzKSBvcHRpb24pLlxyXG5cdHNldE1heEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAodGhpcy5saXN0ZW5zKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKSkge1xyXG5cdFx0XHR0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFib3VuZHMuaXNWYWxpZCgpKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBudWxsO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gYm91bmRzO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMub24oJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWluWm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgbG93ZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21pblpvb21dKCNtYXAtbWluem9vbSkgb3B0aW9uKS5cclxuXHRzZXRNaW5ab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG9sZFpvb20gPSB0aGlzLm9wdGlvbnMubWluWm9vbTtcclxuXHRcdHRoaXMub3B0aW9ucy5taW5ab29tID0gem9vbTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmIG9sZFpvb20gIT09IHpvb20pIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5nZXRab29tKCkgPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE1heFpvb20oem9vbTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHVwcGVyIGxpbWl0IGZvciB0aGUgYXZhaWxhYmxlIHpvb20gbGV2ZWxzIChzZWUgdGhlIFttYXhab29tXSgjbWFwLW1heHpvb20pIG9wdGlvbikuXHJcblx0c2V0TWF4Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHZhciBvbGRab29tID0gdGhpcy5vcHRpb25zLm1heFpvb207XHJcblx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbSA9IHpvb207XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiBvbGRab29tICE9PSB6b29tKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuZ2V0Wm9vbSgpID4gdGhpcy5vcHRpb25zLm1heFpvb20pIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHpvb20pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5JbnNpZGVCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdG8gdGhlIGNsb3Nlc3QgdmlldyB0aGF0IHdvdWxkIGxpZSBpbnNpZGUgdGhlIGdpdmVuIGJvdW5kcyAoaWYgaXQncyBub3QgYWxyZWFkeSksIGNvbnRyb2xsaW5nIHRoZSBhbmltYXRpb24gdXNpbmcgdGhlIG9wdGlvbnMgc3BlY2lmaWMsIGlmIGFueS5cclxuXHRwYW5JbnNpZGVCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IHRydWU7XHJcblx0XHR2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcihjZW50ZXIsIHRoaXMuX3pvb20sIHRvTGF0TG5nQm91bmRzKGJvdW5kcykpO1xyXG5cclxuXHRcdGlmICghY2VudGVyLmVxdWFscyhuZXdDZW50ZXIpKSB7XHJcblx0XHRcdHRoaXMucGFuVG8obmV3Q2VudGVyLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSBmYWxzZTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuSW5zaWRlKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogcGFkZGluZyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0aGUgbWluaW11bSBhbW91bnQgdG8gbWFrZSB0aGUgYGxhdGxuZ2AgdmlzaWJsZS4gVXNlXHJcblx0Ly8gcGFkZGluZyBvcHRpb25zIHRvIGZpdCB0aGUgZGlzcGxheSB0byBtb3JlIHJlc3RyaWN0ZWQgYm91bmRzLlxyXG5cdC8vIElmIGBsYXRsbmdgIGlzIGFscmVhZHkgd2l0aGluIHRoZSAob3B0aW9uYWxseSBwYWRkZWQpIGRpc3BsYXkgYm91bmRzLFxyXG5cdC8vIHRoZSBtYXAgd2lsbCBub3QgYmUgcGFubmVkLlxyXG5cdHBhbkluc2lkZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdUTCA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ0JvdHRvbVJpZ2h0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cdFx0ICAgIHBpeGVsQ2VudGVyID0gdGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLFxyXG5cdFx0ICAgIHBpeGVsUG9pbnQgPSB0aGlzLnByb2plY3QobGF0bG5nKSxcclxuXHRcdCAgICBwaXhlbEJvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBwYWRkZWRCb3VuZHMgPSB0b0JvdW5kcyhbcGl4ZWxCb3VuZHMubWluLmFkZChwYWRkaW5nVEwpLCBwaXhlbEJvdW5kcy5tYXguc3VidHJhY3QocGFkZGluZ0JSKV0pLFxyXG5cdFx0ICAgIHBhZGRlZFNpemUgPSBwYWRkZWRCb3VuZHMuZ2V0U2l6ZSgpO1xyXG5cclxuXHRcdGlmICghcGFkZGVkQm91bmRzLmNvbnRhaW5zKHBpeGVsUG9pbnQpKSB7XHJcblx0XHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IHRydWU7XHJcblx0XHRcdHZhciBjZW50ZXJPZmZzZXQgPSBwaXhlbFBvaW50LnN1YnRyYWN0KHBhZGRlZEJvdW5kcy5nZXRDZW50ZXIoKSk7XHJcblx0XHRcdHZhciBvZmZzZXQgPSBwYWRkZWRCb3VuZHMuZXh0ZW5kKHBpeGVsUG9pbnQpLmdldFNpemUoKS5zdWJ0cmFjdChwYWRkZWRTaXplKTtcclxuXHRcdFx0cGl4ZWxDZW50ZXIueCArPSBjZW50ZXJPZmZzZXQueCA8IDAgPyAtb2Zmc2V0LnggOiBvZmZzZXQueDtcclxuXHRcdFx0cGl4ZWxDZW50ZXIueSArPSBjZW50ZXJPZmZzZXQueSA8IDAgPyAtb2Zmc2V0LnkgOiBvZmZzZXQueTtcclxuXHRcdFx0dGhpcy5wYW5Ubyh0aGlzLnVucHJvamVjdChwaXhlbENlbnRlciksIG9wdGlvbnMpO1xyXG5cdFx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUob3B0aW9uczogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBDaGVja3MgaWYgdGhlIG1hcCBjb250YWluZXIgc2l6ZSBjaGFuZ2VkIGFuZCB1cGRhdGVzIHRoZSBtYXAgaWYgc28g4oCUXHJcblx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcblx0Ly8gcGFuIGJ5IGRlZmF1bHQuIElmIGBvcHRpb25zLnBhbmAgaXMgYGZhbHNlYCwgcGFubmluZyB3aWxsIG5vdCBvY2N1ci5cclxuXHQvLyBJZiBgb3B0aW9ucy5kZWJvdW5jZU1vdmVlbmRgIGlzIGB0cnVlYCwgaXQgd2lsbCBkZWxheSBgbW92ZWVuZGAgZXZlbnQgc29cclxuXHQvLyB0aGF0IGl0IGRvZXNuJ3QgaGFwcGVuIG9mdGVuIGV2ZW4gaWYgdGhlIG1ldGhvZCBpcyBjYWxsZWQgbWFueVxyXG5cdC8vIHRpbWVzIGluIGEgcm93LlxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGludmFsaWRhdGVTaXplKGFuaW1hdGU6IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gQ2hlY2tzIGlmIHRoZSBtYXAgY29udGFpbmVyIHNpemUgY2hhbmdlZCBhbmQgdXBkYXRlcyB0aGUgbWFwIGlmIHNvIOKAlFxyXG5cdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xyXG5cdC8vIHBhbiBieSBkZWZhdWx0LlxyXG5cdGludmFsaWRhdGVTaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRvcHRpb25zID0gVXRpbC5leHRlbmQoe1xyXG5cdFx0XHRhbmltYXRlOiBmYWxzZSxcclxuXHRcdFx0cGFuOiB0cnVlXHJcblx0XHR9LCBvcHRpb25zID09PSB0cnVlID8ge2FuaW1hdGU6IHRydWV9IDogb3B0aW9ucyk7XHJcblxyXG5cdFx0dmFyIG9sZFNpemUgPSB0aGlzLmdldFNpemUoKTtcclxuXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBudWxsO1xyXG5cclxuXHRcdHZhciBuZXdTaXplID0gdGhpcy5nZXRTaXplKCksXHJcblx0XHQgICAgb2xkQ2VudGVyID0gb2xkU2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IG5ld1NpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuXHRcdCAgICBvZmZzZXQgPSBvbGRDZW50ZXIuc3VidHJhY3QobmV3Q2VudGVyKTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgJiYgb3B0aW9ucy5wYW4pIHtcclxuXHRcdFx0dGhpcy5wYW5CeShvZmZzZXQpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmIChvcHRpb25zLnBhbikge1xyXG5cdFx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kKSB7XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcblx0XHRcdFx0dGhpcy5fc2l6ZVRpbWVyID0gc2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbW92ZWVuZCcpLCAyMDApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuXHRcdC8vIEBldmVudCByZXNpemU6IFJlc2l6ZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgcmVzaXplZC5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ3Jlc2l6ZScsIHtcclxuXHRcdFx0b2xkU2l6ZTogb2xkU2l6ZSxcclxuXHRcdFx0bmV3U2l6ZTogbmV3U2l6ZVxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxyXG5cdC8vIEBtZXRob2Qgc3RvcCgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgdGhlIGN1cnJlbnRseSBydW5uaW5nIGBwYW5Ub2Agb3IgYGZseVRvYCBhbmltYXRpb24sIGlmIGFueS5cclxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnNldFpvb20odGhpcy5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcclxuXHRcdGlmICghdGhpcy5vcHRpb25zLnpvb21TbmFwKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgndmlld3Jlc2V0Jyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fc3RvcCgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIEdlb2xvY2F0aW9uIG1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGxvY2F0ZShvcHRpb25zPzogTG9jYXRlIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gVHJpZXMgdG8gbG9jYXRlIHRoZSB1c2VyIHVzaW5nIHRoZSBHZW9sb2NhdGlvbiBBUEksIGZpcmluZyBhIFtgbG9jYXRpb25mb3VuZGBdKCNtYXAtbG9jYXRpb25mb3VuZClcclxuXHQvLyBldmVudCB3aXRoIGxvY2F0aW9uIGRhdGEgb24gc3VjY2VzcyBvciBhIFtgbG9jYXRpb25lcnJvcmBdKCNtYXAtbG9jYXRpb25lcnJvcikgZXZlbnQgb24gZmFpbHVyZSxcclxuXHQvLyBhbmQgb3B0aW9uYWxseSBzZXRzIHRoZSBtYXAgdmlldyB0byB0aGUgdXNlcidzIGxvY2F0aW9uIHdpdGggcmVzcGVjdCB0b1xyXG5cdC8vIGRldGVjdGlvbiBhY2N1cmFjeSAob3IgdG8gdGhlIHdvcmxkIHZpZXcgaWYgZ2VvbG9jYXRpb24gZmFpbGVkKS5cclxuXHQvLyBOb3RlIHRoYXQsIGlmIHlvdXIgcGFnZSBkb2Vzbid0IHVzZSBIVFRQUywgdGhpcyBtZXRob2Qgd2lsbCBmYWlsIGluXHJcblx0Ly8gbW9kZXJuIGJyb3dzZXJzIChbQ2hyb21lIDUwIGFuZCBuZXdlcl0oaHR0cHM6Ly9zaXRlcy5nb29nbGUuY29tL2EvY2hyb21pdW0ub3JnL2Rldi9Ib21lL2Nocm9taXVtLXNlY3VyaXR5L2RlcHJlY2F0aW5nLXBvd2VyZnVsLWZlYXR1cmVzLW9uLWluc2VjdXJlLW9yaWdpbnMpKVxyXG5cdC8vIFNlZSBgTG9jYXRlIG9wdGlvbnNgIGZvciBtb3JlIGRldGFpbHMuXHJcblx0bG9jYXRlOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zID0gVXRpbC5leHRlbmQoe1xyXG5cdFx0XHR0aW1lb3V0OiAxMDAwMCxcclxuXHRcdFx0d2F0Y2g6IGZhbHNlXHJcblx0XHRcdC8vIHNldFZpZXc6IGZhbHNlXHJcblx0XHRcdC8vIG1heFpvb206IDxOdW1iZXI+XHJcblx0XHRcdC8vIG1heGltdW1BZ2U6IDBcclxuXHRcdFx0Ly8gZW5hYmxlSGlnaEFjY3VyYWN5OiBmYWxzZVxyXG5cdFx0fSwgb3B0aW9ucyk7XHJcblxyXG5cdFx0aWYgKCEoJ2dlb2xvY2F0aW9uJyBpbiBuYXZpZ2F0b3IpKSB7XHJcblx0XHRcdHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3Ioe1xyXG5cdFx0XHRcdGNvZGU6IDAsXHJcblx0XHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIG5vdCBzdXBwb3J0ZWQuJ1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9uUmVzcG9uc2UgPSBVdGlsLmJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZSwgdGhpcyksXHJcblx0XHQgICAgb25FcnJvciA9IFV0aWwuYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yLCB0aGlzKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy53YXRjaCkge1xyXG5cdFx0XHR0aGlzLl9sb2NhdGlvbldhdGNoSWQgPVxyXG5cdFx0XHQgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc3RvcExvY2F0ZSgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgd2F0Y2hpbmcgbG9jYXRpb24gcHJldmlvdXNseSBpbml0aWF0ZWQgYnkgYG1hcC5sb2NhdGUoe3dhdGNoOiB0cnVlfSlgXHJcblx0Ly8gYW5kIGFib3J0cyByZXNldHRpbmcgdGhlIG1hcCB2aWV3IGlmIG1hcC5sb2NhdGUgd2FzIGNhbGxlZCB3aXRoXHJcblx0Ly8gYHtzZXRWaWV3OiB0cnVlfWAuXHJcblx0c3RvcExvY2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbiAmJiBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCkge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl9sb2NhdGlvbldhdGNoSWQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlR2VvbG9jYXRpb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgYyA9IGVycm9yLmNvZGUsXHJcblx0XHQgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHxcclxuXHRcdCAgICAgICAgICAgIChjID09PSAxID8gJ3Blcm1pc3Npb24gZGVuaWVkJyA6XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMiA/ICdwb3NpdGlvbiB1bmF2YWlsYWJsZScgOiAndGltZW91dCcpKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ICYmICF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5maXRXb3JsZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIExvY2F0aW9uIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZXJyb3I6IEVycm9yRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpIGZhaWxlZC5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25lcnJvcicsIHtcclxuXHRcdFx0Y29kZTogYyxcclxuXHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIGVycm9yOiAnICsgbWVzc2FnZSArICcuJ1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2U6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBsYXQgPSBwb3MuY29vcmRzLmxhdGl0dWRlLFxyXG5cdFx0ICAgIGxuZyA9IHBvcy5jb29yZHMubG9uZ2l0dWRlLFxyXG5cdFx0ICAgIGxhdGxuZyA9IG5ldyBMYXRMbmcobGF0LCBsbmcpLFxyXG5cdFx0ICAgIGJvdW5kcyA9IGxhdGxuZy50b0JvdW5kcyhwb3MuY29vcmRzLmFjY3VyYWN5ICogMiksXHJcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuc2V0Vmlldykge1xyXG5cdFx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMpO1xyXG5cdFx0XHR0aGlzLnNldFZpZXcobGF0bG5nLCBvcHRpb25zLm1heFpvb20gPyBNYXRoLm1pbih6b29tLCBvcHRpb25zLm1heFpvb20pIDogem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdGxhdGxuZzogbGF0bG5nLFxyXG5cdFx0XHRib3VuZHM6IGJvdW5kcyxcclxuXHRcdFx0dGltZXN0YW1wOiBwb3MudGltZXN0YW1wXHJcblx0XHR9O1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gcG9zLmNvb3Jkcykge1xyXG5cdFx0XHRpZiAodHlwZW9mIHBvcy5jb29yZHNbaV0gPT09ICdudW1iZXInKSB7XHJcblx0XHRcdFx0ZGF0YVtpXSA9IHBvcy5jb29yZHNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbG9jYXRpb25mb3VuZDogTG9jYXRpb25FdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBnZW9sb2NhdGlvbiAodXNpbmcgdGhlIFtgbG9jYXRlYF0oI21hcC1sb2NhdGUpIG1ldGhvZClcclxuXHRcdC8vIHdlbnQgc3VjY2Vzc2Z1bGx5LlxyXG5cdFx0dGhpcy5maXJlKCdsb2NhdGlvbmZvdW5kJywgZGF0YSk7XHJcblx0fSxcclxuXHJcblx0Ly8gVE9ETyBBcHByb3ByaWF0ZSBkb2NzIHNlY3Rpb24/XHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cdC8vIEBtZXRob2QgYWRkSGFuZGxlcihuYW1lOiBTdHJpbmcsIEhhbmRsZXJDbGFzczogRnVuY3Rpb24pOiB0aGlzXHJcblx0Ly8gQWRkcyBhIG5ldyBgSGFuZGxlcmAgdG8gdGhlIG1hcCwgZ2l2ZW4gaXRzIG5hbWUgYW5kIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG5cdGFkZEhhbmRsZXI6IGZ1bmN0aW9uIChuYW1lLCBIYW5kbGVyQ2xhc3MpIHtcclxuXHRcdGlmICghSGFuZGxlckNsYXNzKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGhhbmRsZXIgPSB0aGlzW25hbWVdID0gbmV3IEhhbmRsZXJDbGFzcyh0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcclxuXHRcdFx0aGFuZGxlci5lbmFibGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZSgpOiB0aGlzXHJcblx0Ly8gRGVzdHJveXMgdGhlIG1hcCBhbmQgY2xlYXJzIGFsbCByZWxhdGVkIGV2ZW50IGxpc3RlbmVycy5cclxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLl9pbml0RXZlbnRzKHRydWUpO1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpIHsgdGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpOyB9XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcklkICE9PSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGJlaW5nIHJldXNlZCBieSBhbm90aGVyIGluc3RhbmNlJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gdGhyb3dzIGVycm9yIGluIElFNi04XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQ7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXJJZDtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdFx0XHR0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQgPSB1bmRlZmluZWQ7XHJcblx0XHRcdC8qIGVzbGludC1lbmFibGUgKi9cclxuXHRcdFx0dGhpcy5fY29udGFpbmVySWQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuc3RvcExvY2F0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9tYXBQYW5lKTtcclxuXHJcblx0XHRpZiAodGhpcy5fY2xlYXJDb250cm9sUG9zKSB7XHJcblx0XHRcdHRoaXMuX2NsZWFyQ29udHJvbFBvcygpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpIHtcclxuXHRcdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fcmVzaXplUmVxdWVzdCk7XHJcblx0XHRcdHRoaXMuX3Jlc2l6ZVJlcXVlc3QgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NsZWFySGFuZGxlcnMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCB1bmxvYWQ6IEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBkZXN0cm95ZWQgd2l0aCBbcmVtb3ZlXSgjbWFwLXJlbW92ZSkgbWV0aG9kLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ3VubG9hZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpO1xyXG5cdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ucmVtb3ZlKCk7XHJcblx0XHR9XHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fcGFuZXMpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fcGFuZXNbaV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IFtdO1xyXG5cdFx0dGhpcy5fcGFuZXMgPSBbXTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9tYXBQYW5lO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX3JlbmRlcmVyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVBhbmUobmFtZTogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ3JlYXRlcyBhIG5ldyBbbWFwIHBhbmVdKCNtYXAtcGFuZSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpZiBpdCBkb2Vzbid0IGV4aXN0IGFscmVhZHksXHJcblx0Ly8gdGhlbiByZXR1cm5zIGl0LiBUaGUgcGFuZSBpcyBjcmVhdGVkIGFzIGEgY2hpbGQgb2YgYGNvbnRhaW5lcmAsIG9yXHJcblx0Ly8gYXMgYSBjaGlsZCBvZiB0aGUgbWFpbiBtYXAgcGFuZSBpZiBub3Qgc2V0LlxyXG5cdGNyZWF0ZVBhbmU6IGZ1bmN0aW9uIChuYW1lLCBjb250YWluZXIpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1wYW5lJyArIChuYW1lID8gJyBsZWFmbGV0LScgKyBuYW1lLnJlcGxhY2UoJ1BhbmUnLCAnJykgKyAnLXBhbmUnIDogJycpLFxyXG5cdFx0ICAgIHBhbmUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIgfHwgdGhpcy5fbWFwUGFuZSk7XHJcblxyXG5cdFx0aWYgKG5hbWUpIHtcclxuXHRcdFx0dGhpcy5fcGFuZXNbbmFtZV0gPSBwYW5lO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHBhbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgR2V0dGluZyBNYXAgU3RhdGVcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGNlbnRlciBvZiB0aGUgbWFwIHZpZXdcclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbGFzdENlbnRlciAmJiAhdGhpcy5fbW92ZWQoKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fbGFzdENlbnRlci5jbG9uZSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBvZiB0aGUgbWFwIHZpZXdcclxuXHRnZXRab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fem9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgYm91bmRzIHZpc2libGUgaW4gdGhlIGN1cnJlbnQgbWFwIHZpZXdcclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBib3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgc3cgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0Qm90dG9tTGVmdCgpKSxcclxuXHRcdCAgICBuZSA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRUb3BSaWdodCgpKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhzdywgbmUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TWluWm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWluWm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycyksIG9yIGAwYCBieSBkZWZhdWx0LlxyXG5cdGdldE1pblpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fbGF5ZXJzTWluWm9vbSB8fCAwIDogdGhpcy5vcHRpb25zLm1pblpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRNYXhab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtYXhab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKS5cclxuXHRnZXRNYXhab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdCh0aGlzLl9sYXllcnNNYXhab29tID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IHRoaXMuX2xheWVyc01heFpvb20pIDpcclxuXHRcdFx0dGhpcy5vcHRpb25zLm1heFpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHNab29tKGJvdW5kczogTGF0TG5nQm91bmRzLCBpbnNpZGU/OiBCb29sZWFuLCBwYWRkaW5nPzogUG9pbnQpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIGdpdmVuIGJvdW5kcyBmaXQgdG8gdGhlIG1hcFxyXG5cdC8vIHZpZXcgaW4gaXRzIGVudGlyZXR5LiBJZiBgaW5zaWRlYCAob3B0aW9uYWwpIGlzIHNldCB0byBgdHJ1ZWAsIHRoZSBtZXRob2RcclxuXHQvLyBpbnN0ZWFkIHJldHVybnMgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgbWFwIHZpZXcgZml0cyBpbnRvXHJcblx0Ly8gdGhlIGdpdmVuIGJvdW5kcyBpbiBpdHMgZW50aXJldHkuXHJcblx0Z2V0Qm91bmRzWm9vbTogZnVuY3Rpb24gKGJvdW5kcywgaW5zaWRlLCBwYWRkaW5nKSB7IC8vIChMYXRMbmdCb3VuZHNbLCBCb29sZWFuLCBQb2ludF0pIC0+IE51bWJlclxyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHRcdHBhZGRpbmcgPSB0b1BvaW50KHBhZGRpbmcgfHwgWzAsIDBdKTtcclxuXHJcblx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0Wm9vbSgpIHx8IDAsXHJcblx0XHQgICAgbWluID0gdGhpcy5nZXRNaW5ab29tKCksXHJcblx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXHJcblx0XHQgICAgbncgPSBib3VuZHMuZ2V0Tm9ydGhXZXN0KCksXHJcblx0XHQgICAgc2UgPSBib3VuZHMuZ2V0U291dGhFYXN0KCksXHJcblx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLnN1YnRyYWN0KHBhZGRpbmcpLFxyXG5cdFx0ICAgIGJvdW5kc1NpemUgPSB0b0JvdW5kcyh0aGlzLnByb2plY3Qoc2UsIHpvb20pLCB0aGlzLnByb2plY3QobncsIHpvb20pKS5nZXRTaXplKCksXHJcblx0XHQgICAgc25hcCA9IEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbVNuYXAgOiAxLFxyXG5cdFx0ICAgIHNjYWxleCA9IHNpemUueCAvIGJvdW5kc1NpemUueCxcclxuXHRcdCAgICBzY2FsZXkgPSBzaXplLnkgLyBib3VuZHNTaXplLnksXHJcblx0XHQgICAgc2NhbGUgPSBpbnNpZGUgPyBNYXRoLm1heChzY2FsZXgsIHNjYWxleSkgOiBNYXRoLm1pbihzY2FsZXgsIHNjYWxleSk7XHJcblxyXG5cdFx0em9vbSA9IHRoaXMuZ2V0U2NhbGVab29tKHNjYWxlLCB6b29tKTtcclxuXHJcblx0XHRpZiAoc25hcCkge1xyXG5cdFx0XHR6b29tID0gTWF0aC5yb3VuZCh6b29tIC8gKHNuYXAgLyAxMDApKSAqIChzbmFwIC8gMTAwKTsgLy8gZG9uJ3QganVtcCBpZiB3aXRoaW4gMSUgb2YgYSBzbmFwIGxldmVsXHJcblx0XHRcdHpvb20gPSBpbnNpZGUgPyBNYXRoLmNlaWwoem9vbSAvIHNuYXApICogc25hcCA6IE1hdGguZmxvb3Ioem9vbSAvIHNuYXApICogc25hcDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNpemUoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIG1hcCBjb250YWluZXIgKGluIHBpeGVscykuXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9zaXplIHx8IHRoaXMuX3NpemVDaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuX3NpemUgPSBuZXcgUG9pbnQoXHJcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoIHx8IDAsXHJcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCB8fCAwKTtcclxuXHJcblx0XHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZS5jbG9uZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxCb3VuZHMoKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSBjdXJyZW50IG1hcCB2aWV3IGluIHByb2plY3RlZCBwaXhlbFxyXG5cdC8vIGNvb3JkaW5hdGVzIChzb21ldGltZXMgdXNlZnVsIGluIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXHJcblx0Z2V0UGl4ZWxCb3VuZHM6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciB0b3BMZWZ0UG9pbnQgPSB0aGlzLl9nZXRUb3BMZWZ0UG9pbnQoY2VudGVyLCB6b29tKTtcclxuXHRcdHJldHVybiBuZXcgQm91bmRzKHRvcExlZnRQb2ludCwgdG9wTGVmdFBvaW50LmFkZCh0aGlzLmdldFNpemUoKSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIFRPRE86IENoZWNrIHNlbWFudGljcyAtIGlzbid0IHRoZSBwaXhlbCBvcmlnaW4gdGhlIDAsMCBjb29yZCByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBtYXAgcGFuZT8gXCJsZWZ0IHBvaW50IG9mIHRoZSBtYXAgbGF5ZXJcIiBjYW4gYmUgY29uZnVzaW5nLCBzcGVjaWFsbHlcclxuXHQvLyBzaW5jZSB0aGVyZSBjYW4gYmUgbmVnYXRpdmUgb2Zmc2V0cy5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsT3JpZ2luKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGVkIHBpeGVsIGNvb3JkaW5hdGVzIG9mIHRoZSB0b3AgbGVmdCBwb2ludCBvZlxyXG5cdC8vIHRoZSBtYXAgbGF5ZXIgKHVzZWZ1bCBpbiBjdXN0b20gbGF5ZXIgYW5kIG92ZXJsYXkgaW1wbGVtZW50YXRpb25zKS5cclxuXHRnZXRQaXhlbE9yaWdpbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BpeGVsT3JpZ2luO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxXb3JsZEJvdW5kcyh6b29tPzogTnVtYmVyKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgd29ybGQncyBib3VuZHMgaW4gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIHpvb20gbGV2ZWwgYHpvb21gLlxyXG5cdC8vIElmIGB6b29tYCBpcyBvbWl0dGVkLCB0aGUgbWFwJ3MgY3VycmVudCB6b29tIGxldmVsIGlzIHVzZWQuXHJcblx0Z2V0UGl4ZWxXb3JsZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmdldFByb2plY3RlZEJvdW5kcyh6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLmdldFpvb20oKSA6IHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQYW5lKHBhbmU6IFN0cmluZ3xIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyBhIFttYXAgcGFuZV0oI21hcC1wYW5lKSwgZ2l2ZW4gaXRzIG5hbWUgb3IgaXRzIEhUTUwgZWxlbWVudCAoaXRzIGlkZW50aXR5KS5cclxuXHRnZXRQYW5lOiBmdW5jdGlvbiAocGFuZSkge1xyXG5cdFx0cmV0dXJuIHR5cGVvZiBwYW5lID09PSAnc3RyaW5nJyA/IHRoaXMuX3BhbmVzW3BhbmVdIDogcGFuZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBhbmVzKCk6IE9iamVjdFxyXG5cdC8vIFJldHVybnMgYSBwbGFpbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgYWxsIFtwYW5lc10oI21hcC1wYW5lKSBhcyBrZXlzIGFuZFxyXG5cdC8vIHRoZSBwYW5lcyBhcyB2YWx1ZXMuXHJcblx0Z2V0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9wYW5lcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgbWFwLlxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gQHNlY3Rpb24gQ29udmVyc2lvbiBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Wm9vbVNjYWxlKHRvWm9vbTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgZmFjdG9yIHRvIGJlIGFwcGxpZWQgdG8gYSBtYXAgdHJhbnNpdGlvbiBmcm9tIHpvb20gbGV2ZWxcclxuXHQvLyBgZnJvbVpvb21gIHRvIGB0b1pvb21gLiBVc2VkIGludGVybmFsbHkgdG8gaGVscCB3aXRoIHpvb20gYW5pbWF0aW9ucy5cclxuXHRnZXRab29tU2NhbGU6IGZ1bmN0aW9uICh0b1pvb20sIGZyb21ab29tKSB7XHJcblx0XHQvLyBUT0RPIHJlcGxhY2Ugd2l0aCB1bml2ZXJzYWwgaW1wbGVtZW50YXRpb24gYWZ0ZXIgcmVmYWN0b3JpbmcgcHJvamVjdGlvbnNcclxuXHRcdHZhciBjcnMgPSB0aGlzLm9wdGlvbnMuY3JzO1xyXG5cdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG5cdFx0cmV0dXJuIGNycy5zY2FsZSh0b1pvb20pIC8gY3JzLnNjYWxlKGZyb21ab29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNjYWxlWm9vbShzY2FsZTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgem9vbSBsZXZlbCB0aGF0IHRoZSBtYXAgd291bGQgZW5kIHVwIGF0LCBpZiBpdCBpcyBhdCBgZnJvbVpvb21gXHJcblx0Ly8gbGV2ZWwgYW5kIGV2ZXJ5dGhpbmcgaXMgc2NhbGVkIGJ5IGEgZmFjdG9yIG9mIGBzY2FsZWAuIEludmVyc2Ugb2ZcclxuXHQvLyBbYGdldFpvb21TY2FsZWBdKCNtYXAtZ2V0Wm9vbVNjYWxlKS5cclxuXHRnZXRTY2FsZVpvb206IGZ1bmN0aW9uIChzY2FsZSwgZnJvbVpvb20pIHtcclxuXHRcdHZhciBjcnMgPSB0aGlzLm9wdGlvbnMuY3JzO1xyXG5cdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG5cdFx0dmFyIHpvb20gPSBjcnMuem9vbShzY2FsZSAqIGNycy5zY2FsZShmcm9tWm9vbSkpO1xyXG5cdFx0cmV0dXJuIGlzTmFOKHpvb20pID8gSW5maW5pdHkgOiB6b29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIGBMYXRMbmdgIGFjY29yZGluZyB0byB0aGUgcHJvamVjdGlvblxyXG5cdC8vIG9mIHRoZSBtYXAncyBDUlMsIHRoZW4gc2NhbGVzIGl0IGFjY29yZGluZyB0byBgem9vbWAgYW5kIHRoZSBDUlMnc1xyXG5cdC8vIGBUcmFuc2Zvcm1hdGlvbmAuIFRoZSByZXN1bHQgaXMgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBDUlMgb3JpZ2luLlxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogem9vbTtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmxhdExuZ1RvUG9pbnQodG9MYXRMbmcobGF0bG5nKSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50LCB6b29tOiBOdW1iZXIpOiBMYXRMbmdcclxuXHQvLyBJbnZlcnNlIG9mIFtgcHJvamVjdGBdKCNtYXAtcHJvamVjdCkuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogem9vbTtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLnBvaW50VG9MYXRMbmcodG9Qb2ludChwb2ludCksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF5ZXJQb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbiksXHJcblx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG5cdGxheWVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0b1BvaW50KHBvaW50KS5hZGQodGhpcy5nZXRQaXhlbE9yaWdpbigpKTtcclxuXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChwcm9qZWN0ZWRQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG5cdC8vIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKS5cclxuXHRsYXRMbmdUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdCh0b0xhdExuZyhsYXRsbmcpKS5fcm91bmQoKTtcclxuXHRcdHJldHVybiBwcm9qZWN0ZWRQb2ludC5fc3VidHJhY3QodGhpcy5nZXRQaXhlbE9yaWdpbigpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ2Agd2hlcmUgYGxhdGAgYW5kIGBsbmdgIGhhcyBiZWVuIHdyYXBwZWQgYWNjb3JkaW5nIHRvIHRoZVxyXG5cdC8vIG1hcCdzIENSUydzIGB3cmFwTGF0YCBhbmQgYHdyYXBMbmdgIHByb3BlcnRpZXMsIGlmIHRoZXkgYXJlIG91dHNpZGUgdGhlXHJcblx0Ly8gQ1JTJ3MgYm91bmRzLlxyXG5cdC8vIEJ5IGRlZmF1bHQgdGhpcyBtZWFucyBsb25naXR1ZGUgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGRhdGVsaW5lIHNvIGl0c1xyXG5cdC8vIHZhbHVlIGlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLlxyXG5cdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLndyYXBMYXRMbmcodG9MYXRMbmcobGF0bG5nKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdCb3VuZHNgIHdpdGggdGhlIHNhbWUgc2l6ZSBhcyB0aGUgZ2l2ZW4gb25lLCBlbnN1cmluZyB0aGF0XHJcblx0Ly8gaXRzIGNlbnRlciBpcyB3aXRoaW4gdGhlIENSUydzIGJvdW5kcy5cclxuXHQvLyBCeSBkZWZhdWx0IHRoaXMgbWVhbnMgdGhlIGNlbnRlciBsb25naXR1ZGUgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGRhdGVsaW5lIHNvIGl0c1xyXG5cdC8vIHZhbHVlIGlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLCBhbmQgdGhlIG1ham9yaXR5IG9mIHRoZSBib3VuZHNcclxuXHQvLyBvdmVybGFwcyB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdHdyYXBMYXRMbmdCb3VuZHM6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLndyYXBMYXRMbmdCb3VuZHModG9MYXRMbmdCb3VuZHMobGF0bG5nKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBhY2NvcmRpbmcgdG9cclxuXHQvLyB0aGUgbWFwJ3MgQ1JTLiBCeSBkZWZhdWx0IHRoaXMgbWVhc3VyZXMgZGlzdGFuY2UgaW4gbWV0ZXJzLlxyXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZGlzdGFuY2UodG9MYXRMbmcobGF0bG5nMSksIHRvTGF0TG5nKGxhdGxuZzIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nXHJcblx0Ly8gcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikuXHJcblx0Y29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRyZXR1cm4gdG9Qb2ludChwb2ludCkuc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSxcclxuXHQvLyByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcblx0bGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRyZXR1cm4gdG9Qb2ludChwb2ludCkuYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWluZXJQb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJuc1xyXG5cdC8vIHRoZSBjb3JyZXNwb25kaW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIChmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXHJcblx0Y29udGFpbmVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgbGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodG9Qb2ludChwb2ludCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlXHJcblx0Ly8gcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcblx0bGF0TG5nVG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQodGhpcy5sYXRMbmdUb0xheWVyUG9pbnQodG9MYXRMbmcobGF0bG5nKSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgdGhlIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlXHJcblx0Ly8gbWFwIGNvbnRhaW5lciB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiBEb21FdmVudC5nZXRNb3VzZVBvc2l0aW9uKGUsIHRoaXMuX2NvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9MYXllclBvaW50KGV2OiBNb3VzZUV2ZW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pIHdoZXJlIHRoZSBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xhdExuZyhldjogTW91c2VFdmVudCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgd2hlcmUgdGhlXHJcblx0Ly8gZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9MYXRMbmc6IGZ1bmN0aW9uIChlKSB7IC8vIChNb3VzZUV2ZW50KVxyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIG1hcCBpbml0aWFsaXphdGlvbiBtZXRob2RzXHJcblxyXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmdldChpZCk7XHJcblxyXG5cdFx0aWYgKCFjb250YWluZXIpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIG5vdCBmb3VuZC4nKTtcclxuXHRcdH0gZWxzZSBpZiAoY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBpcyBhbHJlYWR5IGluaXRpYWxpemVkLicpO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbUV2ZW50Lm9uKGNvbnRhaW5lciwgJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsLCB0aGlzKTtcclxuXHRcdHRoaXMuX2NvbnRhaW5lcklkID0gVXRpbC5zdGFtcChjb250YWluZXIpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xyXG5cclxuXHRcdHRoaXMuX2ZhZGVBbmltYXRlZCA9IHRoaXMub3B0aW9ucy5mYWRlQW5pbWF0aW9uICYmIEJyb3dzZXIuYW55M2Q7XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRhaW5lcicgK1xyXG5cdFx0XHQoQnJvd3Nlci50b3VjaCA/ICcgbGVhZmxldC10b3VjaCcgOiAnJykgK1xyXG5cdFx0XHQoQnJvd3Nlci5yZXRpbmEgPyAnIGxlYWZsZXQtcmV0aW5hJyA6ICcnKSArXHJcblx0XHRcdChCcm93c2VyLmllbHQ5ID8gJyBsZWFmbGV0LW9sZGllJyA6ICcnKSArXHJcblx0XHRcdChCcm93c2VyLnNhZmFyaSA/ICcgbGVhZmxldC1zYWZhcmknIDogJycpICtcclxuXHRcdFx0KHRoaXMuX2ZhZGVBbmltYXRlZCA/ICcgbGVhZmxldC1mYWRlLWFuaW0nIDogJycpKTtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSBEb21VdGlsLmdldFN0eWxlKGNvbnRhaW5lciwgJ3Bvc2l0aW9uJyk7XHJcblxyXG5cdFx0aWYgKHBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHBvc2l0aW9uICE9PSAncmVsYXRpdmUnICYmIHBvc2l0aW9uICE9PSAnZml4ZWQnICYmIHBvc2l0aW9uICE9PSAnc3RpY2t5Jykge1xyXG5cdFx0XHRjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRQYW5lcygpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0Q29udHJvbFBvcykge1xyXG5cdFx0XHR0aGlzLl9pbml0Q29udHJvbFBvcygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9pbml0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwYW5lcyA9IHRoaXMuX3BhbmVzID0ge307XHJcblx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzID0ge307XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb25cclxuXHRcdC8vXHJcblx0XHQvLyBQYW5lcyBhcmUgRE9NIGVsZW1lbnRzIHVzZWQgdG8gY29udHJvbCB0aGUgb3JkZXJpbmcgb2YgbGF5ZXJzIG9uIHRoZSBtYXAuIFlvdVxyXG5cdFx0Ly8gY2FuIGFjY2VzcyBwYW5lcyB3aXRoIFtgbWFwLmdldFBhbmVgXSgjbWFwLWdldHBhbmUpIG9yXHJcblx0XHQvLyBbYG1hcC5nZXRQYW5lc2BdKCNtYXAtZ2V0cGFuZXMpIG1ldGhvZHMuIE5ldyBwYW5lcyBjYW4gYmUgY3JlYXRlZCB3aXRoIHRoZVxyXG5cdFx0Ly8gW2BtYXAuY3JlYXRlUGFuZWBdKCNtYXAtY3JlYXRlcGFuZSkgbWV0aG9kLlxyXG5cdFx0Ly9cclxuXHRcdC8vIEV2ZXJ5IG1hcCBoYXMgdGhlIGZvbGxvd2luZyBkZWZhdWx0IHBhbmVzIHRoYXQgZGlmZmVyIG9ubHkgaW4gekluZGV4LlxyXG5cdFx0Ly9cclxuXHRcdC8vIEBwYW5lIG1hcFBhbmU6IEhUTUxFbGVtZW50ID0gJ2F1dG8nXHJcblx0XHQvLyBQYW5lIHRoYXQgY29udGFpbnMgYWxsIG90aGVyIG1hcCBwYW5lc1xyXG5cclxuXHRcdHRoaXMuX21hcFBhbmUgPSB0aGlzLmNyZWF0ZVBhbmUoJ21hcFBhbmUnLCB0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCBuZXcgUG9pbnQoMCwgMCkpO1xyXG5cclxuXHRcdC8vIEBwYW5lIHRpbGVQYW5lOiBIVE1MRWxlbWVudCA9IDIwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYEdyaWRMYXllcmBzIGFuZCBgVGlsZUxheWVyYHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgndGlsZVBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIG92ZXJsYXlQYW5lOiBIVE1MRWxlbWVudCA9IDQwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgdmVjdG9ycyAoYFBhdGhgcywgbGlrZSBgUG9seWxpbmVgcyBhbmQgYFBvbHlnb25gcyksIGBJbWFnZU92ZXJsYXlgcyBhbmQgYFZpZGVvT3ZlcmxheWBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ292ZXJsYXlQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBzaGFkb3dQYW5lOiBIVE1MRWxlbWVudCA9IDUwMFxyXG5cdFx0Ly8gUGFuZSBmb3Igb3ZlcmxheSBzaGFkb3dzIChlLmcuIGBNYXJrZXJgIHNoYWRvd3MpXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3NoYWRvd1BhbmUnKTtcclxuXHRcdC8vIEBwYW5lIG1hcmtlclBhbmU6IEhUTUxFbGVtZW50ID0gNjAwXHJcblx0XHQvLyBQYW5lIGZvciBgSWNvbmBzIG9mIGBNYXJrZXJgc1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdtYXJrZXJQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSB0b29sdGlwUGFuZTogSFRNTEVsZW1lbnQgPSA2NTBcclxuXHRcdC8vIFBhbmUgZm9yIGBUb29sdGlwYHMuXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3Rvb2x0aXBQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBwb3B1cFBhbmU6IEhUTUxFbGVtZW50ID0gNzAwXHJcblx0XHQvLyBQYW5lIGZvciBgUG9wdXBgcy5cclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgncG9wdXBQYW5lJyk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbikge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHBhbmVzLm1hcmtlclBhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHBhbmVzLnNoYWRvd1BhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwcml2YXRlIG1ldGhvZHMgdGhhdCBtb2RpZnkgbWFwIHN0YXRlXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0X3Jlc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgbm9Nb3ZlU3RhcnQpIHtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcblx0XHR2YXIgbG9hZGluZyA9ICF0aGlzLl9sb2FkZWQ7XHJcblx0XHR0aGlzLl9sb2FkZWQgPSB0cnVlO1xyXG5cdFx0em9vbSA9IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdwcmVyZXNldCcpO1xyXG5cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblx0XHR0aGlzXHJcblx0XHRcdC5fbW92ZVN0YXJ0KHpvb21DaGFuZ2VkLCBub01vdmVTdGFydClcclxuXHRcdFx0Ll9tb3ZlKGNlbnRlciwgem9vbSlcclxuXHRcdFx0Ll9tb3ZlRW5kKHpvb21DaGFuZ2VkKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgdmlld3Jlc2V0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIG5lZWRzIHRvIHJlZHJhdyBpdHMgY29udGVudCAodGhpcyB1c3VhbGx5IGhhcHBlbnNcclxuXHRcdC8vIG9uIG1hcCB6b29tIG9yIGxvYWQpLiBWZXJ5IHVzZWZ1bCBmb3IgY3JlYXRpbmcgY3VzdG9tIG92ZXJsYXlzLlxyXG5cdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBpbml0aWFsaXplZCAod2hlbiBpdHMgY2VudGVyIGFuZCB6b29tIGFyZSBzZXRcclxuXHRcdC8vIGZvciB0aGUgZmlyc3QgdGltZSkuXHJcblx0XHRpZiAobG9hZGluZykge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfbW92ZVN0YXJ0OiBmdW5jdGlvbiAoem9vbUNoYW5nZWQsIG5vTW92ZVN0YXJ0KSB7XHJcblx0XHQvLyBAZXZlbnQgem9vbXN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHpvb20gaXMgYWJvdXQgdG8gY2hhbmdlIChlLmcuIGJlZm9yZSB6b29tIGFuaW1hdGlvbikuXHJcblx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdmlldyBvZiB0aGUgbWFwIHN0YXJ0cyBjaGFuZ2luZyAoZS5nLiB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFwKS5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21zdGFydCcpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCFub01vdmVTdGFydCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X21vdmU6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGRhdGEsIHN1cHJlc3NFdmVudCkge1xyXG5cdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR6b29tID0gdGhpcy5fem9vbTtcclxuXHRcdH1cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblxyXG5cdFx0dGhpcy5fem9vbSA9IHpvb207XHJcblx0XHR0aGlzLl9sYXN0Q2VudGVyID0gY2VudGVyO1xyXG5cdFx0dGhpcy5fcGl4ZWxPcmlnaW4gPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIpO1xyXG5cclxuXHRcdGlmICghc3VwcmVzc0V2ZW50KSB7XHJcblx0XHRcdC8vIEBldmVudCB6b29tOiBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IGR1cmluZyBhbnkgY2hhbmdlIGluIHpvb20gbGV2ZWwsXHJcblx0XHRcdC8vIGluY2x1ZGluZyB6b29tIGFuZCBmbHkgYW5pbWF0aW9ucy5cclxuXHRcdFx0aWYgKHpvb21DaGFuZ2VkIHx8IChkYXRhICYmIGRhdGEucGluY2gpKSB7XHQvLyBBbHdheXMgZmlyZSAnem9vbScgaWYgcGluY2hpbmcgYmVjYXVzZSAjMzUzMFxyXG5cdFx0XHRcdHRoaXMuZmlyZSgnem9vbScsIGRhdGEpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW55IG1vdmVtZW50IG9mIHRoZSBtYXAsXHJcblx0XHRcdC8vIGluY2x1ZGluZyBwYW4gYW5kIGZseSBhbmltYXRpb25zLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmUnLCBkYXRhKTtcclxuXHRcdH0gZWxzZSBpZiAoZGF0YSAmJiBkYXRhLnBpbmNoKSB7XHQvLyBBbHdheXMgZmlyZSAnem9vbScgaWYgcGluY2hpbmcgYmVjYXVzZSAjMzUzMFxyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb20nLCBkYXRhKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlRW5kOiBmdW5jdGlvbiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdC8vIEBldmVudCB6b29tZW5kOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHpvb20gY2hhbmdlZCwgYWZ0ZXIgYW55IGFuaW1hdGlvbnMuXHJcblx0XHRpZiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tZW5kJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmVlbmQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBjZW50ZXIgb2YgdGhlIG1hcCBzdG9wcyBjaGFuZ2luZ1xyXG5cdFx0Ly8gKGUuZy4gdXNlciBzdG9wcGVkIGRyYWdnaW5nIHRoZSBtYXAgb3IgYWZ0ZXIgbm9uLWNlbnRlcmVkIHpvb20pLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdH0sXHJcblxyXG5cdF9zdG9wOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mbHlUb0ZyYW1lKTtcclxuXHRcdGlmICh0aGlzLl9wYW5BbmltKSB7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0uc3RvcCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3Jhd1BhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Wm9vbVNwYW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldE1heFpvb20oKSAtIHRoaXMuZ2V0TWluWm9vbSgpO1xyXG5cdH0sXHJcblxyXG5cdF9wYW5JbnNpZGVNYXhCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fZW5mb3JjaW5nQm91bmRzKSB7XHJcblx0XHRcdHRoaXMucGFuSW5zaWRlQm91bmRzKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jaGVja0lmTG9hZGVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NldCBtYXAgY2VudGVyIGFuZCB6b29tIGZpcnN0LicpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIERPTSBldmVudCBoYW5kbGluZ1xyXG5cclxuXHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBldmVudHNcclxuXHRfaW5pdEV2ZW50czogZnVuY3Rpb24gKHJlbW92ZSkge1xyXG5cdFx0dGhpcy5fdGFyZ2V0cyA9IHt9O1xyXG5cdFx0dGhpcy5fdGFyZ2V0c1tVdGlsLnN0YW1wKHRoaXMuX2NvbnRhaW5lcildID0gdGhpcztcclxuXHJcblx0XHR2YXIgb25PZmYgPSByZW1vdmUgPyBEb21FdmVudC5vZmYgOiBEb21FdmVudC5vbjtcclxuXHJcblx0XHQvLyBAZXZlbnQgY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIChvciB0YXBzKSB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IGRibGNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIGRvdWJsZS1jbGlja3MgKG9yIGRvdWJsZS10YXBzKSB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlZG93bjogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwdXNoZXMgdGhlIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNldXA6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgdGhlIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlb3ZlcjogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbW91c2UgZW50ZXJzIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2VvdXQ6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGxlYXZlcyB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlbW92ZTogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hpbGUgdGhlIG1vdXNlIG1vdmVzIG92ZXIgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBjb250ZXh0bWVudTogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwdXNoZXMgdGhlIHJpZ2h0IG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLCBwcmV2ZW50c1xyXG5cdFx0Ly8gZGVmYXVsdCBicm93c2VyIGNvbnRleHQgbWVudSBmcm9tIHNob3dpbmcgaWYgdGhlcmUgYXJlIGxpc3RlbmVycyBvblxyXG5cdFx0Ly8gdGhpcyBldmVudC4gQWxzbyBmaXJlZCBvbiBtb2JpbGUgd2hlbiB0aGUgdXNlciBob2xkcyBhIHNpbmdsZSB0b3VjaFxyXG5cdFx0Ly8gZm9yIGEgc2Vjb25kIChhbHNvIGNhbGxlZCBsb25nIHByZXNzKS5cclxuXHRcdC8vIEBldmVudCBrZXlwcmVzczogS2V5Ym9hcmRFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHRoYXQgcHJvZHVjZXMgYSBjaGFyYWN0ZXIgdmFsdWUgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLlxyXG5cdFx0Ly8gQGV2ZW50IGtleWRvd246IEtleWJvYXJkRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuIFVubGlrZSB0aGUgYGtleXByZXNzYCBldmVudCxcclxuXHRcdC8vIHRoZSBga2V5ZG93bmAgZXZlbnQgaXMgZmlyZWQgZm9yIGtleXMgdGhhdCBwcm9kdWNlIGEgY2hhcmFjdGVyIHZhbHVlIGFuZCBmb3Iga2V5c1xyXG5cdFx0Ly8gdGhhdCBkbyBub3QgcHJvZHVjZSBhIGNoYXJhY3RlciB2YWx1ZS5cclxuXHRcdC8vIEBldmVudCBrZXl1cDogS2V5Ym9hcmRFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuXHJcblx0XHRvbk9mZih0aGlzLl9jb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCAnICtcclxuXHRcdFx0J21vdXNlb3ZlciBtb3VzZW91dCBtb3VzZW1vdmUgY29udGV4dG1lbnUga2V5cHJlc3Mga2V5ZG93biBrZXl1cCcsIHRoaXMuX2hhbmRsZURPTUV2ZW50LCB0aGlzKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnRyYWNrUmVzaXplKSB7XHJcblx0XHRcdG9uT2ZmKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoQnJvd3Nlci5hbnkzZCAmJiB0aGlzLm9wdGlvbnMudHJhbnNmb3JtM0RMaW1pdCkge1xyXG5cdFx0XHQocmVtb3ZlID8gdGhpcy5vZmYgOiB0aGlzLm9uKS5jYWxsKHRoaXMsICdtb3ZlZW5kJywgdGhpcy5fb25Nb3ZlRW5kKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25SZXNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpO1xyXG5cdFx0dGhpcy5fcmVzaXplUmVxdWVzdCA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZShcclxuXHRcdCAgICAgICAgZnVuY3Rpb24gKCkgeyB0aGlzLmludmFsaWRhdGVTaXplKHtkZWJvdW5jZU1vdmVlbmQ6IHRydWV9KTsgfSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uU2Nyb2xsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc2Nyb2xsVG9wICA9IDA7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc2Nyb2xsTGVmdCA9IDA7XHJcblx0fSxcclxuXHJcblx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKTtcclxuXHRcdGlmIChNYXRoLm1heChNYXRoLmFicyhwb3MueCksIE1hdGguYWJzKHBvcy55KSkgPj0gdGhpcy5vcHRpb25zLnRyYW5zZm9ybTNETGltaXQpIHtcclxuXHRcdFx0Ly8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTIwMzg3MyBidXQgV2Via2l0IGFsc28gaGF2ZVxyXG5cdFx0XHQvLyBhIHBpeGVsIG9mZnNldCBvbiB2ZXJ5IGhpZ2ggdmFsdWVzLCBzZWU6IGh0dHBzOi8vanNmaWRkbGUubmV0L2RnNnI1aGhiL1xyXG5cdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgdGhpcy5nZXRab29tKCkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9maW5kRXZlbnRUYXJnZXRzOiBmdW5jdGlvbiAoZSwgdHlwZSkge1xyXG5cdFx0dmFyIHRhcmdldHMgPSBbXSxcclxuXHRcdCAgICB0YXJnZXQsXHJcblx0XHQgICAgaXNIb3ZlciA9IHR5cGUgPT09ICdtb3VzZW91dCcgfHwgdHlwZSA9PT0gJ21vdXNlb3ZlcicsXHJcblx0XHQgICAgc3JjID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxyXG5cdFx0ICAgIGRyYWdnaW5nID0gZmFsc2U7XHJcblxyXG5cdFx0d2hpbGUgKHNyYykge1xyXG5cdFx0XHR0YXJnZXQgPSB0aGlzLl90YXJnZXRzW1V0aWwuc3RhbXAoc3JjKV07XHJcblx0XHRcdGlmICh0YXJnZXQgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ3ByZWNsaWNrJykgJiYgdGhpcy5fZHJhZ2dhYmxlTW92ZWQodGFyZ2V0KSkge1xyXG5cdFx0XHRcdC8vIFByZXZlbnQgZmlyaW5nIGNsaWNrIGFmdGVyIHlvdSBqdXN0IGRyYWdnZWQgYW4gb2JqZWN0LlxyXG5cdFx0XHRcdGRyYWdnaW5nID0gdHJ1ZTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGFyZ2V0ICYmIHRhcmdldC5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdFx0aWYgKGlzSG92ZXIgJiYgIURvbUV2ZW50LmlzRXh0ZXJuYWxUYXJnZXQoc3JjLCBlKSkgeyBicmVhazsgfVxyXG5cdFx0XHRcdHRhcmdldHMucHVzaCh0YXJnZXQpO1xyXG5cdFx0XHRcdGlmIChpc0hvdmVyKSB7IGJyZWFrOyB9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHNyYyA9PT0gdGhpcy5fY29udGFpbmVyKSB7IGJyZWFrOyB9XHJcblx0XHRcdHNyYyA9IHNyYy5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCAmJiAhZHJhZ2dpbmcgJiYgIWlzSG92ZXIgJiYgdGhpcy5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdHRhcmdldHMgPSBbdGhpc107XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGFyZ2V0cztcclxuXHR9LFxyXG5cclxuXHRfaXNDbGlja0Rpc2FibGVkOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHdoaWxlIChlbCAmJiBlbCAhPT0gdGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdGlmIChlbFsnX2xlYWZsZXRfZGlzYWJsZV9jbGljayddKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHRcdGVsID0gZWwucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgZWwgPSAoZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50KTtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkIHx8IGVsWydfbGVhZmxldF9kaXNhYmxlX2V2ZW50cyddIHx8IGUudHlwZSA9PT0gJ2NsaWNrJyAmJiB0aGlzLl9pc0NsaWNrRGlzYWJsZWQoZWwpKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdHlwZSA9IGUudHlwZTtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ21vdXNlZG93bicpIHtcclxuXHRcdFx0Ly8gcHJldmVudHMgb3V0bGluZSB3aGVuIGNsaWNraW5nIG9uIGtleWJvYXJkLWZvY3VzYWJsZSBlbGVtZW50XHJcblx0XHRcdERvbVV0aWwucHJldmVudE91dGxpbmUoZWwpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ZpcmVET01FdmVudChlLCB0eXBlKTtcclxuXHR9LFxyXG5cclxuXHRfbW91c2VFdmVudHM6IFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ2NvbnRleHRtZW51J10sXHJcblxyXG5cdF9maXJlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlLCB0eXBlLCBjYW52YXNUYXJnZXRzKSB7XHJcblxyXG5cdFx0aWYgKGUudHlwZSA9PT0gJ2NsaWNrJykge1xyXG5cdFx0XHQvLyBGaXJlIGEgc3ludGhldGljICdwcmVjbGljaycgZXZlbnQgd2hpY2ggcHJvcGFnYXRlcyB1cCAobWFpbmx5IGZvciBjbG9zaW5nIHBvcHVwcykuXHJcblx0XHRcdC8vIEBldmVudCBwcmVjbGljazogTW91c2VFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCBiZWZvcmUgbW91c2UgY2xpY2sgb24gdGhlIG1hcCAoc29tZXRpbWVzIHVzZWZ1bCB3aGVuIHlvdVxyXG5cdFx0XHQvLyB3YW50IHNvbWV0aGluZyB0byBoYXBwZW4gb24gY2xpY2sgYmVmb3JlIGFueSBleGlzdGluZyBjbGlja1xyXG5cdFx0XHQvLyBoYW5kbGVycyBzdGFydCBydW5uaW5nKS5cclxuXHRcdFx0dmFyIHN5bnRoID0gVXRpbC5leHRlbmQoe30sIGUpO1xyXG5cdFx0XHRzeW50aC50eXBlID0gJ3ByZWNsaWNrJztcclxuXHRcdFx0dGhpcy5fZmlyZURPTUV2ZW50KHN5bnRoLCBzeW50aC50eXBlLCBjYW52YXNUYXJnZXRzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBGaW5kIHRoZSBsYXllciB0aGUgZXZlbnQgaXMgcHJvcGFnYXRpbmcgZnJvbSBhbmQgaXRzIHBhcmVudHMuXHJcblx0XHR2YXIgdGFyZ2V0cyA9IHRoaXMuX2ZpbmRFdmVudFRhcmdldHMoZSwgdHlwZSk7XHJcblxyXG5cdFx0aWYgKGNhbnZhc1RhcmdldHMpIHtcclxuXHRcdFx0dmFyIGZpbHRlcmVkID0gW107IC8vIHBpY2sgb25seSB0YXJnZXRzIHdpdGggbGlzdGVuZXJzXHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2FudmFzVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGlmIChjYW52YXNUYXJnZXRzW2ldLmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuXHRcdFx0XHRcdGZpbHRlcmVkLnB1c2goY2FudmFzVGFyZ2V0c1tpXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHRhcmdldHMgPSBmaWx0ZXJlZC5jb25jYXQodGFyZ2V0cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ2NvbnRleHRtZW51Jykge1xyXG5cdFx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdGFyZ2V0ID0gdGFyZ2V0c1swXTtcclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRvcmlnaW5hbEV2ZW50OiBlXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChlLnR5cGUgIT09ICdrZXlwcmVzcycgJiYgZS50eXBlICE9PSAna2V5ZG93bicgJiYgZS50eXBlICE9PSAna2V5dXAnKSB7XHJcblx0XHRcdHZhciBpc01hcmtlciA9IHRhcmdldC5nZXRMYXRMbmcgJiYgKCF0YXJnZXQuX3JhZGl1cyB8fCB0YXJnZXQuX3JhZGl1cyA8PSAxMCk7XHJcblx0XHRcdGRhdGEuY29udGFpbmVyUG9pbnQgPSBpc01hcmtlciA/XHJcblx0XHRcdFx0dGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHRhcmdldC5nZXRMYXRMbmcoKSkgOiB0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xyXG5cdFx0XHRkYXRhLmxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGRhdGEuY29udGFpbmVyUG9pbnQpO1xyXG5cdFx0XHRkYXRhLmxhdGxuZyA9IGlzTWFya2VyID8gdGFyZ2V0LmdldExhdExuZygpIDogdGhpcy5sYXllclBvaW50VG9MYXRMbmcoZGF0YS5sYXllclBvaW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0YXJnZXRzW2ldLmZpcmUodHlwZSwgZGF0YSwgdHJ1ZSk7XHJcblx0XHRcdGlmIChkYXRhLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgfHxcclxuXHRcdFx0XHQodGFyZ2V0c1tpXS5vcHRpb25zLmJ1YmJsaW5nTW91c2VFdmVudHMgPT09IGZhbHNlICYmIFV0aWwuaW5kZXhPZih0aGlzLl9tb3VzZUV2ZW50cywgdHlwZSkgIT09IC0xKSkgeyByZXR1cm47IH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZHJhZ2dhYmxlTW92ZWQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdG9iaiA9IG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcuZW5hYmxlZCgpID8gb2JqIDogdGhpcztcclxuXHRcdHJldHVybiAob2JqLmRyYWdnaW5nICYmIG9iai5kcmFnZ2luZy5tb3ZlZCgpKSB8fCAodGhpcy5ib3hab29tICYmIHRoaXMuYm94Wm9vbS5tb3ZlZCgpKTtcclxuXHR9LFxyXG5cclxuXHRfY2xlYXJIYW5kbGVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2hhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2hhbmRsZXJzW2ldLmRpc2FibGUoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2Qgd2hlblJlYWR5KGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBSdW5zIHRoZSBnaXZlbiBmdW5jdGlvbiBgZm5gIHdoZW4gdGhlIG1hcCBnZXRzIGluaXRpYWxpemVkIHdpdGhcclxuXHQvLyBhIHZpZXcgKGNlbnRlciBhbmQgem9vbSkgYW5kIGF0IGxlYXN0IG9uZSBsYXllciwgb3IgaW1tZWRpYXRlbHlcclxuXHQvLyBpZiBpdCdzIGFscmVhZHkgaW5pdGlhbGl6ZWQsIG9wdGlvbmFsbHkgcGFzc2luZyBhIGZ1bmN0aW9uIGNvbnRleHQuXHJcblx0d2hlblJlYWR5OiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0Y2FsbGJhY2suY2FsbChjb250ZXh0IHx8IHRoaXMsIHt0YXJnZXQ6IHRoaXN9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMub24oJ2xvYWQnLCBjYWxsYmFjaywgY29udGV4dCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gcHJpdmF0ZSBtZXRob2RzIGZvciBnZXR0aW5nIG1hcCBzdGF0ZVxyXG5cclxuXHRfZ2V0TWFwUGFuZVBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIERvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSkgfHwgbmV3IFBvaW50KDAsIDApO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKTtcclxuXHRcdHJldHVybiBwb3MgJiYgIXBvcy5lcXVhbHMoWzAsIDBdKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0VG9wTGVmdFBvaW50OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgcGl4ZWxPcmlnaW4gPSBjZW50ZXIgJiYgem9vbSAhPT0gdW5kZWZpbmVkID9cclxuXHRcdFx0dGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSA6XHJcblx0XHRcdHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKTtcclxuXHRcdHJldHVybiBwaXhlbE9yaWdpbi5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXROZXdQaXhlbE9yaWdpbjogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLl9zdWJ0cmFjdCh2aWV3SGFsZikuX2FkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpLl9yb3VuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9sYXRMbmdUb05ld0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIGNlbnRlcikge1xyXG5cdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pO1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdChsYXRsbmcsIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KTtcclxuXHR9LFxyXG5cclxuXHRfbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgem9vbSwgY2VudGVyKSB7XHJcblx0XHR2YXIgdG9wTGVmdCA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSk7XHJcblx0XHRyZXR1cm4gdG9Cb3VuZHMoW1xyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXRTb3V0aEVhc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdClcclxuXHRcdF0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIGxheWVyIHBvaW50IG9mIHRoZSBjdXJyZW50IGNlbnRlclxyXG5cdF9nZXRDZW50ZXJMYXllclBvaW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIG9mZnNldCBvZiB0aGUgc3BlY2lmaWVkIHBsYWNlIHRvIHRoZSBjdXJyZW50IGNlbnRlciBpbiBwaXhlbHNcclxuXHRfZ2V0Q2VudGVyT2Zmc2V0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nKS5zdWJ0cmFjdCh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGFkanVzdCBjZW50ZXIgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuXHRfbGltaXRDZW50ZXI6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGJvdW5kcykge1xyXG5cclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBjZW50ZXI7IH1cclxuXHJcblx0XHR2YXIgY2VudGVyUG9pbnQgPSB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKSxcclxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIHZpZXdCb3VuZHMgPSBuZXcgQm91bmRzKGNlbnRlclBvaW50LnN1YnRyYWN0KHZpZXdIYWxmKSwgY2VudGVyUG9pbnQuYWRkKHZpZXdIYWxmKSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KHZpZXdCb3VuZHMsIGJvdW5kcywgem9vbSk7XHJcblxyXG5cdFx0Ly8gSWYgb2Zmc2V0IGlzIGxlc3MgdGhhbiBhIHBpeGVsLCBpZ25vcmUuXHJcblx0XHQvLyBUaGlzIHByZXZlbnRzIHVuc3RhYmxlIHByb2plY3Rpb25zIGZyb20gZ2V0dGluZyBpbnRvXHJcblx0XHQvLyBhbiBpbmZpbml0ZSBsb29wIG9mIHRpbnkgb2Zmc2V0cy5cclxuXHRcdGlmIChNYXRoLmFicyhvZmZzZXQueCkgPD0gMSAmJiBNYXRoLmFicyhvZmZzZXQueSkgPD0gMSkge1xyXG5cdFx0XHRyZXR1cm4gY2VudGVyO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChjZW50ZXJQb2ludC5hZGQob2Zmc2V0KSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gYWRqdXN0IG9mZnNldCBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG5cdF9saW1pdE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCwgYm91bmRzKSB7XHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gb2Zmc2V0OyB9XHJcblxyXG5cdFx0dmFyIHZpZXdCb3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgbmV3Qm91bmRzID0gbmV3IEJvdW5kcyh2aWV3Qm91bmRzLm1pbi5hZGQob2Zmc2V0KSwgdmlld0JvdW5kcy5tYXguYWRkKG9mZnNldCkpO1xyXG5cclxuXHRcdHJldHVybiBvZmZzZXQuYWRkKHRoaXMuX2dldEJvdW5kc09mZnNldChuZXdCb3VuZHMsIGJvdW5kcykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIHJldHVybnMgb2Zmc2V0IG5lZWRlZCBmb3IgcHhCb3VuZHMgdG8gZ2V0IGluc2lkZSBtYXhCb3VuZHMgYXQgYSBzcGVjaWZpZWQgem9vbVxyXG5cdF9nZXRCb3VuZHNPZmZzZXQ6IGZ1bmN0aW9uIChweEJvdW5kcywgbWF4Qm91bmRzLCB6b29tKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkTWF4Qm91bmRzID0gdG9Cb3VuZHMoXHJcblx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG5cdFx0ICAgICAgICB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKVxyXG5cdFx0ICAgICksXHJcblx0XHQgICAgbWluT2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1pbi5zdWJ0cmFjdChweEJvdW5kcy5taW4pLFxyXG5cdFx0ICAgIG1heE9mZnNldCA9IHByb2plY3RlZE1heEJvdW5kcy5tYXguc3VidHJhY3QocHhCb3VuZHMubWF4KSxcclxuXHJcblx0XHQgICAgZHggPSB0aGlzLl9yZWJvdW5kKG1pbk9mZnNldC54LCAtbWF4T2Zmc2V0LngpLFxyXG5cdFx0ICAgIGR5ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueSwgLW1heE9mZnNldC55KTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGR4LCBkeSk7XHJcblx0fSxcclxuXHJcblx0X3JlYm91bmQ6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xyXG5cdFx0cmV0dXJuIGxlZnQgKyByaWdodCA+IDAgP1xyXG5cdFx0XHRNYXRoLnJvdW5kKGxlZnQgLSByaWdodCkgLyAyIDpcclxuXHRcdFx0TWF0aC5tYXgoMCwgTWF0aC5jZWlsKGxlZnQpKSAtIE1hdGgubWF4KDAsIE1hdGguZmxvb3IocmlnaHQpKTtcclxuXHR9LFxyXG5cclxuXHRfbGltaXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuZ2V0TWF4Wm9vbSgpLFxyXG5cdFx0ICAgIHNuYXAgPSBCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21TbmFwIDogMTtcclxuXHRcdGlmIChzbmFwKSB7XHJcblx0XHRcdHpvb20gPSBNYXRoLnJvdW5kKHpvb20gLyBzbmFwKSAqIHNuYXA7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuXHR9LFxyXG5cclxuXHRfb25QYW5UcmFuc2l0aW9uU3RlcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblx0fSxcclxuXHJcblx0X29uUGFuVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xyXG5cdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0fSxcclxuXHJcblx0X3RyeUFuaW1hdGVkUGFuOiBmdW5jdGlvbiAoY2VudGVyLCBvcHRpb25zKSB7XHJcblx0XHQvLyBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG5ldyBhbmQgY3VycmVudCBjZW50ZXJzIGluIHBpeGVsc1xyXG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuX2dldENlbnRlck9mZnNldChjZW50ZXIpLl90cnVuYygpO1xyXG5cclxuXHRcdC8vIGRvbid0IGFuaW1hdGUgdG9vIGZhciB1bmxlc3MgYW5pbWF0ZTogdHJ1ZSBzcGVjaWZpZWQgaW4gb3B0aW9uc1xyXG5cdFx0aWYgKChvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0ZSkgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0dGhpcy5wYW5CeShvZmZzZXQsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVBbmltUHJveHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgcHJveHkgPSB0aGlzLl9wcm94eSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1wcm94eSBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHRcdHRoaXMuX3BhbmVzLm1hcFBhbmUuYXBwZW5kQ2hpbGQocHJveHkpO1xyXG5cclxuXHRcdHRoaXMub24oJ3pvb21hbmltJywgZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0dmFyIHByb3AgPSBEb21VdGlsLlRSQU5TRk9STSxcclxuXHRcdFx0ICAgIHRyYW5zZm9ybSA9IHRoaXMuX3Byb3h5LnN0eWxlW3Byb3BdO1xyXG5cclxuXHRcdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5fcHJveHksIHRoaXMucHJvamVjdChlLmNlbnRlciwgZS56b29tKSwgdGhpcy5nZXRab29tU2NhbGUoZS56b29tLCAxKSk7XHJcblxyXG5cdFx0XHQvLyB3b3JrYXJvdW5kIGZvciBjYXNlIHdoZW4gdHJhbnNmb3JtIGlzIHRoZSBzYW1lIGFuZCBzbyB0cmFuc2l0aW9uZW5kIGV2ZW50IGlzIG5vdCBmaXJlZFxyXG5cdFx0XHRpZiAodHJhbnNmb3JtID09PSB0aGlzLl9wcm94eS5zdHlsZVtwcm9wXSAmJiB0aGlzLl9hbmltYXRpbmdab29tKSB7XHJcblx0XHRcdFx0dGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLm9uKCdsb2FkIG1vdmVlbmQnLCB0aGlzLl9hbmltTW92ZUVuZCwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fb24oJ3VubG9hZCcsIHRoaXMuX2Rlc3Ryb3lBbmltUHJveHksIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9kZXN0cm95QW5pbVByb3h5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9wcm94eSk7XHJcblx0XHR0aGlzLm9mZignbG9hZCBtb3ZlZW5kJywgdGhpcy5fYW5pbU1vdmVFbmQsIHRoaXMpO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX3Byb3h5O1xyXG5cdH0sXHJcblxyXG5cdF9hbmltTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGMgPSB0aGlzLmdldENlbnRlcigpLFxyXG5cdFx0ICAgIHogPSB0aGlzLmdldFpvb20oKTtcclxuXHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX3Byb3h5LCB0aGlzLnByb2plY3QoYywgeiksIHRoaXMuZ2V0Wm9vbVNjYWxlKHosIDEpKTtcclxuXHR9LFxyXG5cclxuXHRfY2F0Y2hUcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20gJiYgZS5wcm9wZXJ0eU5hbWUuaW5kZXhPZigndHJhbnNmb3JtJykgPj0gMCkge1xyXG5cdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X25vdGhpbmdUb0FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhdGhpcy5fY29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpLmxlbmd0aDtcclxuXHR9LFxyXG5cclxuXHRfdHJ5QW5pbWF0ZWRab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIGRpc2FibGVkLCBub3Qgc3VwcG9ydGVkIG9yIHpvb20gZGlmZmVyZW5jZSBpcyB0b28gbGFyZ2VcclxuXHRcdGlmICghdGhpcy5fem9vbUFuaW1hdGVkIHx8IG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgdGhpcy5fbm90aGluZ1RvQW5pbWF0ZSgpIHx8XHJcblx0XHQgICAgICAgIE1hdGguYWJzKHpvb20gLSB0aGlzLl96b29tKSA+IHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uVGhyZXNob2xkKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdC8vIG9mZnNldCBpcyB0aGUgcGl4ZWwgY29vcmRzIG9mIHRoZSB6b29tIG9yaWdpbiByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBjZW50ZXJcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldENlbnRlck9mZnNldChjZW50ZXIpLl9kaXZpZGVCeSgxIC0gMSAvIHNjYWxlKTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIHRoZSB6b29tIG9yaWdpbiBpc24ndCB3aXRoaW4gb25lIHNjcmVlbiBmcm9tIHRoZSBjdXJyZW50IGNlbnRlciwgdW5sZXNzIGZvcmNlZFxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzXHJcblx0XHRcdCAgICAuX21vdmVTdGFydCh0cnVlLCBvcHRpb25zLm5vTW92ZVN0YXJ0IHx8IGZhbHNlKVxyXG5cdFx0XHQgICAgLl9hbmltYXRlWm9vbShjZW50ZXIsIHpvb20sIHRydWUpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBzdGFydEFuaW0sIG5vVXBkYXRlKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcFBhbmUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHN0YXJ0QW5pbSkge1xyXG5cdFx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gdHJ1ZTtcclxuXHJcblx0XHRcdC8vIHJlbWVtYmVyIHdoYXQgY2VudGVyL3pvb20gdG8gc2V0IGFmdGVyIGFuaW1hdGlvblxyXG5cdFx0XHR0aGlzLl9hbmltYXRlVG9DZW50ZXIgPSBjZW50ZXI7XHJcblx0XHRcdHRoaXMuX2FuaW1hdGVUb1pvb20gPSB6b29tO1xyXG5cclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBPdGhlciBFdmVudHNcclxuXHRcdC8vIEBldmVudCB6b29tYW5pbTogWm9vbUFuaW1FdmVudFxyXG5cdFx0Ly8gRmlyZWQgYXQgbGVhc3Qgb25jZSBwZXIgem9vbSBhbmltYXRpb24uIEZvciBjb250aW51b3VzIHpvb20sIGxpa2UgcGluY2ggem9vbWluZywgZmlyZWQgb25jZSBwZXIgZnJhbWUgZHVyaW5nIHpvb20uXHJcblx0XHR0aGlzLmZpcmUoJ3pvb21hbmltJywge1xyXG5cdFx0XHRjZW50ZXI6IGNlbnRlcixcclxuXHRcdFx0em9vbTogem9vbSxcclxuXHRcdFx0bm9VcGRhdGU6IG5vVXBkYXRlXHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX3RlbXBGaXJlWm9vbUV2ZW50KSB7XHJcblx0XHRcdHRoaXMuX3RlbXBGaXJlWm9vbUV2ZW50ID0gdGhpcy5fem9vbSAhPT0gdGhpcy5fYW5pbWF0ZVRvWm9vbTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tb3ZlKHRoaXMuX2FuaW1hdGVUb0NlbnRlciwgdGhpcy5fYW5pbWF0ZVRvWm9vbSwgdW5kZWZpbmVkLCB0cnVlKTtcclxuXHJcblx0XHQvLyBXb3JrIGFyb3VuZCB3ZWJraXQgbm90IGZpcmluZyAndHJhbnNpdGlvbmVuZCcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zNjg5LCAyNjkzXHJcblx0XHRzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kLCB0aGlzKSwgMjUwKTtcclxuXHR9LFxyXG5cclxuXHRfb25ab29tVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9tYXBQYW5lKSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtem9vbS1hbmltJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYW5pbWF0aW5nWm9vbSA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuX21vdmUodGhpcy5fYW5pbWF0ZVRvQ2VudGVyLCB0aGlzLl9hbmltYXRlVG9ab29tLCB1bmRlZmluZWQsIHRydWUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl90ZW1wRmlyZVpvb21FdmVudCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb20nKTtcclxuXHRcdH1cclxuXHRcdGRlbGV0ZSB0aGlzLl90ZW1wRmlyZVpvb21FdmVudDtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHJcblx0XHR0aGlzLl9tb3ZlRW5kKHRydWUpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAc2VjdGlvblxyXG5cclxuLy8gQGZhY3RvcnkgTC5tYXAoaWQ6IFN0cmluZywgb3B0aW9ucz86IE1hcCBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIHRoZSBET00gSUQgb2YgYSBgPGRpdj5gIGVsZW1lbnRcclxuLy8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxyXG4vL1xyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5tYXAoZWw6IEhUTUxFbGVtZW50LCBvcHRpb25zPzogTWFwIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIG1hcCBvYmplY3QgZ2l2ZW4gYW4gaW5zdGFuY2Ugb2YgYSBgPGRpdj5gIEhUTUwgZWxlbWVudFxyXG4vLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNYXAoaWQsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IE1hcChpZCwgb3B0aW9ucyk7XHJcbn1cclxuIiwiXHJcbmltcG9ydCB7Q2xhc3N9IGZyb20gJy4uL2NvcmUvQ2xhc3MnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbFxyXG4gKiBAYWthIEwuQ29udHJvbFxyXG4gKiBAaW5oZXJpdHMgQ2xhc3NcclxuICpcclxuICogTC5Db250cm9sIGlzIGEgYmFzZSBjbGFzcyBmb3IgaW1wbGVtZW50aW5nIG1hcCBjb250cm9scy4gSGFuZGxlcyBwb3NpdGlvbmluZy5cclxuICogQWxsIG90aGVyIGNvbnRyb2xzIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBDb250cm9sID0gQ2xhc3MuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbCBPcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBwb3NpdGlvbjogU3RyaW5nID0gJ3RvcHJpZ2h0J1xyXG5cdFx0Ly8gVGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sIChvbmUgb2YgdGhlIG1hcCBjb3JuZXJzKS4gUG9zc2libGUgdmFsdWVzIGFyZSBgJ3RvcGxlZnQnYCxcclxuXHRcdC8vIGAndG9wcmlnaHQnYCwgYCdib3R0b21sZWZ0J2Agb3IgYCdib3R0b21yaWdodCdgXHJcblx0XHRwb3NpdGlvbjogJ3RvcHJpZ2h0J1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBDbGFzc2VzIGV4dGVuZGluZyBMLkNvbnRyb2wgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgZ2V0UG9zaXRpb246IHN0cmluZ1xyXG5cdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLlxyXG5cdCAqL1xyXG5cdGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UG9zaXRpb24ocG9zaXRpb246IHN0cmluZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC5cclxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvc2l0aW9uKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG5cclxuXHRcdGlmIChtYXApIHtcclxuXHRcdFx0bWFwLnJlbW92ZUNvbnRyb2wodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLnBvc2l0aW9uID0gcG9zaXRpb247XHJcblxyXG5cdFx0aWYgKG1hcCkge1xyXG5cdFx0XHRtYXAuYWRkQ29udHJvbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MRWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBjb250cm9sLlxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZFRvKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGNvbnRyb2wgdG8gdGhlIGdpdmVuIG1hcC5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5yZW1vdmUoKTtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdGhpcy5vbkFkZChtYXApLFxyXG5cdFx0ICAgIHBvcyA9IHRoaXMuZ2V0UG9zaXRpb24oKSxcclxuXHRcdCAgICBjb3JuZXIgPSBtYXAuX2NvbnRyb2xDb3JuZXJzW3Bvc107XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wnKTtcclxuXHJcblx0XHRpZiAocG9zLmluZGV4T2YoJ2JvdHRvbScpICE9PSAtMSkge1xyXG5cdFx0XHRjb3JuZXIuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lciwgY29ybmVyLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29ybmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWFwLm9uKCd1bmxvYWQnLCB0aGlzLnJlbW92ZSwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmU6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBjb250cm9sIGZyb20gdGhlIG1hcCBpdCBpcyBjdXJyZW50bHkgYWN0aXZlIG9uLlxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vblJlbW92ZSkge1xyXG5cdFx0XHR0aGlzLm9uUmVtb3ZlKHRoaXMuX21hcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWFwLm9mZigndW5sb2FkJywgdGhpcy5yZW1vdmUsIHRoaXMpO1xyXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmVmb2N1c09uTWFwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gaWYgbWFwIGV4aXN0cyBhbmQgZXZlbnQgaXMgbm90IGEga2V5Ym9hcmQgZXZlbnRcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgZSAmJiBlLnNjcmVlblggPiAwICYmIGUuc2NyZWVuWSA+IDApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbmV4cG9ydCB2YXIgY29udHJvbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBDb250cm9sKG9wdGlvbnMpO1xyXG59O1xyXG5cclxuLyogQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcclxuICogQHVuaW5oZXJpdGFibGVcclxuICpcclxuICogRXZlcnkgY29udHJvbCBzaG91bGQgZXh0ZW5kIGZyb20gYEwuQ29udHJvbGAgYW5kIChyZS0paW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kcy5cclxuICpcclxuICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IEhUTUxFbGVtZW50XHJcbiAqIFNob3VsZCByZXR1cm4gdGhlIGNvbnRhaW5lciBET00gZWxlbWVudCBmb3IgdGhlIGNvbnRyb2wgYW5kIGFkZCBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy4gQ2FsbGVkIG9uIFtgY29udHJvbC5hZGRUbyhtYXApYF0oI2NvbnRyb2wtYWRkVG8pLlxyXG4gKlxyXG4gKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKVxyXG4gKiBPcHRpb25hbCBtZXRob2QuIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNjb250cm9sLW9uYWRkKS4gQ2FsbGVkIG9uIFtgY29udHJvbC5yZW1vdmUoKWBdKCNjb250cm9sLXJlbW92ZSkuXHJcbiAqL1xyXG5cclxuLyogQG5hbWVzcGFjZSBNYXBcclxuICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG4gKi9cclxuTWFwLmluY2x1ZGUoe1xyXG5cdC8vIEBtZXRob2QgYWRkQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGNvbnRyb2wgdG8gdGhlIG1hcFxyXG5cdGFkZENvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcblx0XHRjb250cm9sLmFkZFRvKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVDb250cm9sKGNvbnRyb2w6IENvbnRyb2wpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gY29udHJvbCBmcm9tIHRoZSBtYXBcclxuXHRyZW1vdmVDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG5cdFx0Y29udHJvbC5yZW1vdmUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0Q29udHJvbFBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvcm5lcnMgPSB0aGlzLl9jb250cm9sQ29ybmVycyA9IHt9LFxyXG5cdFx0ICAgIGwgPSAnbGVhZmxldC0nLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRyb2xDb250YWluZXIgPVxyXG5cdFx0ICAgICAgICAgICAgRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGwgKyAnY29udHJvbC1jb250YWluZXInLCB0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUNvcm5lcih2U2lkZSwgaFNpZGUpIHtcclxuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IGwgKyB2U2lkZSArICcgJyArIGwgKyBoU2lkZTtcclxuXHJcblx0XHRcdGNvcm5lcnNbdlNpZGUgKyBoU2lkZV0gPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ2xlZnQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ3JpZ2h0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdsZWZ0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdyaWdodCcpO1xyXG5cdH0sXHJcblxyXG5cdF9jbGVhckNvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fY29udHJvbENvcm5lcnMpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udHJvbENvcm5lcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udHJvbENvbnRhaW5lcik7XHJcblx0XHRkZWxldGUgdGhpcy5fY29udHJvbENvcm5lcnM7XHJcblx0XHRkZWxldGUgdGhpcy5fY29udHJvbENvbnRhaW5lcjtcclxuXHR9XHJcbn0pO1xyXG4iLCJcclxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIENvbnRyb2wuTGF5ZXJzXHJcbiAqIEBha2EgTC5Db250cm9sLkxheWVyc1xyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBUaGUgbGF5ZXJzIGNvbnRyb2wgZ2l2ZXMgdXNlcnMgdGhlIGFiaWxpdHkgdG8gc3dpdGNoIGJldHdlZW4gZGlmZmVyZW50IGJhc2UgbGF5ZXJzIGFuZCBzd2l0Y2ggb3ZlcmxheXMgb24vb2ZmIChjaGVjayBvdXQgdGhlIFtkZXRhaWxlZCBleGFtcGxlXShodHRwczovL2xlYWZsZXRqcy5jb20vZXhhbXBsZXMvbGF5ZXJzLWNvbnRyb2wvKSkuIEV4dGVuZHMgYENvbnRyb2xgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgYmFzZUxheWVycyA9IHtcclxuICogXHRcIk1hcGJveFwiOiBtYXBib3gsXHJcbiAqIFx0XCJPcGVuU3RyZWV0TWFwXCI6IG9zbVxyXG4gKiB9O1xyXG4gKlxyXG4gKiB2YXIgb3ZlcmxheXMgPSB7XHJcbiAqIFx0XCJNYXJrZXJcIjogbWFya2VyLFxyXG4gKiBcdFwiUm9hZHNcIjogcm9hZHNMYXllclxyXG4gKiB9O1xyXG4gKlxyXG4gKiBMLmNvbnRyb2wubGF5ZXJzKGJhc2VMYXllcnMsIG92ZXJsYXlzKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICpcclxuICogVGhlIGBiYXNlTGF5ZXJzYCBhbmQgYG92ZXJsYXlzYCBwYXJhbWV0ZXJzIGFyZSBvYmplY3QgbGl0ZXJhbHMgd2l0aCBsYXllciBuYW1lcyBhcyBrZXlzIGFuZCBgTGF5ZXJgIG9iamVjdHMgYXMgdmFsdWVzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB7XHJcbiAqICAgICBcIjxzb21lTmFtZTE+XCI6IGxheWVyMSxcclxuICogICAgIFwiPHNvbWVOYW1lMj5cIjogbGF5ZXIyXHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIFRoZSBsYXllciBuYW1lcyBjYW4gY29udGFpbiBIVE1MLCB3aGljaCBhbGxvd3MgeW91IHRvIGFkZCBhZGRpdGlvbmFsIHN0eWxpbmcgdG8gdGhlIGl0ZW1zOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB7XCI8aW1nIHNyYz0nbXktbGF5ZXItaWNvbicgLz4gPHNwYW4gY2xhc3M9J215LWxheWVyLWl0ZW0nPk15IExheWVyPC9zcGFuPlwiOiBteUxheWVyfVxyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIExheWVycyA9IENvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5MYXllcnMgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gY29sbGFwc2VkOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCB3aWxsIGJlIGNvbGxhcHNlZCBpbnRvIGFuIGljb24gYW5kIGV4cGFuZGVkIG9uIG1vdXNlIGhvdmVyLCB0b3VjaCwgb3Iga2V5Ym9hcmQgYWN0aXZhdGlvbi5cclxuXHRcdGNvbGxhcHNlZDogdHJ1ZSxcclxuXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1pJbmRleDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgd2lsbCBhc3NpZ24gekluZGV4ZXMgaW4gaW5jcmVhc2luZyBvcmRlciB0byBhbGwgb2YgaXRzIGxheWVycyBzbyB0aGF0IHRoZSBvcmRlciBpcyBwcmVzZXJ2ZWQgd2hlbiBzd2l0Y2hpbmcgdGhlbSBvbi9vZmYuXHJcblx0XHRhdXRvWkluZGV4OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gaGlkZVNpbmdsZUJhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgYmFzZSBsYXllcnMgaW4gdGhlIGNvbnRyb2wgd2lsbCBiZSBoaWRkZW4gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZS5cclxuXHRcdGhpZGVTaW5nbGVCYXNlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHNvcnRMYXllcnM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0byBzb3J0IHRoZSBsYXllcnMuIFdoZW4gYGZhbHNlYCwgbGF5ZXJzIHdpbGwga2VlcCB0aGUgb3JkZXJcclxuXHRcdC8vIGluIHdoaWNoIHRoZXkgd2VyZSBhZGRlZCB0byB0aGUgY29udHJvbC5cclxuXHRcdHNvcnRMYXllcnM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc29ydEZ1bmN0aW9uOiBGdW5jdGlvbiA9ICpcclxuXHRcdC8vIEEgW2NvbXBhcmUgZnVuY3Rpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnQpXHJcblx0XHQvLyB0aGF0IHdpbGwgYmUgdXNlZCBmb3Igc29ydGluZyB0aGUgbGF5ZXJzLCB3aGVuIGBzb3J0TGF5ZXJzYCBpcyBgdHJ1ZWAuXHJcblx0XHQvLyBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgYm90aCB0aGUgYEwuTGF5ZXJgIGluc3RhbmNlcyBhbmQgdGhlaXIgbmFtZXMsIGFzIGluXHJcblx0XHQvLyBgc29ydEZ1bmN0aW9uKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpYC5cclxuXHRcdC8vIEJ5IGRlZmF1bHQsIGl0IHNvcnRzIGxheWVycyBhbHBoYWJldGljYWxseSBieSB0aGVpciBuYW1lLlxyXG5cdFx0c29ydEZ1bmN0aW9uOiBmdW5jdGlvbiAobGF5ZXJBLCBsYXllckIsIG5hbWVBLCBuYW1lQikge1xyXG5cdFx0XHRyZXR1cm4gbmFtZUEgPCBuYW1lQiA/IC0xIDogKG5hbWVCIDwgbmFtZUEgPyAxIDogMCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzID0gW107XHJcblx0XHR0aGlzLl9sYXllcnMgPSBbXTtcclxuXHRcdHRoaXMuX2xhc3RaSW5kZXggPSAwO1xyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fcHJldmVudENsaWNrID0gZmFsc2U7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBiYXNlTGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2FkZExheWVyKGJhc2VMYXllcnNbaV0sIGkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSBpbiBvdmVybGF5cykge1xyXG5cdFx0XHR0aGlzLl9hZGRMYXllcihvdmVybGF5c1tpXSwgaSwgdHJ1ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpXS5sYXllci5vbignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdENvbnRyb2wucHJvdG90eXBlLmFkZFRvLmNhbGwodGhpcywgbWFwKTtcclxuXHRcdC8vIFRyaWdnZXIgZXhwYW5kIGFmdGVyIExheWVycyBDb250cm9sIGhhcyBiZWVuIGluc2VydGVkIGludG8gRE9NIHNvIHRoYXQgaXMgbm93IGhhcyBhbiBhY3R1YWwgaGVpZ2h0LlxyXG5cdFx0cmV0dXJuIHRoaXMuX2V4cGFuZElmTm90Q29sbGFwc2VkKCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzLCB0aGlzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ubGF5ZXIub2ZmKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRCYXNlTGF5ZXIobGF5ZXI6IExheWVyLCBuYW1lOiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhIGJhc2UgbGF5ZXIgKHJhZGlvIGJ1dHRvbiBlbnRyeSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB0byB0aGUgY29udHJvbC5cclxuXHRhZGRCYXNlTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmFtZSkge1xyXG5cdFx0dGhpcy5fYWRkTGF5ZXIobGF5ZXIsIG5hbWUpO1xyXG5cdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkT3ZlcmxheShsYXllcjogTGF5ZXIsIG5hbWU6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIG92ZXJsYXkgKGNoZWNrYm94IGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG5cdGFkZE92ZXJsYXk6IGZ1bmN0aW9uIChsYXllciwgbmFtZSkge1xyXG5cdFx0dGhpcy5fYWRkTGF5ZXIobGF5ZXIsIG5hbWUsIHRydWUpO1xyXG5cdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZSB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgY29udHJvbC5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRsYXllci5vZmYoJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHJcblx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoVXRpbC5zdGFtcChsYXllcikpO1xyXG5cdFx0aWYgKG9iaikge1xyXG5cdFx0XHR0aGlzLl9sYXllcnMuc3BsaWNlKHRoaXMuX2xheWVycy5pbmRleE9mKG9iaiksIDEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZXhwYW5kKCk6IHRoaXNcclxuXHQvLyBFeHBhbmQgdGhlIGNvbnRyb2wgY29udGFpbmVyIGlmIGNvbGxhcHNlZC5cclxuXHRleHBhbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCcpO1xyXG5cdFx0dGhpcy5fc2VjdGlvbi5zdHlsZS5oZWlnaHQgPSBudWxsO1xyXG5cdFx0dmFyIGFjY2VwdGFibGVIZWlnaHQgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLnkgLSAodGhpcy5fY29udGFpbmVyLm9mZnNldFRvcCArIDUwKTtcclxuXHRcdGlmIChhY2NlcHRhYmxlSGVpZ2h0IDwgdGhpcy5fc2VjdGlvbi5jbGllbnRIZWlnaHQpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9zZWN0aW9uLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXInKTtcclxuXHRcdFx0dGhpcy5fc2VjdGlvbi5zdHlsZS5oZWlnaHQgPSBhY2NlcHRhYmxlSGVpZ2h0ICsgJ3B4JztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fc2VjdGlvbiwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyJyk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbGxhcHNlKCk6IHRoaXNcclxuXHQvLyBDb2xsYXBzZSB0aGUgY29udHJvbCBjb250YWluZXIgaWYgZXhwYW5kZWQuXHJcblx0Y29sbGFwc2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCcpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWxheWVycycsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSksXHJcblx0XHQgICAgY29sbGFwc2VkID0gdGhpcy5vcHRpb25zLmNvbGxhcHNlZDtcclxuXHJcblx0XHQvLyBtYWtlcyB0aGlzIHdvcmsgb24gSUUgdG91Y2ggZGV2aWNlcyBieSBzdG9wcGluZyBpdCBmcm9tIGZpcmluZyBhIG1vdXNlb3V0IGV2ZW50IHdoZW4gdGhlIHRvdWNoIGlzIHJlbGVhc2VkXHJcblx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCdhcmlhLWhhc3BvcHVwJywgdHJ1ZSk7XHJcblxyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHRcdERvbUV2ZW50LmRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG5cclxuXHRcdHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbiA9IERvbVV0aWwuY3JlYXRlKCdzZWN0aW9uJywgY2xhc3NOYW1lICsgJy1saXN0Jyk7XHJcblxyXG5cdFx0aWYgKGNvbGxhcHNlZCkge1xyXG5cdFx0XHR0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5jb2xsYXBzZSwgdGhpcyk7XHJcblxyXG5cdFx0XHREb21FdmVudC5vbihjb250YWluZXIsIHtcclxuXHRcdFx0XHRtb3VzZWVudGVyOiB0aGlzLl9leHBhbmRTYWZlbHksXHJcblx0XHRcdFx0bW91c2VsZWF2ZTogdGhpcy5jb2xsYXBzZVxyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbGluayA9IHRoaXMuX2xheWVyc0xpbmsgPSBEb21VdGlsLmNyZWF0ZSgnYScsIGNsYXNzTmFtZSArICctdG9nZ2xlJywgY29udGFpbmVyKTtcclxuXHRcdGxpbmsuaHJlZiA9ICcjJztcclxuXHRcdGxpbmsudGl0bGUgPSAnTGF5ZXJzJztcclxuXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xyXG5cclxuXHRcdERvbUV2ZW50Lm9uKGxpbmssIHtcclxuXHRcdFx0a2V5ZG93bjogZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRpZiAoZS5rZXlDb2RlID09PSAxMykge1xyXG5cdFx0XHRcdFx0dGhpcy5fZXhwYW5kU2FmZWx5KCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cdFx0XHQvLyBDZXJ0YWluIHNjcmVlbiByZWFkZXJzIGludGVyY2VwdCB0aGUga2V5IGV2ZW50IGFuZCBpbnN0ZWFkIHNlbmQgYSBjbGljayBldmVudFxyXG5cdFx0XHRjbGljazogZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdFx0XHR0aGlzLl9leHBhbmRTYWZlbHkoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKCFjb2xsYXBzZWQpIHtcclxuXHRcdFx0dGhpcy5leHBhbmQoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLWJhc2UnLCBzZWN0aW9uKTtcclxuXHRcdHRoaXMuX3NlcGFyYXRvciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLXNlcGFyYXRvcicsIHNlY3Rpb24pO1xyXG5cdFx0dGhpcy5fb3ZlcmxheXNMaXN0ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctb3ZlcmxheXMnLCBzZWN0aW9uKTtcclxuXHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc2VjdGlvbik7XHJcblx0fSxcclxuXHJcblx0X2dldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5fbGF5ZXJzW2ldICYmIFV0aWwuc3RhbXAodGhpcy5fbGF5ZXJzW2ldLmxheWVyKSA9PT0gaWQpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2FkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUsIG92ZXJsYXkpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0bGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXllcnMucHVzaCh7XHJcblx0XHRcdGxheWVyOiBsYXllcixcclxuXHRcdFx0bmFtZTogbmFtZSxcclxuXHRcdFx0b3ZlcmxheTogb3ZlcmxheVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5zb3J0TGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2xheWVycy5zb3J0KFV0aWwuYmluZChmdW5jdGlvbiAoYSwgYikge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc29ydEZ1bmN0aW9uKGEubGF5ZXIsIGIubGF5ZXIsIGEubmFtZSwgYi5uYW1lKTtcclxuXHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1pJbmRleCAmJiBsYXllci5zZXRaSW5kZXgpIHtcclxuXHRcdFx0dGhpcy5fbGFzdFpJbmRleCsrO1xyXG5cdFx0XHRsYXllci5zZXRaSW5kZXgodGhpcy5fbGFzdFpJbmRleCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZXhwYW5kSWZOb3RDb2xsYXBzZWQoKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdERvbVV0aWwuZW1wdHkodGhpcy5fYmFzZUxheWVyc0xpc3QpO1xyXG5cdFx0RG9tVXRpbC5lbXB0eSh0aGlzLl9vdmVybGF5c0xpc3QpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cyA9IFtdO1xyXG5cdFx0dmFyIGJhc2VMYXllcnNQcmVzZW50LCBvdmVybGF5c1ByZXNlbnQsIGksIG9iaiwgYmFzZUxheWVyc0NvdW50ID0gMDtcclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdG9iaiA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHRcdFx0dGhpcy5fYWRkSXRlbShvYmopO1xyXG5cdFx0XHRvdmVybGF5c1ByZXNlbnQgPSBvdmVybGF5c1ByZXNlbnQgfHwgb2JqLm92ZXJsYXk7XHJcblx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgfHwgIW9iai5vdmVybGF5O1xyXG5cdFx0XHRiYXNlTGF5ZXJzQ291bnQgKz0gIW9iai5vdmVybGF5ID8gMSA6IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSGlkZSBiYXNlIGxheWVycyBzZWN0aW9uIGlmIHRoZXJlJ3Mgb25seSBvbmUgbGF5ZXIuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmhpZGVTaW5nbGVCYXNlKSB7XHJcblx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgJiYgYmFzZUxheWVyc0NvdW50ID4gMTtcclxuXHRcdFx0dGhpcy5fYmFzZUxheWVyc0xpc3Quc3R5bGUuZGlzcGxheSA9IGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc2VwYXJhdG9yLnN0eWxlLmRpc3BsYXkgPSBvdmVybGF5c1ByZXNlbnQgJiYgYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfb25MYXllckNoYW5nZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5faGFuZGxpbmdDbGljaykge1xyXG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoVXRpbC5zdGFtcChlLnRhcmdldCkpO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBMYXllciBldmVudHNcclxuXHRcdC8vIEBldmVudCBiYXNlbGF5ZXJjaGFuZ2U6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYmFzZSBsYXllciBpcyBjaGFuZ2VkIHRocm91Z2ggdGhlIFtsYXllcnMgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuXHRcdC8vIEBldmVudCBvdmVybGF5YWRkOiBMYXllcnNDb250cm9sRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYW4gb3ZlcmxheSBpcyBzZWxlY3RlZCB0aHJvdWdoIHRoZSBbbGF5ZXJzIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAZXZlbnQgb3ZlcmxheXJlbW92ZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgZGVzZWxlY3RlZCB0aHJvdWdoIHRoZSBbbGF5ZXJzIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAbmFtZXNwYWNlIENvbnRyb2wuTGF5ZXJzXHJcblx0XHR2YXIgdHlwZSA9IG9iai5vdmVybGF5ID9cclxuXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnb3ZlcmxheWFkZCcgOiAnb3ZlcmxheXJlbW92ZScpIDpcclxuXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnYmFzZWxheWVyY2hhbmdlJyA6IG51bGwpO1xyXG5cclxuXHRcdGlmICh0eXBlKSB7XHJcblx0XHRcdHRoaXMuX21hcC5maXJlKHR5cGUsIG9iaik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gSUU3IGJ1Z3Mgb3V0IGlmIHlvdSBjcmVhdGUgYSByYWRpbyBkeW5hbWljYWxseSwgc28geW91IGhhdmUgdG8gZG8gaXQgdGhpcyBoYWNreSB3YXkgKHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTE5MDc5KVxyXG5cdF9jcmVhdGVSYWRpb0VsZW1lbnQ6IGZ1bmN0aW9uIChuYW1lLCBjaGVja2VkKSB7XHJcblxyXG5cdFx0dmFyIHJhZGlvSHRtbCA9ICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yXCIgbmFtZT1cIicgK1xyXG5cdFx0XHRcdG5hbWUgKyAnXCInICsgKGNoZWNrZWQgPyAnIGNoZWNrZWQ9XCJjaGVja2VkXCInIDogJycpICsgJy8+JztcclxuXHJcblx0XHR2YXIgcmFkaW9GcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0cmFkaW9GcmFnbWVudC5pbm5lckhUTUwgPSByYWRpb0h0bWw7XHJcblxyXG5cdFx0cmV0dXJuIHJhZGlvRnJhZ21lbnQuZmlyc3RDaGlsZDtcclxuXHR9LFxyXG5cclxuXHRfYWRkSXRlbTogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKSxcclxuXHRcdCAgICBjaGVja2VkID0gdGhpcy5fbWFwLmhhc0xheWVyKG9iai5sYXllciksXHJcblx0XHQgICAgaW5wdXQ7XHJcblxyXG5cdFx0aWYgKG9iai5vdmVybGF5KSB7XHJcblx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuXHRcdFx0aW5wdXQudHlwZSA9ICdjaGVja2JveCc7XHJcblx0XHRcdGlucHV0LmNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yJztcclxuXHRcdFx0aW5wdXQuZGVmYXVsdENoZWNrZWQgPSBjaGVja2VkO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aW5wdXQgPSB0aGlzLl9jcmVhdGVSYWRpb0VsZW1lbnQoJ2xlYWZsZXQtYmFzZS1sYXllcnNfJyArIFV0aWwuc3RhbXAodGhpcyksIGNoZWNrZWQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cy5wdXNoKGlucHV0KTtcclxuXHRcdGlucHV0LmxheWVySWQgPSBVdGlsLnN0YW1wKG9iai5sYXllcik7XHJcblxyXG5cdFx0RG9tRXZlbnQub24oaW5wdXQsICdjbGljaycsIHRoaXMuX29uSW5wdXRDbGljaywgdGhpcyk7XHJcblxyXG5cdFx0dmFyIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcblx0XHRuYW1lLmlubmVySFRNTCA9ICcgJyArIG9iai5uYW1lO1xyXG5cclxuXHRcdC8vIEhlbHBzIGZyb20gcHJldmVudGluZyBsYXllciBjb250cm9sIGZsaWNrZXIgd2hlbiBjaGVja2JveGVzIGFyZSBkaXNhYmxlZFxyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjc3MVxyXG5cdFx0dmFyIGhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuXHJcblx0XHRsYWJlbC5hcHBlbmRDaGlsZChob2xkZXIpO1xyXG5cdFx0aG9sZGVyLmFwcGVuZENoaWxkKGlucHV0KTtcclxuXHRcdGhvbGRlci5hcHBlbmRDaGlsZChuYW1lKTtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gb2JqLm92ZXJsYXkgPyB0aGlzLl9vdmVybGF5c0xpc3QgOiB0aGlzLl9iYXNlTGF5ZXJzTGlzdDtcclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XHJcblxyXG5cdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG5cdFx0cmV0dXJuIGxhYmVsO1xyXG5cdH0sXHJcblxyXG5cdF9vbklucHV0Q2xpY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIGV4cGFuZGluZyB0aGUgY29udHJvbCBvbiBtb2JpbGUgd2l0aCBhIGNsaWNrIGNhbiBjYXVzZSBhZGRpbmcgYSBsYXllciAtIHdlIGRvbid0IHdhbnQgdGhpc1xyXG5cdFx0aWYgKHRoaXMuX3ByZXZlbnRDbGljaykge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGlucHV0cyA9IHRoaXMuX2xheWVyQ29udHJvbElucHV0cyxcclxuXHRcdCAgICBpbnB1dCwgbGF5ZXI7XHJcblx0XHR2YXIgYWRkZWRMYXllcnMgPSBbXSxcclxuXHRcdCAgICByZW1vdmVkTGF5ZXJzID0gW107XHJcblxyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IHRydWU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpbnB1dCA9IGlucHV0c1tpXTtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9nZXRMYXllcihpbnB1dC5sYXllcklkKS5sYXllcjtcclxuXHJcblx0XHRcdGlmIChpbnB1dC5jaGVja2VkKSB7XHJcblx0XHRcdFx0YWRkZWRMYXllcnMucHVzaChsYXllcik7XHJcblx0XHRcdH0gZWxzZSBpZiAoIWlucHV0LmNoZWNrZWQpIHtcclxuXHRcdFx0XHRyZW1vdmVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQnVnZml4IGlzc3VlIDIzMTg6IFNob3VsZCByZW1vdmUgYWxsIG9sZCBsYXllcnMgYmVmb3JlIHJlYWRkaW5nIG5ldyBvbmVzXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgcmVtb3ZlZExheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHJlbW92ZWRMYXllcnNbaV0pKSB7XHJcblx0XHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHJlbW92ZWRMYXllcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgYWRkZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKCF0aGlzLl9tYXAuaGFzTGF5ZXIoYWRkZWRMYXllcnNbaV0pKSB7XHJcblx0XHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGFkZGVkTGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLl9yZWZvY3VzT25NYXAoKTtcclxuXHR9LFxyXG5cclxuXHRfY2hlY2tEaXNhYmxlZExheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGlucHV0cyA9IHRoaXMuX2xheWVyQ29udHJvbElucHV0cyxcclxuXHRcdCAgICBpbnB1dCxcclxuXHRcdCAgICBsYXllcixcclxuXHRcdCAgICB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gaW5wdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2dldExheWVyKGlucHV0LmxheWVySWQpLmxheWVyO1xyXG5cdFx0XHRpbnB1dC5kaXNhYmxlZCA9IChsYXllci5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tIDwgbGF5ZXIub3B0aW9ucy5taW5ab29tKSB8fFxyXG5cdFx0XHQgICAgICAgICAgICAgICAgIChsYXllci5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tID4gbGF5ZXIub3B0aW9ucy5tYXhab29tKTtcclxuXHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2V4cGFuZElmTm90Q29sbGFwc2VkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwICYmICF0aGlzLm9wdGlvbnMuY29sbGFwc2VkKSB7XHJcblx0XHRcdHRoaXMuZXhwYW5kKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfZXhwYW5kU2FmZWx5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb247XHJcblx0XHR0aGlzLl9wcmV2ZW50Q2xpY2sgPSB0cnVlO1xyXG5cdFx0RG9tRXZlbnQub24oc2VjdGlvbiwgJ2NsaWNrJywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdFx0dGhpcy5leHBhbmQoKTtcclxuXHRcdHZhciB0aGF0ID0gdGhpcztcclxuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHREb21FdmVudC5vZmYoc2VjdGlvbiwgJ2NsaWNrJywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdFx0XHR0aGF0Ll9wcmV2ZW50Q2xpY2sgPSBmYWxzZTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC5sYXllcnMoYmFzZWxheWVycz86IE9iamVjdCwgb3ZlcmxheXM/OiBPYmplY3QsIG9wdGlvbnM/OiBDb250cm9sLkxheWVycyBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgbGF5ZXJzIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gbGF5ZXJzLiBCYXNlIGxheWVycyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggcmFkaW8gYnV0dG9ucywgd2hpbGUgb3ZlcmxheXMgd2lsbCBiZSBzd2l0Y2hlZCB3aXRoIGNoZWNrYm94ZXMuIE5vdGUgdGhhdCBhbGwgYmFzZSBsYXllcnMgc2hvdWxkIGJlIHBhc3NlZCBpbiB0aGUgYmFzZSBsYXllcnMgb2JqZWN0LCBidXQgb25seSBvbmUgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBtYXAgZHVyaW5nIG1hcCBpbnN0YW50aWF0aW9uLlxyXG5leHBvcnQgdmFyIGxheWVycyA9IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTGF5ZXJzKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKTtcclxufTtcclxuIiwiXHJcbmltcG9ydCB7Q29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcclxuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLlpvb21cclxuICogQGFrYSBMLkNvbnRyb2wuWm9vbVxyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBBIGJhc2ljIHpvb20gY29udHJvbCB3aXRoIHR3byBidXR0b25zICh6b29tIGluIGFuZCB6b29tIG91dCkuIEl0IGlzIHB1dCBvbiB0aGUgbWFwIGJ5IGRlZmF1bHQgdW5sZXNzIHlvdSBzZXQgaXRzIFtgem9vbUNvbnRyb2xgIG9wdGlvbl0oI21hcC16b29tY29udHJvbCkgdG8gYGZhbHNlYC4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBab29tID0gQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLlpvb20gb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAndG9wbGVmdCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tSW5UZXh0OiBTdHJpbmcgPSAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+Kzwvc3Bhbj4nXHJcblx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIGluJyBidXR0b24uXHJcblx0XHR6b29tSW5UZXh0OiAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+Kzwvc3Bhbj4nLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUluVGl0bGU6IFN0cmluZyA9ICdab29tIGluJ1xyXG5cdFx0Ly8gVGhlIHRpdGxlIHNldCBvbiB0aGUgJ3pvb20gaW4nIGJ1dHRvbi5cclxuXHRcdHpvb21JblRpdGxlOiAnWm9vbSBpbicsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGV4dDogU3RyaW5nID0gJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiYjeDIyMTI7PC9zcGFuPidcclxuXHRcdC8vIFRoZSB0ZXh0IHNldCBvbiB0aGUgJ3pvb20gb3V0JyBidXR0b24uXHJcblx0XHR6b29tT3V0VGV4dDogJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiYjeDIyMTI7PC9zcGFuPicsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGl0bGU6IFN0cmluZyA9ICdab29tIG91dCdcclxuXHRcdC8vIFRoZSB0aXRsZSBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG5cdFx0em9vbU91dFRpdGxlOiAnWm9vbSBvdXQnXHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHZhciB6b29tTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtem9vbScsXHJcblx0XHQgICAgY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHpvb21OYW1lICsgJyBsZWFmbGV0LWJhcicpLFxyXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0dGhpcy5fem9vbUluQnV0dG9uICA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21JblRleHQsIG9wdGlvbnMuem9vbUluVGl0bGUsXHJcblx0XHQgICAgICAgIHpvb21OYW1lICsgJy1pbicsICBjb250YWluZXIsIHRoaXMuX3pvb21Jbik7XHJcblx0XHR0aGlzLl96b29tT3V0QnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbU91dFRleHQsIG9wdGlvbnMuem9vbU91dFRpdGxlLFxyXG5cdFx0ICAgICAgICB6b29tTmFtZSArICctb3V0JywgY29udGFpbmVyLCB0aGlzLl96b29tT3V0KTtcclxuXHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0bWFwLm9uKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLm9mZignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2Rpc2FibGVkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3pvb21JbjogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fZGlzYWJsZWQgJiYgdGhpcy5fbWFwLl96b29tIDwgdGhpcy5fbWFwLmdldE1heFpvb20oKSkge1xyXG5cdFx0XHR0aGlzLl9tYXAuem9vbUluKHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSAqIChlLnNoaWZ0S2V5ID8gMyA6IDEpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfem9vbU91dDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fZGlzYWJsZWQgJiYgdGhpcy5fbWFwLl96b29tID4gdGhpcy5fbWFwLmdldE1pblpvb20oKSkge1xyXG5cdFx0XHR0aGlzLl9tYXAuem9vbU91dCh0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEgKiAoZS5zaGlmdEtleSA/IDMgOiAxKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUJ1dHRvbjogZnVuY3Rpb24gKGh0bWwsIHRpdGxlLCBjbGFzc05hbWUsIGNvbnRhaW5lciwgZm4pIHtcclxuXHRcdHZhciBsaW5rID0gRG9tVXRpbC5jcmVhdGUoJ2EnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcblx0XHRsaW5rLmlubmVySFRNTCA9IGh0bWw7XHJcblx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcblx0XHRsaW5rLnRpdGxlID0gdGl0bGU7XHJcblxyXG5cdFx0LypcclxuXHRcdCAqIFdpbGwgZm9yY2Ugc2NyZWVuIHJlYWRlcnMgbGlrZSBWb2ljZU92ZXIgdG8gcmVhZCB0aGlzIGFzIFwiWm9vbSBpbiAtIGJ1dHRvblwiXHJcblx0XHQgKi9cclxuXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xyXG5cdFx0bGluay5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB0aXRsZSk7XHJcblxyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24obGluayk7XHJcblx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCBEb21FdmVudC5zdG9wKTtcclxuXHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIGZuLCB0aGlzKTtcclxuXHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIHRoaXMuX3JlZm9jdXNPbk1hcCwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIGxpbms7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZURpc2FibGVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWRpc2FibGVkJztcclxuXHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3pvb21JbkJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdHRoaXMuX3pvb21JbkJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcclxuXHRcdHRoaXMuX3pvb21PdXRCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ2ZhbHNlJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1pblpvb20oKSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHRcdHRoaXMuX3pvb21PdXRCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9kaXNhYmxlZCB8fCBtYXAuX3pvb20gPT09IG1hcC5nZXRNYXhab29tKCkpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHRcdHRoaXMuX3pvb21JbkJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuLy8gQG9wdGlvbiB6b29tQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuLy8gV2hldGhlciBhIFt6b29tIGNvbnRyb2xdKCNjb250cm9sLXpvb20pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0em9vbUNvbnRyb2w6IHRydWVcclxufSk7XHJcblxyXG5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xyXG5cdGlmICh0aGlzLm9wdGlvbnMuem9vbUNvbnRyb2wpIHtcclxuXHRcdC8vIEBzZWN0aW9uIENvbnRyb2xzXHJcblx0XHQvLyBAcHJvcGVydHkgem9vbUNvbnRyb2w6IENvbnRyb2wuWm9vbVxyXG5cdFx0Ly8gVGhlIGRlZmF1bHQgem9vbSBjb250cm9sIChvbmx5IGF2YWlsYWJsZSBpZiB0aGVcclxuXHRcdC8vIFtgem9vbUNvbnRyb2xgIG9wdGlvbl0oI21hcC16b29tY29udHJvbCkgd2FzIGB0cnVlYCB3aGVuIGNyZWF0aW5nIHRoZSBtYXApLlxyXG5cdFx0dGhpcy56b29tQ29udHJvbCA9IG5ldyBab29tKCk7XHJcblx0XHR0aGlzLmFkZENvbnRyb2wodGhpcy56b29tQ29udHJvbCk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ29udHJvbC5ab29tXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC56b29tKG9wdGlvbnM6IENvbnRyb2wuWm9vbSBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgem9vbSBjb250cm9sXHJcbmV4cG9ydCB2YXIgem9vbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBab29tKG9wdGlvbnMpO1xyXG59O1xyXG4iLCJcbmltcG9ydCB7Q29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQGNsYXNzIENvbnRyb2wuU2NhbGVcbiAqIEBha2EgTC5Db250cm9sLlNjYWxlXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxuICpcbiAqIEEgc2ltcGxlIHNjYWxlIGNvbnRyb2wgdGhhdCBzaG93cyB0aGUgc2NhbGUgb2YgdGhlIGN1cnJlbnQgY2VudGVyIG9mIHNjcmVlbiBpbiBtZXRyaWMgKG0va20pIGFuZCBpbXBlcmlhbCAobWkvZnQpIHN5c3RlbXMuIEV4dGVuZHMgYENvbnRyb2xgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIEwuY29udHJvbC5zY2FsZSgpLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIFNjYWxlID0gQ29udHJvbC5leHRlbmQoe1xuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIENvbnRyb2wuU2NhbGUgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0cG9zaXRpb246ICdib3R0b21sZWZ0JyxcblxuXHRcdC8vIEBvcHRpb24gbWF4V2lkdGg6IE51bWJlciA9IDEwMFxuXHRcdC8vIE1heGltdW0gd2lkdGggb2YgdGhlIGNvbnRyb2wgaW4gcGl4ZWxzLiBUaGUgd2lkdGggaXMgc2V0IGR5bmFtaWNhbGx5IHRvIHNob3cgcm91bmQgdmFsdWVzIChlLmcuIDEwMCwgMjAwLCA1MDApLlxuXHRcdG1heFdpZHRoOiAxMDAsXG5cblx0XHQvLyBAb3B0aW9uIG1ldHJpYzogQm9vbGVhbiA9IFRydWVcblx0XHQvLyBXaGV0aGVyIHRvIHNob3cgdGhlIG1ldHJpYyBzY2FsZSBsaW5lIChtL2ttKS5cblx0XHRtZXRyaWM6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGltcGVyaWFsOiBCb29sZWFuID0gVHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgaW1wZXJpYWwgc2NhbGUgbGluZSAobWkvZnQpLlxuXHRcdGltcGVyaWFsOiB0cnVlXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5JZGxlOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIGlzIHVwZGF0ZWQgb24gW2Btb3ZlZW5kYF0oI21hcC1tb3ZlZW5kKSwgb3RoZXJ3aXNlIGl0J3MgYWx3YXlzIHVwLXRvLWRhdGUgKHVwZGF0ZWQgb24gW2Btb3ZlYF0oI21hcC1tb3ZlKSkuXG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1zY2FsZScsXG5cdFx0ICAgIGNvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpLFxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0dGhpcy5fYWRkU2NhbGVzKG9wdGlvbnMsIGNsYXNzTmFtZSArICctbGluZScsIGNvbnRhaW5lcik7XG5cblx0XHRtYXAub24ob3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0XHRtYXAud2hlblJlYWR5KHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cblx0XHRyZXR1cm4gY29udGFpbmVyO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLm9mZih0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdH0sXG5cblx0X2FkZFNjYWxlczogZnVuY3Rpb24gKG9wdGlvbnMsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XG5cdFx0aWYgKG9wdGlvbnMubWV0cmljKSB7XG5cdFx0XHR0aGlzLl9tU2NhbGUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuXHRcdH1cblx0XHRpZiAob3B0aW9ucy5pbXBlcmlhbCkge1xuXHRcdFx0dGhpcy5faVNjYWxlID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHkgPSBtYXAuZ2V0U2l6ZSgpLnkgLyAyO1xuXG5cdFx0dmFyIG1heE1ldGVycyA9IG1hcC5kaXN0YW5jZShcblx0XHRcdG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKFswLCB5XSksXG5cdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbdGhpcy5vcHRpb25zLm1heFdpZHRoLCB5XSkpO1xuXG5cdFx0dGhpcy5fdXBkYXRlU2NhbGVzKG1heE1ldGVycyk7XG5cdH0sXG5cblx0X3VwZGF0ZVNjYWxlczogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdGlmICh0aGlzLm9wdGlvbnMubWV0cmljICYmIG1heE1ldGVycykge1xuXHRcdFx0dGhpcy5fdXBkYXRlTWV0cmljKG1heE1ldGVycyk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW1wZXJpYWwgJiYgbWF4TWV0ZXJzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVJbXBlcmlhbChtYXhNZXRlcnMpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlTWV0cmljOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0dmFyIG1ldGVycyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1ldGVycyksXG5cdFx0ICAgIGxhYmVsID0gbWV0ZXJzIDwgMTAwMCA/IG1ldGVycyArICcgbScgOiAobWV0ZXJzIC8gMTAwMCkgKyAnIGttJztcblxuXHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX21TY2FsZSwgbGFiZWwsIG1ldGVycyAvIG1heE1ldGVycyk7XG5cdH0sXG5cblx0X3VwZGF0ZUltcGVyaWFsOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0dmFyIG1heEZlZXQgPSBtYXhNZXRlcnMgKiAzLjI4MDgzOTksXG5cdFx0ICAgIG1heE1pbGVzLCBtaWxlcywgZmVldDtcblxuXHRcdGlmIChtYXhGZWV0ID4gNTI4MCkge1xuXHRcdFx0bWF4TWlsZXMgPSBtYXhGZWV0IC8gNTI4MDtcblx0XHRcdG1pbGVzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWlsZXMpO1xuXHRcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLCBtaWxlcyArICcgbWknLCBtaWxlcyAvIG1heE1pbGVzKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmZWV0ID0gdGhpcy5fZ2V0Um91bmROdW0obWF4RmVldCk7XG5cdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIGZlZXQgKyAnIGZ0JywgZmVldCAvIG1heEZlZXQpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlU2NhbGU6IGZ1bmN0aW9uIChzY2FsZSwgdGV4dCwgcmF0aW8pIHtcblx0XHRzY2FsZS5zdHlsZS53aWR0aCA9IE1hdGgucm91bmQodGhpcy5vcHRpb25zLm1heFdpZHRoICogcmF0aW8pICsgJ3B4Jztcblx0XHRzY2FsZS5pbm5lckhUTUwgPSB0ZXh0O1xuXHR9LFxuXG5cdF9nZXRSb3VuZE51bTogZnVuY3Rpb24gKG51bSkge1xuXHRcdHZhciBwb3cxMCA9IE1hdGgucG93KDEwLCAoTWF0aC5mbG9vcihudW0pICsgJycpLmxlbmd0aCAtIDEpLFxuXHRcdCAgICBkID0gbnVtIC8gcG93MTA7XG5cblx0XHRkID0gZCA+PSAxMCA/IDEwIDpcblx0XHQgICAgZCA+PSA1ID8gNSA6XG5cdFx0ICAgIGQgPj0gMyA/IDMgOlxuXHRcdCAgICBkID49IDIgPyAyIDogMTtcblxuXHRcdHJldHVybiBwb3cxMCAqIGQ7XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwuY29udHJvbC5zY2FsZShvcHRpb25zPzogQ29udHJvbC5TY2FsZSBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhbiBzY2FsZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5leHBvcnQgdmFyIHNjYWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBTY2FsZShvcHRpb25zKTtcbn07XG4iLCJcclxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcblxyXG52YXIgdWtyYWluaWFuRmxhZyA9ICc8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjEyXCIgaGVpZ2h0PVwiOFwiIHZpZXdCb3g9XCIwIDAgMTIgOFwiIGNsYXNzPVwibGVhZmxldC1hdHRyaWJ1dGlvbi1mbGFnXCI+PHBhdGggZmlsbD1cIiM0QzdCRTFcIiBkPVwiTTAgMGgxMnY0SDB6XCIvPjxwYXRoIGZpbGw9XCIjRkZENTAwXCIgZD1cIk0wIDRoMTJ2M0gwelwiLz48cGF0aCBmaWxsPVwiI0UwQkMwMFwiIGQ9XCJNMCA3aDEydjFIMHpcIi8+PC9zdmc+JztcclxuXHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gKiBAYWthIEwuQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBUaGUgYXR0cmlidXRpb24gY29udHJvbCBhbGxvd3MgeW91IHRvIGRpc3BsYXkgYXR0cmlidXRpb24gZGF0YSBpbiBhIHNtYWxsIHRleHQgYm94IG9uIGEgbWFwLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYGF0dHJpYnV0aW9uQ29udHJvbGAgb3B0aW9uXSgjbWFwLWF0dHJpYnV0aW9uY29udHJvbCkgdG8gYGZhbHNlYCwgYW5kIGl0IGZldGNoZXMgYXR0cmlidXRpb24gdGV4dHMgZnJvbSBsYXllcnMgd2l0aCB0aGUgW2BnZXRBdHRyaWJ1dGlvbmAgbWV0aG9kXSgjbGF5ZXItZ2V0YXR0cmlidXRpb24pIGF1dG9tYXRpY2FsbHkuIEV4dGVuZHMgQ29udHJvbC5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIEF0dHJpYnV0aW9uID0gQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLkF0dHJpYnV0aW9uIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3NpdGlvbjogJ2JvdHRvbXJpZ2h0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHByZWZpeDogU3RyaW5nfGZhbHNlID0gJ0xlYWZsZXQnXHJcblx0XHQvLyBUaGUgSFRNTCB0ZXh0IHNob3duIGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLiBQYXNzIGBmYWxzZWAgdG8gZGlzYWJsZS5cclxuXHRcdHByZWZpeDogJzxhIGhyZWY9XCJodHRwczovL2xlYWZsZXRqcy5jb21cIiB0aXRsZT1cIkEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzXCI+JyArIChCcm93c2VyLmlubGluZVN2ZyA/IHVrcmFpbmlhbkZsYWcgKyAnICcgOiAnJykgKyAnTGVhZmxldDwvYT4nXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9hdHRyaWJ1dGlvbnMgPSB7fTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLmF0dHJpYnV0aW9uQ29udHJvbCA9IHRoaXM7XHJcblx0XHR0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbicpO1xyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHQvLyBUT0RPIHVnbHksIHJlZmFjdG9yXHJcblx0XHRmb3IgKHZhciBpIGluIG1hcC5fbGF5ZXJzKSB7XHJcblx0XHRcdGlmIChtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbikge1xyXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRpb24obWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24oKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHRtYXAub24oJ2xheWVyYWRkJywgdGhpcy5fYWRkQXR0cmlidXRpb24sIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vZmYoJ2xheWVyYWRkJywgdGhpcy5fYWRkQXR0cmlidXRpb24sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9hZGRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKGV2KSB7XHJcblx0XHRpZiAoZXYubGF5ZXIuZ2V0QXR0cmlidXRpb24pIHtcclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGlvbihldi5sYXllci5nZXRBdHRyaWJ1dGlvbigpKTtcclxuXHRcdFx0ZXYubGF5ZXIub25jZSgncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdHRoaXMucmVtb3ZlQXR0cmlidXRpb24oZXYubGF5ZXIuZ2V0QXR0cmlidXRpb24oKSk7XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UHJlZml4KHByZWZpeDogU3RyaW5nfGZhbHNlKTogdGhpc1xyXG5cdC8vIFRoZSBIVE1MIHRleHQgc2hvd24gYmVmb3JlIHRoZSBhdHRyaWJ1dGlvbnMuIFBhc3MgYGZhbHNlYCB0byBkaXNhYmxlLlxyXG5cdHNldFByZWZpeDogZnVuY3Rpb24gKHByZWZpeCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnByZWZpeCA9IHByZWZpeDtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRBdHRyaWJ1dGlvbih0ZXh0OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0IChlLmcuIGAnJmNvcHk7IE9wZW5TdHJlZXRNYXAgY29udHJpYnV0b3JzJ2ApLlxyXG5cdGFkZEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG5cdFx0aWYgKCF0ZXh0KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdID0gMDtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSsrO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYW4gYXR0cmlidXRpb24gdGV4dC5cclxuXHRyZW1vdmVBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKHRleHQpIHtcclxuXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdLS07XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBhdHRyaWJzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9hdHRyaWJ1dGlvbnMpIHtcclxuXHRcdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1tpXSkge1xyXG5cdFx0XHRcdGF0dHJpYnMucHVzaChpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwcmVmaXhBbmRBdHRyaWJzID0gW107XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5wcmVmaXgpIHtcclxuXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKHRoaXMub3B0aW9ucy5wcmVmaXgpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGF0dHJpYnMubGVuZ3RoKSB7XHJcblx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaChhdHRyaWJzLmpvaW4oJywgJykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSBwcmVmaXhBbmRBdHRyaWJzLmpvaW4oJyA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj58PC9zcGFuPiAnKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbi8vIEBvcHRpb24gYXR0cmlidXRpb25Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxyXG4vLyBXaGV0aGVyIGEgW2F0dHJpYnV0aW9uIGNvbnRyb2xdKCNjb250cm9sLWF0dHJpYnV0aW9uKSBpcyBhZGRlZCB0byB0aGUgbWFwIGJ5IGRlZmF1bHQuXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcclxuXHRcdG5ldyBBdHRyaWJ1dGlvbigpLmFkZFRvKHRoaXMpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENvbnRyb2wuQXR0cmlidXRpb25cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLmF0dHJpYnV0aW9uKG9wdGlvbnM6IENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBhdHRyaWJ1dGlvbiBjb250cm9sLlxyXG5leHBvcnQgdmFyIGF0dHJpYnV0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEF0dHJpYnV0aW9uKG9wdGlvbnMpO1xyXG59O1xyXG4iLCJpbXBvcnQge0NvbnRyb2wsIGNvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XG5pbXBvcnQge0xheWVycywgbGF5ZXJzfSBmcm9tICcuL0NvbnRyb2wuTGF5ZXJzJztcbmltcG9ydCB7Wm9vbSwgem9vbX0gZnJvbSAnLi9Db250cm9sLlpvb20nO1xuaW1wb3J0IHtTY2FsZSwgc2NhbGV9IGZyb20gJy4vQ29udHJvbC5TY2FsZSc7XG5pbXBvcnQge0F0dHJpYnV0aW9uLCBhdHRyaWJ1dGlvbn0gZnJvbSAnLi9Db250cm9sLkF0dHJpYnV0aW9uJztcblxuQ29udHJvbC5MYXllcnMgPSBMYXllcnM7XG5Db250cm9sLlpvb20gPSBab29tO1xuQ29udHJvbC5TY2FsZSA9IFNjYWxlO1xuQ29udHJvbC5BdHRyaWJ1dGlvbiA9IEF0dHJpYnV0aW9uO1xuXG5jb250cm9sLmxheWVycyA9IGxheWVycztcbmNvbnRyb2wuem9vbSA9IHpvb207XG5jb250cm9sLnNjYWxlID0gc2NhbGU7XG5jb250cm9sLmF0dHJpYnV0aW9uID0gYXR0cmlidXRpb247XG5cbmV4cG9ydCB7Q29udHJvbCwgY29udHJvbH07XG4iLCJpbXBvcnQge0NsYXNzfSBmcm9tICcuL0NsYXNzJztcblxuLypcblx0TC5IYW5kbGVyIGlzIGEgYmFzZSBjbGFzcyBmb3IgaGFuZGxlciBjbGFzc2VzIHRoYXQgYXJlIHVzZWQgaW50ZXJuYWxseSB0byBpbmplY3Rcblx0aW50ZXJhY3Rpb24gZmVhdHVyZXMgbGlrZSBkcmFnZ2luZyB0byBjbGFzc2VzIGxpa2UgTWFwIGFuZCBNYXJrZXIuXG4qL1xuXG4vLyBAY2xhc3MgSGFuZGxlclxuLy8gQGFrYSBMLkhhbmRsZXJcbi8vIEFic3RyYWN0IGNsYXNzIGZvciBtYXAgaW50ZXJhY3Rpb24gaGFuZGxlcnNcblxuZXhwb3J0IHZhciBIYW5kbGVyID0gQ2xhc3MuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGVuYWJsZSgpOiB0aGlzXG5cdC8vIEVuYWJsZXMgdGhlIGhhbmRsZXJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMuYWRkSG9va3MoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKTogdGhpc1xuXHQvLyBEaXNhYmxlcyB0aGUgaGFuZGxlclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cdFx0dGhpcy5yZW1vdmVIb29rcygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZW5hYmxlZCgpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWRcblx0ZW5hYmxlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2VuYWJsZWQ7XG5cdH1cblxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuXHQvLyBDbGFzc2VzIGluaGVyaXRpbmcgZnJvbSBgSGFuZGxlcmAgbXVzdCBpbXBsZW1lbnQgdGhlIHR3byBmb2xsb3dpbmcgbWV0aG9kczpcblx0Ly8gQG1ldGhvZCBhZGRIb29rcygpXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQsIHNob3VsZCBhZGQgZXZlbnQgaG9va3MuXG5cdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKVxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBkaXNhYmxlZCwgc2hvdWxkIHJlbW92ZSB0aGUgZXZlbnQgaG9va3MgYWRkZWQgcHJldmlvdXNseS5cbn0pO1xuXG4vLyBAc2VjdGlvbiBUaGVyZSBpcyBzdGF0aWMgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5IYW5kbGVyOlxuLy8gQGZ1bmN0aW9uIGFkZFRvKG1hcDogTWFwLCBuYW1lOiBTdHJpbmcpOiB0aGlzXG4vLyBBZGRzIGEgbmV3IEhhbmRsZXIgdG8gdGhlIGdpdmVuIG1hcCB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuSGFuZGxlci5hZGRUbyA9IGZ1bmN0aW9uIChtYXAsIG5hbWUpIHtcblx0bWFwLmFkZEhhbmRsZXIobmFtZSwgdGhpcyk7XG5cdHJldHVybiB0aGlzO1xufTtcbiIsImltcG9ydCBCcm93c2VyIGZyb20gJy4vQnJvd3Nlcic7XG5leHBvcnQge0Jyb3dzZXJ9O1xuXG5leHBvcnQge0NsYXNzfSBmcm9tICcuL0NsYXNzJztcblxuaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuL0V2ZW50cyc7XG5pbXBvcnQge0V2ZW50c30gZnJvbSAnLi9FdmVudHMnO1xuZXhwb3J0IHtFdmVudGVkfTtcbmV4cG9ydCB2YXIgTWl4aW4gPSB7RXZlbnRzOiBFdmVudHN9O1xuXG5leHBvcnQge0hhbmRsZXJ9IGZyb20gJy4vSGFuZGxlcic7XG5cbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi9VdGlsJztcbmV4cG9ydCB7VXRpbH07XG5leHBvcnQge2V4dGVuZCwgYmluZCwgc3RhbXAsIHNldE9wdGlvbnN9IGZyb20gJy4vVXRpbCc7XG4iLCJpbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4uL2NvcmUvRXZlbnRzJztcclxuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi9Eb21VdGlsJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRHJhZ2dhYmxlXHJcbiAqIEBha2EgTC5EcmFnZ2FibGVcclxuICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICpcclxuICogQSBjbGFzcyBmb3IgbWFraW5nIERPTSBlbGVtZW50cyBkcmFnZ2FibGUgKGluY2x1ZGluZyB0b3VjaCBzdXBwb3J0KS5cclxuICogVXNlZCBpbnRlcm5hbGx5IGZvciBtYXAgYW5kIG1hcmtlciBkcmFnZ2luZy4gT25seSB3b3JrcyBmb3IgZWxlbWVudHNcclxuICogdGhhdCB3ZXJlIHBvc2l0aW9uZWQgd2l0aCBbYEwuRG9tVXRpbC5zZXRQb3NpdGlvbmBdKCNkb211dGlsLXNldHBvc2l0aW9uKS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogdmFyIGRyYWdnYWJsZSA9IG5ldyBMLkRyYWdnYWJsZShlbGVtZW50VG9EcmFnKTtcclxuICogZHJhZ2dhYmxlLmVuYWJsZSgpO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgU1RBUlQgPSBCcm93c2VyLnRvdWNoID8gJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyA6ICdtb3VzZWRvd24nO1xyXG5cclxuZXhwb3J0IHZhciBEcmFnZ2FibGUgPSBFdmVudGVkLmV4dGVuZCh7XHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBzZWN0aW9uXHJcblx0XHQvLyBAYWthIERyYWdnYWJsZSBvcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIGNsaWNrVG9sZXJhbmNlOiBOdW1iZXIgPSAzXHJcblx0XHQvLyBUaGUgbWF4IG51bWJlciBvZiBwaXhlbHMgYSB1c2VyIGNhbiBzaGlmdCB0aGUgbW91c2UgcG9pbnRlciBkdXJpbmcgYSBjbGlja1xyXG5cdFx0Ly8gZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYSB2YWxpZCBjbGljayAoYXMgb3Bwb3NlZCB0byBhIG1vdXNlIGRyYWcpLlxyXG5cdFx0Y2xpY2tUb2xlcmFuY2U6IDNcclxuXHR9LFxyXG5cclxuXHQvLyBAY29uc3RydWN0b3IgTC5EcmFnZ2FibGUoZWw6IEhUTUxFbGVtZW50LCBkcmFnSGFuZGxlPzogSFRNTEVsZW1lbnQsIHByZXZlbnRPdXRsaW5lPzogQm9vbGVhbiwgb3B0aW9ucz86IERyYWdnYWJsZSBvcHRpb25zKVxyXG5cdC8vIENyZWF0ZXMgYSBgRHJhZ2dhYmxlYCBvYmplY3QgZm9yIG1vdmluZyBgZWxgIHdoZW4geW91IHN0YXJ0IGRyYWdnaW5nIHRoZSBgZHJhZ0hhbmRsZWAgZWxlbWVudCAoZXF1YWxzIGBlbGAgaXRzZWxmIGJ5IGRlZmF1bHQpLlxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChlbGVtZW50LCBkcmFnU3RhcnRUYXJnZXQsIHByZXZlbnRPdXRsaW5lLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0XHR0aGlzLl9kcmFnU3RhcnRUYXJnZXQgPSBkcmFnU3RhcnRUYXJnZXQgfHwgZWxlbWVudDtcclxuXHRcdHRoaXMuX3ByZXZlbnRPdXRsaW5lID0gcHJldmVudE91dGxpbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlbmFibGUoKVxyXG5cdC8vIEVuYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgU1RBUlQsIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXNhYmxlKClcclxuXHQvLyBEaXNhYmxlcyB0aGUgZHJhZ2dpbmcgYWJpbGl0eVxyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBJZiB3ZSdyZSBjdXJyZW50bHkgZHJhZ2dpbmcgdGhpcyBkcmFnZ2FibGUsXHJcblx0XHQvLyBkaXNhYmxpbmcgaXQgY291bnRzIGFzIGZpcnN0IGVuZGluZyB0aGUgZHJhZy5cclxuXHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nID09PSB0aGlzKSB7XHJcblx0XHRcdHRoaXMuZmluaXNoRHJhZyh0cnVlKTtcclxuXHRcdH1cclxuXHJcblx0XHREb21FdmVudC5vZmYodGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBTVEFSVCwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoRG9tVXRpbC5oYXNDbGFzcyh0aGlzLl9lbGVtZW50LCAnbGVhZmxldC16b29tLWFuaW0nKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggIT09IDEpIHtcclxuXHRcdFx0Ly8gRmluaXNoIGRyYWdnaW5nIHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggdG91Y2hab29tXHJcblx0XHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nID09PSB0aGlzKSB7XHJcblx0XHRcdFx0dGhpcy5maW5pc2hEcmFnKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nIHx8IGUuc2hpZnRLZXkgfHwgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpICYmICFlLnRvdWNoZXMpKSB7IHJldHVybjsgfVxyXG5cdFx0RHJhZ2dhYmxlLl9kcmFnZ2luZyA9IHRoaXM7ICAvLyBQcmV2ZW50IGRyYWdnaW5nIG11bHRpcGxlIG9iamVjdHMgYXQgb25jZS5cclxuXHJcblx0XHRpZiAodGhpcy5fcHJldmVudE91dGxpbmUpIHtcclxuXHRcdFx0RG9tVXRpbC5wcmV2ZW50T3V0bGluZSh0aGlzLl9lbGVtZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLmRpc2FibGVJbWFnZURyYWcoKTtcclxuXHRcdERvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92aW5nKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIEBldmVudCBkb3duOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGRyYWcgaXMgYWJvdXQgdG8gc3RhcnQuXHJcblx0XHR0aGlzLmZpcmUoJ2Rvd24nKTtcclxuXHJcblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlLFxyXG5cdFx0ICAgIHNpemVkUGFyZW50ID0gRG9tVXRpbC5nZXRTaXplZFBhcmVudE5vZGUodGhpcy5fZWxlbWVudCk7XHJcblxyXG5cdFx0dGhpcy5fc3RhcnRQb2ludCA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcclxuXHRcdHRoaXMuX3N0YXJ0UG9zID0gRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50KTtcclxuXHJcblx0XHQvLyBDYWNoZSB0aGUgc2NhbGUsIHNvIHRoYXQgd2UgY2FuIGNvbnRpbnVvdXNseSBjb21wZW5zYXRlIGZvciBpdCBkdXJpbmcgZHJhZyAoX29uTW92ZSkuXHJcblx0XHR0aGlzLl9wYXJlbnRTY2FsZSA9IERvbVV0aWwuZ2V0U2NhbGUoc2l6ZWRQYXJlbnQpO1xyXG5cclxuXHRcdHZhciBtb3VzZWV2ZW50ID0gZS50eXBlID09PSAnbW91c2Vkb3duJztcclxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCBtb3VzZWV2ZW50ID8gJ21vdXNlbW92ZScgOiAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCBtb3VzZWV2ZW50ID8gJ21vdXNldXAnIDogJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fb25VcCwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uTW92ZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcblx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmaXJzdCA9IChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA9PT0gMSA/IGUudG91Y2hlc1swXSA6IGUpLFxyXG5cdFx0ICAgIG9mZnNldCA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKS5fc3VidHJhY3QodGhpcy5fc3RhcnRQb2ludCk7XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuOyB9XHJcblx0XHRpZiAoTWF0aC5hYnMob2Zmc2V0LngpICsgTWF0aC5hYnMob2Zmc2V0LnkpIDwgdGhpcy5vcHRpb25zLmNsaWNrVG9sZXJhbmNlKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IHRoZSBwYXJlbnQgY29udGFpbmVyJ3MgcG9zaXRpb24sIGJvcmRlciBhbmQgc2NhbGUgZG8gbm90IGNoYW5nZSBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBkcmFnLlxyXG5cdFx0Ly8gVGhlcmVmb3JlIHRoZXJlIGlzIG5vIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhlIHBvc2l0aW9uIGFuZCBib3JkZXIgKHRoZXkgYXJlIGVsaW1pbmF0ZWQgYnkgdGhlIHN1YnRyYWN0aW9uKVxyXG5cdFx0Ly8gYW5kIHdlIGNhbiB1c2UgdGhlIGNhY2hlZCB2YWx1ZSBmb3IgdGhlIHNjYWxlLlxyXG5cdFx0b2Zmc2V0LnggLz0gdGhpcy5fcGFyZW50U2NhbGUueDtcclxuXHRcdG9mZnNldC55IC89IHRoaXMuX3BhcmVudFNjYWxlLnk7XHJcblxyXG5cdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xyXG5cdFx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgZHJhZyBzdGFydHNcclxuXHRcdFx0dGhpcy5maXJlKCdkcmFnc3RhcnQnKTtcclxuXHJcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcclxuXHJcblx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XHJcblx0XHRcdC8vIElFIGFuZCBFZGdlIGRvIG5vdCBnaXZlIHRoZSA8dXNlPiBlbGVtZW50LCBzbyBmZXRjaCBpdFxyXG5cdFx0XHQvLyBpZiBuZWNlc3NhcnlcclxuXHRcdFx0aWYgKHdpbmRvdy5TVkdFbGVtZW50SW5zdGFuY2UgJiYgdGhpcy5fbGFzdFRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5TVkdFbGVtZW50SW5zdGFuY2UpIHtcclxuXHRcdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gdGhpcy5fbGFzdFRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcclxuXHRcdFx0fVxyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbmV3UG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XHJcblx0XHR0aGlzLl9tb3ZpbmcgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuX2xhc3RFdmVudCA9IGU7XHJcblx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGUgPSB7b3JpZ2luYWxFdmVudDogdGhpcy5fbGFzdEV2ZW50fTtcclxuXHJcblx0XHQvLyBAZXZlbnQgcHJlZHJhZzogRXZlbnRcclxuXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcgKmJlZm9yZSogZWFjaCBjb3JyZXNwb25kaW5nXHJcblx0XHQvLyB1cGRhdGUgb2YgdGhlIGVsZW1lbnQncyBwb3NpdGlvbi5cclxuXHRcdHRoaXMuZmlyZSgncHJlZHJhZycsIGUpO1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50LCB0aGlzLl9uZXdQb3MpO1xyXG5cclxuXHRcdC8vIEBldmVudCBkcmFnOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyBkcmFnZ2luZy5cclxuXHRcdHRoaXMuZmlyZSgnZHJhZycsIGUpO1xyXG5cdH0sXHJcblxyXG5cdF9vblVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuXHR9LFxyXG5cclxuXHRmaW5pc2hEcmFnOiBmdW5jdGlvbiAobm9JbmVydGlhKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xhc3RUYXJnZXQpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG5cdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUgdG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ21vdXNldXAgdG91Y2hlbmQgdG91Y2hjYW5jZWwnLCB0aGlzLl9vblVwLCB0aGlzKTtcclxuXHJcblx0XHREb21VdGlsLmVuYWJsZUltYWdlRHJhZygpO1xyXG5cdFx0RG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XHJcblxyXG5cdFx0dmFyIGZpcmVEcmFnZW5kID0gdGhpcy5fbW92ZWQgJiYgdGhpcy5fbW92aW5nO1xyXG5cclxuXHRcdHRoaXMuX21vdmluZyA9IGZhbHNlO1xyXG5cdFx0RHJhZ2dhYmxlLl9kcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChmaXJlRHJhZ2VuZCkge1xyXG5cdFx0XHQvLyBAZXZlbnQgZHJhZ2VuZDogRHJhZ0VuZEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGRyYWcgZW5kcy5cclxuXHRcdFx0dGhpcy5maXJlKCdkcmFnZW5kJywge1xyXG5cdFx0XHRcdG5vSW5lcnRpYTogbm9JbmVydGlhLFxyXG5cdFx0XHRcdGRpc3RhbmNlOiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcylcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxufSk7XHJcbiIsImltcG9ydCAqIGFzIExpbmVVdGlsIGZyb20gJy4vTGluZVV0aWwnO1xyXG5pbXBvcnQge3RvTGF0TG5nfSBmcm9tICcuLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0IHt0b1BvaW50fSBmcm9tICcuL1BvaW50JztcclxuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgUG9seVV0aWxcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWdvbiBnZW9tZXRyaWVzLlxyXG4gKi9cclxuXHJcbi8qIEBmdW5jdGlvbiBjbGlwUG9seWdvbihwb2ludHM6IFBvaW50W10sIGJvdW5kczogQm91bmRzLCByb3VuZD86IEJvb2xlYW4pOiBQb2ludFtdXHJcbiAqIENsaXBzIHRoZSBwb2x5Z29uIGdlb21ldHJ5IGRlZmluZWQgYnkgdGhlIGdpdmVuIGBwb2ludHNgIGJ5IHRoZSBnaXZlbiBib3VuZHMgKHVzaW5nIHRoZSBbU3V0aGVybGFuZC1Ib2RnbWFuIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3V0aGVybGFuZCVFMiU4MCU5M0hvZGdtYW5fYWxnb3JpdGhtKSkuXHJcbiAqIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWdvbiBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nXHJcbiAqIHBlcmZvcm1hbmNlLiBOb3RlIHRoYXQgcG9seWdvbiBwb2ludHMgbmVlZHMgZGlmZmVyZW50IGFsZ29yaXRobSBmb3IgY2xpcHBpbmdcclxuICogdGhhbiBwb2x5bGluZSwgc28gdGhlcmUncyBhIHNlcGFyYXRlIG1ldGhvZCBmb3IgaXQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2xpcFBvbHlnb24ocG9pbnRzLCBib3VuZHMsIHJvdW5kKSB7XHJcblx0dmFyIGNsaXBwZWRQb2ludHMsXHJcblx0ICAgIGVkZ2VzID0gWzEsIDQsIDIsIDhdLFxyXG5cdCAgICBpLCBqLCBrLFxyXG5cdCAgICBhLCBiLFxyXG5cdCAgICBsZW4sIGVkZ2UsIHA7XHJcblxyXG5cdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0cG9pbnRzW2ldLl9jb2RlID0gTGluZVV0aWwuX2dldEJpdENvZGUocG9pbnRzW2ldLCBib3VuZHMpO1xyXG5cdH1cclxuXHJcblx0Ly8gZm9yIGVhY2ggZWRnZSAobGVmdCwgYm90dG9tLCByaWdodCwgdG9wKVxyXG5cdGZvciAoayA9IDA7IGsgPCA0OyBrKyspIHtcclxuXHRcdGVkZ2UgPSBlZGdlc1trXTtcclxuXHRcdGNsaXBwZWRQb2ludHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xyXG5cdFx0XHRhID0gcG9pbnRzW2ldO1xyXG5cdFx0XHRiID0gcG9pbnRzW2pdO1xyXG5cclxuXHRcdFx0Ly8gaWYgYSBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93XHJcblx0XHRcdGlmICghKGEuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdC8vIGlmIGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZ29lcyBvdXQgb2Ygc2NyZWVuKVxyXG5cdFx0XHRcdGlmIChiLl9jb2RlICYgZWRnZSkge1xyXG5cdFx0XHRcdFx0cCA9IExpbmVVdGlsLl9nZXRFZGdlSW50ZXJzZWN0aW9uKGIsIGEsIGVkZ2UsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0XHRcdFx0cC5fY29kZSA9IExpbmVVdGlsLl9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblx0XHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChhKTtcclxuXHJcblx0XHRcdC8vIGVsc2UgaWYgYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGVudGVycyB0aGUgc2NyZWVuKVxyXG5cdFx0XHR9IGVsc2UgaWYgKCEoYi5fY29kZSAmIGVkZ2UpKSB7XHJcblx0XHRcdFx0cCA9IExpbmVVdGlsLl9nZXRFZGdlSW50ZXJzZWN0aW9uKGIsIGEsIGVkZ2UsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0XHRcdHAuX2NvZGUgPSBMaW5lVXRpbC5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cG9pbnRzID0gY2xpcHBlZFBvaW50cztcclxuXHR9XHJcblxyXG5cdHJldHVybiBwb2ludHM7XHJcbn1cclxuXHJcbi8qIEBmdW5jdGlvbiBwb2x5Z29uQ2VudGVyKGxhdGxuZ3M6IExhdExuZ1tdLCBjcnM6IENSUyk6IExhdExuZ1xyXG4gKiBSZXR1cm5zIHRoZSBjZW50ZXIgKFtjZW50cm9pZF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cm9pZCkpIG9mIHRoZSBwYXNzZWQgTGF0TG5ncyAoZmlyc3QgcmluZykgZnJvbSBhIHBvbHlnb24uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcG9seWdvbkNlbnRlcihsYXRsbmdzLCBjcnMpIHtcclxuXHR2YXIgaSwgaiwgcDEsIHAyLCBmLCBhcmVhLCB4LCB5LCBjZW50ZXI7XHJcblxyXG5cdGlmICghbGF0bG5ncyB8fCBsYXRsbmdzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdsYXRsbmdzIG5vdCBwYXNzZWQnKTtcclxuXHR9XHJcblxyXG5cdGlmICghTGluZVV0aWwuaXNGbGF0KGxhdGxuZ3MpKSB7XHJcblx0XHRjb25zb2xlLndhcm4oJ2xhdGxuZ3MgYXJlIG5vdCBmbGF0ISBPbmx5IHRoZSBmaXJzdCByaW5nIHdpbGwgYmUgdXNlZCcpO1xyXG5cdFx0bGF0bG5ncyA9IGxhdGxuZ3NbMF07XHJcblx0fVxyXG5cclxuXHR2YXIgY2VudHJvaWRMYXRMbmcgPSB0b0xhdExuZyhbMCwgMF0pO1xyXG5cclxuXHR2YXIgYm91bmRzID0gdG9MYXRMbmdCb3VuZHMobGF0bG5ncyk7XHJcblx0dmFyIGFyZWFCb3VuZHMgPSBib3VuZHMuZ2V0Tm9ydGhXZXN0KCkuZGlzdGFuY2VUbyhib3VuZHMuZ2V0U291dGhXZXN0KCkpICogYm91bmRzLmdldE5vcnRoRWFzdCgpLmRpc3RhbmNlVG8oYm91bmRzLmdldE5vcnRoV2VzdCgpKTtcclxuXHQvLyB0ZXN0cyBzaG93ZWQgdGhhdCBiZWxvdyAxNzAwIHJvdW5kaW5nIGVycm9ycyBhcmUgaGFwcGVuaW5nXHJcblx0aWYgKGFyZWFCb3VuZHMgPCAxNzAwKSB7XHJcblx0XHQvLyBnZXR0aW5nIGEgaW5leGFjdCBjZW50ZXIsIHRvIG1vdmUgdGhlIGxhdGxuZ3MgbmVhciB0byBbMCwgMF0gdG8gcHJldmVudCByb3VuZGluZyBlcnJvcnNcclxuXHRcdGNlbnRyb2lkTGF0TG5nID0gY2VudHJvaWQobGF0bG5ncyk7XHJcblx0fVxyXG5cclxuXHR2YXIgbGVuID0gbGF0bG5ncy5sZW5ndGg7XHJcblx0dmFyIHBvaW50cyA9IFtdO1xyXG5cdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dmFyIGxhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZ3NbaV0pO1xyXG5cdFx0cG9pbnRzLnB1c2goY3JzLnByb2plY3QodG9MYXRMbmcoW2xhdGxuZy5sYXQgLSBjZW50cm9pZExhdExuZy5sYXQsIGxhdGxuZy5sbmcgLSBjZW50cm9pZExhdExuZy5sbmddKSkpO1xyXG5cdH1cclxuXHJcblx0YXJlYSA9IHggPSB5ID0gMDtcclxuXHJcblx0Ly8gcG9seWdvbiBjZW50cm9pZCBhbGdvcml0aG07XHJcblx0Zm9yIChpID0gMCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcclxuXHRcdHAxID0gcG9pbnRzW2ldO1xyXG5cdFx0cDIgPSBwb2ludHNbal07XHJcblxyXG5cdFx0ZiA9IHAxLnkgKiBwMi54IC0gcDIueSAqIHAxLng7XHJcblx0XHR4ICs9IChwMS54ICsgcDIueCkgKiBmO1xyXG5cdFx0eSArPSAocDEueSArIHAyLnkpICogZjtcclxuXHRcdGFyZWEgKz0gZiAqIDM7XHJcblx0fVxyXG5cclxuXHRpZiAoYXJlYSA9PT0gMCkge1xyXG5cdFx0Ly8gUG9seWdvbiBpcyBzbyBzbWFsbCB0aGF0IGFsbCBwb2ludHMgYXJlIG9uIHNhbWUgcGl4ZWwuXHJcblx0XHRjZW50ZXIgPSBwb2ludHNbMF07XHJcblx0fSBlbHNlIHtcclxuXHRcdGNlbnRlciA9IFt4IC8gYXJlYSwgeSAvIGFyZWFdO1xyXG5cdH1cclxuXHJcblx0dmFyIGxhdGxuZ0NlbnRlciA9IGNycy51bnByb2plY3QodG9Qb2ludChjZW50ZXIpKTtcclxuXHRyZXR1cm4gdG9MYXRMbmcoW2xhdGxuZ0NlbnRlci5sYXQgKyBjZW50cm9pZExhdExuZy5sYXQsIGxhdGxuZ0NlbnRlci5sbmcgKyBjZW50cm9pZExhdExuZy5sbmddKTtcclxufVxyXG5cclxuLyogQGZ1bmN0aW9uIGNlbnRyb2lkKGxhdGxuZ3M6IExhdExuZ1tdKTogTGF0TG5nXHJcbiAqIFJldHVybnMgdGhlICdjZW50ZXIgb2YgbWFzcycgb2YgdGhlIHBhc3NlZCBMYXRMbmdzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNlbnRyb2lkKGNvb3Jkcykge1xyXG5cdHZhciBsYXRTdW0gPSAwO1xyXG5cdHZhciBsbmdTdW0gPSAwO1xyXG5cdHZhciBsZW4gPSAwO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgbGF0bG5nID0gdG9MYXRMbmcoY29vcmRzW2ldKTtcclxuXHRcdGxhdFN1bSArPSBsYXRsbmcubGF0O1xyXG5cdFx0bG5nU3VtICs9IGxhdGxuZy5sbmc7XHJcblx0XHRsZW4rKztcclxuXHR9XHJcblx0cmV0dXJuIHRvTGF0TG5nKFtsYXRTdW0gLyBsZW4sIGxuZ1N1bSAvIGxlbl0pO1xyXG59XHJcbiIsImltcG9ydCB7UG9pbnQsIHRvUG9pbnR9IGZyb20gJy4vUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQge2NlbnRyb2lkfSBmcm9tICcuL1BvbHlVdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcblxyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBMaW5lVXRpbFxyXG4gKlxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5bGluZSBwb2ludHMgcHJvY2Vzc2luZywgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gbWFrZSBwb2x5bGluZXMgbGlnaHRuaW5nLWZhc3QuXHJcbiAqL1xyXG5cclxuLy8gU2ltcGxpZnkgcG9seWxpbmUgd2l0aCB2ZXJ0ZXggcmVkdWN0aW9uIGFuZCBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24uXHJcbi8vIEltcHJvdmVzIHJlbmRlcmluZyBwZXJmb3JtYW5jZSBkcmFtYXRpY2FsbHkgYnkgbGVzc2VuaW5nIHRoZSBudW1iZXIgb2YgcG9pbnRzIHRvIGRyYXcuXHJcblxyXG4vLyBAZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzOiBQb2ludFtdLCB0b2xlcmFuY2U6IE51bWJlcik6IFBvaW50W11cclxuLy8gRHJhbWF0aWNhbGx5IHJlZHVjZXMgdGhlIG51bWJlciBvZiBwb2ludHMgaW4gYSBwb2x5bGluZSB3aGlsZSByZXRhaW5pbmdcclxuLy8gaXRzIHNoYXBlIGFuZCByZXR1cm5zIGEgbmV3IGFycmF5IG9mIHNpbXBsaWZpZWQgcG9pbnRzLCB1c2luZyB0aGVcclxuLy8gW1JhbWVyLURvdWdsYXMtUGV1Y2tlciBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JhbWVyLURvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG0pLlxyXG4vLyBVc2VkIGZvciBhIGh1Z2UgcGVyZm9ybWFuY2UgYm9vc3Qgd2hlbiBwcm9jZXNzaW5nL2Rpc3BsYXlpbmcgTGVhZmxldCBwb2x5bGluZXMgZm9yXHJcbi8vIGVhY2ggem9vbSBsZXZlbCBhbmQgYWxzbyByZWR1Y2luZyB2aXN1YWwgbm9pc2UuIHRvbGVyYW5jZSBhZmZlY3RzIHRoZSBhbW91bnQgb2ZcclxuLy8gc2ltcGxpZmljYXRpb24gKGxlc3NlciB2YWx1ZSBtZWFucyBoaWdoZXIgcXVhbGl0eSBidXQgc2xvd2VyIGFuZCB3aXRoIG1vcmUgcG9pbnRzKS5cclxuLy8gQWxzbyByZWxlYXNlZCBhcyBhIHNlcGFyYXRlZCBtaWNyby1saWJyYXJ5IFtTaW1wbGlmeS5qc10oaHR0cHM6Ly9tb3VybmVyLmdpdGh1Yi5pby9zaW1wbGlmeS1qcy8pLlxyXG5leHBvcnQgZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzLCB0b2xlcmFuY2UpIHtcclxuXHRpZiAoIXRvbGVyYW5jZSB8fCAhcG9pbnRzLmxlbmd0aCkge1xyXG5cdFx0cmV0dXJuIHBvaW50cy5zbGljZSgpO1xyXG5cdH1cclxuXHJcblx0dmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlO1xyXG5cclxuXHQgICAgLy8gc3RhZ2UgMTogdmVydGV4IHJlZHVjdGlvblxyXG5cdCAgICBwb2ludHMgPSBfcmVkdWNlUG9pbnRzKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuXHQgICAgLy8gc3RhZ2UgMjogRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uXHJcblx0ICAgIHBvaW50cyA9IF9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuXHRyZXR1cm4gcG9pbnRzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiBwb2ludCBgcGAgYW5kIHNlZ21lbnQgYHAxYCB0byBgcDJgLlxyXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwMSwgcDIpIHtcclxuXHRyZXR1cm4gTWF0aC5zcXJ0KF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHRydWUpKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNsb3Nlc3RQb2ludE9uU2VnbWVudChwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgY2xvc2VzdCBwb2ludCBmcm9tIGEgcG9pbnQgYHBgIG9uIGEgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyKSB7XHJcblx0cmV0dXJuIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpO1xyXG59XHJcblxyXG4vLyBSYW1lci1Eb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24sIHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYW1lci1Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtXHJcbmZ1bmN0aW9uIF9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcclxuXHJcblx0dmFyIGxlbiA9IHBvaW50cy5sZW5ndGgsXHJcblx0ICAgIEFycmF5Q29uc3RydWN0b3IgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gdW5kZWZpbmVkICsgJycgPyBVaW50OEFycmF5IDogQXJyYXksXHJcblx0ICAgIG1hcmtlcnMgPSBuZXcgQXJyYXlDb25zdHJ1Y3RvcihsZW4pO1xyXG5cclxuXHQgICAgbWFya2Vyc1swXSA9IG1hcmtlcnNbbGVuIC0gMV0gPSAxO1xyXG5cclxuXHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgMCwgbGVuIC0gMSk7XHJcblxyXG5cdHZhciBpLFxyXG5cdCAgICBuZXdQb2ludHMgPSBbXTtcclxuXHJcblx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRpZiAobWFya2Vyc1tpXSkge1xyXG5cdFx0XHRuZXdQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5ld1BvaW50cztcclxufVxyXG5cclxuZnVuY3Rpb24gX3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBsYXN0KSB7XHJcblxyXG5cdHZhciBtYXhTcURpc3QgPSAwLFxyXG5cdGluZGV4LCBpLCBzcURpc3Q7XHJcblxyXG5cdGZvciAoaSA9IGZpcnN0ICsgMTsgaSA8PSBsYXN0IC0gMTsgaSsrKSB7XHJcblx0XHRzcURpc3QgPSBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocG9pbnRzW2ldLCBwb2ludHNbZmlyc3RdLCBwb2ludHNbbGFzdF0sIHRydWUpO1xyXG5cclxuXHRcdGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcclxuXHRcdFx0aW5kZXggPSBpO1xyXG5cdFx0XHRtYXhTcURpc3QgPSBzcURpc3Q7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAobWF4U3FEaXN0ID4gc3FUb2xlcmFuY2UpIHtcclxuXHRcdG1hcmtlcnNbaW5kZXhdID0gMTtcclxuXHJcblx0XHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGluZGV4KTtcclxuXHRcdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBpbmRleCwgbGFzdCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyByZWR1Y2UgcG9pbnRzIHRoYXQgYXJlIHRvbyBjbG9zZSB0byBlYWNoIG90aGVyIHRvIGEgc2luZ2xlIHBvaW50XHJcbmZ1bmN0aW9uIF9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cdHZhciByZWR1Y2VkUG9pbnRzID0gW3BvaW50c1swXV07XHJcblxyXG5cdGZvciAodmFyIGkgPSAxLCBwcmV2ID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRpZiAoX3NxRGlzdChwb2ludHNbaV0sIHBvaW50c1twcmV2XSkgPiBzcVRvbGVyYW5jZSkge1xyXG5cdFx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuXHRcdFx0cHJldiA9IGk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChwcmV2IDwgbGVuIC0gMSkge1xyXG5cdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tsZW4gLSAxXSk7XHJcblx0fVxyXG5cdHJldHVybiByZWR1Y2VkUG9pbnRzO1xyXG59XHJcblxyXG52YXIgX2xhc3RDb2RlO1xyXG5cclxuLy8gQGZ1bmN0aW9uIGNsaXBTZWdtZW50KGE6IFBvaW50LCBiOiBQb2ludCwgYm91bmRzOiBCb3VuZHMsIHVzZUxhc3RDb2RlPzogQm9vbGVhbiwgcm91bmQ/OiBCb29sZWFuKTogUG9pbnRbXXxCb29sZWFuXHJcbi8vIENsaXBzIHRoZSBzZWdtZW50IGEgdG8gYiBieSByZWN0YW5ndWxhciBib3VuZHMgd2l0aCB0aGVcclxuLy8gW0NvaGVuLVN1dGhlcmxhbmQgYWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2hlbiVFMiU4MCU5M1N1dGhlcmxhbmRfYWxnb3JpdGhtKVxyXG4vLyAobW9kaWZ5aW5nIHRoZSBzZWdtZW50IHBvaW50cyBkaXJlY3RseSEpLiBVc2VkIGJ5IExlYWZsZXQgdG8gb25seSBzaG93IHBvbHlsaW5lXHJcbi8vIHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2NyZWVuIG9yIG5lYXIsIGluY3JlYXNpbmcgcGVyZm9ybWFuY2UuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGlwU2VnbWVudChhLCBiLCBib3VuZHMsIHVzZUxhc3RDb2RlLCByb3VuZCkge1xyXG5cdHZhciBjb2RlQSA9IHVzZUxhc3RDb2RlID8gX2xhc3RDb2RlIDogX2dldEJpdENvZGUoYSwgYm91bmRzKSxcclxuXHQgICAgY29kZUIgPSBfZ2V0Qml0Q29kZShiLCBib3VuZHMpLFxyXG5cclxuXHQgICAgY29kZU91dCwgcCwgbmV3Q29kZTtcclxuXHJcblx0ICAgIC8vIHNhdmUgMm5kIGNvZGUgdG8gYXZvaWQgY2FsY3VsYXRpbmcgaXQgb24gdGhlIG5leHQgc2VnbWVudFxyXG5cdCAgICBfbGFzdENvZGUgPSBjb2RlQjtcclxuXHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdC8vIGlmIGEsYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIGFjY2VwdClcclxuXHRcdGlmICghKGNvZGVBIHwgY29kZUIpKSB7XHJcblx0XHRcdHJldHVybiBbYSwgYl07XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaWYgYSxiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIHJlamVjdClcclxuXHRcdGlmIChjb2RlQSAmIGNvZGVCKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBvdGhlciBjYXNlc1xyXG5cdFx0Y29kZU91dCA9IGNvZGVBIHx8IGNvZGVCO1xyXG5cdFx0cCA9IF9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGVPdXQsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0bmV3Q29kZSA9IF9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKGNvZGVPdXQgPT09IGNvZGVBKSB7XHJcblx0XHRcdGEgPSBwO1xyXG5cdFx0XHRjb2RlQSA9IG5ld0NvZGU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRiID0gcDtcclxuXHRcdFx0Y29kZUIgPSBuZXdDb2RlO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGUsIGJvdW5kcywgcm91bmQpIHtcclxuXHR2YXIgZHggPSBiLnggLSBhLngsXHJcblx0ICAgIGR5ID0gYi55IC0gYS55LFxyXG5cdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG5cdCAgICBtYXggPSBib3VuZHMubWF4LFxyXG5cdCAgICB4LCB5O1xyXG5cclxuXHRpZiAoY29kZSAmIDgpIHsgLy8gdG9wXHJcblx0XHR4ID0gYS54ICsgZHggKiAobWF4LnkgLSBhLnkpIC8gZHk7XHJcblx0XHR5ID0gbWF4Lnk7XHJcblxyXG5cdH0gZWxzZSBpZiAoY29kZSAmIDQpIHsgLy8gYm90dG9tXHJcblx0XHR4ID0gYS54ICsgZHggKiAobWluLnkgLSBhLnkpIC8gZHk7XHJcblx0XHR5ID0gbWluLnk7XHJcblxyXG5cdH0gZWxzZSBpZiAoY29kZSAmIDIpIHsgLy8gcmlnaHRcclxuXHRcdHggPSBtYXgueDtcclxuXHRcdHkgPSBhLnkgKyBkeSAqIChtYXgueCAtIGEueCkgLyBkeDtcclxuXHJcblx0fSBlbHNlIGlmIChjb2RlICYgMSkgeyAvLyBsZWZ0XHJcblx0XHR4ID0gbWluLng7XHJcblx0XHR5ID0gYS55ICsgZHkgKiAobWluLnggLSBhLngpIC8gZHg7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3IFBvaW50KHgsIHksIHJvdW5kKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRCaXRDb2RlKHAsIGJvdW5kcykge1xyXG5cdHZhciBjb2RlID0gMDtcclxuXHJcblx0aWYgKHAueCA8IGJvdW5kcy5taW4ueCkgeyAvLyBsZWZ0XHJcblx0XHRjb2RlIHw9IDE7XHJcblx0fSBlbHNlIGlmIChwLnggPiBib3VuZHMubWF4LngpIHsgLy8gcmlnaHRcclxuXHRcdGNvZGUgfD0gMjtcclxuXHR9XHJcblxyXG5cdGlmIChwLnkgPCBib3VuZHMubWluLnkpIHsgLy8gYm90dG9tXHJcblx0XHRjb2RlIHw9IDQ7XHJcblx0fSBlbHNlIGlmIChwLnkgPiBib3VuZHMubWF4LnkpIHsgLy8gdG9wXHJcblx0XHRjb2RlIHw9IDg7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gY29kZTtcclxufVxyXG5cclxuLy8gc3F1YXJlIGRpc3RhbmNlICh0byBhdm9pZCB1bm5lY2Vzc2FyeSBNYXRoLnNxcnQgY2FsbHMpXHJcbmZ1bmN0aW9uIF9zcURpc3QocDEsIHAyKSB7XHJcblx0dmFyIGR4ID0gcDIueCAtIHAxLngsXHJcblx0ICAgIGR5ID0gcDIueSAtIHAxLnk7XHJcblx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG59XHJcblxyXG4vLyByZXR1cm4gY2xvc2VzdCBwb2ludCBvbiBzZWdtZW50IG9yIGRpc3RhbmNlIHRvIHRoYXQgcG9pbnRcclxuZXhwb3J0IGZ1bmN0aW9uIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHNxRGlzdCkge1xyXG5cdHZhciB4ID0gcDEueCxcclxuXHQgICAgeSA9IHAxLnksXHJcblx0ICAgIGR4ID0gcDIueCAtIHgsXHJcblx0ICAgIGR5ID0gcDIueSAtIHksXHJcblx0ICAgIGRvdCA9IGR4ICogZHggKyBkeSAqIGR5LFxyXG5cdCAgICB0O1xyXG5cclxuXHRpZiAoZG90ID4gMCkge1xyXG5cdFx0dCA9ICgocC54IC0geCkgKiBkeCArIChwLnkgLSB5KSAqIGR5KSAvIGRvdDtcclxuXHJcblx0XHRpZiAodCA+IDEpIHtcclxuXHRcdFx0eCA9IHAyLng7XHJcblx0XHRcdHkgPSBwMi55O1xyXG5cdFx0fSBlbHNlIGlmICh0ID4gMCkge1xyXG5cdFx0XHR4ICs9IGR4ICogdDtcclxuXHRcdFx0eSArPSBkeSAqIHQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRkeCA9IHAueCAtIHg7XHJcblx0ZHkgPSBwLnkgLSB5O1xyXG5cclxuXHRyZXR1cm4gc3FEaXN0ID8gZHggKiBkeCArIGR5ICogZHkgOiBuZXcgUG9pbnQoeCwgeSk7XHJcbn1cclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3M6IExhdExuZ1tdKTogQm9vbGVhblxyXG4vLyBSZXR1cm5zIHRydWUgaWYgYGxhdGxuZ3NgIGlzIGEgZmxhdCBhcnJheSwgZmFsc2UgaXMgbmVzdGVkLlxyXG5leHBvcnQgZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3MpIHtcclxuXHRyZXR1cm4gIVV0aWwuaXNBcnJheShsYXRsbmdzWzBdKSB8fCAodHlwZW9mIGxhdGxuZ3NbMF1bMF0gIT09ICdvYmplY3QnICYmIHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAndW5kZWZpbmVkJyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfZmxhdChsYXRsbmdzKSB7XHJcblx0Y29uc29sZS53YXJuKCdEZXByZWNhdGVkIHVzZSBvZiBfZmxhdCwgcGxlYXNlIHVzZSBMLkxpbmVVdGlsLmlzRmxhdCBpbnN0ZWFkLicpO1xyXG5cdHJldHVybiBpc0ZsYXQobGF0bG5ncyk7XHJcbn1cclxuXHJcbi8qIEBmdW5jdGlvbiBwb2x5bGluZUNlbnRlcihsYXRsbmdzOiBMYXRMbmdbXSwgY3JzOiBDUlMpOiBMYXRMbmdcclxuICogUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgcGFzc2VkIExhdExuZ3MgKGZpcnN0IHJpbmcpIGZyb20gYSBwb2x5bGluZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwb2x5bGluZUNlbnRlcihsYXRsbmdzLCBjcnMpIHtcclxuXHR2YXIgaSwgaGFsZkRpc3QsIHNlZ0Rpc3QsIGRpc3QsIHAxLCBwMiwgcmF0aW8sIGNlbnRlcjtcclxuXHJcblx0aWYgKCFsYXRsbmdzIHx8IGxhdGxuZ3MubGVuZ3RoID09PSAwKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2xhdGxuZ3Mgbm90IHBhc3NlZCcpO1xyXG5cdH1cclxuXHJcblx0aWYgKCFpc0ZsYXQobGF0bG5ncykpIHtcclxuXHRcdGNvbnNvbGUud2FybignbGF0bG5ncyBhcmUgbm90IGZsYXQhIE9ubHkgdGhlIGZpcnN0IHJpbmcgd2lsbCBiZSB1c2VkJyk7XHJcblx0XHRsYXRsbmdzID0gbGF0bG5nc1swXTtcclxuXHR9XHJcblxyXG5cdHZhciBjZW50cm9pZExhdExuZyA9IHRvTGF0TG5nKFswLCAwXSk7XHJcblxyXG5cdHZhciBib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhsYXRsbmdzKTtcclxuXHR2YXIgYXJlYUJvdW5kcyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKS5kaXN0YW5jZVRvKGJvdW5kcy5nZXRTb3V0aFdlc3QoKSkgKiBib3VuZHMuZ2V0Tm9ydGhFYXN0KCkuZGlzdGFuY2VUbyhib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpO1xyXG5cdC8vIHRlc3RzIHNob3dlZCB0aGF0IGJlbG93IDE3MDAgcm91bmRpbmcgZXJyb3JzIGFyZSBoYXBwZW5pbmdcclxuXHRpZiAoYXJlYUJvdW5kcyA8IDE3MDApIHtcclxuXHRcdC8vIGdldHRpbmcgYSBpbmV4YWN0IGNlbnRlciwgdG8gbW92ZSB0aGUgbGF0bG5ncyBuZWFyIHRvIFswLCAwXSB0byBwcmV2ZW50IHJvdW5kaW5nIGVycm9yc1xyXG5cdFx0Y2VudHJvaWRMYXRMbmcgPSBjZW50cm9pZChsYXRsbmdzKTtcclxuXHR9XHJcblxyXG5cdHZhciBsZW4gPSBsYXRsbmdzLmxlbmd0aDtcclxuXHR2YXIgcG9pbnRzID0gW107XHJcblx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHR2YXIgbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nc1tpXSk7XHJcblx0XHRwb2ludHMucHVzaChjcnMucHJvamVjdCh0b0xhdExuZyhbbGF0bG5nLmxhdCAtIGNlbnRyb2lkTGF0TG5nLmxhdCwgbGF0bG5nLmxuZyAtIGNlbnRyb2lkTGF0TG5nLmxuZ10pKSk7XHJcblx0fVxyXG5cclxuXHRmb3IgKGkgPSAwLCBoYWxmRGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcclxuXHRcdGhhbGZEaXN0ICs9IHBvaW50c1tpXS5kaXN0YW5jZVRvKHBvaW50c1tpICsgMV0pIC8gMjtcclxuXHR9XHJcblxyXG5cdC8vIFRoZSBsaW5lIGlzIHNvIHNtYWxsIGluIHRoZSBjdXJyZW50IHZpZXcgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiB0aGUgc2FtZSBwaXhlbC5cclxuXHRpZiAoaGFsZkRpc3QgPT09IDApIHtcclxuXHRcdGNlbnRlciA9IHBvaW50c1swXTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Zm9yIChpID0gMCwgZGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcclxuXHRcdFx0cDEgPSBwb2ludHNbaV07XHJcblx0XHRcdHAyID0gcG9pbnRzW2kgKyAxXTtcclxuXHRcdFx0c2VnRGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xyXG5cdFx0XHRkaXN0ICs9IHNlZ0Rpc3Q7XHJcblxyXG5cdFx0XHRpZiAoZGlzdCA+IGhhbGZEaXN0KSB7XHJcblx0XHRcdFx0cmF0aW8gPSAoZGlzdCAtIGhhbGZEaXN0KSAvIHNlZ0Rpc3Q7XHJcblx0XHRcdFx0Y2VudGVyID0gW1xyXG5cdFx0XHRcdFx0cDIueCAtIHJhdGlvICogKHAyLnggLSBwMS54KSxcclxuXHRcdFx0XHRcdHAyLnkgLSByYXRpbyAqIChwMi55IC0gcDEueSlcclxuXHRcdFx0XHRdO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR2YXIgbGF0bG5nQ2VudGVyID0gY3JzLnVucHJvamVjdCh0b1BvaW50KGNlbnRlcikpO1xyXG5cdHJldHVybiB0b0xhdExuZyhbbGF0bG5nQ2VudGVyLmxhdCArIGNlbnRyb2lkTGF0TG5nLmxhdCwgbGF0bG5nQ2VudGVyLmxuZyArIGNlbnRyb2lkTGF0TG5nLmxuZ10pO1xyXG59XHJcbiIsImltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBzZWN0aW9uXHJcbiAqIExlYWZsZXQgY29tZXMgd2l0aCBhIHNldCBvZiBhbHJlYWR5IGRlZmluZWQgUHJvamVjdGlvbnMgb3V0IG9mIHRoZSBib3g6XHJcbiAqXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5Mb25MYXRcclxuICpcclxuICogRXF1aXJlY3Rhbmd1bGFyLCBvciBQbGF0ZSBDYXJyZWUgcHJvamVjdGlvbiDigJQgdGhlIG1vc3Qgc2ltcGxlIHByb2plY3Rpb24sXHJcbiAqIG1vc3RseSB1c2VkIGJ5IEdJUyBlbnRodXNpYXN0cy4gRGlyZWN0bHkgbWFwcyBgeGAgYXMgbG9uZ2l0dWRlLCBhbmQgYHlgIGFzXHJcbiAqIGxhdGl0dWRlLiBBbHNvIHN1aXRhYmxlIGZvciBmbGF0IHdvcmxkcywgZS5nLiBnYW1lIG1hcHMuIFVzZWQgYnkgdGhlXHJcbiAqIGBFUFNHOjQzMjZgIGFuZCBgU2ltcGxlYCBDUlMuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBMb25MYXQgPSB7XHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nLCBsYXRsbmcubGF0KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcocG9pbnQueSwgcG9pbnQueCk7XHJcblx0fSxcclxuXHJcblx0Ym91bmRzOiBuZXcgQm91bmRzKFstMTgwLCAtOTBdLCBbMTgwLCA5MF0pXHJcbn07XHJcbiIsImltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5NZXJjYXRvclxyXG4gKlxyXG4gKiBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24g4oCUIG1vcmUgY29tcGxleCB0aGFuIFNwaGVyaWNhbCBNZXJjYXRvci4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzIGFuIGVsbGlwc29pZC4gVXNlZCBieSB0aGUgRVBTRzozMzk1IENSUy5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIE1lcmNhdG9yID0ge1xyXG5cdFI6IDYzNzgxMzcsXHJcblx0Ul9NSU5PUjogNjM1Njc1Mi4zMTQyNDUxNzksXHJcblxyXG5cdGJvdW5kczogbmV3IEJvdW5kcyhbLTIwMDM3NTA4LjM0Mjc5LCAtMTU0OTY1NzAuNzM5NzJdLCBbMjAwMzc1MDguMzQyNzksIDE4NzY0NjU2LjIzMTM4XSksXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcclxuXHRcdCAgICByID0gdGhpcy5SLFxyXG5cdFx0ICAgIHkgPSBsYXRsbmcubGF0ICogZCxcclxuXHRcdCAgICB0bXAgPSB0aGlzLlJfTUlOT1IgLyByLFxyXG5cdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXHJcblx0XHQgICAgY29uID0gZSAqIE1hdGguc2luKHkpO1xyXG5cclxuXHRcdHZhciB0cyA9IE1hdGgudGFuKE1hdGguUEkgLyA0IC0geSAvIDIpIC8gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcblx0XHR5ID0gLXIgKiBNYXRoLmxvZyhNYXRoLm1heCh0cywgMUUtMTApKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGxhdGxuZy5sbmcgKiBkICogciwgeSk7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSSxcclxuXHRcdCAgICByID0gdGhpcy5SLFxyXG5cdFx0ICAgIHRtcCA9IHRoaXMuUl9NSU5PUiAvIHIsXHJcblx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcclxuXHRcdCAgICB0cyA9IE1hdGguZXhwKC1wb2ludC55IC8gciksXHJcblx0XHQgICAgcGhpID0gTWF0aC5QSSAvIDIgLSAyICogTWF0aC5hdGFuKHRzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgZHBoaSA9IDAuMSwgY29uOyBpIDwgMTUgJiYgTWF0aC5hYnMoZHBoaSkgPiAxZS03OyBpKyspIHtcclxuXHRcdFx0Y29uID0gZSAqIE1hdGguc2luKHBoaSk7XHJcblx0XHRcdGNvbiA9IE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZSAvIDIpO1xyXG5cdFx0XHRkcGhpID0gTWF0aC5QSSAvIDIgLSAyICogTWF0aC5hdGFuKHRzICogY29uKSAtIHBoaTtcclxuXHRcdFx0cGhpICs9IGRwaGk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcocGhpICogZCwgcG9pbnQueCAqIGQgLyByKTtcclxuXHR9XHJcbn07XHJcbiIsIi8qXG4gKiBAY2xhc3MgUHJvamVjdGlvblxuXG4gKiBBbiBvYmplY3Qgd2l0aCBtZXRob2RzIGZvciBwcm9qZWN0aW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBvZiB0aGUgd29ybGQgb250b1xuICogYSBmbGF0IHN1cmZhY2UgKGFuZCBiYWNrKS4gU2VlIFtNYXAgcHJvamVjdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFwX3Byb2plY3Rpb24pLlxuXG4gKiBAcHJvcGVydHkgYm91bmRzOiBCb3VuZHNcbiAqIFRoZSBib3VuZHMgKHNwZWNpZmllZCBpbiBDUlMgdW5pdHMpIHdoZXJlIHRoZSBwcm9qZWN0aW9uIGlzIHZhbGlkXG5cbiAqIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZyk6IFBvaW50XG4gKiBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBhIDJEIHBvaW50LlxuICogT25seSBhY2NlcHRzIGFjdHVhbCBgTC5MYXRMbmdgIGluc3RhbmNlcywgbm90IGFycmF5cy5cblxuICogQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50KTogTGF0TG5nXG4gKiBUaGUgaW52ZXJzZSBvZiBgcHJvamVjdGAuIFByb2plY3RzIGEgMkQgcG9pbnQgaW50byBhIGdlb2dyYXBoaWNhbCBsb2NhdGlvbi5cbiAqIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cblxuICogTm90ZSB0aGF0IHRoZSBwcm9qZWN0aW9uIGluc3RhbmNlcyBkbyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcbiAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxuICogYW5kIG1ldGhvZHMgY2FuJ3QgYmUgYWRkZWQgdG8gdGhlbSB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXG5cbiAqL1xuXG5leHBvcnQge0xvbkxhdH0gZnJvbSAnLi9Qcm9qZWN0aW9uLkxvbkxhdCc7XG5leHBvcnQge01lcmNhdG9yfSBmcm9tICcuL1Byb2plY3Rpb24uTWVyY2F0b3InO1xuZXhwb3J0IHtTcGhlcmljYWxNZXJjYXRvcn0gZnJvbSAnLi9Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yJztcbiIsImltcG9ydCB7RWFydGh9IGZyb20gJy4vQ1JTLkVhcnRoJztcclxuaW1wb3J0IHtNZXJjYXRvcn0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLk1lcmNhdG9yJztcclxuaW1wb3J0IHt0b1RyYW5zZm9ybWF0aW9ufSBmcm9tICcuLi8uLi9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzMzOTVcclxuICpcclxuICogUmFyZWx5IHVzZWQgYnkgc29tZSBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBVc2VzIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi5cclxuICovXHJcbmV4cG9ydCB2YXIgRVBTRzMzOTUgPSBVdGlsLmV4dGVuZCh7fSwgRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzozMzk1JyxcclxuXHRwcm9qZWN0aW9uOiBNZXJjYXRvcixcclxuXHJcblx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIE1lcmNhdG9yLlIpO1xyXG5cdFx0cmV0dXJuIHRvVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG5cdH0oKSlcclxufSk7XHJcbiIsImltcG9ydCB7RWFydGh9IGZyb20gJy4vQ1JTLkVhcnRoJztcclxuaW1wb3J0IHtMb25MYXR9IGZyb20gJy4uL3Byb2plY3Rpb24vUHJvamVjdGlvbi5Mb25MYXQnO1xyXG5pbXBvcnQge3RvVHJhbnNmb3JtYXRpb259IGZyb20gJy4uLy4uL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5FUFNHNDMyNlxyXG4gKlxyXG4gKiBBIGNvbW1vbiBDUlMgYW1vbmcgR0lTIGVudGh1c2lhc3RzLiBVc2VzIHNpbXBsZSBFcXVpcmVjdGFuZ3VsYXIgcHJvamVjdGlvbi5cclxuICpcclxuICogTGVhZmxldCAxLjAueCBjb21wbGllcyB3aXRoIHRoZSBbVE1TIGNvb3JkaW5hdGUgc2NoZW1lIGZvciBFUFNHOjQzMjZdKGh0dHBzOi8vd2lraS5vc2dlby5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlX1NwZWNpZmljYXRpb24jZ2xvYmFsLWdlb2RldGljKSxcclxuICogd2hpY2ggaXMgYSBicmVha2luZyBjaGFuZ2UgZnJvbSAwLjcueCBiZWhhdmlvdXIuICBJZiB5b3UgYXJlIHVzaW5nIGEgYFRpbGVMYXllcmBcclxuICogd2l0aCB0aGlzIENSUywgZW5zdXJlIHRoYXQgdGhlcmUgYXJlIHR3byAyNTZ4MjU2IHBpeGVsIHRpbGVzIGNvdmVyaW5nIHRoZVxyXG4gKiB3aG9sZSBlYXJ0aCBhdCB6b29tIGxldmVsIHplcm8sIGFuZCB0aGF0IHRoZSB0aWxlIGNvb3JkaW5hdGUgb3JpZ2luIGlzICgtMTgwLCs5MCksXHJcbiAqIG9yICgtMTgwLC05MCkgZm9yIGBUaWxlTGF5ZXJgcyB3aXRoIFt0aGUgYHRtc2Agb3B0aW9uXSgjdGlsZWxheWVyLXRtcykgc2V0LlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRVBTRzQzMjYgPSBVdGlsLmV4dGVuZCh7fSwgRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzo0MzI2JyxcclxuXHRwcm9qZWN0aW9uOiBMb25MYXQsXHJcblx0dHJhbnNmb3JtYXRpb246IHRvVHJhbnNmb3JtYXRpb24oMSAvIDE4MCwgMSwgLTEgLyAxODAsIDAuNSlcclxufSk7XHJcbiIsImltcG9ydCB7Q1JTfSBmcm9tICcuL0NSUyc7XG5pbXBvcnQge0xvbkxhdH0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLkxvbkxhdCc7XG5pbXBvcnQge3RvVHJhbnNmb3JtYXRpb259IGZyb20gJy4uLy4uL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBuYW1lc3BhY2UgQ1JTXG4gKiBAY3JzIEwuQ1JTLlNpbXBsZVxuICpcbiAqIEEgc2ltcGxlIENSUyB0aGF0IG1hcHMgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSBpbnRvIGB4YCBhbmQgYHlgIGRpcmVjdGx5LlxuICogTWF5IGJlIHVzZWQgZm9yIG1hcHMgb2YgZmxhdCBzdXJmYWNlcyAoZS5nLiBnYW1lIG1hcHMpLiBOb3RlIHRoYXQgdGhlIGB5YFxuICogYXhpcyBzaG91bGQgc3RpbGwgYmUgaW52ZXJ0ZWQgKGdvaW5nIGZyb20gYm90dG9tIHRvIHRvcCkuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gKiBzaW1wbGUgZXVjbGlkZWFuIGRpc3RhbmNlLlxuICovXG5cbmV4cG9ydCB2YXIgU2ltcGxlID0gVXRpbC5leHRlbmQoe30sIENSUywge1xuXHRwcm9qZWN0aW9uOiBMb25MYXQsXG5cdHRyYW5zZm9ybWF0aW9uOiB0b1RyYW5zZm9ybWF0aW9uKDEsIDAsIC0xLCAwKSxcblxuXHRzY2FsZTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHRyZXR1cm4gTWF0aC5wb3coMiwgem9vbSk7XG5cdH0sXG5cblx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XG5cdFx0cmV0dXJuIE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yO1xuXHR9LFxuXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuXHRcdHZhciBkeCA9IGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcsXG5cdFx0ICAgIGR5ID0gbGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdDtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXHR9LFxuXG5cdGluZmluaXRlOiB0cnVlXG59KTtcbiIsImltcG9ydCB7Q1JTfSBmcm9tICcuL0NSUyc7XG5pbXBvcnQge0VhcnRofSBmcm9tICcuL0NSUy5FYXJ0aCc7XG5pbXBvcnQge0VQU0czMzk1fSBmcm9tICcuL0NSUy5FUFNHMzM5NSc7XG5pbXBvcnQge0VQU0czODU3LCBFUFNHOTAwOTEzfSBmcm9tICcuL0NSUy5FUFNHMzg1Nyc7XG5pbXBvcnQge0VQU0c0MzI2fSBmcm9tICcuL0NSUy5FUFNHNDMyNic7XG5pbXBvcnQge1NpbXBsZX0gZnJvbSAnLi9DUlMuU2ltcGxlJztcblxuQ1JTLkVhcnRoID0gRWFydGg7XG5DUlMuRVBTRzMzOTUgPSBFUFNHMzM5NTtcbkNSUy5FUFNHMzg1NyA9IEVQU0czODU3O1xuQ1JTLkVQU0c5MDA5MTMgPSBFUFNHOTAwOTEzO1xuQ1JTLkVQU0c0MzI2ID0gRVBTRzQzMjY7XG5DUlMuU2ltcGxlID0gU2ltcGxlO1xuXG5leHBvcnQge0NSU307XG4iLCJpbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4uL2NvcmUvRXZlbnRzJztcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBjbGFzcyBMYXllclxuICogQGluaGVyaXRzIEV2ZW50ZWRcbiAqIEBha2EgTC5MYXllclxuICogQGFrYSBJTGF5ZXJcbiAqXG4gKiBBIHNldCBvZiBtZXRob2RzIGZyb20gdGhlIExheWVyIGJhc2UgY2xhc3MgdGhhdCBhbGwgTGVhZmxldCBsYXllcnMgdXNlLlxuICogSW5oZXJpdHMgYWxsIG1ldGhvZHMsIG9wdGlvbnMgYW5kIGV2ZW50cyBmcm9tIGBMLkV2ZW50ZWRgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIHZhciBsYXllciA9IEwubWFya2VyKGxhdGxuZykuYWRkVG8obWFwKTtcbiAqIGxheWVyLmFkZFRvKG1hcCk7XG4gKiBsYXllci5yZW1vdmUoKTtcbiAqIGBgYFxuICpcbiAqIEBldmVudCBhZGQ6IEV2ZW50XG4gKiBGaXJlZCBhZnRlciB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gYSBtYXBcbiAqXG4gKiBAZXZlbnQgcmVtb3ZlOiBFdmVudFxuICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSBhIG1hcFxuICovXG5cblxuZXhwb3J0IHZhciBMYXllciA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuXHQvLyBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgb3B0aW9uczpcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ292ZXJsYXlQYW5lJ1xuXHRcdC8vIEJ5IGRlZmF1bHQgdGhlIGxheWVyIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCdzIFtvdmVybGF5IHBhbmVdKCNtYXAtb3ZlcmxheXBhbmUpLiBPdmVycmlkaW5nIHRoaXMgb3B0aW9uIHdpbGwgY2F1c2UgdGhlIGxheWVyIHRvIGJlIHBsYWNlZCBvbiBhbm90aGVyIHBhbmUgYnkgZGVmYXVsdC5cblx0XHRwYW5lOiAnb3ZlcmxheVBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBhdHRyaWJ1dGlvbjogU3RyaW5nID0gbnVsbFxuXHRcdC8vIFN0cmluZyB0byBiZSBzaG93biBpbiB0aGUgYXR0cmlidXRpb24gY29udHJvbCwgZS5nLiBcIsKpIE9wZW5TdHJlZXRNYXAgY29udHJpYnV0b3JzXCIuIEl0IGRlc2NyaWJlcyB0aGUgbGF5ZXIgZGF0YSBhbmQgaXMgb2Z0ZW4gYSBsZWdhbCBvYmxpZ2F0aW9uIHRvd2FyZHMgY29weXJpZ2h0IGhvbGRlcnMgYW5kIHRpbGUgcHJvdmlkZXJzLlxuXHRcdGF0dHJpYnV0aW9uOiBudWxsLFxuXG5cdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuXHR9LFxuXG5cdC8qIEBzZWN0aW9uXG5cdCAqIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuXHQgKlxuXHQgKiBAbWV0aG9kIGFkZFRvKG1hcDogTWFwfExheWVyR3JvdXApOiB0aGlzXG5cdCAqIEFkZHMgdGhlIGxheWVyIHRvIHRoZSBnaXZlbiBtYXAgb3IgbGF5ZXIgZ3JvdXAuXG5cdCAqL1xuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlRnJvbSh0aGlzLl9tYXAgfHwgdGhpcy5fbWFwVG9BZGQpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlRnJvbShtYXA6IE1hcCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgZ2l2ZW4gbWFwXG5cdC8vXG5cdC8vIEBhbHRlcm5hdGl2ZVxuXHQvLyBAbWV0aG9kIHJlbW92ZUZyb20oZ3JvdXA6IExheWVyR3JvdXApOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIGdpdmVuIGBMYXllckdyb3VwYFxuXHRyZW1vdmVGcm9tOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0aWYgKG9iaikge1xuXHRcdFx0b2JqLnJlbW92ZUxheWVyKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFBhbmUobmFtZT8gOiBTdHJpbmcpOiBIVE1MRWxlbWVudFxuXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIHJlcHJlc2VudGluZyB0aGUgbmFtZWQgcGFuZSBvbiB0aGUgbWFwLiBJZiBgbmFtZWAgaXMgb21pdHRlZCwgcmV0dXJucyB0aGUgcGFuZSBmb3IgdGhpcyBsYXllci5cblx0Z2V0UGFuZTogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFwLmdldFBhbmUobmFtZSA/ICh0aGlzLm9wdGlvbnNbbmFtZV0gfHwgbmFtZSkgOiB0aGlzLm9wdGlvbnMucGFuZSk7XG5cdH0sXG5cblx0YWRkSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuXHRcdHRoaXMuX21hcC5fdGFyZ2V0c1tVdGlsLnN0YW1wKHRhcmdldEVsKV0gPSB0aGlzO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUludGVyYWN0aXZlVGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0RWwpIHtcblx0XHRkZWxldGUgdGhpcy5fbWFwLl90YXJnZXRzW1V0aWwuc3RhbXAodGFyZ2V0RWwpXTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEF0dHJpYnV0aW9uOiBTdHJpbmdcblx0Ly8gVXNlZCBieSB0aGUgYGF0dHJpYnV0aW9uIGNvbnRyb2xgLCByZXR1cm5zIHRoZSBbYXR0cmlidXRpb24gb3B0aW9uXSgjZ3JpZGxheWVyLWF0dHJpYnV0aW9uKS5cblx0Z2V0QXR0cmlidXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uO1xuXHR9LFxuXG5cdF9sYXllckFkZDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gZS50YXJnZXQ7XG5cblx0XHQvLyBjaGVjayBpbiBjYXNlIGxheWVyIGdldHMgYWRkZWQgYW5kIHRoZW4gcmVtb3ZlZCBiZWZvcmUgdGhlIG1hcCBpcyByZWFkeVxuXHRcdGlmICghbWFwLmhhc0xheWVyKHRoaXMpKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xuXG5cdFx0aWYgKHRoaXMuZ2V0RXZlbnRzKSB7XG5cdFx0XHR2YXIgZXZlbnRzID0gdGhpcy5nZXRFdmVudHMoKTtcblx0XHRcdG1hcC5vbihldmVudHMsIHRoaXMpO1xuXHRcdFx0dGhpcy5vbmNlKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdG1hcC5vZmYoZXZlbnRzLCB0aGlzKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMub25BZGQobWFwKTtcblxuXHRcdHRoaXMuZmlyZSgnYWRkJyk7XG5cdFx0bWFwLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiB0aGlzfSk7XG5cdH1cbn0pO1xuXG4vKiBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuICogQHVuaW5oZXJpdGFibGVcbiAqXG4gKiBFdmVyeSBsYXllciBzaG91bGQgZXh0ZW5kIGZyb20gYEwuTGF5ZXJgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXG4gKlxuICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IHRoaXNcbiAqIFNob3VsZCBjb250YWluIGNvZGUgdGhhdCBjcmVhdGVzIERPTSBlbGVtZW50cyBmb3IgdGhlIGxheWVyLCBhZGRzIHRoZW0gdG8gYG1hcCBwYW5lc2Agd2hlcmUgdGhleSBzaG91bGQgYmVsb25nIGFuZCBwdXRzIGxpc3RlbmVycyBvbiByZWxldmFudCBtYXAgZXZlbnRzLiBDYWxsZWQgb24gW2BtYXAuYWRkTGF5ZXIobGF5ZXIpYF0oI21hcC1hZGRsYXllcikuXG4gKlxuICogQG1ldGhvZCBvblJlbW92ZShtYXA6IE1hcCk6IHRoaXNcbiAqIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGF5ZXIncyBlbGVtZW50cyBmcm9tIHRoZSBET00gYW5kIHJlbW92ZXMgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNsYXllci1vbmFkZCkuIENhbGxlZCBvbiBbYG1hcC5yZW1vdmVMYXllcihsYXllcilgXSgjbWFwLXJlbW92ZWxheWVyKS5cbiAqXG4gKiBAbWV0aG9kIGdldEV2ZW50cygpOiBPYmplY3RcbiAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0IGxpa2UgYHsgdmlld3Jlc2V0OiB0aGlzLl9yZXNldCB9YCBmb3IgW2BhZGRFdmVudExpc3RlbmVyYF0oI2V2ZW50ZWQtYWRkZXZlbnRsaXN0ZW5lcikuIFRoZSBldmVudCBoYW5kbGVycyBpbiB0aGlzIG9iamVjdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgbWFwIHdpdGggeW91ciBsYXllci5cbiAqXG4gKiBAbWV0aG9kIGdldEF0dHJpYnV0aW9uKCk6IFN0cmluZ1xuICogVGhpcyBvcHRpb25hbCBtZXRob2Qgc2hvdWxkIHJldHVybiBhIHN0cmluZyBjb250YWluaW5nIEhUTUwgdG8gYmUgc2hvd24gb24gdGhlIGBBdHRyaWJ1dGlvbiBjb250cm9sYCB3aGVuZXZlciB0aGUgbGF5ZXIgaXMgdmlzaWJsZS5cbiAqXG4gKiBAbWV0aG9kIGJlZm9yZUFkZChtYXA6IE1hcCk6IHRoaXNcbiAqIE9wdGlvbmFsIG1ldGhvZC4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLCBiZWZvcmUgdGhlIGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAsIGJlZm9yZSBldmVudHMgYXJlIGluaXRpYWxpemVkLCB3aXRob3V0IHdhaXRpbmcgdW50aWwgdGhlIG1hcCBpcyBpbiBhIHVzYWJsZSBzdGF0ZS4gVXNlIGZvciBlYXJseSBpbml0aWFsaXphdGlvbiBvbmx5LlxuICovXG5cblxuLyogQG5hbWVzcGFjZSBNYXBcbiAqIEBzZWN0aW9uIExheWVyIGV2ZW50c1xuICpcbiAqIEBldmVudCBsYXllcmFkZDogTGF5ZXJFdmVudFxuICogRmlyZWQgd2hlbiBhIG5ldyBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLlxuICpcbiAqIEBldmVudCBsYXllcnJlbW92ZTogTGF5ZXJFdmVudFxuICogRmlyZWQgd2hlbiBzb21lIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwXG4gKlxuICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xuICovXG5NYXAuaW5jbHVkZSh7XG5cdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHQvLyBBZGRzIHRoZSBnaXZlbiBsYXllciB0byB0aGUgbWFwXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoIWxheWVyLl9sYXllckFkZCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgb2JqZWN0IGlzIG5vdCBhIExheWVyLicpO1xuXHRcdH1cblxuXHRcdHZhciBpZCA9IFV0aWwuc3RhbXAobGF5ZXIpO1xuXHRcdGlmICh0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xuXG5cdFx0bGF5ZXIuX21hcFRvQWRkID0gdGhpcztcblxuXHRcdGlmIChsYXllci5iZWZvcmVBZGQpIHtcblx0XHRcdGxheWVyLmJlZm9yZUFkZCh0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLndoZW5SZWFkeShsYXllci5fbGF5ZXJBZGQsIGxheWVyKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBtYXAuXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBVdGlsLnN0YW1wKGxheWVyKTtcblxuXHRcdGlmICghdGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuXHRcdFx0bGF5ZXIub25SZW1vdmUodGhpcyk7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XG5cblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG5cdFx0XHR0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xuXHRcdFx0bGF5ZXIuZmlyZSgncmVtb3ZlJyk7XG5cdFx0fVxuXG5cdFx0bGF5ZXIuX21hcCA9IGxheWVyLl9tYXBUb0FkZCA9IG51bGw7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGhhc0xheWVyKGxheWVyOiBMYXllcik6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgbWFwXG5cdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRyZXR1cm4gVXRpbC5zdGFtcChsYXllcikgaW4gdGhpcy5fbGF5ZXJzO1xuXHR9LFxuXG5cdC8qIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcblx0ICogSXRlcmF0ZXMgb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSBtYXAsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBjb250ZXh0IG9mIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cblx0ICogYGBgXG5cdCAqIG1hcC5lYWNoTGF5ZXIoZnVuY3Rpb24obGF5ZXIpe1xuXHQgKiAgICAgbGF5ZXIuYmluZFBvcHVwKCdIZWxsbycpO1xuXHQgKiB9KTtcblx0ICogYGBgXG5cdCAqL1xuXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2FkZExheWVyczogZnVuY3Rpb24gKGxheWVycykge1xuXHRcdGxheWVycyA9IGxheWVycyA/IChVdGlsLmlzQXJyYXkobGF5ZXJzKSA/IGxheWVycyA6IFtsYXllcnNdKSA6IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoIWlzTmFOKGxheWVyLm9wdGlvbnMubWF4Wm9vbSkgfHwgIWlzTmFOKGxheWVyLm9wdGlvbnMubWluWm9vbSkpIHtcblx0XHRcdHRoaXMuX3pvb21Cb3VuZExheWVyc1tVdGlsLnN0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVpvb21MaW1pdDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGlkID0gVXRpbC5zdGFtcChsYXllcik7XG5cblx0XHRpZiAodGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXSkge1xuXHRcdFx0ZGVsZXRlIHRoaXMuX3pvb21Cb3VuZExheWVyc1tpZF07XG5cdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVab29tTGV2ZWxzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1pblpvb20gPSBJbmZpbml0eSxcblx0XHQgICAgbWF4Wm9vbSA9IC1JbmZpbml0eSxcblx0XHQgICAgb2xkWm9vbVNwYW4gPSB0aGlzLl9nZXRab29tU3BhbigpO1xuXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl96b29tQm91bmRMYXllcnMpIHtcblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2ldLm9wdGlvbnM7XG5cblx0XHRcdG1pblpvb20gPSBvcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IG1pblpvb20gOiBNYXRoLm1pbihtaW5ab29tLCBvcHRpb25zLm1pblpvb20pO1xuXHRcdFx0bWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gbWF4Wm9vbSA6IE1hdGgubWF4KG1heFpvb20sIG9wdGlvbnMubWF4Wm9vbSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbGF5ZXJzTWF4Wm9vbSA9IG1heFpvb20gPT09IC1JbmZpbml0eSA/IHVuZGVmaW5lZCA6IG1heFpvb207XG5cdFx0dGhpcy5fbGF5ZXJzTWluWm9vbSA9IG1pblpvb20gPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogbWluWm9vbTtcblxuXHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IHpvb21sZXZlbHNjaGFuZ2U6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbnVtYmVyIG9mIHpvb21sZXZlbHMgb24gdGhlIG1hcCBpcyBjaGFuZ2VkIGR1ZVxuXHRcdC8vIHRvIGFkZGluZyBvciByZW1vdmluZyBhIGxheWVyLlxuXHRcdGlmIChvbGRab29tU3BhbiAhPT0gdGhpcy5fZ2V0Wm9vbVNwYW4oKSkge1xuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgJiYgdGhpcy5fbGF5ZXJzTWF4Wm9vbSAmJiB0aGlzLmdldFpvb20oKSA+IHRoaXMuX2xheWVyc01heFpvb20pIHtcblx0XHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9sYXllcnNNYXhab29tKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgJiYgdGhpcy5fbGF5ZXJzTWluWm9vbSAmJiB0aGlzLmdldFpvb20oKSA8IHRoaXMuX2xheWVyc01pblpvb20pIHtcblx0XHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9sYXllcnNNaW5ab29tKTtcblx0XHR9XG5cdH1cbn0pO1xuIiwiXHJcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTGF5ZXJHcm91cFxyXG4gKiBAYWthIEwuTGF5ZXJHcm91cFxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICpcclxuICogVXNlZCB0byBncm91cCBzZXZlcmFsIGxheWVycyBhbmQgaGFuZGxlIHRoZW0gYXMgb25lLiBJZiB5b3UgYWRkIGl0IHRvIHRoZSBtYXAsXHJcbiAqIGFueSBsYXllcnMgYWRkZWQgb3IgcmVtb3ZlZCBmcm9tIHRoZSBncm91cCB3aWxsIGJlIGFkZGVkL3JlbW92ZWQgb24gdGhlIG1hcCBhc1xyXG4gKiB3ZWxsLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwubGF5ZXJHcm91cChbbWFya2VyMSwgbWFya2VyMl0pXHJcbiAqIFx0LmFkZExheWVyKHBvbHlsaW5lKVxyXG4gKiBcdC5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIExheWVyR3JvdXAgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG5cdFx0dmFyIGksIGxlbjtcclxuXHJcblx0XHRpZiAobGF5ZXJzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBncm91cC5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWQgPSB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgZ3JvdXAuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihpZDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGludGVybmFsIElEIGZyb20gdGhlIGdyb3VwLlxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IGxheWVyIGluIHRoaXMuX2xheWVycyA/IGxheWVyIDogdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwICYmIHRoaXMuX2xheWVyc1tpZF0pIHtcclxuXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpZF0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIoaWQ6IE51bWJlcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBncm91cC5cclxuXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgbGF5ZXJJZCA9IHR5cGVvZiBsYXllciA9PT0gJ251bWJlcicgPyBsYXllciA6IHRoaXMuZ2V0TGF5ZXJJZChsYXllcik7XHJcblx0XHRyZXR1cm4gbGF5ZXJJZCBpbiB0aGlzLl9sYXllcnM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbGVhckxheWVycygpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbGwgdGhlIGxheWVycyBmcm9tIHRoZSBncm91cC5cclxuXHRjbGVhckxheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKHRoaXMucmVtb3ZlTGF5ZXIsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW52b2tlKG1ldGhvZE5hbWU6IFN0cmluZywg4oCmKTogdGhpc1xyXG5cdC8vIENhbGxzIGBtZXRob2ROYW1lYCBvbiBldmVyeSBsYXllciBjb250YWluZWQgaW4gdGhpcyBncm91cCwgcGFzc2luZyBhbnlcclxuXHQvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMuIEhhcyBubyBlZmZlY3QgaWYgdGhlIGxheWVycyBjb250YWluZWQgZG8gbm90XHJcblx0Ly8gaW1wbGVtZW50IGBtZXRob2ROYW1lYC5cclxuXHRpbnZva2U6IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XHJcblx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXHJcblx0XHQgICAgaSwgbGF5ZXI7XHJcblxyXG5cdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHJcblx0XHRcdGlmIChsYXllclttZXRob2ROYW1lXSkge1xyXG5cdFx0XHRcdGxheWVyW21ldGhvZE5hbWVdLmFwcGx5KGxheWVyLCBhcmdzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLmVhY2hMYXllcihtYXAuYWRkTGF5ZXIsIG1hcCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuZWFjaExheWVyKG1hcC5yZW1vdmVMYXllciwgbWFwKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVhY2hMYXllcihmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gSXRlcmF0ZXMgb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSBncm91cCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIGNvbnRleHQgb2YgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLlxyXG5cdC8vIGBgYGpzXHJcblx0Ly8gZ3JvdXAuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdC8vIFx0bGF5ZXIuYmluZFBvcHVwKCdIZWxsbycpO1xyXG5cdC8vIH0pO1xyXG5cdC8vIGBgYFxyXG5cdGVhY2hMYXllcjogZnVuY3Rpb24gKG1ldGhvZCwgY29udGV4dCkge1xyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXIoaWQ6IE51bWJlcik6IExheWVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQuXHJcblx0Z2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xheWVyc1tpZF07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcnMoKTogTGF5ZXJbXVxyXG5cdC8vIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHRoZSBsYXllcnMgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdGdldExheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGxheWVycyA9IFtdO1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIobGF5ZXJzLnB1c2gsIGxheWVycyk7XHJcblx0XHRyZXR1cm4gbGF5ZXJzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4KHpJbmRleDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENhbGxzIGBzZXRaSW5kZXhgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIHRoZSB6LWluZGV4LlxyXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRaSW5kZXgnLCB6SW5kZXgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXJJZChsYXllcjogTGF5ZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBpbnRlcm5hbCBJRCBmb3IgYSBsYXllclxyXG5cdGdldExheWVySWQ6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0cmV0dXJuIFV0aWwuc3RhbXAobGF5ZXIpO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5sYXllckdyb3VwKGxheWVycz86IExheWVyW10sIG9wdGlvbnM/OiBPYmplY3QpXHJcbi8vIENyZWF0ZSBhIGxheWVyIGdyb3VwLCBvcHRpb25hbGx5IGdpdmVuIGFuIGluaXRpYWwgc2V0IG9mIGxheWVycyBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuZXhwb3J0IHZhciBsYXllckdyb3VwID0gZnVuY3Rpb24gKGxheWVycywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTGF5ZXJHcm91cChsYXllcnMsIG9wdGlvbnMpO1xyXG59O1xyXG4iLCJpbXBvcnQge0xheWVyR3JvdXB9IGZyb20gJy4vTGF5ZXJHcm91cCc7XHJcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi9nZW8vTGF0TG5nQm91bmRzJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBGZWF0dXJlR3JvdXBcclxuICogQGFrYSBMLkZlYXR1cmVHcm91cFxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJHcm91cFxyXG4gKlxyXG4gKiBFeHRlbmRlZCBgTGF5ZXJHcm91cGAgdGhhdCBtYWtlcyBpdCBlYXNpZXIgdG8gZG8gdGhlIHNhbWUgdGhpbmcgdG8gYWxsIGl0cyBtZW1iZXIgbGF5ZXJzOlxyXG4gKiAgKiBbYGJpbmRQb3B1cGBdKCNsYXllci1iaW5kcG9wdXApIGJpbmRzIGEgcG9wdXAgdG8gYWxsIG9mIHRoZSBsYXllcnMgYXQgb25jZSAobGlrZXdpc2Ugd2l0aCBbYGJpbmRUb29sdGlwYF0oI2xheWVyLWJpbmR0b29sdGlwKSlcclxuICogICogRXZlbnRzIGFyZSBwcm9wYWdhdGVkIHRvIHRoZSBgRmVhdHVyZUdyb3VwYCwgc28gaWYgdGhlIGdyb3VwIGhhcyBhbiBldmVudFxyXG4gKiBoYW5kbGVyLCBpdCB3aWxsIGhhbmRsZSBldmVudHMgZnJvbSBhbnkgb2YgdGhlIGxheWVycy4gVGhpcyBpbmNsdWRlcyBtb3VzZSBldmVudHNcclxuICogYW5kIGN1c3RvbSBldmVudHMuXHJcbiAqICAqIEhhcyBgbGF5ZXJhZGRgIGFuZCBgbGF5ZXJyZW1vdmVgIGV2ZW50c1xyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmZlYXR1cmVHcm91cChbbWFya2VyMSwgbWFya2VyMiwgcG9seWxpbmVdKVxyXG4gKiBcdC5iaW5kUG9wdXAoJ0hlbGxvIHdvcmxkIScpXHJcbiAqIFx0Lm9uKCdjbGljaycsIGZ1bmN0aW9uKCkgeyBhbGVydCgnQ2xpY2tlZCBvbiBhIG1lbWJlciBvZiB0aGUgZ3JvdXAhJyk7IH0pXHJcbiAqIFx0LmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRmVhdHVyZUdyb3VwID0gTGF5ZXJHcm91cC5leHRlbmQoe1xyXG5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAodGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIuYWRkRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG5cdFx0TGF5ZXJHcm91cC5wcm90b3R5cGUuYWRkTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgbGF5ZXIgaXMgYWRkZWQgdG8gdGhpcyBgRmVhdHVyZUdyb3VwYFxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IGxheWVyfSk7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKCF0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdGlmIChsYXllciBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbbGF5ZXJdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxheWVyLnJlbW92ZUV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuXHRcdExheWVyR3JvdXAucHJvdG90eXBlLnJlbW92ZUxheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsYXllcnJlbW92ZTogTGF5ZXJFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGlzIGBGZWF0dXJlR3JvdXBgXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgZ2l2ZW4gcGF0aCBvcHRpb25zIHRvIGVhY2ggbGF5ZXIgb2YgdGhlIGdyb3VwIHRoYXQgaGFzIGEgYHNldFN0eWxlYCBtZXRob2QuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRTdHlsZScsIHN0eWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgdG9wIG9mIGFsbCBvdGhlciBsYXllcnNcclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0Zyb250Jyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgYmFjayBvZiBhbGwgb3RoZXIgbGF5ZXJzXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0JhY2snKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBMYXRMbmdCb3VuZHMgb2YgdGhlIEZlYXR1cmUgR3JvdXAgKGNyZWF0ZWQgZnJvbSBib3VuZHMgYW5kIGNvb3JkaW5hdGVzIG9mIGl0cyBjaGlsZHJlbikuXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcygpO1xyXG5cclxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cdFx0XHRib3VuZHMuZXh0ZW5kKGxheWVyLmdldEJvdW5kcyA/IGxheWVyLmdldEJvdW5kcygpIDogbGF5ZXIuZ2V0TGF0TG5nKCkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGJvdW5kcztcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQGZhY3RvcnkgTC5mZWF0dXJlR3JvdXAobGF5ZXJzPzogTGF5ZXJbXSwgb3B0aW9ucz86IE9iamVjdClcclxuLy8gQ3JlYXRlIGEgZmVhdHVyZSBncm91cCwgb3B0aW9uYWxseSBnaXZlbiBhbiBpbml0aWFsIHNldCBvZiBsYXllcnMgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbmV4cG9ydCB2YXIgZmVhdHVyZUdyb3VwID0gZnVuY3Rpb24gKGxheWVycywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycywgb3B0aW9ucyk7XHJcbn07XHJcbiIsImltcG9ydCB7Q2xhc3N9IGZyb20gJy4uLy4uL2NvcmUvQ2xhc3MnO1xyXG5pbXBvcnQge3NldE9wdGlvbnN9IGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9Qb2ludCBhcyBwb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xyXG5cclxuLypcclxuICogQGNsYXNzIEljb25cclxuICogQGFrYSBMLkljb25cclxuICpcclxuICogUmVwcmVzZW50cyBhbiBpY29uIHRvIHByb3ZpZGUgd2hlbiBjcmVhdGluZyBhIG1hcmtlci5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIG15SWNvbiA9IEwuaWNvbih7XHJcbiAqICAgICBpY29uVXJsOiAnbXktaWNvbi5wbmcnLFxyXG4gKiAgICAgaWNvblJldGluYVVybDogJ215LWljb25AMngucG5nJyxcclxuICogICAgIGljb25TaXplOiBbMzgsIDk1XSxcclxuICogICAgIGljb25BbmNob3I6IFsyMiwgOTRdLFxyXG4gKiAgICAgcG9wdXBBbmNob3I6IFstMywgLTc2XSxcclxuICogICAgIHNoYWRvd1VybDogJ215LWljb24tc2hhZG93LnBuZycsXHJcbiAqICAgICBzaGFkb3dSZXRpbmFVcmw6ICdteS1pY29uLXNoYWRvd0AyeC5wbmcnLFxyXG4gKiAgICAgc2hhZG93U2l6ZTogWzY4LCA5NV0sXHJcbiAqICAgICBzaGFkb3dBbmNob3I6IFsyMiwgOTRdXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICpcclxuICogYEwuSWNvbi5EZWZhdWx0YCBleHRlbmRzIGBMLkljb25gIGFuZCBpcyB0aGUgYmx1ZSBpY29uIExlYWZsZXQgdXNlcyBmb3IgbWFya2VycyBieSBkZWZhdWx0LlxyXG4gKlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgSWNvbiA9IENsYXNzLmV4dGVuZCh7XHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQGFrYSBJY29uIG9wdGlvbnNcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqICoqKHJlcXVpcmVkKSoqIFRoZSBVUkwgdG8gdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXIgc2NyaXB0IHBhdGgpLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uUmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogVGhlIFVSTCB0byBhIHJldGluYSBzaXplZCB2ZXJzaW9uIG9mIHRoZSBpY29uIGltYWdlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB5b3VyXHJcblx0ICogc2NyaXB0IHBhdGgpLiBVc2VkIGZvciBSZXRpbmEgc2NyZWVuIGRldmljZXMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25TaXplOiBQb2ludCA9IG51bGxcclxuXHQgKiBTaXplIG9mIHRoZSBpY29uIGltYWdlIGluIHBpeGVscy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvbkFuY2hvcjogUG9pbnQgPSBudWxsXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBpY29uIChyZWxhdGl2ZSB0byBpdHMgdG9wIGxlZnQgY29ybmVyKS4gVGhlIGljb25cclxuXHQgKiB3aWxsIGJlIGFsaWduZWQgc28gdGhhdCB0aGlzIHBvaW50IGlzIGF0IHRoZSBtYXJrZXIncyBnZW9ncmFwaGljYWwgbG9jYXRpb24uIENlbnRlcmVkXHJcblx0ICogYnkgZGVmYXVsdCBpZiBzaXplIGlzIHNwZWNpZmllZCwgYWxzbyBjYW4gYmUgc2V0IGluIENTUyB3aXRoIG5lZ2F0aXZlIG1hcmdpbnMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHBvcHVwQW5jaG9yOiBQb2ludCA9IFswLCAwXVxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCBwb3B1cHMgd2lsbCBcIm9wZW5cIiwgcmVsYXRpdmUgdG8gdGhlIGljb24gYW5jaG9yLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiB0b29sdGlwQW5jaG9yOiBQb2ludCA9IFswLCAwXVxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCB0b29sdGlwcyB3aWxsIFwib3BlblwiLCByZWxhdGl2ZSB0byB0aGUgaWNvbiBhbmNob3IuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1VybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqIFRoZSBVUkwgdG8gdGhlIGljb24gc2hhZG93IGltYWdlLiBJZiBub3Qgc3BlY2lmaWVkLCBubyBzaGFkb3cgaW1hZ2Ugd2lsbCBiZSBjcmVhdGVkLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dSZXRpbmFVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93U2l6ZTogUG9pbnQgPSBudWxsXHJcblx0ICogU2l6ZSBvZiB0aGUgc2hhZG93IGltYWdlIGluIHBpeGVscy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93QW5jaG9yOiBQb2ludCA9IG51bGxcclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIHNoYWRvdyAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikgKHRoZSBzYW1lXHJcblx0ICogYXMgaWNvbkFuY2hvciBpZiBub3Qgc3BlY2lmaWVkKS5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdCAqIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIGJvdGggaWNvbiBhbmQgc2hhZG93IGltYWdlcy4gRW1wdHkgYnkgZGVmYXVsdC5cclxuXHQgKi9cclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9wdXBBbmNob3I6IFswLCAwXSxcclxuXHRcdHRvb2x0aXBBbmNob3I6IFswLCAwXSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgdGlsZXMuXHJcblx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgYWxsIHRpbGVzIHdpbGwgaGF2ZSB0aGVpciBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyB0aWxlIHBpeGVsIGRhdGEuXHJcblx0XHQvLyBSZWZlciB0byBbQ09SUyBTZXR0aW5nc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXMpIGZvciB2YWxpZCBTdHJpbmcgdmFsdWVzLlxyXG5cdFx0Y3Jvc3NPcmlnaW46IGZhbHNlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVJY29uKG9sZEljb24/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ2FsbGVkIGludGVybmFsbHkgd2hlbiB0aGUgaWNvbiBoYXMgdG8gYmUgc2hvd24sIHJldHVybnMgYSBgPGltZz5gIEhUTUwgZWxlbWVudFxyXG5cdC8vIHN0eWxlZCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnMuXHJcblx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdpY29uJywgb2xkSWNvbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVTaGFkb3cob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBBcyBgY3JlYXRlSWNvbmAsIGJ1dCBmb3IgdGhlIHNoYWRvdyBiZW5lYXRoIGl0LlxyXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdzaGFkb3cnLCBvbGRJY29uKTtcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlSWNvbjogZnVuY3Rpb24gKG5hbWUsIG9sZEljb24pIHtcclxuXHRcdHZhciBzcmMgPSB0aGlzLl9nZXRJY29uVXJsKG5hbWUpO1xyXG5cclxuXHRcdGlmICghc3JjKSB7XHJcblx0XHRcdGlmIChuYW1lID09PSAnaWNvbicpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ljb25Vcmwgbm90IHNldCBpbiBJY29uIG9wdGlvbnMgKHNlZSB0aGUgZG9jcykuJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGltZyA9IHRoaXMuX2NyZWF0ZUltZyhzcmMsIG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnSU1HJyA/IG9sZEljb24gOiBudWxsKTtcclxuXHRcdHRoaXMuX3NldEljb25TdHlsZXMoaW1nLCBuYW1lKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luIHx8IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gJycpIHtcclxuXHRcdFx0aW1nLmNyb3NzT3JpZ2luID0gdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSB0cnVlID8gJycgOiB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW47XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGltZztcclxuXHR9LFxyXG5cclxuXHRfc2V0SWNvblN0eWxlczogZnVuY3Rpb24gKGltZywgbmFtZSkge1xyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblx0XHR2YXIgc2l6ZU9wdGlvbiA9IG9wdGlvbnNbbmFtZSArICdTaXplJ107XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBzaXplT3B0aW9uID09PSAnbnVtYmVyJykge1xyXG5cdFx0XHRzaXplT3B0aW9uID0gW3NpemVPcHRpb24sIHNpemVPcHRpb25dO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzaXplID0gcG9pbnQoc2l6ZU9wdGlvbiksXHJcblx0XHQgICAgYW5jaG9yID0gcG9pbnQobmFtZSA9PT0gJ3NoYWRvdycgJiYgb3B0aW9ucy5zaGFkb3dBbmNob3IgfHwgb3B0aW9ucy5pY29uQW5jaG9yIHx8XHJcblx0XHQgICAgICAgICAgICBzaXplICYmIHNpemUuZGl2aWRlQnkoMiwgdHJ1ZSkpO1xyXG5cclxuXHRcdGltZy5jbGFzc05hbWUgPSAnbGVhZmxldC1tYXJrZXItJyArIG5hbWUgKyAnICcgKyAob3B0aW9ucy5jbGFzc05hbWUgfHwgJycpO1xyXG5cclxuXHRcdGlmIChhbmNob3IpIHtcclxuXHRcdFx0aW1nLnN0eWxlLm1hcmdpbkxlZnQgPSAoLWFuY2hvci54KSArICdweCc7XHJcblx0XHRcdGltZy5zdHlsZS5tYXJnaW5Ub3AgID0gKC1hbmNob3IueSkgKyAncHgnO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzaXplKSB7XHJcblx0XHRcdGltZy5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG5cdFx0XHRpbWcuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlSW1nOiBmdW5jdGlvbiAoc3JjLCBlbCkge1xyXG5cdFx0ZWwgPSBlbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuXHRcdGVsLnNyYyA9IHNyYztcclxuXHRcdHJldHVybiBlbDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0SWNvblVybDogZnVuY3Rpb24gKG5hbWUpIHtcclxuXHRcdHJldHVybiBCcm93c2VyLnJldGluYSAmJiB0aGlzLm9wdGlvbnNbbmFtZSArICdSZXRpbmFVcmwnXSB8fCB0aGlzLm9wdGlvbnNbbmFtZSArICdVcmwnXTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwuaWNvbihvcHRpb25zOiBJY29uIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYW4gaWNvbiBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxyXG5leHBvcnQgZnVuY3Rpb24gaWNvbihvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBJY29uKG9wdGlvbnMpO1xyXG59XHJcbiIsImltcG9ydCB7SWNvbn0gZnJvbSAnLi9JY29uJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQG1pbmljbGFzcyBJY29uLkRlZmF1bHQgKEljb24pXG4gKiBAYWthIEwuSWNvbi5EZWZhdWx0XG4gKiBAc2VjdGlvblxuICpcbiAqIEEgdHJpdmlhbCBzdWJjbGFzcyBvZiBgSWNvbmAsIHJlcHJlc2VudHMgdGhlIGljb24gdG8gdXNlIGluIGBNYXJrZXJgcyB3aGVuXG4gKiBubyBpY29uIGlzIHNwZWNpZmllZC4gUG9pbnRzIHRvIHRoZSBibHVlIG1hcmtlciBpbWFnZSBkaXN0cmlidXRlZCB3aXRoIExlYWZsZXRcbiAqIHJlbGVhc2VzLlxuICpcbiAqIEluIG9yZGVyIHRvIGN1c3RvbWl6ZSB0aGUgZGVmYXVsdCBpY29uLCBqdXN0IGNoYW5nZSB0aGUgcHJvcGVydGllcyBvZiBgTC5JY29uLkRlZmF1bHQucHJvdG90eXBlLm9wdGlvbnNgXG4gKiAod2hpY2ggaXMgYSBzZXQgb2YgYEljb24gb3B0aW9uc2ApLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIF9jb21wbGV0ZWx5XyByZXBsYWNlIHRoZSBkZWZhdWx0IGljb24sIG92ZXJyaWRlIHRoZVxuICogYEwuTWFya2VyLnByb3RvdHlwZS5vcHRpb25zLmljb25gIHdpdGggeW91ciBvd24gaWNvbiBpbnN0ZWFkLlxuICovXG5cbmV4cG9ydCB2YXIgSWNvbkRlZmF1bHQgPSBJY29uLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdGljb25Vcmw6ICAgICAgICdtYXJrZXItaWNvbi5wbmcnLFxuXHRcdGljb25SZXRpbmFVcmw6ICdtYXJrZXItaWNvbi0yeC5wbmcnLFxuXHRcdHNoYWRvd1VybDogICAgICdtYXJrZXItc2hhZG93LnBuZycsXG5cdFx0aWNvblNpemU6ICAgIFsyNSwgNDFdLFxuXHRcdGljb25BbmNob3I6ICBbMTIsIDQxXSxcblx0XHRwb3B1cEFuY2hvcjogWzEsIC0zNF0sXG5cdFx0dG9vbHRpcEFuY2hvcjogWzE2LCAtMjhdLFxuXHRcdHNoYWRvd1NpemU6ICBbNDEsIDQxXVxuXHR9LFxuXG5cdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdGlmICh0eXBlb2YgSWNvbkRlZmF1bHQuaW1hZ2VQYXRoICE9PSAnc3RyaW5nJykge1x0Ly8gRGVwcmVjYXRlZCwgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgb25seVxuXHRcdFx0SWNvbkRlZmF1bHQuaW1hZ2VQYXRoID0gdGhpcy5fZGV0ZWN0SWNvblBhdGgoKTtcblx0XHR9XG5cblx0XHQvLyBAb3B0aW9uIGltYWdlUGF0aDogU3RyaW5nXG5cdFx0Ly8gYEljb24uRGVmYXVsdGAgd2lsbCB0cnkgdG8gYXV0by1kZXRlY3QgdGhlIGxvY2F0aW9uIG9mIHRoZVxuXHRcdC8vIGJsdWUgaWNvbiBpbWFnZXMuIElmIHlvdSBhcmUgcGxhY2luZyB0aGVzZSBpbWFnZXMgaW4gYSBub24tc3RhbmRhcmRcblx0XHQvLyB3YXksIHNldCB0aGlzIG9wdGlvbiB0byBwb2ludCB0byB0aGUgcmlnaHQgcGF0aC5cblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5pbWFnZVBhdGggfHwgSWNvbkRlZmF1bHQuaW1hZ2VQYXRoKSArIEljb24ucHJvdG90eXBlLl9nZXRJY29uVXJsLmNhbGwodGhpcywgbmFtZSk7XG5cdH0sXG5cblx0X3N0cmlwVXJsOiBmdW5jdGlvbiAocGF0aCkge1x0Ly8gc2VwYXJhdGUgZnVuY3Rpb24gdG8gdXNlIGluIHRlc3RzXG5cdFx0dmFyIHN0cmlwID0gZnVuY3Rpb24gKHN0ciwgcmUsIGlkeCkge1xuXHRcdFx0dmFyIG1hdGNoID0gcmUuZXhlYyhzdHIpO1xuXHRcdFx0cmV0dXJuIG1hdGNoICYmIG1hdGNoW2lkeF07XG5cdFx0fTtcblx0XHRwYXRoID0gc3RyaXAocGF0aCwgL151cmxcXCgoWydcIl0pPyguKylcXDFcXCkkLywgMik7XG5cdFx0cmV0dXJuIHBhdGggJiYgc3RyaXAocGF0aCwgL14oLiopbWFya2VyLWljb25cXC5wbmckLywgMSk7XG5cdH0sXG5cblx0X2RldGVjdEljb25QYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGVsID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICAnbGVhZmxldC1kZWZhdWx0LWljb24tcGF0aCcsIGRvY3VtZW50LmJvZHkpO1xuXHRcdHZhciBwYXRoID0gRG9tVXRpbC5nZXRTdHlsZShlbCwgJ2JhY2tncm91bmQtaW1hZ2UnKSB8fFxuXHRcdCAgICAgICAgICAgRG9tVXRpbC5nZXRTdHlsZShlbCwgJ2JhY2tncm91bmRJbWFnZScpO1x0Ly8gSUU4XG5cblx0XHRkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcblx0XHRwYXRoID0gdGhpcy5fc3RyaXBVcmwocGF0aCk7XG5cdFx0aWYgKHBhdGgpIHsgcmV0dXJuIHBhdGg7IH1cblx0XHR2YXIgbGluayA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2xpbmtbaHJlZiQ9XCJsZWFmbGV0LmNzc1wiXScpO1xuXHRcdGlmICghbGluaykgeyByZXR1cm4gJyc7IH1cblx0XHRyZXR1cm4gbGluay5ocmVmLnN1YnN0cmluZygwLCBsaW5rLmhyZWYubGVuZ3RoIC0gJ2xlYWZsZXQuY3NzJy5sZW5ndGggLSAxKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCB7RHJhZ2dhYmxlfSBmcm9tICcuLi8uLi9kb20vRHJhZ2dhYmxlJztcbmltcG9ydCB7dG9Cb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7cmVxdWVzdEFuaW1GcmFtZSwgY2FuY2VsQW5pbUZyYW1lfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogTC5IYW5kbGVyLk1hcmtlckRyYWcgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IEwuTWFya2VyIHRvIG1ha2UgdGhlIG1hcmtlcnMgZHJhZ2dhYmxlLlxuICovXG5cblxuLyogQG5hbWVzcGFjZSBNYXJrZXJcbiAqIEBzZWN0aW9uIEludGVyYWN0aW9uIGhhbmRsZXJzXG4gKlxuICogSW50ZXJhY3Rpb24gaGFuZGxlcnMgYXJlIHByb3BlcnRpZXMgb2YgYSBtYXJrZXIgaW5zdGFuY2UgdGhhdCBhbGxvdyB5b3UgdG8gY29udHJvbCBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoIGFzIGRyYWdnaW5nIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBtYXJrZXIuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuICogYGBgXG4gKlxuICogQHByb3BlcnR5IGRyYWdnaW5nOiBIYW5kbGVyXG4gKiBNYXJrZXIgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLiBPbmx5IHZhbGlkIHdoZW4gdGhlIG1hcmtlciBpcyBvbiB0aGUgbWFwIChPdGhlcndpc2Ugc2V0IFtgbWFya2VyLm9wdGlvbnMuZHJhZ2dhYmxlYF0oI21hcmtlci1kcmFnZ2FibGUpKS5cbiAqL1xuXG5leHBvcnQgdmFyIE1hcmtlckRyYWcgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXJrZXIpIHtcblx0XHR0aGlzLl9tYXJrZXIgPSBtYXJrZXI7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaWNvbiA9IHRoaXMuX21hcmtlci5faWNvbjtcblxuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKGljb24sIGljb24sIHRydWUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG5cdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0cHJlZHJhZzogdGhpcy5fb25QcmVEcmFnLFxuXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0fSwgdGhpcykuZW5hYmxlKCk7XG5cblx0XHREb21VdGlsLmFkZENsYXNzKGljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5vZmYoe1xuXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdHByZWRyYWc6IHRoaXMuX29uUHJlRHJhZyxcblx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdH0sIHRoaXMpLmRpc2FibGUoKTtcblxuXHRcdGlmICh0aGlzLl9tYXJrZXIuX2ljb24pIHtcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFya2VyLl9pY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG5cdFx0fVxuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcmtlciA9IHRoaXMuX21hcmtlcixcblx0XHQgICAgbWFwID0gbWFya2VyLl9tYXAsXG5cdFx0ICAgIHNwZWVkID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblNwZWVkLFxuXHRcdCAgICBwYWRkaW5nID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcsXG5cdFx0ICAgIGljb25Qb3MgPSBEb21VdGlsLmdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG5cdFx0ICAgIGJvdW5kcyA9IG1hcC5nZXRQaXhlbEJvdW5kcygpLFxuXHRcdCAgICBvcmlnaW4gPSBtYXAuZ2V0UGl4ZWxPcmlnaW4oKTtcblxuXHRcdHZhciBwYW5Cb3VuZHMgPSB0b0JvdW5kcyhcblx0XHRcdGJvdW5kcy5taW4uX3N1YnRyYWN0KG9yaWdpbikuYWRkKHBhZGRpbmcpLFxuXHRcdFx0Ym91bmRzLm1heC5fc3VidHJhY3Qob3JpZ2luKS5zdWJ0cmFjdChwYWRkaW5nKVxuXHRcdCk7XG5cblx0XHRpZiAoIXBhbkJvdW5kcy5jb250YWlucyhpY29uUG9zKSkge1xuXHRcdFx0Ly8gQ29tcHV0ZSBpbmNyZW1lbnRhbCBtb3ZlbWVudFxuXHRcdFx0dmFyIG1vdmVtZW50ID0gdG9Qb2ludChcblx0XHRcdFx0KE1hdGgubWF4KHBhbkJvdW5kcy5tYXgueCwgaWNvblBvcy54KSAtIHBhbkJvdW5kcy5tYXgueCkgLyAoYm91bmRzLm1heC54IC0gcGFuQm91bmRzLm1heC54KSAtXG5cdFx0XHRcdChNYXRoLm1pbihwYW5Cb3VuZHMubWluLngsIGljb25Qb3MueCkgLSBwYW5Cb3VuZHMubWluLngpIC8gKGJvdW5kcy5taW4ueCAtIHBhbkJvdW5kcy5taW4ueCksXG5cblx0XHRcdFx0KE1hdGgubWF4KHBhbkJvdW5kcy5tYXgueSwgaWNvblBvcy55KSAtIHBhbkJvdW5kcy5tYXgueSkgLyAoYm91bmRzLm1heC55IC0gcGFuQm91bmRzLm1heC55KSAtXG5cdFx0XHRcdChNYXRoLm1pbihwYW5Cb3VuZHMubWluLnksIGljb25Qb3MueSkgLSBwYW5Cb3VuZHMubWluLnkpIC8gKGJvdW5kcy5taW4ueSAtIHBhbkJvdW5kcy5taW4ueSlcblx0XHRcdCkubXVsdGlwbHlCeShzcGVlZCk7XG5cblx0XHRcdG1hcC5wYW5CeShtb3ZlbWVudCwge2FuaW1hdGU6IGZhbHNlfSk7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLl9hZGQobW92ZW1lbnQpO1xuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcy5fYWRkKG1vdmVtZW50KTtcblxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihtYXJrZXIuX2ljb24sIHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zKTtcblx0XHRcdHRoaXMuX29uRHJhZyhlKTtcblxuXHRcdFx0dGhpcy5fcGFuUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fYWRqdXN0UGFuLmJpbmQodGhpcywgZSkpO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBAc2VjdGlvbiBEcmFnZ2luZyBldmVudHNcblx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXJrZXIuXG5cblx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdGFydHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblxuXHRcdHRoaXMuX29sZExhdExuZyA9IHRoaXMuX21hcmtlci5nZXRMYXRMbmcoKTtcblxuXHRcdC8vIFdoZW4gdXNpbmcgRVM2IGltcG9ydHMgaXQgY291bGQgbm90IGJlIHNldCB3aGVuIGBQb3B1cGAgd2FzIG5vdCBpbXBvcnRlZCBhcyB3ZWxsXG5cdFx0dGhpcy5fbWFya2VyLmNsb3NlUG9wdXAgJiYgdGhpcy5fbWFya2VyLmNsb3NlUG9wdXAoKTtcblxuXHRcdHRoaXMuX21hcmtlclxuXHRcdFx0LmZpcmUoJ21vdmVzdGFydCcpXG5cdFx0XHQuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cdH0sXG5cblx0X29uUHJlRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAodGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1Bhbikge1xuXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX3BhblJlcXVlc3QpO1xuXHRcdFx0dGhpcy5fcGFuUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fYWRqdXN0UGFuLmJpbmQodGhpcywgZSkpO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG5cdFx0ICAgIHNoYWRvdyA9IG1hcmtlci5fc2hhZG93LFxuXHRcdCAgICBpY29uUG9zID0gRG9tVXRpbC5nZXRQb3NpdGlvbihtYXJrZXIuX2ljb24pLFxuXHRcdCAgICBsYXRsbmcgPSBtYXJrZXIuX21hcC5sYXllclBvaW50VG9MYXRMbmcoaWNvblBvcyk7XG5cblx0XHQvLyB1cGRhdGUgc2hhZG93IHBvc2l0aW9uXG5cdFx0aWYgKHNoYWRvdykge1xuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihzaGFkb3csIGljb25Qb3MpO1xuXHRcdH1cblxuXHRcdG1hcmtlci5fbGF0bG5nID0gbGF0bG5nO1xuXHRcdGUubGF0bG5nID0gbGF0bG5nO1xuXHRcdGUub2xkTGF0TG5nID0gdGhpcy5fb2xkTGF0TG5nO1xuXG5cdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSB3aGlsZSB0aGUgdXNlciBkcmFncyB0aGUgbWFya2VyLlxuXHRcdG1hcmtlclxuXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG5cdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG5cdH0sXG5cblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBAZXZlbnQgZHJhZ2VuZDogRHJhZ0VuZEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG5cdFx0IGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9wYW5SZXF1ZXN0KTtcblxuXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdG9wcyBtb3ZpbmcgKGJlY2F1c2Ugb2YgZHJhZ2dpbmcpLlxuXHRcdGRlbGV0ZSB0aGlzLl9vbGRMYXRMbmc7XG5cdFx0dGhpcy5fbWFya2VyXG5cdFx0ICAgIC5maXJlKCdtb3ZlZW5kJylcblx0XHQgICAgLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuLi9MYXllcic7XHJcbmltcG9ydCB7SWNvbkRlZmF1bHR9IGZyb20gJy4vSWNvbi5EZWZhdWx0JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3RvTGF0TG5nIGFzIGxhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCB7dG9Qb2ludCBhcyBwb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0IHtNYXJrZXJEcmFnfSBmcm9tICcuL01hcmtlci5EcmFnJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBNYXJrZXJcclxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAqIEBha2EgTC5NYXJrZXJcclxuICogTC5NYXJrZXIgaXMgdXNlZCB0byBkaXNwbGF5IGNsaWNrYWJsZS9kcmFnZ2FibGUgaWNvbnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLm1hcmtlcihbNTAuNSwgMzAuNV0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTWFya2VyID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIE1hcmtlciBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBpY29uOiBJY29uID0gKlxyXG5cdFx0Ly8gSWNvbiBpbnN0YW5jZSB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgbWFya2VyLlxyXG5cdFx0Ly8gU2VlIFtJY29uIGRvY3VtZW50YXRpb25dKCNMLkljb24pIGZvciBkZXRhaWxzIG9uIGhvdyB0byBjdXN0b21pemUgdGhlIG1hcmtlciBpY29uLlxyXG5cdFx0Ly8gSWYgbm90IHNwZWNpZmllZCwgYSBjb21tb24gaW5zdGFuY2Ugb2YgYEwuSWNvbi5EZWZhdWx0YCBpcyB1c2VkLlxyXG5cdFx0aWNvbjogbmV3IEljb25EZWZhdWx0KCksXHJcblxyXG5cdFx0Ly8gT3B0aW9uIGluaGVyaXRlZCBmcm9tIFwiSW50ZXJhY3RpdmUgbGF5ZXJcIiBhYnN0cmFjdCBjbGFzc1xyXG5cdFx0aW50ZXJhY3RpdmU6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBjYW4gYmUgdGFiYmVkIHRvIHdpdGggYSBrZXlib2FyZCBhbmQgY2xpY2tlZCBieSBwcmVzc2luZyBlbnRlci5cclxuXHRcdGtleWJvYXJkOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdGl0bGU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYnJvd3NlciB0b29sdGlwIHRoYXQgYXBwZWFyIG9uIG1hcmtlciBob3ZlciAobm8gdG9vbHRpcCBieSBkZWZhdWx0KS5cclxuXHRcdC8vIFtVc2VmdWwgZm9yIGFjY2Vzc2liaWxpdHldKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9leGFtcGxlcy9hY2Nlc3NpYmlsaXR5LyNtYXJrZXJzLW11c3QtYmUtbGFiZWxsZWQpLlxyXG5cdFx0dGl0bGU6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnTWFya2VyJ1xyXG5cdFx0Ly8gVGV4dCBmb3IgdGhlIGBhbHRgIGF0dHJpYnV0ZSBvZiB0aGUgaWNvbiBpbWFnZS5cclxuXHRcdC8vIFtVc2VmdWwgZm9yIGFjY2Vzc2liaWxpdHldKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9leGFtcGxlcy9hY2Nlc3NpYmlsaXR5LyNtYXJrZXJzLW11c3QtYmUtbGFiZWxsZWQpLlxyXG5cdFx0YWx0OiAnTWFya2VyJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpJbmRleE9mZnNldDogTnVtYmVyID0gMFxyXG5cdFx0Ly8gQnkgZGVmYXVsdCwgbWFya2VyIGltYWdlcyB6SW5kZXggaXMgc2V0IGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gaXRzIGxhdGl0dWRlLiBVc2UgdGhpcyBvcHRpb24gaWYgeW91IHdhbnQgdG8gcHV0IHRoZSBtYXJrZXIgb24gdG9wIG9mIGFsbCBvdGhlcnMgKG9yIGJlbG93KSwgc3BlY2lmeWluZyBhIGhpZ2ggdmFsdWUgbGlrZSBgMTAwMGAgKG9yIGhpZ2ggbmVnYXRpdmUgdmFsdWUsIHJlc3BlY3RpdmVseSkuXHJcblx0XHR6SW5kZXhPZmZzZXQ6IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcclxuXHRcdC8vIFRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXHJcblx0XHRvcGFjaXR5OiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmlzZU9uSG92ZXI6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgbWFya2VyIHdpbGwgZ2V0IG9uIHRvcCBvZiBvdGhlcnMgd2hlbiB5b3UgaG92ZXIgdGhlIG1vdXNlIG92ZXIgaXQuXHJcblx0XHRyaXNlT25Ib3ZlcjogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByaXNlT2Zmc2V0OiBOdW1iZXIgPSAyNTBcclxuXHRcdC8vIFRoZSB6LWluZGV4IG9mZnNldCB1c2VkIGZvciB0aGUgYHJpc2VPbkhvdmVyYCBmZWF0dXJlLlxyXG5cdFx0cmlzZU9mZnNldDogMjUwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ21hcmtlclBhbmUnXHJcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBtYXJrZXJzIGljb24gd2lsbCBiZSBhZGRlZC5cclxuXHRcdHBhbmU6ICdtYXJrZXJQYW5lJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHNoYWRvd1BhbmU6IFN0cmluZyA9ICdzaGFkb3dQYW5lJ1xyXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgbWFya2VycyBzaGFkb3cgd2lsbCBiZSBhZGRlZC5cclxuXHRcdHNoYWRvd1BhbmU6ICdzaGFkb3dQYW5lJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGJ1YmJsaW5nTW91c2VFdmVudHM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hlbiBgdHJ1ZWAsIGEgbW91c2UgZXZlbnQgb24gdGhpcyBtYXJrZXIgd2lsbCB0cmlnZ2VyIHRoZSBzYW1lIGV2ZW50IG9uIHRoZSBtYXBcclxuXHRcdC8vICh1bmxlc3MgW2BMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbmBdKCNkb21ldmVudC1zdG9wcHJvcGFnYXRpb24pIGlzIHVzZWQpLlxyXG5cdFx0YnViYmxpbmdNb3VzZUV2ZW50czogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuT25Gb2N1czogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZW4gYHRydWVgLCB0aGUgbWFwIHdpbGwgcGFuIHdoZW5ldmVyIHRoZSBtYXJrZXIgaXMgZm9jdXNlZCAodmlhXHJcblx0XHQvLyBlLmcuIHByZXNzaW5nIGB0YWJgIG9uIHRoZSBrZXlib2FyZCkgdG8gZW5zdXJlIHRoZSBtYXJrZXIgaXNcclxuXHRcdC8vIHZpc2libGUgd2l0aGluIHRoZSBtYXAncyBib3VuZHNcclxuXHRcdGF1dG9QYW5PbkZvY3VzOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIERyYWdnYWJsZSBtYXJrZXIgb3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBkcmFnZ2FibGU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGlzIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cclxuXHRcdGRyYWdnYWJsZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdG8gcGFuIHRoZSBtYXAgd2hlbiBkcmFnZ2luZyB0aGlzIG1hcmtlciBuZWFyIGl0cyBlZGdlIG9yIG5vdC5cclxuXHRcdGF1dG9QYW46IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmc6IFBvaW50ID0gUG9pbnQoNTAsIDUwKVxyXG5cdFx0Ly8gRGlzdGFuY2UgKGluIHBpeGVscyB0byB0aGUgbGVmdC9yaWdodCBhbmQgdG8gdGhlIHRvcC9ib3R0b20pIG9mIHRoZVxyXG5cdFx0Ly8gbWFwIGVkZ2UgdG8gc3RhcnQgcGFubmluZyB0aGUgbWFwLlxyXG5cdFx0YXV0b1BhblBhZGRpbmc6IFs1MCwgNTBdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblNwZWVkOiBOdW1iZXIgPSAxMFxyXG5cdFx0Ly8gTnVtYmVyIG9mIHBpeGVscyB0aGUgbWFwIHNob3VsZCBwYW4gYnkuXHJcblx0XHRhdXRvUGFuU3BlZWQ6IDEwXHJcblx0fSxcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKlxyXG5cdCAqIEluIGFkZGl0aW9uIHRvIFtzaGFyZWQgbGF5ZXIgbWV0aG9kc10oI0xheWVyKSBsaWtlIGBhZGRUbygpYCBhbmQgYHJlbW92ZSgpYCBhbmQgW3BvcHVwIG1ldGhvZHNdKCNQb3B1cCkgbGlrZSBiaW5kUG9wdXAoKSB5b3UgY2FuIGFsc28gdXNlIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gbGF0TG5nKGxhdGxuZyk7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IHRoaXMuX3pvb21BbmltYXRlZCAmJiBtYXAub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0bWFwLm9uKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0aWYgKHRoaXMuZHJhZ2dpbmcgJiYgdGhpcy5kcmFnZ2luZy5lbmFibGVkKCkpIHtcclxuXHRcdFx0dGhpcy5vcHRpb25zLmRyYWdnYWJsZSA9IHRydWU7XHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcucmVtb3ZlSG9va3MoKTtcclxuXHRcdH1cclxuXHRcdGRlbGV0ZSB0aGlzLmRyYWdnaW5nO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0bWFwLm9mZignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG5cdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR6b29tOiB0aGlzLnVwZGF0ZSxcclxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLnVwZGF0ZVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExhdExuZzogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgcG9zaXRpb24gb2YgdGhlIG1hcmtlci5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgbWFya2VyIHBvc2l0aW9uIHRvIHRoZSBnaXZlbiBwb2ludC5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBvbGRMYXRMbmcgPSB0aGlzLl9sYXRsbmc7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBsYXRMbmcobGF0bG5nKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgaXMgbW92ZWQgdmlhIFtgc2V0TGF0TG5nYF0oI21hcmtlci1zZXRsYXRsbmcpIG9yIGJ5IFtkcmFnZ2luZ10oI21hcmtlci1kcmFnZ2luZykuIE9sZCBhbmQgbmV3IGNvb3JkaW5hdGVzIGFyZSBpbmNsdWRlZCBpbiBldmVudCBhcmd1bWVudHMgYXMgYG9sZExhdExuZ2AsIGBsYXRsbmdgLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIHtvbGRMYXRMbmc6IG9sZExhdExuZywgbGF0bG5nOiB0aGlzLl9sYXRsbmd9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpJbmRleE9mZnNldChvZmZzZXQ6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4IG9mZnNldF0oI21hcmtlci16aW5kZXhvZmZzZXQpIG9mIHRoZSBtYXJrZXIuXHJcblx0c2V0WkluZGV4T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0ID0gb2Zmc2V0O1xyXG5cdFx0cmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRJY29uOiBJY29uXHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBpY29uIHVzZWQgYnkgdGhlIG1hcmtlclxyXG5cdGdldEljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldEljb24oaWNvbjogSWNvbik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBtYXJrZXIgaWNvbi5cclxuXHRzZXRJY29uOiBmdW5jdGlvbiAoaWNvbikge1xyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5pY29uID0gaWNvbjtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJY29uKCk7XHJcblx0XHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuYmluZFBvcHVwKHRoaXMuX3BvcHVwLCB0aGlzLl9wb3B1cC5vcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5faWNvbjtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faWNvbiAmJiB0aGlzLl9tYXApIHtcclxuXHRcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKS5yb3VuZCgpO1xyXG5cdFx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdEljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG5cdFx0ICAgIGNsYXNzVG9BZGQgPSAnbGVhZmxldC16b29tLScgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyk7XHJcblxyXG5cdFx0dmFyIGljb24gPSBvcHRpb25zLmljb24uY3JlYXRlSWNvbih0aGlzLl9pY29uKSxcclxuXHRcdCAgICBhZGRJY29uID0gZmFsc2U7XHJcblxyXG5cdFx0Ly8gaWYgd2UncmUgbm90IHJldXNpbmcgdGhlIGljb24sIHJlbW92ZSB0aGUgb2xkIG9uZSBhbmQgaW5pdCBuZXcgb25lXHJcblx0XHRpZiAoaWNvbiAhPT0gdGhpcy5faWNvbikge1xyXG5cdFx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRhZGRJY29uID0gdHJ1ZTtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLnRpdGxlKSB7XHJcblx0XHRcdFx0aWNvbi50aXRsZSA9IG9wdGlvbnMudGl0bGU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChpY29uLnRhZ05hbWUgPT09ICdJTUcnKSB7XHJcblx0XHRcdFx0aWNvbi5hbHQgPSBvcHRpb25zLmFsdCB8fCAnJztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoaWNvbiwgY2xhc3NUb0FkZCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMua2V5Ym9hcmQpIHtcclxuXHRcdFx0aWNvbi50YWJJbmRleCA9ICcwJztcclxuXHRcdFx0aWNvbi5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faWNvbiA9IGljb247XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vbih7XHJcblx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcblx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1Bhbk9uRm9jdXMpIHtcclxuXHRcdFx0RG9tRXZlbnQub24oaWNvbiwgJ2ZvY3VzJywgdGhpcy5fcGFuT25Gb2N1cywgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5ld1NoYWRvdyA9IG9wdGlvbnMuaWNvbi5jcmVhdGVTaGFkb3codGhpcy5fc2hhZG93KSxcclxuXHRcdCAgICBhZGRTaGFkb3cgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAobmV3U2hhZG93ICE9PSB0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcblx0XHRcdGFkZFNoYWRvdyA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdykge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKG5ld1NoYWRvdywgY2xhc3NUb0FkZCk7XHJcblx0XHRcdG5ld1NoYWRvdy5hbHQgPSAnJztcclxuXHRcdH1cclxuXHRcdHRoaXMuX3NoYWRvdyA9IG5ld1NoYWRvdztcclxuXHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHRpZiAoYWRkSWNvbikge1xyXG5cdFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pY29uKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2luaXRJbnRlcmFjdGlvbigpO1xyXG5cdFx0aWYgKG5ld1NoYWRvdyAmJiBhZGRTaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5nZXRQYW5lKG9wdGlvbnMuc2hhZG93UGFuZSkuYXBwZW5kQ2hpbGQodGhpcy5fc2hhZG93KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlSWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG5cdFx0XHR0aGlzLm9mZih7XHJcblx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcblx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1Bhbk9uRm9jdXMpIHtcclxuXHRcdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2ljb24sICdmb2N1cycsIHRoaXMuX3Bhbk9uRm9jdXMsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2ljb24pO1xyXG5cdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcblx0XHR0aGlzLl9pY29uID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlU2hhZG93OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX3NoYWRvdyk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9zaGFkb3cgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRQb3M6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2ljb24sIHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX3NoYWRvdywgcG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl96SW5kZXggPSBwb3MueSArIHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQ7XHJcblxyXG5cdFx0dGhpcy5fcmVzZXRaSW5kZXgoKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHR0aGlzLl9pY29uLnN0eWxlLnpJbmRleCA9IHRoaXMuX3pJbmRleCArIG9mZnNldDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChvcHQpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIG9wdC56b29tLCBvcHQuY2VudGVyKS5yb3VuZCgpO1xyXG5cclxuXHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SW50ZXJhY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2ljb24sICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcblxyXG5cdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcblx0XHRpZiAoTWFya2VyRHJhZykge1xyXG5cdFx0XHR2YXIgZHJhZ2dhYmxlID0gdGhpcy5vcHRpb25zLmRyYWdnYWJsZTtcclxuXHRcdFx0aWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuXHRcdFx0XHRkcmFnZ2FibGUgPSB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKTtcclxuXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmRpc2FibGUoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5kcmFnZ2luZyA9IG5ldyBNYXJrZXJEcmFnKHRoaXMpO1xyXG5cclxuXHRcdFx0aWYgKGRyYWdnYWJsZSkge1xyXG5cdFx0XHRcdHRoaXMuZHJhZ2dpbmcuZW5hYmxlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBvcGFjaXR5ID0gdGhpcy5vcHRpb25zLm9wYWNpdHk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2ljb24sIG9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX3NoYWRvdywgb3BhY2l0eSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KHRoaXMub3B0aW9ucy5yaXNlT2Zmc2V0KTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXRaSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgwKTtcclxuXHR9LFxyXG5cclxuXHRfcGFuT25Gb2N1czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcclxuXHRcdGlmICghbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBpY29uT3B0cyA9IHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnM7XHJcblx0XHR2YXIgc2l6ZSA9IGljb25PcHRzLmljb25TaXplID8gcG9pbnQoaWNvbk9wdHMuaWNvblNpemUpIDogcG9pbnQoMCwgMCk7XHJcblx0XHR2YXIgYW5jaG9yID0gaWNvbk9wdHMuaWNvbkFuY2hvciA/IHBvaW50KGljb25PcHRzLmljb25BbmNob3IpIDogcG9pbnQoMCwgMCk7XHJcblxyXG5cdFx0bWFwLnBhbkluc2lkZSh0aGlzLl9sYXRsbmcsIHtcclxuXHRcdFx0cGFkZGluZ1RvcExlZnQ6IGFuY2hvcixcclxuXHRcdFx0cGFkZGluZ0JvdHRvbVJpZ2h0OiBzaXplLnN1YnRyYWN0KGFuY2hvcilcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRQb3B1cEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnMucG9wdXBBbmNob3I7XHJcblx0fSxcclxuXHJcblx0X2dldFRvb2x0aXBBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnRvb2x0aXBBbmNob3I7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBmYWN0b3J5IEwubWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPyA6IE1hcmtlciBvcHRpb25zKVxyXG5cclxuLy8gQGZhY3RvcnkgTC5tYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/IDogTWFya2VyIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIE1hcmtlciBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQgYW5kIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcclxufVxyXG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuLi9MYXllcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgUGF0aFxuICogQGFrYSBMLlBhdGhcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxuICpcbiAqIEFuIGFic3RyYWN0IGNsYXNzIHRoYXQgY29udGFpbnMgb3B0aW9ucyBhbmQgY29uc3RhbnRzIHNoYXJlZCBiZXR3ZWVuIHZlY3RvclxuICogb3ZlcmxheXMgKFBvbHlnb24sIFBvbHlsaW5lLCBDaXJjbGUpLiBEbyBub3QgdXNlIGl0IGRpcmVjdGx5LiBFeHRlbmRzIGBMYXllcmAuXG4gKi9cblxuZXhwb3J0IHZhciBQYXRoID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFBhdGggb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBzdHJva2U6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gV2hldGhlciB0byBkcmF3IHN0cm9rZSBhbG9uZyB0aGUgcGF0aC4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBib3JkZXJzIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXG5cdFx0c3Ryb2tlOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiBjb2xvcjogU3RyaW5nID0gJyMzMzg4ZmYnXG5cdFx0Ly8gU3Ryb2tlIGNvbG9yXG5cdFx0Y29sb3I6ICcjMzM4OGZmJyxcblxuXHRcdC8vIEBvcHRpb24gd2VpZ2h0OiBOdW1iZXIgPSAzXG5cdFx0Ly8gU3Ryb2tlIHdpZHRoIGluIHBpeGVsc1xuXHRcdHdlaWdodDogMyxcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG5cdFx0Ly8gU3Ryb2tlIG9wYWNpdHlcblx0XHRvcGFjaXR5OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiBsaW5lQ2FwOiBTdHJpbmc9ICdyb3VuZCdcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW3NoYXBlIHRvIGJlIHVzZWQgYXQgdGhlIGVuZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbGluZWNhcCkgb2YgdGhlIHN0cm9rZS5cblx0XHRsaW5lQ2FwOiAncm91bmQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBsaW5lSm9pbjogU3RyaW5nID0gJ3JvdW5kJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgY29ybmVyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbGluZWpvaW4pIG9mIHRoZSBzdHJva2UuXG5cdFx0bGluZUpvaW46ICdyb3VuZCcsXG5cblx0XHQvLyBAb3B0aW9uIGRhc2hBcnJheTogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgc3Ryb2tlIFtkYXNoIHBhdHRlcm5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hhcnJheSkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cblx0XHRkYXNoQXJyYXk6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGRhc2hPZmZzZXQ6IFN0cmluZyA9IG51bGxcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgdGhlIFtkaXN0YW5jZSBpbnRvIHRoZSBkYXNoIHBhdHRlcm4gdG8gc3RhcnQgdGhlIGRhc2hdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hvZmZzZXQpLiBEb2Vzbid0IHdvcmsgb24gYENhbnZhc2AtcG93ZXJlZCBsYXllcnMgaW4gW3NvbWUgb2xkIGJyb3dzZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoI0Jyb3dzZXJfY29tcGF0aWJpbGl0eSkuXG5cdFx0ZGFzaE9mZnNldDogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZmlsbDogQm9vbGVhbiA9IGRlcGVuZHNcblx0XHQvLyBXaGV0aGVyIHRvIGZpbGwgdGhlIHBhdGggd2l0aCBjb2xvci4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBmaWxsaW5nIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXG5cdFx0ZmlsbDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxDb2xvcjogU3RyaW5nID0gKlxuXHRcdC8vIEZpbGwgY29sb3IuIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBvZiB0aGUgW2Bjb2xvcmBdKCNwYXRoLWNvbG9yKSBvcHRpb25cblx0XHRmaWxsQ29sb3I6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxPcGFjaXR5OiBOdW1iZXIgPSAwLjJcblx0XHQvLyBGaWxsIG9wYWNpdHkuXG5cdFx0ZmlsbE9wYWNpdHk6IDAuMixcblxuXHRcdC8vIEBvcHRpb24gZmlsbFJ1bGU6IFN0cmluZyA9ICdldmVub2RkJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbaG93IHRoZSBpbnNpZGUgb2YgYSBzaGFwZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9maWxsLXJ1bGUpIGlzIGRldGVybWluZWQuXG5cdFx0ZmlsbFJ1bGU6ICdldmVub2RkJyxcblxuXHRcdC8vIGNsYXNzTmFtZTogJycsXG5cblx0XHQvLyBPcHRpb24gaW5oZXJpdGVkIGZyb20gXCJJbnRlcmFjdGl2ZSBsYXllclwiIGFic3RyYWN0IGNsYXNzXG5cdFx0aW50ZXJhY3RpdmU6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGJ1YmJsaW5nTW91c2VFdmVudHM6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gV2hlbiBgdHJ1ZWAsIGEgbW91c2UgZXZlbnQgb24gdGhpcyBwYXRoIHdpbGwgdHJpZ2dlciB0aGUgc2FtZSBldmVudCBvbiB0aGUgbWFwXG5cdFx0Ly8gKHVubGVzcyBbYEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uYF0oI2RvbWV2ZW50LXN0b3Bwcm9wYWdhdGlvbikgaXMgdXNlZCkuXG5cdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuXHR9LFxuXG5cdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdC8vIFJlbmRlcmVyIGlzIHNldCBoZXJlIGJlY2F1c2Ugd2UgbmVlZCB0byBjYWxsIHJlbmRlcmVyLmdldEV2ZW50c1xuXHRcdC8vIGJlZm9yZSB0aGlzLmdldEV2ZW50cy5cblx0XHR0aGlzLl9yZW5kZXJlciA9IG1hcC5nZXRSZW5kZXJlcih0aGlzKTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9pbml0UGF0aCh0aGlzKTtcblx0XHR0aGlzLl9yZXNldCgpO1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9hZGRQYXRoKHRoaXMpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3JlbW92ZVBhdGgodGhpcyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZWRyYXcoKTogdGhpc1xuXHQvLyBSZWRyYXdzIHRoZSBsYXllci4gU29tZXRpbWVzIHVzZWZ1bCBhZnRlciB5b3UgY2hhbmdlZCB0aGUgY29vcmRpbmF0ZXMgdGhhdCB0aGUgcGF0aCB1c2VzLlxuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUGF0aCh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRTdHlsZShzdHlsZTogUGF0aCBvcHRpb25zKTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSBhcHBlYXJhbmNlIG9mIGEgUGF0aCBiYXNlZCBvbiB0aGUgb3B0aW9ucyBpbiB0aGUgYFBhdGggb3B0aW9uc2Agb2JqZWN0LlxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIHN0eWxlKTtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVTdHlsZSh0aGlzKTtcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuc3Ryb2tlICYmIHN0eWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdHlsZSwgJ3dlaWdodCcpKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgcGF0aCBsYXllcnMuXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9Gcm9udCh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgcGF0aCBsYXllcnMuXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0JhY2sodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aDtcblx0fSxcblxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBkZWZpbmVkIGluIGNoaWxkIGNsYXNzZXNcblx0XHR0aGlzLl9wcm9qZWN0KCk7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X2NsaWNrVG9sZXJhbmNlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdXNlZCB3aGVuIGRvaW5nIGhpdCBkZXRlY3Rpb24gZm9yIENhbnZhcyBsYXllcnNcblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5zdHJva2UgPyB0aGlzLm9wdGlvbnMud2VpZ2h0IC8gMiA6IDApICtcblx0XHQgICh0aGlzLl9yZW5kZXJlci5vcHRpb25zLnRvbGVyYW5jZSB8fCAwKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge1BhdGh9IGZyb20gJy4vUGF0aCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge3RvTGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG5cbi8qXG4gKiBAY2xhc3MgQ2lyY2xlTWFya2VyXG4gKiBAYWthIEwuQ2lyY2xlTWFya2VyXG4gKiBAaW5oZXJpdHMgUGF0aFxuICpcbiAqIEEgY2lyY2xlIG9mIGEgZml4ZWQgc2l6ZSB3aXRoIHJhZGl1cyBzcGVjaWZpZWQgaW4gcGl4ZWxzLiBFeHRlbmRzIGBQYXRoYC5cbiAqL1xuXG5leHBvcnQgdmFyIENpcmNsZU1hcmtlciA9IFBhdGguZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIENpcmNsZU1hcmtlciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHRmaWxsOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiByYWRpdXM6IE51bWJlciA9IDEwXG5cdFx0Ly8gUmFkaXVzIG9mIHRoZSBjaXJjbGUgbWFya2VyLCBpbiBwaXhlbHNcblx0XHRyYWRpdXM6IDEwXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0TG5nOiBMYXRMbmcpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGEgY2lyY2xlIG1hcmtlciB0byBhIG5ldyBsb2NhdGlvbi5cblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XG5cdFx0dmFyIG9sZExhdExuZyA9IHRoaXMuX2xhdGxuZztcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdHRoaXMucmVkcmF3KCk7XG5cblx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgaXMgbW92ZWQgdmlhIFtgc2V0TGF0TG5nYF0oI2NpcmNsZW1hcmtlci1zZXRsYXRsbmcpLiBPbGQgYW5kIG5ldyBjb29yZGluYXRlcyBhcmUgaW5jbHVkZWQgaW4gZXZlbnQgYXJndW1lbnRzIGFzIGBvbGRMYXRMbmdgLCBgbGF0bG5nYC5cblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge29sZExhdExuZzogb2xkTGF0TG5nLCBsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nKCk6IExhdExuZ1xuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0UmFkaXVzKHJhZGl1czogTnVtYmVyKTogdGhpc1xuXHQvLyBTZXRzIHRoZSByYWRpdXMgb2YgYSBjaXJjbGUgbWFya2VyLiBVbml0cyBhcmUgaW4gcGl4ZWxzLlxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcblx0XHR0aGlzLm9wdGlvbnMucmFkaXVzID0gdGhpcy5fcmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiB0aGUgY2lyY2xlXG5cdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpdXM7XG5cdH0sXG5cblx0c2V0U3R5bGUgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdHZhciByYWRpdXMgPSBvcHRpb25zICYmIG9wdGlvbnMucmFkaXVzIHx8IHRoaXMuX3JhZGl1cztcblx0XHRQYXRoLnByb3RvdHlwZS5zZXRTdHlsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuc2V0UmFkaXVzKHJhZGl1cyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0fSxcblxuXHRfdXBkYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHIgPSB0aGlzLl9yYWRpdXMsXG5cdFx0ICAgIHIyID0gdGhpcy5fcmFkaXVzWSB8fCByLFxuXHRcdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcblx0XHQgICAgcCA9IFtyICsgdywgcjIgKyB3XTtcblx0XHR0aGlzLl9weEJvdW5kcyA9IG5ldyBCb3VuZHModGhpcy5fcG9pbnQuc3VidHJhY3QocCksIHRoaXMuX3BvaW50LmFkZChwKSk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3VwZGF0ZVBhdGgoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlQ2lyY2xlKHRoaXMpO1xuXHR9LFxuXG5cdF9lbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpdXMgJiYgIXRoaXMuX3JlbmRlcmVyLl9ib3VuZHMuaW50ZXJzZWN0cyh0aGlzLl9weEJvdW5kcyk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHRyZXR1cm4gcC5kaXN0YW5jZVRvKHRoaXMuX3BvaW50KSA8PSB0aGlzLl9yYWRpdXMgKyB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLmNpcmNsZU1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZU1hcmtlciBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG1hcmtlciBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdC5cbmV4cG9ydCBmdW5jdGlvbiBjaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgQ2lyY2xlTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge0NpcmNsZU1hcmtlcn0gZnJvbSAnLi9DaXJjbGVNYXJrZXInO1xuaW1wb3J0IHtQYXRofSBmcm9tICcuL1BhdGgnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHt0b0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5pbXBvcnQge0VhcnRofSBmcm9tICcuLi8uLi9nZW8vY3JzL0NSUy5FYXJ0aCc7XG5cblxuLypcbiAqIEBjbGFzcyBDaXJjbGVcbiAqIEBha2EgTC5DaXJjbGVcbiAqIEBpbmhlcml0cyBDaXJjbGVNYXJrZXJcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIGNpcmNsZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgQ2lyY2xlTWFya2VyYC5cbiAqXG4gKiBJdCdzIGFuIGFwcHJveGltYXRpb24gYW5kIHN0YXJ0cyB0byBkaXZlcmdlIGZyb20gYSByZWFsIGNpcmNsZSBjbG9zZXIgdG8gcG9sZXMgKGR1ZSB0byBwcm9qZWN0aW9uIGRpc3RvcnRpb24pLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIEwuY2lyY2xlKFs1MC41LCAzMC41XSwge3JhZGl1czogMjAwfSkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgQ2lyY2xlID0gQ2lyY2xlTWFya2VyLmV4dGVuZCh7XG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucykge1xuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcblx0XHRcdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggZmFjdG9yeSAobGF0bG5nLCByYWRpdXMsIG9wdGlvbnM/KVxuXHRcdFx0b3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBsZWdhY3lPcHRpb25zLCB7cmFkaXVzOiBvcHRpb25zfSk7XG5cdFx0fVxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXG5cdFx0aWYgKGlzTmFOKHRoaXMub3B0aW9ucy5yYWRpdXMpKSB7IHRocm93IG5ldyBFcnJvcignQ2lyY2xlIHJhZGl1cyBjYW5ub3QgYmUgTmFOJyk7IH1cblxuXHRcdC8vIEBzZWN0aW9uXG5cdFx0Ly8gQGFrYSBDaXJjbGUgb3B0aW9uc1xuXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXI7IFJhZGl1cyBvZiB0aGUgY2lyY2xlLCBpbiBtZXRlcnMuXG5cdFx0dGhpcy5fbVJhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHJhZGl1cyBvZiBhIGNpcmNsZS4gVW5pdHMgYXJlIGluIG1ldGVycy5cblx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XG5cdFx0dGhpcy5fbVJhZGl1cyA9IHJhZGl1cztcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFJhZGl1cygpOiBOdW1iZXJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCByYWRpdXMgb2YgYSBjaXJjbGUuIFVuaXRzIGFyZSBpbiBtZXRlcnMuXG5cdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tUmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xuXHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGhhbGYgPSBbdGhpcy5fcmFkaXVzLCB0aGlzLl9yYWRpdXNZIHx8IHRoaXMuX3JhZGl1c107XG5cblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhcblx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuc3VidHJhY3QoaGFsZikpLFxuXHRcdFx0dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludC5hZGQoaGFsZikpKTtcblx0fSxcblxuXHRzZXRTdHlsZTogUGF0aC5wcm90b3R5cGUuc2V0U3R5bGUsXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBsbmcgPSB0aGlzLl9sYXRsbmcubG5nLFxuXHRcdCAgICBsYXQgPSB0aGlzLl9sYXRsbmcubGF0LFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycztcblxuXHRcdGlmIChjcnMuZGlzdGFuY2UgPT09IEVhcnRoLmRpc3RhbmNlKSB7XG5cdFx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXG5cdFx0XHQgICAgbGF0UiA9ICh0aGlzLl9tUmFkaXVzIC8gRWFydGguUikgLyBkLFxuXHRcdFx0ICAgIHRvcCA9IG1hcC5wcm9qZWN0KFtsYXQgKyBsYXRSLCBsbmddKSxcblx0XHRcdCAgICBib3R0b20gPSBtYXAucHJvamVjdChbbGF0IC0gbGF0UiwgbG5nXSksXG5cdFx0XHQgICAgcCA9IHRvcC5hZGQoYm90dG9tKS5kaXZpZGVCeSgyKSxcblx0XHRcdCAgICBsYXQyID0gbWFwLnVucHJvamVjdChwKS5sYXQsXG5cdFx0XHQgICAgbG5nUiA9IE1hdGguYWNvcygoTWF0aC5jb3MobGF0UiAqIGQpIC0gTWF0aC5zaW4obGF0ICogZCkgKiBNYXRoLnNpbihsYXQyICogZCkpIC9cblx0XHRcdCAgICAgICAgICAgIChNYXRoLmNvcyhsYXQgKiBkKSAqIE1hdGguY29zKGxhdDIgKiBkKSkpIC8gZDtcblxuXHRcdFx0aWYgKGlzTmFOKGxuZ1IpIHx8IGxuZ1IgPT09IDApIHtcblx0XHRcdFx0bG5nUiA9IGxhdFIgLyBNYXRoLmNvcyhNYXRoLlBJIC8gMTgwICogbGF0KTsgLy8gRmFsbGJhY2sgZm9yIGVkZ2UgY2FzZSwgIzI0MjVcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fcG9pbnQgPSBwLnN1YnRyYWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKTtcblx0XHRcdHRoaXMuX3JhZGl1cyA9IGlzTmFOKGxuZ1IpID8gMCA6IHAueCAtIG1hcC5wcm9qZWN0KFtsYXQyLCBsbmcgLSBsbmdSXSkueDtcblx0XHRcdHRoaXMuX3JhZGl1c1kgPSBwLnkgLSB0b3AueTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbGF0bG5nMiA9IGNycy51bnByb2plY3QoY3JzLnByb2plY3QodGhpcy5fbGF0bG5nKS5zdWJ0cmFjdChbdGhpcy5fbVJhZGl1cywgMF0pKTtcblxuXHRcdFx0dGhpcy5fcG9pbnQgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLl9wb2ludC54IC0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcyKS54O1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIGNpcmNsZSBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25zIG9iamVjdFxuLy8gd2hpY2ggY29udGFpbnMgdGhlIGNpcmNsZSByYWRpdXMuXG4vLyBAYWx0ZXJuYXRpdmVcbi8vIEBmYWN0b3J5IEwuY2lyY2xlKGxhdGxuZzogTGF0TG5nLCByYWRpdXM6IE51bWJlciwgb3B0aW9ucz86IENpcmNsZSBvcHRpb25zKVxuLy8gT2Jzb2xldGUgd2F5IG9mIGluc3RhbnRpYXRpbmcgYSBjaXJjbGUsIGZvciBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggY29kZS5cbi8vIERvIG5vdCB1c2UgaW4gbmV3IGFwcGxpY2F0aW9ucyBvciBwbHVnaW5zLlxuZXhwb3J0IGZ1bmN0aW9uIGNpcmNsZShsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBDaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKTtcbn1cbiIsImltcG9ydCB7UGF0aH0gZnJvbSAnLi9QYXRoJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIExpbmVVdGlsIGZyb20gJy4uLy4uL2dlb21ldHJ5L0xpbmVVdGlsJztcbmltcG9ydCB7TGF0TG5nLCB0b0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcblxuLypcbiAqIEBjbGFzcyBQb2x5bGluZVxuICogQGFrYSBMLlBvbHlsaW5lXG4gKiBAaW5oZXJpdHMgUGF0aFxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcG9seWxpbmUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBhdGhgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogXHRbNDUuNTEsIC0xMjIuNjhdLFxuICogXHRbMzcuNzcsIC0xMjIuNDNdLFxuICogXHRbMzQuMDQsIC0xMTguMl1cbiAqIF07XG4gKlxuICogdmFyIHBvbHlsaW5lID0gTC5wb2x5bGluZShsYXRsbmdzLCB7Y29sb3I6ICdyZWQnfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlsaW5lXG4gKiBtYXAuZml0Qm91bmRzKHBvbHlsaW5lLmdldEJvdW5kcygpKTtcbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gYWxzbyBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgYE11bHRpUG9seWxpbmVgIHNoYXBlOlxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWxpbmUgZnJvbSBhbiBhcnJheSBvZiBhcnJheXMgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiBcdFtbNDUuNTEsIC0xMjIuNjhdLFxuICogXHQgWzM3Ljc3LCAtMTIyLjQzXSxcbiAqIFx0IFszNC4wNCwgLTExOC4yXV0sXG4gKiBcdFtbNDAuNzgsIC03My45MV0sXG4gKiBcdCBbNDEuODMsIC04Ny42Ml0sXG4gKiBcdCBbMzIuNzYsIC05Ni43Ml1dXG4gKiBdO1xuICogYGBgXG4gKi9cblxuXG5leHBvcnQgdmFyIFBvbHlsaW5lID0gUGF0aC5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUG9seWxpbmUgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBzbW9vdGhGYWN0b3I6IE51bWJlciA9IDEuMFxuXHRcdC8vIEhvdyBtdWNoIHRvIHNpbXBsaWZ5IHRoZSBwb2x5bGluZSBvbiBlYWNoIHpvb20gbGV2ZWwuIE1vcmUgbWVhbnNcblx0XHQvLyBiZXR0ZXIgcGVyZm9ybWFuY2UgYW5kIHNtb290aGVyIGxvb2ssIGFuZCBsZXNzIG1lYW5zIG1vcmUgYWNjdXJhdGUgcmVwcmVzZW50YXRpb24uXG5cdFx0c21vb3RoRmFjdG9yOiAxLjAsXG5cblx0XHQvLyBAb3B0aW9uIG5vQ2xpcDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gRGlzYWJsZSBwb2x5bGluZSBjbGlwcGluZy5cblx0XHRub0NsaXA6IGZhbHNlXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fc2V0TGF0TG5ncyhsYXRsbmdzKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldExhdExuZ3MoKTogTGF0TG5nW11cblx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcG9pbnRzIGluIHRoZSBwYXRoLCBvciBuZXN0ZWQgYXJyYXlzIG9mIHBvaW50cyBpbiBjYXNlIG9mIG11bHRpLXBvbHlsaW5lLlxuXHRnZXRMYXRMbmdzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZ3M7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmdzKGxhdGxuZ3M6IExhdExuZ1tdKTogdGhpc1xuXHQvLyBSZXBsYWNlcyBhbGwgdGhlIHBvaW50cyBpbiB0aGUgcG9seWxpbmUgd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2YgZ2VvZ3JhcGhpY2FsIHBvaW50cy5cblx0c2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNFbXB0eSgpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBQb2x5bGluZSBoYXMgbm8gTGF0TG5ncy5cblx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGg7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZXN0TGF5ZXJQb2ludChwOiBQb2ludCk6IFBvaW50XG5cdC8vIFJldHVybnMgdGhlIHBvaW50IGNsb3Nlc3QgdG8gYHBgIG9uIHRoZSBQb2x5bGluZS5cblx0Y2xvc2VzdExheWVyUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG5cdFx0dmFyIG1pbkRpc3RhbmNlID0gSW5maW5pdHksXG5cdFx0ICAgIG1pblBvaW50ID0gbnVsbCxcblx0XHQgICAgY2xvc2VzdCA9IExpbmVVdGlsLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudCxcblx0XHQgICAgcDEsIHAyO1xuXG5cdFx0Zm9yICh2YXIgaiA9IDAsIGpMZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcblx0XHRcdHZhciBwb2ludHMgPSB0aGlzLl9wYXJ0c1tqXTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDEsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRwMSA9IHBvaW50c1tpIC0gMV07XG5cdFx0XHRcdHAyID0gcG9pbnRzW2ldO1xuXG5cdFx0XHRcdHZhciBzcURpc3QgPSBjbG9zZXN0KHAsIHAxLCBwMiwgdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKHNxRGlzdCA8IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHRcdFx0bWluRGlzdGFuY2UgPSBzcURpc3Q7XG5cdFx0XHRcdFx0bWluUG9pbnQgPSBjbG9zZXN0KHAsIHAxLCBwMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG1pblBvaW50KSB7XG5cdFx0XHRtaW5Qb2ludC5kaXN0YW5jZSA9IE1hdGguc3FydChtaW5EaXN0YW5jZSk7XG5cdFx0fVxuXHRcdHJldHVybiBtaW5Qb2ludDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIHBvbHlsaW5lLlxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB0aHJvd3MgZXJyb3Igd2hlbiBub3QgeWV0IGFkZGVkIHRvIG1hcCBhcyB0aGlzIGNlbnRlciBjYWxjdWxhdGlvbiByZXF1aXJlcyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IGFkZCBsYXllciB0byBtYXAgYmVmb3JlIHVzaW5nIGdldENlbnRlcigpJyk7XG5cdFx0fVxuXHRcdHJldHVybiBMaW5lVXRpbC5wb2x5bGluZUNlbnRlcih0aGlzLl9kZWZhdWx0U2hhcGUoKSwgdGhpcy5fbWFwLm9wdGlvbnMuY3JzKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcblx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBhZGRMYXRMbmcobGF0bG5nOiBMYXRMbmcsIGxhdGxuZ3M/OiBMYXRMbmdbXSk6IHRoaXNcblx0Ly8gQWRkcyBhIGdpdmVuIHBvaW50IHRvIHRoZSBwb2x5bGluZS4gQnkgZGVmYXVsdCwgYWRkcyB0byB0aGUgZmlyc3QgcmluZyBvZlxuXHQvLyB0aGUgcG9seWxpbmUgaW4gY2FzZSBvZiBhIG11bHRpLXBvbHlsaW5lLCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgcGFzc2luZ1xuXHQvLyBhIHNwZWNpZmljIHJpbmcgYXMgYSBMYXRMbmcgYXJyYXkgKHRoYXQgeW91IGNhbiBlYXJsaWVyIGFjY2VzcyB3aXRoIFtgZ2V0TGF0TG5nc2BdKCNwb2x5bGluZS1nZXRsYXRsbmdzKSkuXG5cdGFkZExhdExuZzogZnVuY3Rpb24gKGxhdGxuZywgbGF0bG5ncykge1xuXHRcdGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuX2RlZmF1bHRTaGFwZSgpO1xuXHRcdGxhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XG5cdFx0dGhpcy5fYm91bmRzLmV4dGVuZChsYXRsbmcpO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoKTtcblx0XHR0aGlzLl9sYXRsbmdzID0gdGhpcy5fY29udmVydExhdExuZ3MobGF0bG5ncyk7XG5cdH0sXG5cblx0X2RlZmF1bHRTaGFwZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncykgPyB0aGlzLl9sYXRsbmdzIDogdGhpcy5fbGF0bG5nc1swXTtcblx0fSxcblxuXHQvLyByZWN1cnNpdmVseSBjb252ZXJ0IGxhdGxuZ3MgaW5wdXQgaW50byBhY3R1YWwgTGF0TG5nIGluc3RhbmNlczsgY2FsY3VsYXRlIGJvdW5kcyBhbG9uZyB0aGUgd2F5XG5cdF9jb252ZXJ0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR2YXIgcmVzdWx0ID0gW10sXG5cdFx0ICAgIGZsYXQgPSBMaW5lVXRpbC5pc0ZsYXQobGF0bG5ncyk7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGZsYXQpIHtcblx0XHRcdFx0cmVzdWx0W2ldID0gdG9MYXRMbmcobGF0bG5nc1tpXSk7XG5cdFx0XHRcdHRoaXMuX2JvdW5kcy5leHRlbmQocmVzdWx0W2ldKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3NbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHhCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG5cdFx0dGhpcy5fcmluZ3MgPSBbXTtcblx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyh0aGlzLl9sYXRsbmdzLCB0aGlzLl9yaW5ncywgcHhCb3VuZHMpO1xuXG5cdFx0aWYgKHRoaXMuX2JvdW5kcy5pc1ZhbGlkKCkgJiYgcHhCb3VuZHMuaXNWYWxpZCgpKSB7XG5cdFx0XHR0aGlzLl9yYXdQeEJvdW5kcyA9IHB4Qm91bmRzO1xuXHRcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCksXG5cdFx0ICAgIHAgPSBuZXcgUG9pbnQodywgdyk7XG5cblx0XHRpZiAoIXRoaXMuX3Jhd1B4Qm91bmRzKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fcHhCb3VuZHMgPSBuZXcgQm91bmRzKFtcblx0XHRcdHRoaXMuX3Jhd1B4Qm91bmRzLm1pbi5zdWJ0cmFjdChwKSxcblx0XHRcdHRoaXMuX3Jhd1B4Qm91bmRzLm1heC5hZGQocClcblx0XHRdKTtcblx0fSxcblxuXHQvLyByZWN1cnNpdmVseSB0dXJucyBsYXRsbmdzIGludG8gYSBzZXQgb2YgcmluZ3Mgd2l0aCBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0X3Byb2plY3RMYXRsbmdzOiBmdW5jdGlvbiAobGF0bG5ncywgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpIHtcblx0XHR2YXIgZmxhdCA9IGxhdGxuZ3NbMF0gaW5zdGFuY2VvZiBMYXRMbmcsXG5cdFx0ICAgIGxlbiA9IGxhdGxuZ3MubGVuZ3RoLFxuXHRcdCAgICBpLCByaW5nO1xuXG5cdFx0aWYgKGZsYXQpIHtcblx0XHRcdHJpbmcgPSBbXTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRyaW5nW2ldID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmdzW2ldKTtcblx0XHRcdFx0cHJvamVjdGVkQm91bmRzLmV4dGVuZChyaW5nW2ldKTtcblx0XHRcdH1cblx0XHRcdHJlc3VsdC5wdXNoKHJpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fcHJvamVjdExhdGxuZ3MobGF0bG5nc1tpXSwgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBjbGlwIHBvbHlsaW5lIGJ5IHJlbmRlcmVyIGJvdW5kcyBzbyB0aGF0IHdlIGhhdmUgbGVzcyB0byByZW5kZXIgZm9yIHBlcmZvcm1hbmNlXG5cdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlbmRlcmVyLl9ib3VuZHM7XG5cblx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxuXHRcdCAgICBpLCBqLCBrLCBsZW4sIGxlbjIsIHNlZ21lbnQsIHBvaW50cztcblxuXHRcdGZvciAoaSA9IDAsIGsgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cG9pbnRzID0gdGhpcy5fcmluZ3NbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMiAtIDE7IGorKykge1xuXHRcdFx0XHRzZWdtZW50ID0gTGluZVV0aWwuY2xpcFNlZ21lbnQocG9pbnRzW2pdLCBwb2ludHNbaiArIDFdLCBib3VuZHMsIGosIHRydWUpO1xuXG5cdFx0XHRcdGlmICghc2VnbWVudCkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRcdHBhcnRzW2tdID0gcGFydHNba10gfHwgW107XG5cdFx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFswXSk7XG5cblx0XHRcdFx0Ly8gaWYgc2VnbWVudCBnb2VzIG91dCBvZiBzY3JlZW4sIG9yIGl0J3MgdGhlIGxhc3Qgb25lLCBpdCdzIHRoZSBlbmQgb2YgdGhlIGxpbmUgcGFydFxuXHRcdFx0XHRpZiAoKHNlZ21lbnRbMV0gIT09IHBvaW50c1tqICsgMV0pIHx8IChqID09PSBsZW4yIC0gMikpIHtcblx0XHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMV0pO1xuXHRcdFx0XHRcdGsrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBzaW1wbGlmeSBlYWNoIGNsaXBwZWQgcGFydCBvZiB0aGUgcG9seWxpbmUgZm9yIHBlcmZvcm1hbmNlXG5cdF9zaW1wbGlmeVBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxuXHRcdCAgICB0b2xlcmFuY2UgPSB0aGlzLm9wdGlvbnMuc21vb3RoRmFjdG9yO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwYXJ0c1tpXSA9IExpbmVVdGlsLnNpbXBsaWZ5KHBhcnRzW2ldLCB0b2xlcmFuY2UpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9jbGlwUG9pbnRzKCk7XG5cdFx0dGhpcy5fc2ltcGxpZnlQb2ludHMoKTtcblx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzKTtcblx0fSxcblxuXHQvLyBOZWVkZWQgYnkgdGhlIGBDYW52YXNgIHJlbmRlcmVyIGZvciBpbnRlcmFjdGl2aXR5XG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCwgY2xvc2VkKSB7XG5cdFx0dmFyIGksIGosIGssIGxlbiwgbGVuMiwgcGFydCxcblx0XHQgICAgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCk7XG5cblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdC8vIGhpdCBkZXRlY3Rpb24gZm9yIHBvbHlsaW5lc1xuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuXHRcdFx0XHRpZiAoIWNsb3NlZCAmJiAoaiA9PT0gMCkpIHsgY29udGludWU7IH1cblxuXHRcdFx0XHRpZiAoTGluZVV0aWwucG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwYXJ0W2tdLCBwYXJ0W2pdKSA8PSB3KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5wb2x5bGluZShsYXRsbmdzOiBMYXRMbmdbXSwgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBwb2x5bGluZSBvYmplY3QgZ2l2ZW4gYW4gYXJyYXkgb2YgZ2VvZ3JhcGhpY2FsIHBvaW50cyBhbmRcbi8vIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuIFlvdSBjYW4gY3JlYXRlIGEgYFBvbHlsaW5lYCBvYmplY3Qgd2l0aFxuLy8gbXVsdGlwbGUgc2VwYXJhdGUgbGluZXMgKGBNdWx0aVBvbHlsaW5lYCkgYnkgcGFzc2luZyBhbiBhcnJheSBvZiBhcnJheXNcbi8vIG9mIGdlb2dyYXBoaWMgcG9pbnRzLlxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBQb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcbn1cblxuLy8gUmV0cm9jb21wYXQuIEFsbG93IHBsdWdpbnMgdG8gc3VwcG9ydCBMZWFmbGV0IHZlcnNpb25zIGJlZm9yZSBhbmQgYWZ0ZXIgMS4xLlxuUG9seWxpbmUuX2ZsYXQgPSBMaW5lVXRpbC5fZmxhdDtcbiIsImltcG9ydCB7UG9seWxpbmV9IGZyb20gJy4vUG9seWxpbmUnO1xuaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xuaW1wb3J0ICogYXMgTGluZVV0aWwgZnJvbSAnLi4vLi4vZ2VvbWV0cnkvTGluZVV0aWwnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQgKiBhcyBQb2x5VXRpbCBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2x5VXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgUG9seWdvblxuICogQGFrYSBMLlBvbHlnb25cbiAqIEBpbmhlcml0cyBQb2x5bGluZVxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcG9seWdvbiBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUG9seWxpbmVgLlxuICpcbiAqIE5vdGUgdGhhdCBwb2ludHMgeW91IHBhc3Mgd2hlbiBjcmVhdGluZyBhIHBvbHlnb24gc2hvdWxkbid0IGhhdmUgYW4gYWRkaXRpb25hbCBsYXN0IHBvaW50IGVxdWFsIHRvIHRoZSBmaXJzdCBvbmUg4oCUIGl0J3MgYmV0dGVyIHRvIGZpbHRlciBvdXQgc3VjaCBwb2ludHMuXG4gKlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5Z29uIGZyb20gYW4gYXJyYXkgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV07XG4gKlxuICogdmFyIHBvbHlnb24gPSBMLnBvbHlnb24obGF0bG5ncywge2NvbG9yOiAncmVkJ30pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSBwb2x5Z29uXG4gKiBtYXAuZml0Qm91bmRzKHBvbHlnb24uZ2V0Qm91bmRzKCkpO1xuICogYGBgXG4gKlxuICogWW91IGNhbiBhbHNvIHBhc3MgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIGxhdGxuZ3MsIHdpdGggdGhlIGZpcnN0IGFycmF5IHJlcHJlc2VudGluZyB0aGUgb3V0ZXIgc2hhcGUgYW5kIHRoZSBvdGhlciBhcnJheXMgcmVwcmVzZW50aW5nIGhvbGVzIGluIHRoZSBvdXRlciBzaGFwZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiAgIFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXSwgLy8gb3V0ZXIgcmluZ1xuICogICBbWzM3LjI5LCAtMTA4LjU4XSxbNDAuNzEsIC0xMDguNThdLFs0MC43MSwgLTEwMi41MF0sWzM3LjI5LCAtMTAyLjUwXV0gLy8gaG9sZVxuICogXTtcbiAqIGBgYFxuICpcbiAqIEFkZGl0aW9uYWxseSwgeW91IGNhbiBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgTXVsdGlQb2x5Z29uIHNoYXBlLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqICAgWyAvLyBmaXJzdCBwb2x5Z29uXG4gKiAgICAgW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dLCAvLyBvdXRlciByaW5nXG4gKiAgICAgW1szNy4yOSwgLTEwOC41OF0sWzQwLjcxLCAtMTA4LjU4XSxbNDAuNzEsIC0xMDIuNTBdLFszNy4yOSwgLTEwMi41MF1dIC8vIGhvbGVcbiAqICAgXSxcbiAqICAgWyAvLyBzZWNvbmQgcG9seWdvblxuICogICAgIFtbNDEsIC0xMTEuMDNdLFs0NSwgLTExMS4wNF0sWzQ1LCAtMTA0LjA1XSxbNDEsIC0xMDQuMDVdXVxuICogICBdXG4gKiBdO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBQb2x5Z29uID0gUG9seWxpbmUuZXh0ZW5kKHtcblxuXHRvcHRpb25zOiB7XG5cdFx0ZmlsbDogdHJ1ZVxuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2xhdGxuZ3MubGVuZ3RoIHx8ICF0aGlzLl9sYXRsbmdzWzBdLmxlbmd0aDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgUG9seWdvbi5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTXVzdCBhZGQgbGF5ZXIgdG8gbWFwIGJlZm9yZSB1c2luZyBnZXRDZW50ZXIoKScpO1xuXHRcdH1cblx0XHRyZXR1cm4gUG9seVV0aWwucG9seWdvbkNlbnRlcih0aGlzLl9kZWZhdWx0U2hhcGUoKSwgdGhpcy5fbWFwLm9wdGlvbnMuY3JzKTtcblx0fSxcblxuXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFBvbHlsaW5lLnByb3RvdHlwZS5fY29udmVydExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKSxcblx0XHQgICAgbGVuID0gcmVzdWx0Lmxlbmd0aDtcblxuXHRcdC8vIHJlbW92ZSBsYXN0IHBvaW50IGlmIGl0IGVxdWFscyBmaXJzdCBvbmVcblx0XHRpZiAobGVuID49IDIgJiYgcmVzdWx0WzBdIGluc3RhbmNlb2YgTGF0TG5nICYmIHJlc3VsdFswXS5lcXVhbHMocmVzdWx0W2xlbiAtIDFdKSkge1xuXHRcdFx0cmVzdWx0LnBvcCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdFBvbHlsaW5lLnByb3RvdHlwZS5fc2V0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpO1xuXHRcdGlmIChMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncykpIHtcblx0XHRcdHRoaXMuX2xhdGxuZ3MgPSBbdGhpcy5fbGF0bG5nc107XG5cdFx0fVxuXHR9LFxuXG5cdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pID8gdGhpcy5fbGF0bG5nc1swXSA6IHRoaXMuX2xhdGxuZ3NbMF1bMF07XG5cdH0sXG5cblx0X2NsaXBQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwb2x5Z29ucyBuZWVkIGEgZGlmZmVyZW50IGNsaXBwaW5nIGFsZ29yaXRobSBzbyB3ZSByZWRlZmluZSB0aGF0XG5cblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcyxcblx0XHQgICAgdyA9IHRoaXMub3B0aW9ucy53ZWlnaHQsXG5cdFx0ICAgIHAgPSBuZXcgUG9pbnQodywgdyk7XG5cblx0XHQvLyBpbmNyZWFzZSBjbGlwIHBhZGRpbmcgYnkgc3Ryb2tlIHdpZHRoIHRvIGF2b2lkIHN0cm9rZSBvbiBjbGlwIGVkZ2VzXG5cdFx0Ym91bmRzID0gbmV3IEJvdW5kcyhib3VuZHMubWluLnN1YnRyYWN0KHApLCBib3VuZHMubWF4LmFkZChwKSk7XG5cblx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGgsIGNsaXBwZWQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Y2xpcHBlZCA9IFBvbHlVdGlsLmNsaXBQb2x5Z29uKHRoaXMuX3JpbmdzW2ldLCBib3VuZHMsIHRydWUpO1xuXHRcdFx0aWYgKGNsaXBwZWQubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuX3BhcnRzLnB1c2goY2xpcHBlZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcywgdHJ1ZSk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHR2YXIgaW5zaWRlID0gZmFsc2UsXG5cdFx0ICAgIHBhcnQsIHAxLCBwMiwgaSwgaiwgaywgbGVuLCBsZW4yO1xuXG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyByYXkgY2FzdGluZyBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBpZiBwb2ludCBpcyBpbiBwb2x5Z29uXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG5cdFx0XHRcdHAxID0gcGFydFtqXTtcblx0XHRcdFx0cDIgPSBwYXJ0W2tdO1xuXG5cdFx0XHRcdGlmICgoKHAxLnkgPiBwLnkpICE9PSAocDIueSA+IHAueSkpICYmIChwLnggPCAocDIueCAtIHAxLngpICogKHAueSAtIHAxLnkpIC8gKHAyLnkgLSBwMS55KSArIHAxLngpKSB7XG5cdFx0XHRcdFx0aW5zaWRlID0gIWluc2lkZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGFsc28gY2hlY2sgaWYgaXQncyBvbiBwb2x5Z29uIHN0cm9rZVxuXHRcdHJldHVybiBpbnNpZGUgfHwgUG9seWxpbmUucHJvdG90eXBlLl9jb250YWluc1BvaW50LmNhbGwodGhpcywgcCwgdHJ1ZSk7XG5cdH1cblxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5wb2x5Z29uKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbmV4cG9ydCBmdW5jdGlvbiBwb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBQb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xufVxuIiwiaW1wb3J0IHtMYXllckdyb3VwfSBmcm9tICcuL0xheWVyR3JvdXAnO1xyXG5pbXBvcnQge0ZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7TWFya2VyfSBmcm9tICcuL21hcmtlci9NYXJrZXInO1xyXG5pbXBvcnQge0NpcmNsZX0gZnJvbSAnLi92ZWN0b3IvQ2lyY2xlJztcclxuaW1wb3J0IHtDaXJjbGVNYXJrZXJ9IGZyb20gJy4vdmVjdG9yL0NpcmNsZU1hcmtlcic7XHJcbmltcG9ydCB7UG9seWxpbmV9IGZyb20gJy4vdmVjdG9yL1BvbHlsaW5lJztcclxuaW1wb3J0IHtQb2x5Z29ufSBmcm9tICcuL3ZlY3Rvci9Qb2x5Z29uJztcclxuaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuLi9nZW9tZXRyeS9MaW5lVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5cclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBHZW9KU09OXHJcbiAqIEBha2EgTC5HZW9KU09OXHJcbiAqIEBpbmhlcml0cyBGZWF0dXJlR3JvdXBcclxuICpcclxuICogUmVwcmVzZW50cyBhIEdlb0pTT04gb2JqZWN0IG9yIGFuIGFycmF5IG9mIEdlb0pTT04gb2JqZWN0cy4gQWxsb3dzIHlvdSB0byBwYXJzZVxyXG4gKiBHZW9KU09OIGRhdGEgYW5kIGRpc3BsYXkgaXQgb24gdGhlIG1hcC4gRXh0ZW5kcyBgRmVhdHVyZUdyb3VwYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5nZW9KU09OKGRhdGEsIHtcclxuICogXHRzdHlsZTogZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuICogXHRcdHJldHVybiB7Y29sb3I6IGZlYXR1cmUucHJvcGVydGllcy5jb2xvcn07XHJcbiAqIFx0fVxyXG4gKiB9KS5iaW5kUG9wdXAoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAqIFx0cmV0dXJuIGxheWVyLmZlYXR1cmUucHJvcGVydGllcy5kZXNjcmlwdGlvbjtcclxuICogfSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBHZW9KU09OID0gRmVhdHVyZUdyb3VwLmV4dGVuZCh7XHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQGFrYSBHZW9KU09OIG9wdGlvbnNcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gcG9pbnRUb0xheWVyOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgZGVmaW5pbmcgaG93IEdlb0pTT04gcG9pbnRzIHNwYXduIExlYWZsZXQgbGF5ZXJzLiBJdCBpcyBpbnRlcm5hbGx5XHJcblx0ICogY2FsbGVkIHdoZW4gZGF0YSBpcyBhZGRlZCwgcGFzc2luZyB0aGUgR2VvSlNPTiBwb2ludCBmZWF0dXJlIGFuZCBpdHMgYExhdExuZ2AuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gc3Bhd24gYSBkZWZhdWx0IGBNYXJrZXJgOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24oZ2VvSnNvblBvaW50LCBsYXRsbmcpIHtcclxuXHQgKiBcdHJldHVybiBMLm1hcmtlcihsYXRsbmcpO1xyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc3R5bGU6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyB0aGUgYFBhdGggb3B0aW9uc2AgZm9yIHN0eWxpbmcgR2VvSlNPTiBsaW5lcyBhbmQgcG9seWdvbnMsXHJcblx0ICogY2FsbGVkIGludGVybmFsbHkgd2hlbiBkYXRhIGlzIGFkZGVkLlxyXG5cdCAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRvIG5vdCBvdmVycmlkZSBhbnkgZGVmYXVsdHM6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbiAoZ2VvSnNvbkZlYXR1cmUpIHtcclxuXHQgKiBcdHJldHVybiB7fVxyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gb25FYWNoRmVhdHVyZTogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSBmb3IgZWFjaCBjcmVhdGVkIGBGZWF0dXJlYCwgYWZ0ZXIgaXQgaGFzXHJcblx0ICogYmVlbiBjcmVhdGVkIGFuZCBzdHlsZWQuIFVzZWZ1bCBmb3IgYXR0YWNoaW5nIGV2ZW50cyBhbmQgcG9wdXBzIHRvIGZlYXR1cmVzLlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIGRvIG5vdGhpbmcgd2l0aCB0aGUgbmV3bHkgY3JlYXRlZCBsYXllcnM6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbiAoZmVhdHVyZSwgbGF5ZXIpIHt9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGZpbHRlcjogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGRlY2lkZSB3aGV0aGVyIHRvIGluY2x1ZGUgYSBmZWF0dXJlIG9yIG5vdC5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBpbmNsdWRlIGFsbCBmZWF0dXJlczpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG5cdCAqIFx0cmV0dXJuIHRydWU7XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqIE5vdGU6IGR5bmFtaWNhbGx5IGNoYW5naW5nIHRoZSBgZmlsdGVyYCBvcHRpb24gd2lsbCBoYXZlIGVmZmVjdCBvbmx5IG9uIG5ld2x5XHJcblx0ICogYWRkZWQgZGF0YS4gSXQgd2lsbCBfbm90XyByZS1ldmFsdWF0ZSBhbHJlYWR5IGluY2x1ZGVkIGZlYXR1cmVzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBjb29yZHNUb0xhdExuZzogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBjb252ZXJ0aW5nIEdlb0pTT04gY29vcmRpbmF0ZXMgdG8gYExhdExuZ2BzLlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRoZSBgY29vcmRzVG9MYXRMbmdgIHN0YXRpYyBtZXRob2QuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIG1hcmtlcnNJbmhlcml0T3B0aW9uczogQm9vbGVhbiA9IGZhbHNlXHJcblx0ICogV2hldGhlciBkZWZhdWx0IE1hcmtlcnMgZm9yIFwiUG9pbnRcIiB0eXBlIEZlYXR1cmVzIGluaGVyaXQgZnJvbSBncm91cCBvcHRpb25zLlxyXG5cdCAqL1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cclxuXHRcdGlmIChnZW9qc29uKSB7XHJcblx0XHRcdHRoaXMuYWRkRGF0YShnZW9qc29uKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZERhdGEoIDxHZW9KU09OPiBkYXRhICk6IHRoaXNcclxuXHQvLyBBZGRzIGEgR2VvSlNPTiBvYmplY3QgdG8gdGhlIGxheWVyLlxyXG5cdGFkZERhdGE6IGZ1bmN0aW9uIChnZW9qc29uKSB7XHJcblx0XHR2YXIgZmVhdHVyZXMgPSBVdGlsLmlzQXJyYXkoZ2VvanNvbikgPyBnZW9qc29uIDogZ2VvanNvbi5mZWF0dXJlcyxcclxuXHRcdCAgICBpLCBsZW4sIGZlYXR1cmU7XHJcblxyXG5cdFx0aWYgKGZlYXR1cmVzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0Ly8gb25seSBhZGQgdGhpcyBpZiBnZW9tZXRyeSBvciBnZW9tZXRyaWVzIGFyZSBzZXQgYW5kIG5vdCBudWxsXHJcblx0XHRcdFx0ZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xyXG5cdFx0XHRcdGlmIChmZWF0dXJlLmdlb21ldHJpZXMgfHwgZmVhdHVyZS5nZW9tZXRyeSB8fCBmZWF0dXJlLmZlYXR1cmVzIHx8IGZlYXR1cmUuY29vcmRpbmF0ZXMpIHtcclxuXHRcdFx0XHRcdHRoaXMuYWRkRGF0YShmZWF0dXJlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuZmlsdGVyICYmICFvcHRpb25zLmZpbHRlcihnZW9qc29uKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBsYXllciA9IGdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zKTtcclxuXHRcdGlmICghbGF5ZXIpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRsYXllci5mZWF0dXJlID0gYXNGZWF0dXJlKGdlb2pzb24pO1xyXG5cclxuXHRcdGxheWVyLmRlZmF1bHRPcHRpb25zID0gbGF5ZXIub3B0aW9ucztcclxuXHRcdHRoaXMucmVzZXRTdHlsZShsYXllcik7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub25FYWNoRmVhdHVyZSkge1xyXG5cdFx0XHRvcHRpb25zLm9uRWFjaEZlYXR1cmUoZ2VvanNvbiwgbGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmFkZExheWVyKGxheWVyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlc2V0U3R5bGUoIDxQYXRoPiBsYXllcj8gKTogdGhpc1xyXG5cdC8vIFJlc2V0cyB0aGUgZ2l2ZW4gdmVjdG9yIGxheWVyJ3Mgc3R5bGUgdG8gdGhlIG9yaWdpbmFsIEdlb0pTT04gc3R5bGUsIHVzZWZ1bCBmb3IgcmVzZXR0aW5nIHN0eWxlIGFmdGVyIGhvdmVyIGV2ZW50cy5cclxuXHQvLyBJZiBgbGF5ZXJgIGlzIG9taXR0ZWQsIHRoZSBzdHlsZSBvZiBhbGwgZmVhdHVyZXMgaW4gdGhlIGN1cnJlbnQgbGF5ZXIgaXMgcmVzZXQuXHJcblx0cmVzZXRTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIodGhpcy5yZXNldFN0eWxlLCB0aGlzKTtcclxuXHRcdH1cclxuXHRcdC8vIHJlc2V0IGFueSBjdXN0b20gc3R5bGVzXHJcblx0XHRsYXllci5vcHRpb25zID0gVXRpbC5leHRlbmQoe30sIGxheWVyLmRlZmF1bHRPcHRpb25zKTtcclxuXHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHRoaXMub3B0aW9ucy5zdHlsZSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKCA8RnVuY3Rpb24+IHN0eWxlICk6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHN0eWxlcyBvZiBHZW9KU09OIHZlY3RvciBsYXllcnMgd2l0aCB0aGUgZ2l2ZW4gc3R5bGUgZnVuY3Rpb24uXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCBzdHlsZSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfc2V0TGF5ZXJTdHlsZTogZnVuY3Rpb24gKGxheWVyLCBzdHlsZSkge1xyXG5cdFx0aWYgKGxheWVyLnNldFN0eWxlKSB7XHJcblx0XHRcdGlmICh0eXBlb2Ygc3R5bGUgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRzdHlsZSA9IHN0eWxlKGxheWVyLmZlYXR1cmUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxheWVyLnNldFN0eWxlKHN0eWxlKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQHNlY3Rpb25cclxuLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLkdlb0pTT046XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2VvbWV0cnlUb0xheWVyKGZlYXR1cmVEYXRhOiBPYmplY3QsIG9wdGlvbnM/OiBHZW9KU09OIG9wdGlvbnMpOiBMYXllclxyXG4vLyBDcmVhdGVzIGEgYExheWVyYCBmcm9tIGEgZ2l2ZW4gR2VvSlNPTiBmZWF0dXJlLiBDYW4gdXNlIGEgY3VzdG9tXHJcbi8vIFtgcG9pbnRUb0xheWVyYF0oI2dlb2pzb24tcG9pbnR0b2xheWVyKSBhbmQvb3IgW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKVxyXG4vLyBmdW5jdGlvbnMgaWYgcHJvdmlkZWQgYXMgb3B0aW9ucy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zKSB7XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnID8gZ2VvanNvbi5nZW9tZXRyeSA6IGdlb2pzb24sXHJcblx0ICAgIGNvb3JkcyA9IGdlb21ldHJ5ID8gZ2VvbWV0cnkuY29vcmRpbmF0ZXMgOiBudWxsLFxyXG5cdCAgICBsYXllcnMgPSBbXSxcclxuXHQgICAgcG9pbnRUb0xheWVyID0gb3B0aW9ucyAmJiBvcHRpb25zLnBvaW50VG9MYXllcixcclxuXHQgICAgX2Nvb3Jkc1RvTGF0TG5nID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvb3Jkc1RvTGF0TG5nIHx8IGNvb3Jkc1RvTGF0TG5nLFxyXG5cdCAgICBsYXRsbmcsIGxhdGxuZ3MsIGksIGxlbjtcclxuXHJcblx0aWYgKCFjb29yZHMgJiYgIWdlb21ldHJ5KSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xyXG5cdGNhc2UgJ1BvaW50JzpcclxuXHRcdGxhdGxuZyA9IF9jb29yZHNUb0xhdExuZyhjb29yZHMpO1xyXG5cdFx0cmV0dXJuIF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyLCBnZW9qc29uLCBsYXRsbmcsIG9wdGlvbnMpO1xyXG5cclxuXHRjYXNlICdNdWx0aVBvaW50JzpcclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRsYXRsbmcgPSBfY29vcmRzVG9MYXRMbmcoY29vcmRzW2ldKTtcclxuXHRcdFx0bGF5ZXJzLnB1c2goX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXIsIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucykpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0Y2FzZSAnTGluZVN0cmluZyc6XHJcblx0Y2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcclxuXHRcdGxhdGxuZ3MgPSBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycgPyAwIDogMSwgX2Nvb3Jkc1RvTGF0TG5nKTtcclxuXHRcdHJldHVybiBuZXcgUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG5cdGNhc2UgJ1BvbHlnb24nOlxyXG5cdGNhc2UgJ011bHRpUG9seWdvbic6XHJcblx0XHRsYXRsbmdzID0gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nID8gMSA6IDIsIF9jb29yZHNUb0xhdExuZyk7XHJcblx0XHRyZXR1cm4gbmV3IFBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG5cdGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHZhciBnZW9MYXllciA9IGdlb21ldHJ5VG9MYXllcih7XHJcblx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5Lmdlb21ldHJpZXNbaV0sXHJcblx0XHRcdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG5cdFx0XHRcdHByb3BlcnRpZXM6IGdlb2pzb24ucHJvcGVydGllc1xyXG5cdFx0XHR9LCBvcHRpb25zKTtcclxuXHJcblx0XHRcdGlmIChnZW9MYXllcikge1xyXG5cdFx0XHRcdGxheWVycy5wdXNoKGdlb0xheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0Y2FzZSAnRmVhdHVyZUNvbGxlY3Rpb24nOlxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gZ2VvbWV0cnkuZmVhdHVyZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dmFyIGZlYXR1cmVMYXllciA9IGdlb21ldHJ5VG9MYXllcihnZW9tZXRyeS5mZWF0dXJlc1tpXSwgb3B0aW9ucyk7XHJcblxyXG5cdFx0XHRpZiAoZmVhdHVyZUxheWVyKSB7XHJcblx0XHRcdFx0bGF5ZXJzLnB1c2goZmVhdHVyZUxheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0ZGVmYXVsdDpcclxuXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHZW9KU09OIG9iamVjdC4nKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyRm4sIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucykge1xyXG5cdHJldHVybiBwb2ludFRvTGF5ZXJGbiA/XHJcblx0XHRwb2ludFRvTGF5ZXJGbihnZW9qc29uLCBsYXRsbmcpIDpcclxuXHRcdG5ldyBNYXJrZXIobGF0bG5nLCBvcHRpb25zICYmIG9wdGlvbnMubWFya2Vyc0luaGVyaXRPcHRpb25zICYmIG9wdGlvbnMpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmcoY29vcmRzOiBBcnJheSk6IExhdExuZ1xyXG4vLyBDcmVhdGVzIGEgYExhdExuZ2Agb2JqZWN0IGZyb20gYW4gYXJyYXkgb2YgMiBudW1iZXJzIChsb25naXR1ZGUsIGxhdGl0dWRlKVxyXG4vLyBvciAzIG51bWJlcnMgKGxvbmdpdHVkZSwgbGF0aXR1ZGUsIGFsdGl0dWRlKSB1c2VkIGluIEdlb0pTT04gZm9yIHBvaW50cy5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5nKGNvb3Jkcykge1xyXG5cdHJldHVybiBuZXcgTGF0TG5nKGNvb3Jkc1sxXSwgY29vcmRzWzBdLCBjb29yZHNbMl0pO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmdzKGNvb3JkczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNvb3Jkc1RvTGF0TG5nPzogRnVuY3Rpb24pOiBBcnJheVxyXG4vLyBDcmVhdGVzIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheSBvZiBgTGF0TG5nYHMgZnJvbSBhIEdlb0pTT04gY29vcmRpbmF0ZXMgYXJyYXkuXHJcbi8vIGBsZXZlbHNEZWVwYCBzcGVjaWZpZXMgdGhlIG5lc3RpbmcgbGV2ZWwgKDAgaXMgZm9yIGFuIGFycmF5IG9mIHBvaW50cywgMSBmb3IgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIHBvaW50cywgZXRjLiwgMCBieSBkZWZhdWx0KS5cclxuLy8gQ2FuIHVzZSBhIGN1c3RvbSBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpIGZ1bmN0aW9uLlxyXG5leHBvcnQgZnVuY3Rpb24gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgbGV2ZWxzRGVlcCwgX2Nvb3Jkc1RvTGF0TG5nKSB7XHJcblx0dmFyIGxhdGxuZ3MgPSBbXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGgsIGxhdGxuZzsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRsYXRsbmcgPSBsZXZlbHNEZWVwID9cclxuXHRcdFx0Y29vcmRzVG9MYXRMbmdzKGNvb3Jkc1tpXSwgbGV2ZWxzRGVlcCAtIDEsIF9jb29yZHNUb0xhdExuZykgOlxyXG5cdFx0XHQoX2Nvb3Jkc1RvTGF0TG5nIHx8IGNvb3Jkc1RvTGF0TG5nKShjb29yZHNbaV0pO1xyXG5cclxuXHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGxhdGxuZ3M7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBsYXRMbmdUb0Nvb3JkcyhsYXRsbmc6IExhdExuZywgcHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogQXJyYXlcclxuLy8gUmV2ZXJzZSBvZiBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpXHJcbi8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbi5cclxuZXhwb3J0IGZ1bmN0aW9uIGxhdExuZ1RvQ29vcmRzKGxhdGxuZywgcHJlY2lzaW9uKSB7XHJcblx0bGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcclxuXHRyZXR1cm4gbGF0bG5nLmFsdCAhPT0gdW5kZWZpbmVkID9cclxuXHRcdFtVdGlsLmZvcm1hdE51bShsYXRsbmcubG5nLCBwcmVjaXNpb24pLCBVdGlsLmZvcm1hdE51bShsYXRsbmcubGF0LCBwcmVjaXNpb24pLCBVdGlsLmZvcm1hdE51bShsYXRsbmcuYWx0LCBwcmVjaXNpb24pXSA6XHJcblx0XHRbVXRpbC5mb3JtYXROdW0obGF0bG5nLmxuZywgcHJlY2lzaW9uKSwgVXRpbC5mb3JtYXROdW0obGF0bG5nLmxhdCwgcHJlY2lzaW9uKV07XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBsYXRMbmdzVG9Db29yZHMobGF0bG5nczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNsb3NlZD86IEJvb2xlYW4sIHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IEFycmF5XHJcbi8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ3NgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZ3MpXHJcbi8vIGBjbG9zZWRgIGRldGVybWluZXMgd2hldGhlciB0aGUgZmlyc3QgcG9pbnQgc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5IHRvIGNsb3NlIHRoZSBmZWF0dXJlLCBvbmx5IHVzZWQgd2hlbiBgbGV2ZWxzRGVlcGAgaXMgMC4gRmFsc2UgYnkgZGVmYXVsdC5cclxuLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uLlxyXG5leHBvcnQgZnVuY3Rpb24gbGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3MsIGxldmVsc0RlZXAsIGNsb3NlZCwgcHJlY2lzaW9uKSB7XHJcblx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0Ly8gQ2hlY2sgZm9yIGZsYXQgYXJyYXlzIHJlcXVpcmVkIHRvIGVuc3VyZSB1bmJhbGFuY2VkIGFycmF5cyBhcmUgY29ycmVjdGx5IGNvbnZlcnRlZCBpbiByZWN1cnNpb25cclxuXHRcdGNvb3Jkcy5wdXNoKGxldmVsc0RlZXAgP1xyXG5cdFx0XHRsYXRMbmdzVG9Db29yZHMobGF0bG5nc1tpXSwgTGluZVV0aWwuaXNGbGF0KGxhdGxuZ3NbaV0pID8gMCA6IGxldmVsc0RlZXAgLSAxLCBjbG9zZWQsIHByZWNpc2lvbikgOlxyXG5cdFx0XHRsYXRMbmdUb0Nvb3JkcyhsYXRsbmdzW2ldLCBwcmVjaXNpb24pKTtcclxuXHR9XHJcblxyXG5cdGlmICghbGV2ZWxzRGVlcCAmJiBjbG9zZWQgJiYgY29vcmRzLmxlbmd0aCA+IDApIHtcclxuXHRcdGNvb3Jkcy5wdXNoKGNvb3Jkc1swXS5zbGljZSgpKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBjb29yZHM7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRGZWF0dXJlKGxheWVyLCBuZXdHZW9tZXRyeSkge1xyXG5cdHJldHVybiBsYXllci5mZWF0dXJlID9cclxuXHRcdFV0aWwuZXh0ZW5kKHt9LCBsYXllci5mZWF0dXJlLCB7Z2VvbWV0cnk6IG5ld0dlb21ldHJ5fSkgOlxyXG5cdFx0YXNGZWF0dXJlKG5ld0dlb21ldHJ5KTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGFzRmVhdHVyZShnZW9qc29uOiBPYmplY3QpOiBPYmplY3RcclxuLy8gTm9ybWFsaXplIEdlb0pTT04gZ2VvbWV0cmllcy9mZWF0dXJlcyBpbnRvIEdlb0pTT04gZmVhdHVyZXMuXHJcbmV4cG9ydCBmdW5jdGlvbiBhc0ZlYXR1cmUoZ2VvanNvbikge1xyXG5cdGlmIChnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyB8fCBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcclxuXHRcdHJldHVybiBnZW9qc29uO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuXHRcdHByb3BlcnRpZXM6IHt9LFxyXG5cdFx0Z2VvbWV0cnk6IGdlb2pzb25cclxuXHR9O1xyXG59XHJcblxyXG52YXIgUG9pbnRUb0dlb0pTT04gPSB7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdQb2ludCcsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBsYXRMbmdUb0Nvb3Jkcyh0aGlzLmdldExhdExuZygpLCBwcmVjaXNpb24pXHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcmtlclxyXG4vLyBAc2VjdGlvbiBPdGhlciBtZXRob2RzXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE9iamVjdFxyXG4vLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24gd2l0aCBnaXZlbiBgcHJlY2lzaW9uYC5cclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXJrZXIgKGFzIGEgR2VvSlNPTiBgUG9pbnRgIEZlYXR1cmUpLlxyXG5NYXJrZXIuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENpcmNsZU1hcmtlclxyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBPYmplY3RcclxuLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uIHdpdGggZ2l2ZW4gYHByZWNpc2lvbmAuXHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlciAoYXMgYSBHZW9KU09OIGBQb2ludGAgRmVhdHVyZSkuXHJcbkNpcmNsZS5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuQ2lyY2xlTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9seWxpbmVcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogT2JqZWN0XHJcbi8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvbHlsaW5lIChhcyBhIEdlb0pTT04gYExpbmVTdHJpbmdgIG9yIGBNdWx0aUxpbmVTdHJpbmdgIEZlYXR1cmUpLlxyXG5Qb2x5bGluZS5pbmNsdWRlKHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHZhciBtdWx0aSA9ICFMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncyk7XHJcblxyXG5cdFx0dmFyIGNvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDEgOiAwLCBmYWxzZSwgcHJlY2lzaW9uKTtcclxuXHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnTGluZVN0cmluZycsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHRcdH0pO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvbHlnb25cclxuLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogT2JqZWN0XHJcbi8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvbHlnb24gKGFzIGEgR2VvSlNPTiBgUG9seWdvbmAgb3IgYE11bHRpUG9seWdvbmAgRmVhdHVyZSkuXHJcblBvbHlnb24uaW5jbHVkZSh7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHR2YXIgaG9sZXMgPSAhTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3MpLFxyXG5cdFx0ICAgIG11bHRpID0gaG9sZXMgJiYgIUxpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzWzBdKTtcclxuXHJcblx0XHR2YXIgY29vcmRzID0gbGF0TG5nc1RvQ29vcmRzKHRoaXMuX2xhdGxuZ3MsIG11bHRpID8gMiA6IGhvbGVzID8gMSA6IDAsIHRydWUsIHByZWNpc2lvbik7XHJcblxyXG5cdFx0aWYgKCFob2xlcykge1xyXG5cdFx0XHRjb29yZHMgPSBbY29vcmRzXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnUG9seWdvbicsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHRcdH0pO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBMYXllckdyb3VwXHJcbkxheWVyR3JvdXAuaW5jbHVkZSh7XHJcblx0dG9NdWx0aVBvaW50OiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHR2YXIgY29vcmRzID0gW107XHJcblxyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdGNvb3Jkcy5wdXNoKGxheWVyLnRvR2VvSlNPTihwcmVjaXNpb24pLmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogJ011bHRpUG9pbnQnLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBPYmplY3RcclxuXHQvLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24gd2l0aCBnaXZlbiBgcHJlY2lzaW9uYC5cclxuXHQvLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxheWVyIGdyb3VwIChhcyBhIEdlb0pTT04gYEZlYXR1cmVDb2xsZWN0aW9uYCwgYEdlb21ldHJ5Q29sbGVjdGlvbmAsIG9yIGBNdWx0aVBvaW50YCkuXHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblxyXG5cdFx0dmFyIHR5cGUgPSB0aGlzLmZlYXR1cmUgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5ICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeS50eXBlO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnTXVsdGlQb2ludCcpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudG9NdWx0aVBvaW50KHByZWNpc2lvbik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGlzR2VvbWV0cnlDb2xsZWN0aW9uID0gdHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicsXHJcblx0XHQgICAganNvbnMgPSBbXTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0aWYgKGxheWVyLnRvR2VvSlNPTikge1xyXG5cdFx0XHRcdHZhciBqc29uID0gbGF5ZXIudG9HZW9KU09OKHByZWNpc2lvbik7XHJcblx0XHRcdFx0aWYgKGlzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XHJcblx0XHRcdFx0XHRqc29ucy5wdXNoKGpzb24uZ2VvbWV0cnkpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR2YXIgZmVhdHVyZSA9IGFzRmVhdHVyZShqc29uKTtcclxuXHRcdFx0XHRcdC8vIFNxdWFzaCBuZXN0ZWQgZmVhdHVyZSBjb2xsZWN0aW9uc1xyXG5cdFx0XHRcdFx0aWYgKGZlYXR1cmUudHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xyXG5cdFx0XHRcdFx0XHRqc29ucy5wdXNoLmFwcGx5KGpzb25zLCBmZWF0dXJlLmZlYXR1cmVzKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGpzb25zLnB1c2goZmVhdHVyZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuXHRcdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHRcdGdlb21ldHJpZXM6IGpzb25zLFxyXG5cdFx0XHRcdHR5cGU6ICdHZW9tZXRyeUNvbGxlY3Rpb24nXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXHJcblx0XHRcdGZlYXR1cmVzOiBqc29uc1xyXG5cdFx0fTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBHZW9KU09OXHJcbi8vIEBmYWN0b3J5IEwuZ2VvSlNPTihnZW9qc29uPzogT2JqZWN0LCBvcHRpb25zPzogR2VvSlNPTiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgR2VvSlNPTiBsYXllci4gT3B0aW9uYWxseSBhY2NlcHRzIGFuIG9iamVjdCBpblxyXG4vLyBbR2VvSlNPTiBmb3JtYXRdKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3OTQ2KSB0byBkaXNwbGF5IG9uIHRoZSBtYXBcclxuLy8gKHlvdSBjYW4gYWx0ZXJuYXRpdmVseSBhZGQgaXQgbGF0ZXIgd2l0aCBgYWRkRGF0YWAgbWV0aG9kKSBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlb0pTT04oZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgR2VvSlNPTihnZW9qc29uLCBvcHRpb25zKTtcclxufVxyXG5cclxuLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eS5cclxuZXhwb3J0IHZhciBnZW9Kc29uID0gZ2VvSlNPTjtcclxuIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBJbWFnZU92ZXJsYXlcclxuICogQGFrYSBMLkltYWdlT3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICpcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgc2luZ2xlIGltYWdlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGltYWdlVXJsID0gJ2h0dHBzOi8vbWFwcy5saWIudXRleGFzLmVkdS9tYXBzL2hpc3RvcmljYWwvbmV3YXJrX25qXzE5MjIuanBnJyxcclxuICogXHRpbWFnZUJvdW5kcyA9IFtbNDAuNzEyMjE2LCAtNzQuMjI2NTVdLCBbNDAuNzczOTQxLCAtNzQuMTI1NDRdXTtcclxuICogTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmwsIGltYWdlQm91bmRzKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEltYWdlT3ZlcmxheSA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBJbWFnZU92ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcblx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cclxuXHRcdG9wYWNpdHk6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpbWFnZSAodXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5KS5cclxuXHRcdGFsdDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBpbnRlcmFjdGl2ZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBpbWFnZSBvdmVybGF5IHdpbGwgZW1pdCBbbW91c2UgZXZlbnRzXSgjaW50ZXJhY3RpdmUtbGF5ZXIpIHdoZW4gY2xpY2tlZCBvciBob3ZlcmVkLlxyXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBpbWFnZS5cclxuXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCB0aGUgaW1hZ2Ugd2lsbCBoYXZlIGl0cyBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyBpbWFnZSBwaXhlbCBkYXRhLlxyXG5cdFx0Ly8gUmVmZXIgdG8gW0NPUlMgU2V0dGluZ3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzKSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuXHRcdGNyb3NzT3JpZ2luOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGVycm9yT3ZlcmxheVVybDogU3RyaW5nID0gJydcclxuXHRcdC8vIFVSTCB0byB0aGUgb3ZlcmxheSBpbWFnZSB0byBzaG93IGluIHBsYWNlIG9mIHRoZSBvdmVybGF5IHRoYXQgZmFpbGVkIHRvIGxvYWQuXHJcblx0XHRlcnJvck92ZXJsYXlVcmw6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gekluZGV4OiBOdW1iZXIgPSAxXHJcblx0XHQvLyBUaGUgZXhwbGljaXQgW3pJbmRleF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQ1NTL0NTU19Qb3NpdGlvbmluZy9VbmRlcnN0YW5kaW5nX3pfaW5kZXgpIG9mIHRoZSBvdmVybGF5IGxheWVyLlxyXG5cdFx0ekluZGV4OiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIGltYWdlLiBFbXB0eSBieSBkZWZhdWx0LlxyXG5cdFx0Y2xhc3NOYW1lOiAnJ1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykgeyAvLyAoU3RyaW5nLCBMYXRMbmdCb3VuZHMsIE9iamVjdClcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHRcdHRoaXMuX2JvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJbWFnZSgpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pbWFnZSwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faW1hZ2UpO1xyXG5cdFx0dGhpcy5fcmVzZXQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5faW1hZ2UpO1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG5cdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIG92ZXJsYXkuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHJcblx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZU9wdHMpIHtcclxuXHRcdGlmIChzdHlsZU9wdHMub3BhY2l0eSkge1xyXG5cdFx0XHR0aGlzLnNldE9wYWNpdHkoc3R5bGVPcHRzLm9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgb3ZlcmxheXMuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9Gcm9udCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIG92ZXJsYXlzLlxyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9CYWNrKHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VXJsKHVybDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIFVSTCBvZiB0aGUgaW1hZ2UuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsKSB7XHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IHVybDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG5cdC8vIFVwZGF0ZSB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcblx0c2V0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHR0aGlzLl9ib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fcmVzZXQoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IHtcclxuXHRcdFx0em9vbTogdGhpcy5fcmVzZXQsXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4KHZhbHVlOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2ltYWdlb3ZlcmxheS16aW5kZXgpIG9mIHRoZSBpbWFnZSBvdmVybGF5LlxyXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gdmFsdWU7XHJcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIEdldCB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgSFRNTEltYWdlRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9IVE1MSW1hZ2VFbGVtZW50KVxyXG5cdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9pbWFnZTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgd2FzRWxlbWVudFN1cHBsaWVkID0gdGhpcy5fdXJsLnRhZ05hbWUgPT09ICdJTUcnO1xyXG5cdFx0dmFyIGltZyA9IHRoaXMuX2ltYWdlID0gd2FzRWxlbWVudFN1cHBsaWVkID8gdGhpcy5fdXJsIDogRG9tVXRpbC5jcmVhdGUoJ2ltZycpO1xyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoaW1nLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBEb21VdGlsLmFkZENsYXNzKGltZywgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpOyB9XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBEb21VdGlsLmFkZENsYXNzKGltZywgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSk7IH1cclxuXHJcblx0XHRpbWcub25zZWxlY3RzdGFydCA9IFV0aWwuZmFsc2VGbjtcclxuXHRcdGltZy5vbm1vdXNlbW92ZSA9IFV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIEltYWdlT3ZlcmxheSBsYXllciBoYXMgbG9hZGVkIGl0cyBpbWFnZVxyXG5cdFx0aW1nLm9ubG9hZCA9IFV0aWwuYmluZCh0aGlzLmZpcmUsIHRoaXMsICdsb2FkJyk7XHJcblx0XHRpbWcub25lcnJvciA9IFV0aWwuYmluZCh0aGlzLl9vdmVybGF5T25FcnJvciwgdGhpcywgJ2Vycm9yJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcblx0XHRcdGltZy5jcm9zc09yaWdpbiA9IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICcnIDogdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuekluZGV4KSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHtcclxuXHRcdFx0dGhpcy5fdXJsID0gaW1nLnNyYztcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGltZy5zcmMgPSB0aGlzLl91cmw7XHJcblx0XHRpbWcuYWx0ID0gdGhpcy5vcHRpb25zLmFsdDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKGUuem9vbSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fbWFwLl9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzKHRoaXMuX2JvdW5kcywgZS56b29tLCBlLmNlbnRlcikubWluO1xyXG5cclxuXHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX2ltYWdlLCBvZmZzZXQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlLFxyXG5cdFx0ICAgIGJvdW5kcyA9IG5ldyBCb3VuZHMoXHJcblx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldE5vcnRoV2VzdCgpKSxcclxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0U291dGhFYXN0KCkpKSxcclxuXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcclxuXHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGltYWdlLCBib3VuZHMubWluKTtcclxuXHJcblx0XHRpbWFnZS5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG5cdFx0aW1hZ2Uuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2ltYWdlLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2ltYWdlICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSBudWxsKSB7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X292ZXJsYXlPbkVycm9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBAZXZlbnQgZXJyb3I6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBJbWFnZU92ZXJsYXkgbGF5ZXIgZmFpbHMgdG8gbG9hZCBpdHMgaW1hZ2VcclxuXHRcdHRoaXMuZmlyZSgnZXJyb3InKTtcclxuXHJcblx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JPdmVybGF5VXJsO1xyXG5cdFx0aWYgKGVycm9yVXJsICYmIHRoaXMuX3VybCAhPT0gZXJyb3JVcmwpIHtcclxuXHRcdFx0dGhpcy5fdXJsID0gZXJyb3JVcmw7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IGVycm9yVXJsO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciBvZiB0aGUgSW1hZ2VPdmVybGF5LlxyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcy5nZXRDZW50ZXIoKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQGZhY3RvcnkgTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmw6IFN0cmluZywgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBJbWFnZU92ZXJsYXkgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIHRoZSBVUkwgb2YgdGhlIGltYWdlIGFuZCB0aGVcclxuLy8gZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxyXG5leHBvcnQgdmFyIGltYWdlT3ZlcmxheSA9IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgSW1hZ2VPdmVybGF5KHVybCwgYm91bmRzLCBvcHRpb25zKTtcclxufTtcclxuIiwiaW1wb3J0IHtJbWFnZU92ZXJsYXl9IGZyb20gJy4vSW1hZ2VPdmVybGF5JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBWaWRlb092ZXJsYXlcclxuICogQGFrYSBMLlZpZGVvT3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgSW1hZ2VPdmVybGF5XHJcbiAqXHJcbiAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSBhIHZpZGVvIHBsYXllciBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBJbWFnZU92ZXJsYXlgLlxyXG4gKlxyXG4gKiBBIHZpZGVvIG92ZXJsYXkgdXNlcyB0aGUgW2A8dmlkZW8+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSFRNTC9FbGVtZW50L3ZpZGVvKVxyXG4gKiBIVE1MNSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgdmlkZW9VcmwgPSAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS9iaXRlcy8wMDE4OC9wYXRyaWNpYV9uYXNhLndlYm0nLFxyXG4gKiBcdHZpZGVvQm91bmRzID0gW1sgMzIsIC0xMzBdLCBbIDEzLCAtMTAwXV07XHJcbiAqIEwudmlkZW9PdmVybGF5KHZpZGVvVXJsLCB2aWRlb0JvdW5kcyApLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgVmlkZW9PdmVybGF5ID0gSW1hZ2VPdmVybGF5LmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBWaWRlb092ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gYXV0b3BsYXk6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyBzdGFydHMgcGxheWluZyBhdXRvbWF0aWNhbGx5IHdoZW4gbG9hZGVkLlxyXG5cdFx0Ly8gT24gc29tZSBicm93c2VycyBhdXRvcGxheSB3aWxsIG9ubHkgd29yayB3aXRoIGBtdXRlZDogdHJ1ZWBcclxuXHRcdGF1dG9wbGF5OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbG9vcDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHdpbGwgbG9vcCBiYWNrIHRvIHRoZSBiZWdpbm5pbmcgd2hlbiBwbGF5ZWQuXHJcblx0XHRsb29wOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24ga2VlcEFzcGVjdFJhdGlvOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gd2lsbCBzYXZlIGFzcGVjdCByYXRpbyBhZnRlciB0aGUgcHJvamVjdGlvbi5cclxuXHRcdC8vIFJlbGV2YW50IGZvciBzdXBwb3J0ZWQgYnJvd3NlcnMuIFNlZSBbYnJvd3NlciBjb21wYXRpYmlsaXR5XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1Mvb2JqZWN0LWZpdClcclxuXHRcdGtlZXBBc3BlY3RSYXRpbzogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG11dGVkOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHN0YXJ0cyBvbiBtdXRlIHdoZW4gbG9hZGVkLlxyXG5cdFx0bXV0ZWQ6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcGxheXNJbmxpbmU6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBNb2JpbGUgYnJvd3NlcnMgd2lsbCBwbGF5IHRoZSB2aWRlbyByaWdodCB3aGVyZSBpdCBpcyBpbnN0ZWFkIG9mIG9wZW4gaXQgdXAgaW4gZnVsbHNjcmVlbiBtb2RlLlxyXG5cdFx0cGxheXNJbmxpbmU6IHRydWVcclxuXHR9LFxyXG5cclxuXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgd2FzRWxlbWVudFN1cHBsaWVkID0gdGhpcy5fdXJsLnRhZ05hbWUgPT09ICdWSURFTyc7XHJcblx0XHR2YXIgdmlkID0gdGhpcy5faW1hZ2UgPSB3YXNFbGVtZW50U3VwcGxpZWQgPyB0aGlzLl91cmwgOiBEb21VdGlsLmNyZWF0ZSgndmlkZW8nKTtcclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKHZpZCwgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHsgRG9tVXRpbC5hZGRDbGFzcyh2aWQsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHsgRG9tVXRpbC5hZGRDbGFzcyh2aWQsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XHJcblxyXG5cdFx0dmlkLm9uc2VsZWN0c3RhcnQgPSBVdGlsLmZhbHNlRm47XHJcblx0XHR2aWQub25tb3VzZW1vdmUgPSBVdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWRlbyBoYXMgZmluaXNoZWQgbG9hZGluZyB0aGUgZmlyc3QgZnJhbWVcclxuXHRcdHZpZC5vbmxvYWRlZGRhdGEgPSBVdGlsLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbG9hZCcpO1xyXG5cclxuXHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHtcclxuXHRcdFx0dmFyIHNvdXJjZUVsZW1lbnRzID0gdmlkLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzb3VyY2UnKTtcclxuXHRcdFx0dmFyIHNvdXJjZXMgPSBbXTtcclxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBzb3VyY2VFbGVtZW50cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdHNvdXJjZXMucHVzaChzb3VyY2VFbGVtZW50c1tqXS5zcmMpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLl91cmwgPSAoc291cmNlRWxlbWVudHMubGVuZ3RoID4gMCkgPyBzb3VyY2VzIDogW3ZpZC5zcmNdO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFVdGlsLmlzQXJyYXkodGhpcy5fdXJsKSkgeyB0aGlzLl91cmwgPSBbdGhpcy5fdXJsXTsgfVxyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLmtlZXBBc3BlY3RSYXRpbyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmlkLnN0eWxlLCAnb2JqZWN0Rml0JykpIHtcclxuXHRcdFx0dmlkLnN0eWxlWydvYmplY3RGaXQnXSA9ICdmaWxsJztcclxuXHRcdH1cclxuXHRcdHZpZC5hdXRvcGxheSA9ICEhdGhpcy5vcHRpb25zLmF1dG9wbGF5O1xyXG5cdFx0dmlkLmxvb3AgPSAhIXRoaXMub3B0aW9ucy5sb29wO1xyXG5cdFx0dmlkLm11dGVkID0gISF0aGlzLm9wdGlvbnMubXV0ZWQ7XHJcblx0XHR2aWQucGxheXNJbmxpbmUgPSAhIXRoaXMub3B0aW9ucy5wbGF5c0lubGluZTtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdXJsLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBzb3VyY2UgPSBEb21VdGlsLmNyZWF0ZSgnc291cmNlJyk7XHJcblx0XHRcdHNvdXJjZS5zcmMgPSB0aGlzLl91cmxbaV07XHJcblx0XHRcdHZpZC5hcHBlbmRDaGlsZChzb3VyY2UpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IEhUTUxWaWRlb0VsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYEhUTUxWaWRlb0VsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvSFRNTFZpZGVvRWxlbWVudClcclxuXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC52aWRlb092ZXJsYXkodmlkZW86IFN0cmluZ3xBcnJheXxIVE1MVmlkZW9FbGVtZW50LCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFZpZGVvT3ZlcmxheSBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgdmlkZW8gKG9yIGFycmF5IG9mIFVSTHMsIG9yIGV2ZW4gYSB2aWRlbyBlbGVtZW50KSBhbmQgdGhlXHJcbi8vIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB2aWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVmlkZW9PdmVybGF5KHZpZGVvLCBib3VuZHMsIG9wdGlvbnMpO1xyXG59XHJcbiIsImltcG9ydCB7SW1hZ2VPdmVybGF5fSBmcm9tICcuL0ltYWdlT3ZlcmxheSc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBjbGFzcyBTVkdPdmVybGF5XG4gKiBAYWthIEwuU1ZHT3ZlcmxheVxuICogQGluaGVyaXRzIEltYWdlT3ZlcmxheVxuICpcbiAqIFVzZWQgdG8gbG9hZCwgZGlzcGxheSBhbmQgcHJvdmlkZSBET00gYWNjZXNzIHRvIGFuIFNWRyBmaWxlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYEltYWdlT3ZlcmxheWAuXG4gKlxuICogQW4gU1ZHIG92ZXJsYXkgdXNlcyB0aGUgW2A8c3ZnPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9FbGVtZW50L3N2ZykgZWxlbWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiB2YXIgc3ZnRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpO1xuICogc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3htbG5zJywgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKTtcbiAqIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgXCIwIDAgMjAwIDIwMFwiKTtcbiAqIHN2Z0VsZW1lbnQuaW5uZXJIVE1MID0gJzxyZWN0IHdpZHRoPVwiMjAwXCIgaGVpZ2h0PVwiMjAwXCIvPjxyZWN0IHg9XCI3NVwiIHk9XCIyM1wiIHdpZHRoPVwiNTBcIiBoZWlnaHQ9XCI1MFwiIHN0eWxlPVwiZmlsbDpyZWRcIi8+PHJlY3QgeD1cIjc1XCIgeT1cIjEyM1wiIHdpZHRoPVwiNTBcIiBoZWlnaHQ9XCI1MFwiIHN0eWxlPVwiZmlsbDojMDAxM2ZmXCIvPic7XG4gKiB2YXIgc3ZnRWxlbWVudEJvdW5kcyA9IFsgWyAzMiwgLTEzMCBdLCBbIDEzLCAtMTAwIF0gXTtcbiAqIEwuc3ZnT3ZlcmxheShzdmdFbGVtZW50LCBzdmdFbGVtZW50Qm91bmRzKS5hZGRUbyhtYXApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBTVkdPdmVybGF5ID0gSW1hZ2VPdmVybGF5LmV4dGVuZCh7XG5cdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZWwgPSB0aGlzLl9pbWFnZSA9IHRoaXMuX3VybDtcblxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoZWwsICdsZWFmbGV0LWltYWdlLWxheWVyJyk7XG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBEb21VdGlsLmFkZENsYXNzKGVsLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7IH1cblx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBEb21VdGlsLmFkZENsYXNzKGVsLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTsgfVxuXG5cdFx0ZWwub25zZWxlY3RzdGFydCA9IFV0aWwuZmFsc2VGbjtcblx0XHRlbC5vbm1vdXNlbW92ZSA9IFV0aWwuZmFsc2VGbjtcblx0fVxuXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBTVkdFbGVtZW50XG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgU1ZHRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdFbGVtZW50KVxuXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwuc3ZnT3ZlcmxheShzdmc6IFN0cmluZ3xTVkdFbGVtZW50LCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFNWR092ZXJsYXkgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiBhbiBTVkcgZWxlbWVudCBhbmQgdGhlIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cbi8vIEEgdmlld0JveCBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgb24gdGhlIFNWRyBlbGVtZW50IHRvIHpvb20gaW4gYW5kIG91dCBwcm9wZXJseS5cblxuZXhwb3J0IGZ1bmN0aW9uIHN2Z092ZXJsYXkoZWwsIGJvdW5kcywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFNWR092ZXJsYXkoZWwsIGJvdW5kcywgb3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQge0ZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmcsIExhdExuZ30gZnJvbSAnLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCB7dG9Qb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBEaXZPdmVybGF5XHJcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gKiBAYWthIEwuRGl2T3ZlcmxheVxyXG4gKiBCYXNlIG1vZGVsIGZvciBMLlBvcHVwIGFuZCBMLlRvb2x0aXAuIEluaGVyaXQgZnJvbSBpdCBmb3IgY3VzdG9tIG92ZXJsYXlzIGxpa2UgcGx1Z2lucy5cclxuICovXHJcblxyXG4vLyBAbmFtZXNwYWNlIERpdk92ZXJsYXlcclxuZXhwb3J0IHZhciBEaXZPdmVybGF5ID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIERpdk92ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgdHJ1ZSwgdGhlIHBvcHVwL3Rvb2x0aXAgd2lsbCBsaXN0ZW4gdG8gdGhlIG1vdXNlIGV2ZW50cy5cclxuXHRcdGludGVyYWN0aXZlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCAwKVxyXG5cdFx0Ly8gVGhlIG9mZnNldCBvZiB0aGUgb3ZlcmxheSBwb3NpdGlvbi5cclxuXHRcdG9mZnNldDogWzAsIDBdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBvdmVybGF5LlxyXG5cdFx0Y2xhc3NOYW1lOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgb3ZlcmxheSB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0cGFuZTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9uID0gJydcclxuXHRcdC8vIFNldHMgdGhlIEhUTUwgY29udGVudCBvZiB0aGUgb3ZlcmxheSB3aGlsZSBpbml0aWFsaXppbmcuIElmIGEgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBzb3VyY2UgbGF5ZXIgd2lsbCBiZVxyXG5cdFx0Ly8gcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi4gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgIHRvIGJlIHVzZWQgaW4gdGhlIG92ZXJsYXkuXHJcblx0XHRjb250ZW50OiAnJ1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuXHRcdGlmIChvcHRpb25zICYmIChvcHRpb25zIGluc3RhbmNlb2YgTGF0TG5nIHx8IFV0aWwuaXNBcnJheShvcHRpb25zKSkpIHtcclxuXHRcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcob3B0aW9ucyk7XHJcblx0XHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBzb3VyY2UpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdFx0XHR0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNvbnRlbnQpIHtcclxuXHRcdFx0dGhpcy5fY29udGVudCA9IHRoaXMub3B0aW9ucy5jb250ZW50O1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3Blbk9uKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIG92ZXJsYXkgdG8gdGhlIG1hcC5cclxuXHQvLyBBbHRlcm5hdGl2ZSB0byBgbWFwLm9wZW5Qb3B1cChwb3B1cClgL2Aub3BlblRvb2x0aXAodG9vbHRpcClgLlxyXG5cdG9wZW5PbjogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwID0gYXJndW1lbnRzLmxlbmd0aCA/IG1hcCA6IHRoaXMuX3NvdXJjZS5fbWFwOyAvLyBleHBlcmltZW50YWwsIG5vdCB0aGUgcGFydCBvZiBwdWJsaWMgYXBpXHJcblx0XHRpZiAoIW1hcC5oYXNMYXllcih0aGlzKSkge1xyXG5cdFx0XHRtYXAuYWRkTGF5ZXIodGhpcyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsb3NlKCk6IHRoaXNcclxuXHQvLyBDbG9zZXMgdGhlIG92ZXJsYXkuXHJcblx0Ly8gQWx0ZXJuYXRpdmUgdG8gYG1hcC5jbG9zZVBvcHVwKHBvcHVwKWAvYC5jbG9zZVRvb2x0aXAodG9vbHRpcClgXHJcblx0Ly8gYW5kIGBsYXllci5jbG9zZVBvcHVwKClgL2AuY2xvc2VUb29sdGlwKClgLlxyXG5cdGNsb3NlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9nZ2xlKGxheWVyPzogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSBvdmVybGF5IGJvdW5kIHRvIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cclxuXHQvLyBBcmd1bWVudCBtYXkgYmUgb21pdHRlZCBvbmx5IGZvciBvdmVybGF5IGJvdW5kIHRvIGxheWVyLlxyXG5cdC8vIEFsdGVybmF0aXZlIHRvIGBsYXllci50b2dnbGVQb3B1cCgpYC9gLnRvZ2dsZVRvb2x0aXAoKWAuXHJcblx0dG9nZ2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5jbG9zZSgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0XHR0aGlzLl9zb3VyY2UgPSBsYXllcjtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsYXllciA9IHRoaXMuX3NvdXJjZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLl9wcmVwYXJlT3BlbigpO1xyXG5cclxuXHRcdFx0Ly8gb3BlbiB0aGUgb3ZlcmxheSBvbiB0aGUgbWFwXHJcblx0XHRcdHRoaXMub3Blbk9uKGxheWVyLl9tYXApO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xyXG5cclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3JlbW92ZVRpbWVvdXQpO1xyXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYnJpbmdUb0Zyb250KCk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcblx0XHRcdHRoaXMuX3JlbW92ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KFV0aWwuYmluZChEb21VdGlsLnJlbW92ZSwgdW5kZWZpbmVkLCB0aGlzLl9jb250YWluZXIpLCAyMDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBwb2ludCBvZiB0aGUgb3ZlcmxheS5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IHdoZXJlIHRoZSBvdmVybGF5IHdpbGwgb3Blbi5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblx0XHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSBvdmVybGF5LlxyXG5cdGdldENvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250ZW50O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Q29udGVudChodG1sQ29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9uKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIEhUTUwgY29udGVudCBvZiB0aGUgb3ZlcmxheS4gSWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHNvdXJjZSBsYXllciB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uXHJcblx0Ly8gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgIHRvIGJlIHVzZWQgaW4gdGhlIG92ZXJsYXkuXHJcblx0c2V0Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuXHRcdHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudDogU3RyaW5nfEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgSFRNTCBjb250YWluZXIgb2YgdGhlIG92ZXJsYXkuXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVwZGF0ZTogbnVsbFxyXG5cdC8vIFVwZGF0ZXMgdGhlIG92ZXJsYXkgY29udGVudCwgbGF5b3V0IGFuZCBwb3NpdGlvbi4gVXNlZnVsIGZvciB1cGRhdGluZyB0aGUgb3ZlcmxheSBhZnRlciBzb21ldGhpbmcgaW5zaWRlIGNoYW5nZWQsIGUuZy4gaW1hZ2UgbG9hZGVkLlxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuXHJcblx0XHR0aGlzLl91cGRhdGVDb250ZW50KCk7XHJcblx0XHR0aGlzLl91cGRhdGVMYXlvdXQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcclxuXHJcblx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSB7XHJcblx0XHRcdHpvb206IHRoaXMuX3VwZGF0ZVBvc2l0aW9uLFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3VwZGF0ZVBvc2l0aW9uXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNPcGVuOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgd2hlbiB0aGUgb3ZlcmxheSBpcyB2aXNpYmxlIG9uIHRoZSBtYXAuXHJcblx0aXNPcGVuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISF0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250OiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoaXMgb3ZlcmxheSBpbiBmcm9udCBvZiBvdGhlciBvdmVybGF5cyAoaW4gdGhlIHNhbWUgbWFwIHBhbmUpLlxyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHREb21VdGlsLnRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhpcyBvdmVybGF5IHRvIHRoZSBiYWNrIG9mIG90aGVyIG92ZXJsYXlzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0RG9tVXRpbC50b0JhY2sodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIHByZXBhcmUgYm91bmQgb3ZlcmxheSB0byBvcGVuOiB1cGRhdGUgbGF0bG5nIHBvcyAvIGNvbnRlbnQgc291cmNlIChmb3IgRmVhdHVyZUdyb3VwKVxyXG5cdF9wcmVwYXJlT3BlbjogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIHNvdXJjZSA9IHRoaXMuX3NvdXJjZTtcclxuXHRcdGlmICghc291cmNlLl9tYXApIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0aWYgKHNvdXJjZSBpbnN0YW5jZW9mIEZlYXR1cmVHcm91cCkge1xyXG5cdFx0XHRzb3VyY2UgPSBudWxsO1xyXG5cdFx0XHR2YXIgbGF5ZXJzID0gdGhpcy5fc291cmNlLl9sYXllcnM7XHJcblx0XHRcdGZvciAodmFyIGlkIGluIGxheWVycykge1xyXG5cdFx0XHRcdGlmIChsYXllcnNbaWRdLl9tYXApIHtcclxuXHRcdFx0XHRcdHNvdXJjZSA9IGxheWVyc1tpZF07XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCFzb3VyY2UpIHsgcmV0dXJuIGZhbHNlOyB9IC8vIFVuYWJsZSB0byBnZXQgc291cmNlIGxheWVyLlxyXG5cclxuXHRcdFx0Ly8gc2V0IG92ZXJsYXkgc291cmNlIHRvIHRoaXMgbGF5ZXJcclxuXHRcdFx0dGhpcy5fc291cmNlID0gc291cmNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghbGF0bG5nKSB7XHJcblx0XHRcdGlmIChzb3VyY2UuZ2V0Q2VudGVyKSB7XHJcblx0XHRcdFx0bGF0bG5nID0gc291cmNlLmdldENlbnRlcigpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHNvdXJjZS5nZXRMYXRMbmcpIHtcclxuXHRcdFx0XHRsYXRsbmcgPSBzb3VyY2UuZ2V0TGF0TG5nKCk7XHJcblx0XHRcdH0gZWxzZSBpZiAoc291cmNlLmdldEJvdW5kcykge1xyXG5cdFx0XHRcdGxhdGxuZyA9IHNvdXJjZS5nZXRCb3VuZHMoKS5nZXRDZW50ZXIoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgc291cmNlIGxheWVyIExhdExuZy4nKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dGhpcy5zZXRMYXRMbmcobGF0bG5nKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdC8vIHVwZGF0ZSB0aGUgb3ZlcmxheSAoY29udGVudCwgbGF5b3V0LCBldGMuLi4pXHJcblx0XHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGVudCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbm9kZSA9IHRoaXMuX2NvbnRlbnROb2RlO1xyXG5cdFx0dmFyIGNvbnRlbnQgPSAodHlwZW9mIHRoaXMuX2NvbnRlbnQgPT09ICdmdW5jdGlvbicpID8gdGhpcy5fY29udGVudCh0aGlzLl9zb3VyY2UgfHwgdGhpcykgOiB0aGlzLl9jb250ZW50O1xyXG5cclxuXHRcdGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0bm9kZS5pbm5lckhUTUwgPSBjb250ZW50O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0d2hpbGUgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XHJcblx0XHRcdFx0bm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcblx0XHQvLyBAc2VjdGlvbiBEaXZPdmVybGF5IGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGNvbnRlbnR1cGRhdGU6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBjb250ZW50IG9mIHRoZSBvdmVybGF5IGlzIHVwZGF0ZWRcclxuXHRcdHRoaXMuZmlyZSgnY29udGVudHVwZGF0ZScpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxyXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvZmZzZXQgPSBvZmZzZXQuYWRkKHBvcykuYWRkKGFuY2hvcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGJvdHRvbSA9IHRoaXMuX2NvbnRhaW5lckJvdHRvbSA9IC1vZmZzZXQueSxcclxuXHRcdCAgICBsZWZ0ID0gdGhpcy5fY29udGFpbmVyTGVmdCA9IC1NYXRoLnJvdW5kKHRoaXMuX2NvbnRhaW5lcldpZHRoIC8gMikgKyBvZmZzZXQueDtcclxuXHJcblx0XHQvLyBib3R0b20gcG9zaXRpb24gdGhlIG92ZXJsYXkgaW4gY2FzZSB0aGUgaGVpZ2h0IG9mIHRoZSBvdmVybGF5IGNoYW5nZXMgKGltYWdlcyBsb2FkaW5nIGV0YylcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5ib3R0b20gPSBib3R0b20gKyAncHgnO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gWzAsIDBdO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuTWFwLmluY2x1ZGUoe1xyXG5cdF9pbml0T3ZlcmxheTogZnVuY3Rpb24gKE92ZXJsYXlDbGFzcywgY29udGVudCwgbGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgb3ZlcmxheSA9IGNvbnRlbnQ7XHJcblx0XHRpZiAoIShvdmVybGF5IGluc3RhbmNlb2YgT3ZlcmxheUNsYXNzKSkge1xyXG5cdFx0XHRvdmVybGF5ID0gbmV3IE92ZXJsYXlDbGFzcyhvcHRpb25zKS5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGxhdGxuZykge1xyXG5cdFx0XHRvdmVybGF5LnNldExhdExuZyhsYXRsbmcpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG92ZXJsYXk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG5MYXllci5pbmNsdWRlKHtcclxuXHRfaW5pdE92ZXJsYXk6IGZ1bmN0aW9uIChPdmVybGF5Q2xhc3MsIG9sZCwgY29udGVudCwgb3B0aW9ucykge1xyXG5cdFx0dmFyIG92ZXJsYXkgPSBjb250ZW50O1xyXG5cdFx0aWYgKG92ZXJsYXkgaW5zdGFuY2VvZiBPdmVybGF5Q2xhc3MpIHtcclxuXHRcdFx0VXRpbC5zZXRPcHRpb25zKG92ZXJsYXksIG9wdGlvbnMpO1xyXG5cdFx0XHRvdmVybGF5Ll9zb3VyY2UgPSB0aGlzO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b3ZlcmxheSA9IChvbGQgJiYgIW9wdGlvbnMpID8gb2xkIDogbmV3IE92ZXJsYXlDbGFzcyhvcHRpb25zLCB0aGlzKTtcclxuXHRcdFx0b3ZlcmxheS5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG92ZXJsYXk7XHJcblx0fVxyXG59KTtcclxuIiwiaW1wb3J0IHtEaXZPdmVybGF5fSBmcm9tICcuL0Rpdk92ZXJsYXknO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0IHtQb2ludCwgdG9Qb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQge1BhdGh9IGZyb20gJy4vdmVjdG9yL1BhdGgnO1xyXG5pbXBvcnQge0ZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFBvcHVwXHJcbiAqIEBpbmhlcml0cyBEaXZPdmVybGF5XHJcbiAqIEBha2EgTC5Qb3B1cFxyXG4gKiBVc2VkIHRvIG9wZW4gcG9wdXBzIGluIGNlcnRhaW4gcGxhY2VzIG9mIHRoZSBtYXAuIFVzZSBbTWFwLm9wZW5Qb3B1cF0oI21hcC1vcGVucG9wdXApIHRvXHJcbiAqIG9wZW4gcG9wdXBzIHdoaWxlIG1ha2luZyBzdXJlIHRoYXQgb25seSBvbmUgcG9wdXAgaXMgb3BlbiBhdCBvbmUgdGltZVxyXG4gKiAocmVjb21tZW5kZWQgZm9yIHVzYWJpbGl0eSksIG9yIHVzZSBbTWFwLmFkZExheWVyXSgjbWFwLWFkZGxheWVyKSB0byBvcGVuIGFzIG1hbnkgYXMgeW91IHdhbnQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIElmIHlvdSB3YW50IHRvIGp1c3QgYmluZCBhIHBvcHVwIHRvIG1hcmtlciBjbGljayBhbmQgdGhlbiBvcGVuIGl0LCBpdCdzIHJlYWxseSBlYXN5OlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXJrZXIuYmluZFBvcHVwKHBvcHVwQ29udGVudCkub3BlblBvcHVwKCk7XHJcbiAqIGBgYFxyXG4gKiBQYXRoIG92ZXJsYXlzIGxpa2UgcG9seWxpbmVzIGFsc28gaGF2ZSBhIGBiaW5kUG9wdXBgIG1ldGhvZC5cclxuICpcclxuICogQSBwb3B1cCBjYW4gYmUgYWxzbyBzdGFuZGFsb25lOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcG9wdXAgPSBMLnBvcHVwKClcclxuICogXHQuc2V0TGF0TG5nKGxhdGxuZylcclxuICogXHQuc2V0Q29udGVudCgnPHA+SGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgcG9wdXAuPC9wPicpXHJcbiAqIFx0Lm9wZW5PbihtYXApO1xyXG4gKiBgYGBcclxuICogb3JcclxuICogYGBganNcclxuICogdmFyIHBvcHVwID0gTC5wb3B1cChsYXRsbmcsIHtjb250ZW50OiAnPHA+SGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgcG9wdXAuPC9wPicpXHJcbiAqIFx0Lm9wZW5PbihtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG5leHBvcnQgdmFyIFBvcHVwID0gRGl2T3ZlcmxheS5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgUG9wdXAgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3BvcHVwUGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHBvcHVwIHdpbGwgYmUgYWRkZWQuXHJcblx0XHRwYW5lOiAncG9wdXBQYW5lJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCA3KVxyXG5cdFx0Ly8gVGhlIG9mZnNldCBvZiB0aGUgcG9wdXAgcG9zaXRpb24uXHJcblx0XHRvZmZzZXQ6IFswLCA3XSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heFdpZHRoOiBOdW1iZXIgPSAzMDBcclxuXHRcdC8vIE1heCB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuXHRcdG1heFdpZHRoOiAzMDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtaW5XaWR0aDogTnVtYmVyID0gNTBcclxuXHRcdC8vIE1pbiB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuXHRcdG1pbldpZHRoOiA1MCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heEhlaWdodDogTnVtYmVyID0gbnVsbFxyXG5cdFx0Ly8gSWYgc2V0LCBjcmVhdGVzIGEgc2Nyb2xsYWJsZSBjb250YWluZXIgb2YgdGhlIGdpdmVuIGhlaWdodFxyXG5cdFx0Ly8gaW5zaWRlIGEgcG9wdXAgaWYgaXRzIGNvbnRlbnQgZXhjZWVkcyBpdC5cclxuXHRcdC8vIFRoZSBzY3JvbGxhYmxlIGNvbnRhaW5lciBjYW4gYmUgc3R5bGVkIHVzaW5nIHRoZVxyXG5cdFx0Ly8gYGxlYWZsZXQtcG9wdXAtc2Nyb2xsZWRgIENTUyBjbGFzcyBzZWxlY3Rvci5cclxuXHRcdG1heEhlaWdodDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW46IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgbWFwIHRvIGRvIHBhbm5pbmcgYW5pbWF0aW9uXHJcblx0XHQvLyB0byBmaXQgdGhlIG9wZW5lZCBwb3B1cC5cclxuXHRcdGF1dG9QYW46IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IFBvaW50ID0gbnVsbFxyXG5cdFx0Ly8gVGhlIG1hcmdpbiBiZXR3ZWVuIHRoZSBwb3B1cCBhbmQgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgbWFwXHJcblx0XHQvLyB2aWV3IGFmdGVyIGF1dG9wYW5uaW5nIHdhcyBwZXJmb3JtZWQuXHJcblx0XHRhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBQb2ludCA9IG51bGxcclxuXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBtYXBcclxuXHRcdC8vIHZpZXcgYWZ0ZXIgYXV0b3Bhbm5pbmcgd2FzIHBlcmZvcm1lZC5cclxuXHRcdGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZzogUG9pbnQgPSBQb2ludCg1LCA1KVxyXG5cdFx0Ly8gRXF1aXZhbGVudCBvZiBzZXR0aW5nIGJvdGggdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBhdXRvcGFuIHBhZGRpbmcgdG8gdGhlIHNhbWUgdmFsdWUuXHJcblx0XHRhdXRvUGFuUGFkZGluZzogWzUsIDVdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24ga2VlcEluVmlldzogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBTZXQgaXQgdG8gYHRydWVgIGlmIHlvdSB3YW50IHRvIHByZXZlbnQgdXNlcnMgZnJvbSBwYW5uaW5nIHRoZSBwb3B1cFxyXG5cdFx0Ly8gb2ZmIG9mIHRoZSBzY3JlZW4gd2hpbGUgaXQgaXMgb3Blbi5cclxuXHRcdGtlZXBJblZpZXc6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xvc2VCdXR0b246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBDb250cm9scyB0aGUgcHJlc2VuY2Ugb2YgYSBjbG9zZSBidXR0b24gaW4gdGhlIHBvcHVwLlxyXG5cdFx0Y2xvc2VCdXR0b246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvQ2xvc2U6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZlxyXG5cdFx0Ly8gdGhlIHBvcHVwIGNsb3Npbmcgd2hlbiBhbm90aGVyIHBvcHVwIGlzIG9wZW5lZC5cclxuXHRcdGF1dG9DbG9zZTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsb3NlT25Fc2NhcGVLZXk6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZlxyXG5cdFx0Ly8gdGhlIEVTQyBrZXkgZm9yIGNsb3Npbmcgb2YgdGhlIHBvcHVwLlxyXG5cdFx0Y2xvc2VPbkVzY2FwZUtleTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsb3NlT25DbGljazogQm9vbGVhbiA9ICpcclxuXHRcdC8vIFNldCBpdCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiB0aGUgcG9wdXAgY2xvc2luZyB3aGVuIHVzZXIgY2xpY2tzXHJcblx0XHQvLyBvbiB0aGUgbWFwLiBEZWZhdWx0cyB0byB0aGUgbWFwJ3MgW2BjbG9zZVBvcHVwT25DbGlja2BdKCNtYXAtY2xvc2Vwb3B1cG9uY2xpY2spIG9wdGlvbi5cclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIENTUyBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgcG9wdXAuXHJcblx0XHRjbGFzc05hbWU6ICcnXHJcblx0fSxcclxuXHJcblx0Ly8gQG5hbWVzcGFjZSBQb3B1cFxyXG5cdC8vIEBtZXRob2Qgb3Blbk9uKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFsdGVybmF0aXZlIHRvIGBtYXAub3BlblBvcHVwKHBvcHVwKWAuXHJcblx0Ly8gQWRkcyB0aGUgcG9wdXAgdG8gdGhlIG1hcCBhbmQgY2xvc2VzIHRoZSBwcmV2aW91cyBvbmUuXHJcblx0b3Blbk9uOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAgPSBhcmd1bWVudHMubGVuZ3RoID8gbWFwIDogdGhpcy5fc291cmNlLl9tYXA7IC8vIGV4cGVyaW1lbnRhbCwgbm90IHRoZSBwYXJ0IG9mIHB1YmxpYyBhcGlcclxuXHJcblx0XHRpZiAoIW1hcC5oYXNMYXllcih0aGlzKSAmJiBtYXAuX3BvcHVwICYmIG1hcC5fcG9wdXAub3B0aW9ucy5hdXRvQ2xvc2UpIHtcclxuXHRcdFx0bWFwLnJlbW92ZUxheWVyKG1hcC5fcG9wdXApO1xyXG5cdFx0fVxyXG5cdFx0bWFwLl9wb3B1cCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuIERpdk92ZXJsYXkucHJvdG90eXBlLm9wZW5Pbi5jYWxsKHRoaXMsIG1hcCk7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaXMgb3BlbmVkIGluIHRoZSBtYXBcclxuXHRcdG1hcC5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCBwb3B1cG9wZW46IFBvcHVwRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkXHJcblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuXHRcdFx0Ly8gRm9yIG5vbi1wYXRoIGxheWVycywgd2UgdG9nZ2xlIHRoZSBwb3B1cCB3aGVuIGNsaWNraW5nXHJcblx0XHRcdC8vIGFnYWluIHRoZSBsYXllciwgc28gcHJldmVudCB0aGUgbWFwIHRvIHJlb3BlbiBpdC5cclxuXHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgUGF0aCkpIHtcclxuXHRcdFx0XHR0aGlzLl9zb3VyY2Uub24oJ3ByZWNsaWNrJywgRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHBvcHVwY2xvc2U6IFBvcHVwRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBpbiB0aGUgbWFwIGlzIGNsb3NlZFxyXG5cdFx0bWFwLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZFxyXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG5cdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG5cdFx0XHRcdHRoaXMuX3NvdXJjZS5vZmYoJ3ByZWNsaWNrJywgRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IERpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrICE9PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrIDogdGhpcy5fbWFwLm9wdGlvbnMuY2xvc2VQb3B1cE9uQ2xpY2spIHtcclxuXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5jbG9zZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmtlZXBJblZpZXcpIHtcclxuXHRcdFx0ZXZlbnRzLm1vdmVlbmQgPSB0aGlzLl9hZGp1c3RQYW47XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXBvcHVwJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JyxcclxuXHRcdFx0cHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICtcclxuXHRcdFx0JyBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHJcblx0XHR2YXIgd3JhcHBlciA9IHRoaXMuX3dyYXBwZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50LXdyYXBwZXInLCBjb250YWluZXIpO1xyXG5cdFx0dGhpcy5fY29udGVudE5vZGUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50Jywgd3JhcHBlcik7XHJcblxyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHRcdERvbUV2ZW50LmRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbih0aGlzLl9jb250ZW50Tm9kZSk7XHJcblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdjb250ZXh0bWVudScsIERvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblxyXG5cdFx0dGhpcy5fdGlwQ29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctdGlwLWNvbnRhaW5lcicsIGNvbnRhaW5lcik7XHJcblx0XHR0aGlzLl90aXAgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy10aXAnLCB0aGlzLl90aXBDb250YWluZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VCdXR0b24pIHtcclxuXHRcdFx0dmFyIGNsb3NlQnV0dG9uID0gdGhpcy5fY2xvc2VCdXR0b24gPSBEb21VdGlsLmNyZWF0ZSgnYScsIHByZWZpeCArICctY2xvc2UtYnV0dG9uJywgY29udGFpbmVyKTtcclxuXHRcdFx0Y2xvc2VCdXR0b24uc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpOyAvLyBvdmVycmlkZXMgdGhlIGltcGxpY2l0IHJvbGU9bGluayBvZiA8YT4gZWxlbWVudHMgIzczOTlcclxuXHRcdFx0Y2xvc2VCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgJ0Nsb3NlIHBvcHVwJyk7XHJcblx0XHRcdGNsb3NlQnV0dG9uLmhyZWYgPSAnI2Nsb3NlJztcclxuXHRcdFx0Y2xvc2VCdXR0b24uaW5uZXJIVE1MID0gJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiYjMjE1Ozwvc3Bhbj4nO1xyXG5cclxuXHRcdFx0RG9tRXZlbnQub24oY2xvc2VCdXR0b24sICdjbGljaycsIGZ1bmN0aW9uIChldikge1xyXG5cdFx0XHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGV2KTtcclxuXHRcdFx0XHR0aGlzLmNsb3NlKCk7XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250ZW50Tm9kZSxcclxuXHRcdCAgICBzdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcclxuXHJcblx0XHRzdHlsZS53aWR0aCA9ICcnO1xyXG5cdFx0c3R5bGUud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xyXG5cclxuXHRcdHZhciB3aWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuXHRcdHdpZHRoID0gTWF0aC5taW4od2lkdGgsIHRoaXMub3B0aW9ucy5tYXhXaWR0aCk7XHJcblx0XHR3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCB0aGlzLm9wdGlvbnMubWluV2lkdGgpO1xyXG5cclxuXHRcdHN0eWxlLndpZHRoID0gKHdpZHRoICsgMSkgKyAncHgnO1xyXG5cdFx0c3R5bGUud2hpdGVTcGFjZSA9ICcnO1xyXG5cclxuXHRcdHN0eWxlLmhlaWdodCA9ICcnO1xyXG5cclxuXHRcdHZhciBoZWlnaHQgPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0LFxyXG5cdFx0ICAgIG1heEhlaWdodCA9IHRoaXMub3B0aW9ucy5tYXhIZWlnaHQsXHJcblx0XHQgICAgc2Nyb2xsZWRDbGFzcyA9ICdsZWFmbGV0LXBvcHVwLXNjcm9sbGVkJztcclxuXHJcblx0XHRpZiAobWF4SGVpZ2h0ICYmIGhlaWdodCA+IG1heEhlaWdodCkge1xyXG5cdFx0XHRzdHlsZS5oZWlnaHQgPSBtYXhIZWlnaHQgKyAncHgnO1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGg7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgZS56b29tLCBlLmNlbnRlciksXHJcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zLmFkZChhbmNob3IpKTtcclxuXHR9LFxyXG5cclxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5hdXRvUGFuKSB7IHJldHVybjsgfVxyXG5cdFx0aWYgKHRoaXMuX21hcC5fcGFuQW5pbSkgeyB0aGlzLl9tYXAuX3BhbkFuaW0uc3RvcCgpOyB9XHJcblxyXG5cdFx0Ly8gV2UgY2FuIGVuZGxlc3NseSByZWN1cnNlIGlmIGtlZXBJblZpZXcgaXMgc2V0IGFuZCB0aGUgdmlldyByZXNldHMuXHJcblx0XHQvLyBMZXQncyBndWFyZCBhZ2FpbnN0IHRoYXQgYnkgZXhpdGluZyBlYXJseSBpZiB3ZSdyZSByZXNwb25kaW5nIHRvIG91ciBvd24gYXV0b3Bhbi5cclxuXHRcdGlmICh0aGlzLl9hdXRvcGFubmluZykge1xyXG5cdFx0XHR0aGlzLl9hdXRvcGFubmluZyA9IGZhbHNlO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBtYXJnaW5Cb3R0b20gPSBwYXJzZUludChEb21VdGlsLmdldFN0eWxlKHRoaXMuX2NvbnRhaW5lciwgJ21hcmdpbkJvdHRvbScpLCAxMCkgfHwgMCxcclxuXHRcdCAgICBjb250YWluZXJIZWlnaHQgPSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0ICsgbWFyZ2luQm90dG9tLFxyXG5cdFx0ICAgIGNvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVyV2lkdGgsXHJcblx0XHQgICAgbGF5ZXJQb3MgPSBuZXcgUG9pbnQodGhpcy5fY29udGFpbmVyTGVmdCwgLWNvbnRhaW5lckhlaWdodCAtIHRoaXMuX2NvbnRhaW5lckJvdHRvbSk7XHJcblxyXG5cdFx0bGF5ZXJQb3MuX2FkZChEb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lcikpO1xyXG5cclxuXHRcdHZhciBjb250YWluZXJQb3MgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQobGF5ZXJQb3MpLFxyXG5cdFx0ICAgIHBhZGRpbmcgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZyksXHJcblx0XHQgICAgcGFkZGluZ1RMID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdUb3BMZWZ0IHx8IHBhZGRpbmcpLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQgfHwgcGFkZGluZyksXHJcblx0XHQgICAgc2l6ZSA9IG1hcC5nZXRTaXplKCksXHJcblx0XHQgICAgZHggPSAwLFxyXG5cdFx0ICAgIGR5ID0gMDtcclxuXHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCArIHBhZGRpbmdCUi54ID4gc2l6ZS54KSB7IC8vIHJpZ2h0XHJcblx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCAtIHNpemUueCArIHBhZGRpbmdCUi54O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy54IC0gZHggLSBwYWRkaW5nVEwueCA8IDApIHsgLy8gbGVmdFxyXG5cdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54IC0gcGFkZGluZ1RMLng7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgKyBwYWRkaW5nQlIueSA+IHNpemUueSkgeyAvLyBib3R0b21cclxuXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCAtIHNpemUueSArIHBhZGRpbmdCUi55O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy55IC0gZHkgLSBwYWRkaW5nVEwueSA8IDApIHsgLy8gdG9wXHJcblx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgLSBwYWRkaW5nVEwueTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgYXV0b3BhbnN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHN0YXJ0cyBhdXRvcGFubmluZyB3aGVuIG9wZW5pbmcgYSBwb3B1cC5cclxuXHRcdGlmIChkeCB8fCBkeSkge1xyXG5cdFx0XHQvLyBUcmFjayB0aGF0IHdlJ3JlIGF1dG9wYW5uaW5nLCBhcyB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgcmUtcmFuIG9uIG1vdmVlbmRcclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5rZWVwSW5WaWV3KSB7XHJcblx0XHRcdFx0dGhpcy5fYXV0b3Bhbm5pbmcgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtYXBcclxuXHRcdFx0ICAgIC5maXJlKCdhdXRvcGFuc3RhcnQnKVxyXG5cdFx0XHQgICAgLnBhbkJ5KFtkeCwgZHldKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSBwb3B1cCBvbiB0aGUgc291cmNlIGxheWVyP1xyXG5cdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IgPyB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yKCkgOiBbMCwgMF0pO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG4vLyBAZmFjdG9yeSBMLnBvcHVwKG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcclxuLy8gSW5zdGFudGlhdGVzIGEgYFBvcHVwYCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSBwb3B1cCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnBvcHVwKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogUG9wdXAgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgYFBvcHVwYCBvYmplY3QgZ2l2ZW4gYGxhdGxuZ2Agd2hlcmUgdGhlIHBvcHVwIHdpbGwgb3BlbiBhbmQgYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24uXHJcbmV4cG9ydCB2YXIgcG9wdXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcblx0cmV0dXJuIG5ldyBQb3B1cChvcHRpb25zLCBzb3VyY2UpO1xyXG59O1xyXG5cclxuXHJcbi8qIEBuYW1lc3BhY2UgTWFwXHJcbiAqIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuICogQG9wdGlvbiBjbG9zZVBvcHVwT25DbGljazogQm9vbGVhbiA9IHRydWVcclxuICogU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IGRvbid0IHdhbnQgcG9wdXBzIHRvIGNsb3NlIHdoZW4gdXNlciBjbGlja3MgdGhlIG1hcC5cclxuICovXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGNsb3NlUG9wdXBPbkNsaWNrOiB0cnVlXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuTWFwLmluY2x1ZGUoe1xyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKHBvcHVwOiBQb3B1cCk6IHRoaXNcclxuXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHBvcHVwIHdoaWxlIGNsb3NpbmcgdGhlIHByZXZpb3VzbHkgb3BlbmVkICh0byBtYWtlIHN1cmUgb25seSBvbmUgaXMgb3BlbmVkIGF0IG9uZSB0aW1lIGZvciB1c2FiaWxpdHkpLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKTogdGhpc1xyXG5cdC8vIENyZWF0ZXMgYSBwb3B1cCB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBhbmQgb3B0aW9ucyBhbmQgb3BlbnMgaXQgaW4gdGhlIGdpdmVuIHBvaW50IG9uIGEgbWFwLlxyXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKHBvcHVwLCBsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdHRoaXMuX2luaXRPdmVybGF5KFBvcHVwLCBwb3B1cCwgbGF0bG5nLCBvcHRpb25zKVxyXG5cdFx0ICAub3Blbk9uKHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xvc2VQb3B1cChwb3B1cD86IFBvcHVwKTogdGhpc1xyXG5cdC8vIENsb3NlcyB0aGUgcG9wdXAgcHJldmlvdXNseSBvcGVuZWQgd2l0aCBbb3BlblBvcHVwXSgjbWFwLW9wZW5wb3B1cCkgKG9yIHRoZSBnaXZlbiBvbmUpLlxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCkge1xyXG5cdFx0cG9wdXAgPSBhcmd1bWVudHMubGVuZ3RoID8gcG9wdXAgOiB0aGlzLl9wb3B1cDtcclxuXHRcdGlmIChwb3B1cCkge1xyXG5cdFx0XHRwb3B1cC5jbG9zZSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgTGF5ZXJcclxuICogQHNlY3Rpb24gUG9wdXAgbWV0aG9kcyBleGFtcGxlXHJcbiAqXHJcbiAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHBvcHVwcyB0byBpdC5cclxuICpcclxuICogYGBganNcclxuICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRQb3B1cCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcclxuICogbGF5ZXIub3BlblBvcHVwKCk7XHJcbiAqIGxheWVyLmNsb3NlUG9wdXAoKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFBvcHVwcyB3aWxsIGFsc28gYmUgYXV0b21hdGljYWxseSBvcGVuZWQgd2hlbiB0aGUgbGF5ZXIgaXMgY2xpY2tlZCBvbiBhbmQgY2xvc2VkIHdoZW4gdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwIG9yIGFub3RoZXIgcG9wdXAgaXMgb3BlbmVkLlxyXG4gKi9cclxuXHJcbi8vIEBzZWN0aW9uIFBvcHVwIG1ldGhvZHNcclxuTGF5ZXIuaW5jbHVkZSh7XHJcblxyXG5cdC8vIEBtZXRob2QgYmluZFBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxQb3B1cCwgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQmluZHMgYSBwb3B1cCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcclxuXHQvLyBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxyXG5cdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxyXG5cdGJpbmRQb3B1cDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcclxuXHRcdHRoaXMuX3BvcHVwID0gdGhpcy5faW5pdE92ZXJsYXkoUG9wdXAsIHRoaXMuX3BvcHVwLCBjb250ZW50LCBvcHRpb25zKTtcclxuXHRcdGlmICghdGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkKSB7XHJcblx0XHRcdHRoaXMub24oe1xyXG5cdFx0XHRcdGNsaWNrOiB0aGlzLl9vcGVuUG9wdXAsXHJcblx0XHRcdFx0a2V5cHJlc3M6IHRoaXMuX29uS2V5UHJlc3MsXHJcblx0XHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlUG9wdXAsXHJcblx0XHRcdFx0bW92ZTogdGhpcy5fbW92ZVBvcHVwXHJcblx0XHRcdH0pO1xyXG5cdFx0XHR0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5iaW5kUG9wdXAoKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIHBvcHVwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFBvcHVwYC5cclxuXHR1bmJpbmRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMub2ZmKHtcclxuXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxyXG5cdFx0XHRcdGtleXByZXNzOiB0aGlzLl9vbktleVByZXNzLFxyXG5cdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxyXG5cdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxyXG5cdFx0XHR9KTtcclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuX3BvcHVwID0gbnVsbDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcclxuXHQvLyBPcGVucyB0aGUgYm91bmQgcG9wdXAgYXQgdGhlIHNwZWNpZmllZCBgbGF0bG5nYCBvciBhdCB0aGUgZGVmYXVsdCBwb3B1cCBhbmNob3IgaWYgbm8gYGxhdGxuZ2AgaXMgcGFzc2VkLlxyXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBGZWF0dXJlR3JvdXApKSB7XHJcblx0XHRcdFx0dGhpcy5fcG9wdXAuX3NvdXJjZSA9IHRoaXM7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRoaXMuX3BvcHVwLl9wcmVwYXJlT3BlbihsYXRsbmcgfHwgdGhpcy5fbGF0bG5nKSkge1xyXG5cdFx0XHRcdC8vIG9wZW4gdGhlIHBvcHVwIG9uIHRoZSBtYXBcclxuXHRcdFx0XHR0aGlzLl9wb3B1cC5vcGVuT24odGhpcy5fbWFwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKCk6IHRoaXNcclxuXHQvLyBDbG9zZXMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaWYgaXQgaXMgb3Blbi5cclxuXHRjbG9zZVBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAuY2xvc2UoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9nZ2xlUG9wdXAoKTogdGhpc1xyXG5cdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXHJcblx0dG9nZ2xlUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLl9wb3B1cC50b2dnbGUodGhpcyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGlzUG9wdXBPcGVuKCk6IGJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjdXJyZW50bHkgb3Blbi5cclxuXHRpc1BvcHVwT3BlbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICh0aGlzLl9wb3B1cCA/IHRoaXMuX3BvcHVwLmlzT3BlbigpIDogZmFsc2UpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UG9wdXBDb250ZW50KGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxQb3B1cCk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyLlxyXG5cdHNldFBvcHVwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLl9wb3B1cC5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQb3B1cCgpOiBQb3B1cFxyXG5cdC8vIFJldHVybnMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXHJcblx0Z2V0UG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9wb3B1cDtcclxuXHR9LFxyXG5cclxuXHRfb3BlblBvcHVwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9wb3B1cCB8fCAhdGhpcy5fbWFwKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdC8vIHByZXZlbnQgbWFwIGNsaWNrXHJcblx0XHREb21FdmVudC5zdG9wKGUpO1xyXG5cclxuXHRcdHZhciB0YXJnZXQgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwLl9zb3VyY2UgPT09IHRhcmdldCAmJiAhKHRhcmdldCBpbnN0YW5jZW9mIFBhdGgpKSB7XHJcblx0XHRcdC8vIHRyZWF0IGl0IGxpa2UgYSBtYXJrZXIgYW5kIGZpZ3VyZSBvdXRcclxuXHRcdFx0Ly8gaWYgd2Ugc2hvdWxkIHRvZ2dsZSBpdCBvcGVuL2Nsb3NlZFxyXG5cdFx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHRoaXMuX3BvcHVwKSkge1xyXG5cdFx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMub3BlblBvcHVwKGUubGF0bG5nKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHR0aGlzLl9wb3B1cC5fc291cmNlID0gdGFyZ2V0O1xyXG5cdFx0dGhpcy5vcGVuUG9wdXAoZS5sYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9wb3B1cC5zZXRMYXRMbmcoZS5sYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdF9vbktleVByZXNzOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKGUub3JpZ2luYWxFdmVudC5rZXlDb2RlID09PSAxMykge1xyXG5cdFx0XHR0aGlzLl9vcGVuUG9wdXAoZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuIiwiaW1wb3J0IHtEaXZPdmVybGF5fSBmcm9tICcuL0Rpdk92ZXJsYXknO1xuaW1wb3J0IHt0b1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XG5pbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcbmltcG9ydCB7RmVhdHVyZUdyb3VwfSBmcm9tICcuL0ZlYXR1cmVHcm91cCc7XG5cbi8qXG4gKiBAY2xhc3MgVG9vbHRpcFxuICogQGluaGVyaXRzIERpdk92ZXJsYXlcbiAqIEBha2EgTC5Ub29sdGlwXG4gKiBVc2VkIHRvIGRpc3BsYXkgc21hbGwgdGV4dHMgb24gdG9wIG9mIG1hcCBsYXllcnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIElmIHlvdSB3YW50IHRvIGp1c3QgYmluZCBhIHRvb2x0aXAgdG8gbWFya2VyOlxuICpcbiAqIGBgYGpzXG4gKiBtYXJrZXIuYmluZFRvb2x0aXAoXCJteSB0b29sdGlwIHRleHRcIikub3BlblRvb2x0aXAoKTtcbiAqIGBgYFxuICogUGF0aCBvdmVybGF5cyBsaWtlIHBvbHlsaW5lcyBhbHNvIGhhdmUgYSBgYmluZFRvb2x0aXBgIG1ldGhvZC5cbiAqXG4gKiBBIHRvb2x0aXAgY2FuIGJlIGFsc28gc3RhbmRhbG9uZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHRvb2x0aXAgPSBMLnRvb2x0aXAoKVxuICogXHQuc2V0TGF0TG5nKGxhdGxuZylcbiAqIFx0LnNldENvbnRlbnQoJ0hlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHRvb2x0aXAuJylcbiAqIFx0LmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqIG9yXG4gKiBgYGBqc1xuICogdmFyIHRvb2x0aXAgPSBMLnRvb2x0aXAobGF0bG5nLCB7Y29udGVudDogJ0hlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHRvb2x0aXAuJ30pXG4gKiBcdC5hZGRUbyhtYXApO1xuICogYGBgXG4gKlxuICpcbiAqIE5vdGUgYWJvdXQgdG9vbHRpcCBvZmZzZXQuIExlYWZsZXQgdGFrZXMgdHdvIG9wdGlvbnMgaW4gY29uc2lkZXJhdGlvblxuICogZm9yIGNvbXB1dGluZyB0b29sdGlwIG9mZnNldHRpbmc6XG4gKiAtIHRoZSBgb2Zmc2V0YCBUb29sdGlwIG9wdGlvbjogaXQgZGVmYXVsdHMgdG8gWzAsIDBdLCBhbmQgaXQncyBzcGVjaWZpYyB0byBvbmUgdG9vbHRpcC5cbiAqICAgQWRkIGEgcG9zaXRpdmUgeCBvZmZzZXQgdG8gbW92ZSB0aGUgdG9vbHRpcCB0byB0aGUgcmlnaHQsIGFuZCBhIHBvc2l0aXZlIHkgb2Zmc2V0IHRvXG4gKiAgIG1vdmUgaXQgdG8gdGhlIGJvdHRvbS4gTmVnYXRpdmVzIHdpbGwgbW92ZSB0byB0aGUgbGVmdCBhbmQgdG9wLlxuICogLSB0aGUgYHRvb2x0aXBBbmNob3JgIEljb24gb3B0aW9uOiB0aGlzIHdpbGwgb25seSBiZSBjb25zaWRlcmVkIGZvciBNYXJrZXIuIFlvdVxuICogICBzaG91bGQgYWRhcHQgdGhpcyB2YWx1ZSBpZiB5b3UgdXNlIGEgY3VzdG9tIGljb24uXG4gKi9cblxuXG4vLyBAbmFtZXNwYWNlIFRvb2x0aXBcbmV4cG9ydCB2YXIgVG9vbHRpcCA9IERpdk92ZXJsYXkuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFRvb2x0aXAgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAndG9vbHRpcFBhbmUnXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgdG9vbHRpcCB3aWxsIGJlIGFkZGVkLlxuXHRcdHBhbmU6ICd0b29sdGlwUGFuZScsXG5cblx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCAwKVxuXHRcdC8vIE9wdGlvbmFsIG9mZnNldCBvZiB0aGUgdG9vbHRpcCBwb3NpdGlvbi5cblx0XHRvZmZzZXQ6IFswLCAwXSxcblxuXHRcdC8vIEBvcHRpb24gZGlyZWN0aW9uOiBTdHJpbmcgPSAnYXV0bydcblx0XHQvLyBEaXJlY3Rpb24gd2hlcmUgdG8gb3BlbiB0aGUgdG9vbHRpcC4gUG9zc2libGUgdmFsdWVzIGFyZTogYHJpZ2h0YCwgYGxlZnRgLFxuXHRcdC8vIGB0b3BgLCBgYm90dG9tYCwgYGNlbnRlcmAsIGBhdXRvYC5cblx0XHQvLyBgYXV0b2Agd2lsbCBkeW5hbWljYWxseSBzd2l0Y2ggYmV0d2VlbiBgcmlnaHRgIGFuZCBgbGVmdGAgYWNjb3JkaW5nIHRvIHRoZSB0b29sdGlwXG5cdFx0Ly8gcG9zaXRpb24gb24gdGhlIG1hcC5cblx0XHRkaXJlY3Rpb246ICdhdXRvJyxcblxuXHRcdC8vIEBvcHRpb24gcGVybWFuZW50OiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBXaGV0aGVyIHRvIG9wZW4gdGhlIHRvb2x0aXAgcGVybWFuZW50bHkgb3Igb25seSBvbiBtb3VzZW92ZXIuXG5cdFx0cGVybWFuZW50OiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gc3RpY2t5OiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiB0cnVlLCB0aGUgdG9vbHRpcCB3aWxsIGZvbGxvdyB0aGUgbW91c2UgaW5zdGVhZCBvZiBiZWluZyBmaXhlZCBhdCB0aGUgZmVhdHVyZSBjZW50ZXIuXG5cdFx0c3RpY2t5OiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMC45XG5cdFx0Ly8gVG9vbHRpcCBjb250YWluZXIgb3BhY2l0eS5cblx0XHRvcGFjaXR5OiAwLjlcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcblx0XHR0aGlzLnNldE9wYWNpdHkodGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaXMgb3BlbmVkIGluIHRoZSBtYXAuXG5cdFx0bWFwLmZpcmUoJ3Rvb2x0aXBvcGVuJywge3Rvb2x0aXA6IHRoaXN9KTtcblxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcblx0XHRcdHRoaXMuYWRkRXZlbnRQYXJlbnQodGhpcy5fc291cmNlKTtcblxuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuXHRcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIG9wZW5lZC5cblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCd0b29sdGlwb3BlbicsIHt0b29sdGlwOiB0aGlzfSwgdHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGluIHRoZSBtYXAgaXMgY2xvc2VkLlxuXHRcdG1hcC5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30pO1xuXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xuXHRcdFx0dGhpcy5yZW1vdmVFdmVudFBhcmVudCh0aGlzLl9zb3VyY2UpO1xuXG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXG5cdFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdFx0Ly8gQGV2ZW50IHRvb2x0aXBjbG9zZTogVG9vbHRpcEV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZC5cblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0gRGl2T3ZlcmxheS5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy5wZXJtYW5lbnQpIHtcblx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuY2xvc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwcmVmaXggPSAnbGVhZmxldC10b29sdGlwJyxcblx0XHQgICAgY2xhc3NOYW1lID0gcHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICsgJyBsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKTtcblxuXHRcdHRoaXMuX2NvbnRlbnROb2RlID0gdGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSk7XG5cblx0XHR0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3Rvb2x0aXAnKTtcblx0XHR0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKCdpZCcsICdsZWFmbGV0LXRvb2x0aXAtJyArIFV0aWwuc3RhbXAodGhpcykpO1xuXHR9LFxuXG5cdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uICgpIHt9LFxuXG5cdF9zZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvcykge1xuXHRcdHZhciBzdWJYLCBzdWJZLFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcblx0XHQgICAgY2VudGVyUG9pbnQgPSBtYXAubGF0TG5nVG9Db250YWluZXJQb2ludChtYXAuZ2V0Q2VudGVyKCkpLFxuXHRcdCAgICB0b29sdGlwUG9pbnQgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9zKSxcblx0XHQgICAgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbixcblx0XHQgICAgdG9vbHRpcFdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoLFxuXHRcdCAgICB0b29sdGlwSGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcblx0XHQgICAgb2Zmc2V0ID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XG5cblx0XHRpZiAoZGlyZWN0aW9uID09PSAndG9wJykge1xuXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCAvIDI7XG5cdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodDtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScpIHtcblx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGggLyAyO1xuXHRcdFx0c3ViWSA9IDA7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoIC8gMjtcblx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdFx0c3ViWCA9IDA7XG5cdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdsZWZ0Jykge1xuXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aDtcblx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcblx0XHR9IGVsc2UgaWYgKHRvb2x0aXBQb2ludC54IDwgY2VudGVyUG9pbnQueCkge1xuXHRcdFx0ZGlyZWN0aW9uID0gJ3JpZ2h0Jztcblx0XHRcdHN1YlggPSAwO1xuXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXJlY3Rpb24gPSAnbGVmdCc7XG5cdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoICsgKG9mZnNldC54ICsgYW5jaG9yLngpICogMjtcblx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcblx0XHR9XG5cblx0XHRwb3MgPSBwb3Muc3VidHJhY3QodG9Qb2ludChzdWJYLCBzdWJZLCB0cnVlKSkuYWRkKG9mZnNldCkuYWRkKGFuY2hvcik7XG5cblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1yaWdodCcpO1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLWxlZnQnKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC10b3AnKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1ib3R0b20nKTtcblx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC0nICsgZGlyZWN0aW9uKTtcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgcG9zKTtcblx0fSxcblxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG5cdH0sXG5cblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG5cblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCBvcGFjaXR5KTtcblx0XHR9XG5cdH0sXG5cblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIGUuem9vbSwgZS5jZW50ZXIpO1xuXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG5cdH0sXG5cblx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFdoZXJlIHNob3VsZCB3ZSBhbmNob3IgdGhlIHRvb2x0aXAgb24gdGhlIHNvdXJjZSBsYXllcj9cblx0XHRyZXR1cm4gdG9Qb2ludCh0aGlzLl9zb3VyY2UgJiYgdGhpcy5fc291cmNlLl9nZXRUb29sdGlwQW5jaG9yICYmICF0aGlzLm9wdGlvbnMuc3RpY2t5ID8gdGhpcy5fc291cmNlLl9nZXRUb29sdGlwQW5jaG9yKCkgOiBbMCwgMF0pO1xuXHR9XG5cbn0pO1xuXG4vLyBAbmFtZXNwYWNlIFRvb2x0aXBcbi8vIEBmYWN0b3J5IEwudG9vbHRpcChvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcbi8vIEluc3RhbnRpYXRlcyBhIGBUb29sdGlwYCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSB0b29sdGlwIHdpdGggYSByZWZlcmVuY2UgdG8gdGhlIExheWVyIHRvIHdoaWNoIGl0IHJlZmVycy5cbi8vIEBhbHRlcm5hdGl2ZVxuLy8gQGZhY3RvcnkgTC50b29sdGlwKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgYFRvb2x0aXBgIG9iamVjdCBnaXZlbiBgbGF0bG5nYCB3aGVyZSB0aGUgdG9vbHRpcCB3aWxsIG9wZW4gYW5kIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uLlxuZXhwb3J0IHZhciB0b29sdGlwID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuXHRyZXR1cm4gbmV3IFRvb2x0aXAob3B0aW9ucywgc291cmNlKTtcbn07XG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXG5NYXAuaW5jbHVkZSh7XG5cblx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcCh0b29sdGlwOiBUb29sdGlwKTogdGhpc1xuXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHRvb2x0aXAuXG5cdC8vIEBhbHRlcm5hdGl2ZVxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG5cdC8vIENyZWF0ZXMgYSB0b29sdGlwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVuIGl0LlxuXHRvcGVuVG9vbHRpcDogZnVuY3Rpb24gKHRvb2x0aXAsIGxhdGxuZywgb3B0aW9ucykge1xuXHRcdHRoaXMuX2luaXRPdmVybGF5KFRvb2x0aXAsIHRvb2x0aXAsIGxhdGxuZywgb3B0aW9ucylcblx0XHQgIC5vcGVuT24odGhpcyk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGNsb3NlVG9vbHRpcCh0b29sdGlwOiBUb29sdGlwKTogdGhpc1xuXHQvLyBDbG9zZXMgdGhlIHRvb2x0aXAgZ2l2ZW4gYXMgcGFyYW1ldGVyLlxuXHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uICh0b29sdGlwKSB7XG5cdFx0dG9vbHRpcC5jbG9zZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cbn0pO1xuXG4vKlxuICogQG5hbWVzcGFjZSBMYXllclxuICogQHNlY3Rpb24gVG9vbHRpcCBtZXRob2RzIGV4YW1wbGVcbiAqXG4gKiBBbGwgbGF5ZXJzIHNoYXJlIGEgc2V0IG9mIG1ldGhvZHMgY29udmVuaWVudCBmb3IgYmluZGluZyB0b29sdGlwcyB0byBpdC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRUb29sdGlwKCdIaSBUaGVyZSEnKS5hZGRUbyhtYXApO1xuICogbGF5ZXIub3BlblRvb2x0aXAoKTtcbiAqIGxheWVyLmNsb3NlVG9vbHRpcCgpO1xuICogYGBgXG4gKi9cblxuLy8gQHNlY3Rpb24gVG9vbHRpcCBtZXRob2RzXG5MYXllci5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIGJpbmRUb29sdGlwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxUb29sdGlwLCBvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zKTogdGhpc1xuXHQvLyBCaW5kcyBhIHRvb2x0aXAgdG8gdGhlIGxheWVyIHdpdGggdGhlIHBhc3NlZCBgY29udGVudGAgYW5kIHNldHMgdXAgdGhlXG5cdC8vIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMuIElmIGEgYEZ1bmN0aW9uYCBpcyBwYXNzZWQgaXQgd2lsbCByZWNlaXZlXG5cdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxuXHRiaW5kVG9vbHRpcDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcblxuXHRcdGlmICh0aGlzLl90b29sdGlwICYmIHRoaXMuaXNUb29sdGlwT3BlbigpKSB7XG5cdFx0XHR0aGlzLnVuYmluZFRvb2x0aXAoKTtcblx0XHR9XG5cblx0XHR0aGlzLl90b29sdGlwID0gdGhpcy5faW5pdE92ZXJsYXkoVG9vbHRpcCwgdGhpcy5fdG9vbHRpcCwgY29udGVudCwgb3B0aW9ucyk7XG5cdFx0dGhpcy5faW5pdFRvb2x0aXBJbnRlcmFjdGlvbnMoKTtcblxuXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMucGVybWFuZW50ICYmIHRoaXMuX21hcCAmJiB0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcykpIHtcblx0XHRcdHRoaXMub3BlblRvb2x0aXAoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHVuYmluZFRvb2x0aXAoKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSB0b29sdGlwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFRvb2x0aXBgLlxuXHR1bmJpbmRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zKHRydWUpO1xuXHRcdFx0dGhpcy5jbG9zZVRvb2x0aXAoKTtcblx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfaW5pdFRvb2x0aXBJbnRlcmFjdGlvbnM6IGZ1bmN0aW9uIChyZW1vdmUpIHtcblx0XHRpZiAoIXJlbW92ZSAmJiB0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCkgeyByZXR1cm47IH1cblx0XHR2YXIgb25PZmYgPSByZW1vdmUgPyAnb2ZmJyA6ICdvbicsXG5cdFx0ICAgIGV2ZW50cyA9IHtcblx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVRvb2x0aXAsXG5cdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlVG9vbHRpcFxuXHRcdCAgICB9O1xuXHRcdGlmICghdGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCkge1xuXHRcdFx0ZXZlbnRzLm1vdXNlb3ZlciA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdFx0ZXZlbnRzLm1vdXNlb3V0ID0gdGhpcy5jbG9zZVRvb2x0aXA7XG5cdFx0XHRldmVudHMuY2xpY2sgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdFx0dGhpcy5fYWRkRm9jdXNMaXN0ZW5lcnMoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV2ZW50cy5hZGQgPSB0aGlzLl9hZGRGb2N1c0xpc3RlbmVycztcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXZlbnRzLmFkZCA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdH1cblx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSkge1xuXHRcdFx0ZXZlbnRzLm1vdXNlbW92ZSA9IHRoaXMuX21vdmVUb29sdGlwO1xuXHRcdH1cblx0XHR0aGlzW29uT2ZmXShldmVudHMpO1xuXHRcdHRoaXMuX3Rvb2x0aXBIYW5kbGVyc0FkZGVkID0gIXJlbW92ZTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcblx0Ly8gT3BlbnMgdGhlIGJvdW5kIHRvb2x0aXAgYXQgdGhlIHNwZWNpZmllZCBgbGF0bG5nYCBvciBhdCB0aGUgZGVmYXVsdCB0b29sdGlwIGFuY2hvciBpZiBubyBgbGF0bG5nYCBpcyBwYXNzZWQuXG5cdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAobGF0bG5nKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBGZWF0dXJlR3JvdXApKSB7XG5cdFx0XHRcdHRoaXMuX3Rvb2x0aXAuX3NvdXJjZSA9IHRoaXM7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5fcHJlcGFyZU9wZW4obGF0bG5nKSkge1xuXHRcdFx0XHQvLyBvcGVuIHRoZSB0b29sdGlwIG9uIHRoZSBtYXBcblx0XHRcdFx0dGhpcy5fdG9vbHRpcC5vcGVuT24odGhpcy5fbWFwKTtcblxuXHRcdFx0XHRpZiAodGhpcy5nZXRFbGVtZW50KSB7XG5cdFx0XHRcdFx0dGhpcy5fc2V0QXJpYURlc2NyaWJlZEJ5T25MYXllcih0aGlzKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLmVhY2hMYXllcikge1xuXHRcdFx0XHRcdHRoaXMuZWFjaExheWVyKHRoaXMuX3NldEFyaWFEZXNjcmliZWRCeU9uTGF5ZXIsIHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKCk6IHRoaXNcblx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaWYgaXQgaXMgb3Blbi5cblx0Y2xvc2VUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHJldHVybiB0aGlzLl90b29sdGlwLmNsb3NlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEBtZXRob2QgdG9nZ2xlVG9vbHRpcCgpOiB0aGlzXG5cdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cblx0dG9nZ2xlVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl90b29sdGlwLnRvZ2dsZSh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc1Rvb2x0aXBPcGVuKCk6IGJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjdXJyZW50bHkgb3Blbi5cblx0aXNUb29sdGlwT3BlbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl90b29sdGlwLmlzT3BlbigpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0VG9vbHRpcENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFRvb2x0aXApOiB0aGlzXG5cdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0c2V0VG9vbHRpcENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudChjb250ZW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRUb29sdGlwKCk6IFRvb2x0aXBcblx0Ly8gUmV0dXJucyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuXHRnZXRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXA7XG5cdH0sXG5cblx0X2FkZEZvY3VzTGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuZ2V0RWxlbWVudCkge1xuXHRcdFx0dGhpcy5fYWRkRm9jdXNMaXN0ZW5lcnNPbkxheWVyKHRoaXMpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5lYWNoTGF5ZXIpIHtcblx0XHRcdHRoaXMuZWFjaExheWVyKHRoaXMuX2FkZEZvY3VzTGlzdGVuZXJzT25MYXllciwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRGb2N1c0xpc3RlbmVyc09uTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBlbCA9IHR5cGVvZiBsYXllci5nZXRFbGVtZW50ID09PSAnZnVuY3Rpb24nICYmIGxheWVyLmdldEVsZW1lbnQoKTtcblx0XHRpZiAoZWwpIHtcblx0XHRcdERvbUV2ZW50Lm9uKGVsLCAnZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMuX3Rvb2x0aXAuX3NvdXJjZSA9IGxheWVyO1xuXHRcdFx0XHR0aGlzLm9wZW5Ub29sdGlwKCk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHRcdERvbUV2ZW50Lm9uKGVsLCAnYmx1cicsIHRoaXMuY2xvc2VUb29sdGlwLCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldEFyaWFEZXNjcmliZWRCeU9uTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBlbCA9IHR5cGVvZiBsYXllci5nZXRFbGVtZW50ID09PSAnZnVuY3Rpb24nICYmIGxheWVyLmdldEVsZW1lbnQoKTtcblx0XHRpZiAoZWwpIHtcblx0XHRcdGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScsIHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lci5pZCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0X29wZW5Ub29sdGlwOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fdG9vbHRpcCB8fCAhdGhpcy5fbWFwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIG1hcCBpcyBtb3ZpbmcsIHdlIHdpbGwgc2hvdyB0aGUgdG9vbHRpcCBhZnRlciBpdCdzIGRvbmUuXG5cdFx0aWYgKHRoaXMuX21hcC5kcmFnZ2luZyAmJiB0aGlzLl9tYXAuZHJhZ2dpbmcubW92aW5nKCkgJiYgIXRoaXMuX29wZW5PbmNlRmxhZykge1xuXHRcdFx0dGhpcy5fb3Blbk9uY2VGbGFnID0gdHJ1ZTtcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdHRoaXMuX21hcC5vbmNlKCdtb3ZlZW5kJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGF0Ll9vcGVuT25jZUZsYWcgPSBmYWxzZTtcblx0XHRcdFx0dGhhdC5fb3BlblRvb2x0aXAoZSk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl90b29sdGlwLl9zb3VyY2UgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xuXG5cdFx0dGhpcy5vcGVuVG9vbHRpcCh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ID8gZS5sYXRsbmcgOiB1bmRlZmluZWQpO1xuXHR9LFxuXG5cdF9tb3ZlVG9vbHRpcDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF0bG5nID0gZS5sYXRsbmcsIGNvbnRhaW5lclBvaW50LCBsYXllclBvaW50O1xuXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ICYmIGUub3JpZ2luYWxFdmVudCkge1xuXHRcdFx0Y29udGFpbmVyUG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS5vcmlnaW5hbEV2ZW50KTtcblx0XHRcdGxheWVyUG9pbnQgPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoY29udGFpbmVyUG9pbnQpO1xuXHRcdFx0bGF0bG5nID0gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcblx0XHR9XG5cdFx0dGhpcy5fdG9vbHRpcC5zZXRMYXRMbmcobGF0bG5nKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge0ljb259IGZyb20gJy4vSWNvbic7XG5pbXBvcnQge3RvUG9pbnQgYXMgcG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7ZW1wdHl9IGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcblxuLypcbiAqIEBjbGFzcyBEaXZJY29uXG4gKiBAYWthIEwuRGl2SWNvblxuICogQGluaGVyaXRzIEljb25cbiAqXG4gKiBSZXByZXNlbnRzIGEgbGlnaHR3ZWlnaHQgaWNvbiBmb3IgbWFya2VycyB0aGF0IHVzZXMgYSBzaW1wbGUgYDxkaXY+YFxuICogZWxlbWVudCBpbnN0ZWFkIG9mIGFuIGltYWdlLiBJbmhlcml0cyBmcm9tIGBJY29uYCBidXQgaWdub3JlcyB0aGUgYGljb25VcmxgIGFuZCBzaGFkb3cgb3B0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIHZhciBteUljb24gPSBMLmRpdkljb24oe2NsYXNzTmFtZTogJ215LWRpdi1pY29uJ30pO1xuICogLy8geW91IGNhbiBzZXQgLm15LWRpdi1pY29uIHN0eWxlcyBpbiBDU1NcbiAqXG4gKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xuICogYGBgXG4gKlxuICogQnkgZGVmYXVsdCwgaXQgaGFzIGEgJ2xlYWZsZXQtZGl2LWljb24nIENTUyBjbGFzcyBhbmQgaXMgc3R5bGVkIGFzIGEgbGl0dGxlIHdoaXRlIHNxdWFyZSB3aXRoIGEgc2hhZG93LlxuICovXG5cbmV4cG9ydCB2YXIgRGl2SWNvbiA9IEljb24uZXh0ZW5kKHtcblx0b3B0aW9uczoge1xuXHRcdC8vIEBzZWN0aW9uXG5cdFx0Ly8gQGFrYSBEaXZJY29uIG9wdGlvbnNcblx0XHRpY29uU2l6ZTogWzEyLCAxMl0sIC8vIGFsc28gY2FuIGJlIHNldCB0aHJvdWdoIENTU1xuXG5cdFx0Ly8gaWNvbkFuY2hvcjogKFBvaW50KSxcblx0XHQvLyBwb3B1cEFuY2hvcjogKFBvaW50KSxcblxuXHRcdC8vIEBvcHRpb24gaHRtbDogU3RyaW5nfEhUTUxFbGVtZW50ID0gJydcblx0XHQvLyBDdXN0b20gSFRNTCBjb2RlIHRvIHB1dCBpbnNpZGUgdGhlIGRpdiBlbGVtZW50LCBlbXB0eSBieSBkZWZhdWx0LiBBbHRlcm5hdGl2ZWx5LFxuXHRcdC8vIGFuIGluc3RhbmNlIG9mIGBIVE1MRWxlbWVudGAuXG5cdFx0aHRtbDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGJnUG9zOiBQb2ludCA9IFswLCAwXVxuXHRcdC8vIE9wdGlvbmFsIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBiYWNrZ3JvdW5kLCBpbiBwaXhlbHNcblx0XHRiZ1BvczogbnVsbCxcblxuXHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24nXG5cdH0sXG5cblx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcblx0XHR2YXIgZGl2ID0gKG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnRElWJykgPyBvbGRJY29uIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRpZiAob3B0aW9ucy5odG1sIGluc3RhbmNlb2YgRWxlbWVudCkge1xuXHRcdFx0ZW1wdHkoZGl2KTtcblx0XHRcdGRpdi5hcHBlbmRDaGlsZChvcHRpb25zLmh0bWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXYuaW5uZXJIVE1MID0gb3B0aW9ucy5odG1sICE9PSBmYWxzZSA/IG9wdGlvbnMuaHRtbCA6ICcnO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmJnUG9zKSB7XG5cdFx0XHR2YXIgYmdQb3MgPSBwb2ludChvcHRpb25zLmJnUG9zKTtcblx0XHRcdGRpdi5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSAoLWJnUG9zLngpICsgJ3B4ICcgKyAoLWJnUG9zLnkpICsgJ3B4Jztcblx0XHR9XG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhkaXYsICdpY29uJyk7XG5cblx0XHRyZXR1cm4gZGl2O1xuXHR9LFxuXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5kaXZJY29uKG9wdGlvbnM6IERpdkljb24gb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBgRGl2SWNvbmAgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBkaXZJY29uKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBEaXZJY29uKG9wdGlvbnMpO1xufVxuIiwiaW1wb3J0IHtJY29ufSBmcm9tICcuL0ljb24nO1xuZXhwb3J0IHtpY29ufSBmcm9tICcuL0ljb24nO1xuaW1wb3J0IHtJY29uRGVmYXVsdH0gZnJvbSAnLi9JY29uLkRlZmF1bHQnO1xuSWNvbi5EZWZhdWx0ID0gSWNvbkRlZmF1bHQ7XG5leHBvcnQge0ljb259O1xuXG5leHBvcnQge0Rpdkljb24sIGRpdkljb259IGZyb20gJy4vRGl2SWNvbic7XG5leHBvcnQge01hcmtlciwgbWFya2VyfSBmcm9tICcuL01hcmtlcic7XG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuLi9MYXllcic7XG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcbmltcG9ydCB7TGF0TG5nQm91bmRzLCB0b0xhdExuZ0JvdW5kcyBhcyBsYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuXG4vKlxuICogQGNsYXNzIEdyaWRMYXllclxuICogQGluaGVyaXRzIExheWVyXG4gKiBAYWthIEwuR3JpZExheWVyXG4gKlxuICogR2VuZXJpYyBjbGFzcyBmb3IgaGFuZGxpbmcgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMuIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCB0aWxlIGxheWVycyBhbmQgcmVwbGFjZXMgYFRpbGVMYXllci5DYW52YXNgLlxuICogR3JpZExheWVyIGNhbiBiZSBleHRlbmRlZCB0byBjcmVhdGUgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMgbGlrZSBgPGNhbnZhcz5gLCBgPGltZz5gIG9yIGA8ZGl2PmAuIEdyaWRMYXllciB3aWxsIGhhbmRsZSBjcmVhdGluZyBhbmQgYW5pbWF0aW5nIHRoZXNlIERPTSBlbGVtZW50cyBmb3IgeW91LlxuICpcbiAqXG4gKiBAc2VjdGlvbiBTeW5jaHJvbm91cyB1c2FnZVxuICogQGV4YW1wbGVcbiAqXG4gKiBUbyBjcmVhdGUgYSBjdXN0b20gbGF5ZXIsIGV4dGVuZCBHcmlkTGF5ZXIgYW5kIGltcGxlbWVudCB0aGUgYGNyZWF0ZVRpbGUoKWAgbWV0aG9kLCB3aGljaCB3aWxsIGJlIHBhc3NlZCBhIGBQb2ludGAgb2JqZWN0IHdpdGggdGhlIGB4YCwgYHlgLCBhbmQgYHpgICh6b29tIGxldmVsKSBjb29yZGluYXRlcyB0byBkcmF3IHlvdXIgdGlsZS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIENhbnZhc0xheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAqICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMpe1xuICogICAgICAgICAvLyBjcmVhdGUgYSA8Y2FudmFzPiBlbGVtZW50IGZvciBkcmF3aW5nXG4gKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICpcbiAqICAgICAgICAgLy8gc2V0dXAgdGlsZSB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAqICAgICAgICAgdGlsZS53aWR0aCA9IHNpemUueDtcbiAqICAgICAgICAgdGlsZS5oZWlnaHQgPSBzaXplLnk7XG4gKlxuICogICAgICAgICAvLyBnZXQgYSBjYW52YXMgY29udGV4dCBhbmQgZHJhdyBzb21ldGhpbmcgb24gaXQgdXNpbmcgY29vcmRzLngsIGNvb3Jkcy55IGFuZCBjb29yZHMuelxuICogICAgICAgICB2YXIgY3R4ID0gdGlsZS5nZXRDb250ZXh0KCcyZCcpO1xuICpcbiAqICAgICAgICAgLy8gcmV0dXJuIHRoZSB0aWxlIHNvIGl0IGNhbiBiZSByZW5kZXJlZCBvbiBzY3JlZW5cbiAqICAgICAgICAgcmV0dXJuIHRpbGU7XG4gKiAgICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAc2VjdGlvbiBBc3luY2hyb25vdXMgdXNhZ2VcbiAqIEBleGFtcGxlXG4gKlxuICogVGlsZSBjcmVhdGlvbiBjYW4gYWxzbyBiZSBhc3luY2hyb25vdXMsIHRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgYSB0aGlyZC1wYXJ0eSBkcmF3aW5nIGxpYnJhcnkuIE9uY2UgdGhlIHRpbGUgaXMgZmluaXNoZWQgZHJhd2luZyBpdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBgZG9uZSgpYCBjYWxsYmFjay5cbiAqXG4gKiBgYGBqc1xuICogdmFyIENhbnZhc0xheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAqICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMsIGRvbmUpe1xuICogICAgICAgICB2YXIgZXJyb3I7XG4gKlxuICogICAgICAgICAvLyBjcmVhdGUgYSA8Y2FudmFzPiBlbGVtZW50IGZvciBkcmF3aW5nXG4gKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICpcbiAqICAgICAgICAgLy8gc2V0dXAgdGlsZSB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAqICAgICAgICAgdGlsZS53aWR0aCA9IHNpemUueDtcbiAqICAgICAgICAgdGlsZS5oZWlnaHQgPSBzaXplLnk7XG4gKlxuICogICAgICAgICAvLyBkcmF3IHNvbWV0aGluZyBhc3luY2hyb25vdXNseSBhbmQgcGFzcyB0aGUgdGlsZSB0byB0aGUgZG9uZSgpIGNhbGxiYWNrXG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBkb25lKGVycm9yLCB0aWxlKTtcbiAqICAgICAgICAgfSwgMTAwMCk7XG4gKlxuICogICAgICAgICByZXR1cm4gdGlsZTtcbiAqICAgICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBzZWN0aW9uXG4gKi9cblxuXG5leHBvcnQgdmFyIEdyaWRMYXllciA9IExheWVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBHcmlkTGF5ZXIgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiB0aWxlU2l6ZTogTnVtYmVyfFBvaW50ID0gMjU2XG5cdFx0Ly8gV2lkdGggYW5kIGhlaWdodCBvZiB0aWxlcyBpbiB0aGUgZ3JpZC4gVXNlIGEgbnVtYmVyIGlmIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGVxdWFsLCBvciBgTC5wb2ludCh3aWR0aCwgaGVpZ2h0KWAgb3RoZXJ3aXNlLlxuXHRcdHRpbGVTaXplOiAyNTYsXG5cblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxuXHRcdC8vIE9wYWNpdHkgb2YgdGhlIHRpbGVzLiBDYW4gYmUgdXNlZCBpbiB0aGUgYGNyZWF0ZVRpbGUoKWAgZnVuY3Rpb24uXG5cdFx0b3BhY2l0eTogMSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlbklkbGU6IEJvb2xlYW4gPSAoZGVwZW5kcylcblx0XHQvLyBMb2FkIG5ldyB0aWxlcyBvbmx5IHdoZW4gcGFubmluZyBlbmRzLlxuXHRcdC8vIGB0cnVlYCBieSBkZWZhdWx0IG9uIG1vYmlsZSBicm93c2VycywgaW4gb3JkZXIgdG8gYXZvaWQgdG9vIG1hbnkgcmVxdWVzdHMgYW5kIGtlZXAgc21vb3RoIG5hdmlnYXRpb24uXG5cdFx0Ly8gYGZhbHNlYCBvdGhlcndpc2UgaW4gb3JkZXIgdG8gZGlzcGxheSBuZXcgdGlsZXMgX2R1cmluZ18gcGFubmluZywgc2luY2UgaXQgaXMgZWFzeSB0byBwYW4gb3V0c2lkZSB0aGVcblx0XHQvLyBbYGtlZXBCdWZmZXJgXSgjZ3JpZGxheWVyLWtlZXBidWZmZXIpIG9wdGlvbiBpbiBkZXNrdG9wIGJyb3dzZXJzLlxuXHRcdHVwZGF0ZVdoZW5JZGxlOiBCcm93c2VyLm1vYmlsZSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlblpvb21pbmc6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gQnkgZGVmYXVsdCwgYSBzbW9vdGggem9vbSBhbmltYXRpb24gKGR1cmluZyBhIFt0b3VjaCB6b29tXSgjbWFwLXRvdWNoem9vbSkgb3IgYSBbYGZseVRvKClgXSgjbWFwLWZseXRvKSkgd2lsbCB1cGRhdGUgZ3JpZCBsYXllcnMgZXZlcnkgaW50ZWdlciB6b29tIGxldmVsLiBTZXR0aW5nIHRoaXMgb3B0aW9uIHRvIGBmYWxzZWAgd2lsbCB1cGRhdGUgdGhlIGdyaWQgbGF5ZXIgb25seSB3aGVuIHRoZSBzbW9vdGggYW5pbWF0aW9uIGVuZHMuXG5cdFx0dXBkYXRlV2hlblpvb21pbmc6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZUludGVydmFsOiBOdW1iZXIgPSAyMDBcblx0XHQvLyBUaWxlcyB3aWxsIG5vdCB1cGRhdGUgbW9yZSB0aGFuIG9uY2UgZXZlcnkgYHVwZGF0ZUludGVydmFsYCBtaWxsaXNlY29uZHMgd2hlbiBwYW5uaW5nLlxuXHRcdHVwZGF0ZUludGVydmFsOiAyMDAsXG5cblx0XHQvLyBAb3B0aW9uIHpJbmRleDogTnVtYmVyID0gMVxuXHRcdC8vIFRoZSBleHBsaWNpdCB6SW5kZXggb2YgdGhlIHRpbGUgbGF5ZXIuXG5cdFx0ekluZGV4OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiBib3VuZHM6IExhdExuZ0JvdW5kcyA9IHVuZGVmaW5lZFxuXHRcdC8vIElmIHNldCwgdGlsZXMgd2lsbCBvbmx5IGJlIGxvYWRlZCBpbnNpZGUgdGhlIHNldCBgTGF0TG5nQm91bmRzYC5cblx0XHRib3VuZHM6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcblx0XHQvLyBUaGUgbWluaW11bSB6b29tIGxldmVsIGRvd24gdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cblx0XHRtaW5ab29tOiAwLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHQvLyBUaGUgbWF4aW11bSB6b29tIGxldmVsIHVwIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXG5cdFx0bWF4Wm9vbTogdW5kZWZpbmVkLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhOYXRpdmVab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHQvLyBNYXhpbXVtIHpvb20gbnVtYmVyIHRoZSB0aWxlIHNvdXJjZSBoYXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzcGVjaWZpZWQsXG5cdFx0Ly8gdGhlIHRpbGVzIG9uIGFsbCB6b29tIGxldmVscyBoaWdoZXIgdGhhbiBgbWF4TmF0aXZlWm9vbWAgd2lsbCBiZSBsb2FkZWRcblx0XHQvLyBmcm9tIGBtYXhOYXRpdmVab29tYCBsZXZlbCBhbmQgYXV0by1zY2FsZWQuXG5cdFx0bWF4TmF0aXZlWm9vbTogdW5kZWZpbmVkLFxuXG5cdFx0Ly8gQG9wdGlvbiBtaW5OYXRpdmVab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHQvLyBNaW5pbXVtIHpvb20gbnVtYmVyIHRoZSB0aWxlIHNvdXJjZSBoYXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzcGVjaWZpZWQsXG5cdFx0Ly8gdGhlIHRpbGVzIG9uIGFsbCB6b29tIGxldmVscyBsb3dlciB0aGFuIGBtaW5OYXRpdmVab29tYCB3aWxsIGJlIGxvYWRlZFxuXHRcdC8vIGZyb20gYG1pbk5hdGl2ZVpvb21gIGxldmVsIGFuZCBhdXRvLXNjYWxlZC5cblx0XHRtaW5OYXRpdmVab29tOiB1bmRlZmluZWQsXG5cblx0XHQvLyBAb3B0aW9uIG5vV3JhcDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciB0aGUgbGF5ZXIgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGFudGltZXJpZGlhbi4gSWYgYHRydWVgLCB0aGVcblx0XHQvLyBHcmlkTGF5ZXIgd2lsbCBvbmx5IGJlIGRpc3BsYXllZCBvbmNlIGF0IGxvdyB6b29tIGxldmVscy4gSGFzIG5vXG5cdFx0Ly8gZWZmZWN0IHdoZW4gdGhlIFttYXAgQ1JTXSgjbWFwLWNycykgZG9lc24ndCB3cmFwIGFyb3VuZC4gQ2FuIGJlIHVzZWRcblx0XHQvLyBpbiBjb21iaW5hdGlvbiB3aXRoIFtgYm91bmRzYF0oI2dyaWRsYXllci1ib3VuZHMpIHRvIHByZXZlbnQgcmVxdWVzdGluZ1xuXHRcdC8vIHRpbGVzIG91dHNpZGUgdGhlIENSUyBsaW1pdHMuXG5cdFx0bm9XcmFwOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3RpbGVQYW5lJ1xuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIGdyaWQgbGF5ZXIgd2lsbCBiZSBhZGRlZC5cblx0XHRwYW5lOiAndGlsZVBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXG5cdFx0Ly8gQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHRpbGUgbGF5ZXIuIEVtcHR5IGJ5IGRlZmF1bHQuXG5cdFx0Y2xhc3NOYW1lOiAnJyxcblxuXHRcdC8vIEBvcHRpb24ga2VlcEJ1ZmZlcjogTnVtYmVyID0gMlxuXHRcdC8vIFdoZW4gcGFubmluZyB0aGUgbWFwLCBrZWVwIHRoaXMgbWFueSByb3dzIGFuZCBjb2x1bW5zIG9mIHRpbGVzIGJlZm9yZSB1bmxvYWRpbmcgdGhlbS5cblx0XHRrZWVwQnVmZmVyOiAyXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7XG5cblx0XHR0aGlzLl9sZXZlbHMgPSB7fTtcblx0XHR0aGlzLl90aWxlcyA9IHt9O1xuXG5cdFx0dGhpcy5fcmVzZXRWaWV3KCk7IC8vIGltcGxpY2l0IF91cGRhdGUoKSBjYWxsXG5cdH0sXG5cblx0YmVmb3JlQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLl9hZGRab29tTGltaXQodGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0bWFwLl9yZW1vdmVab29tTGltaXQodGhpcyk7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gbnVsbDtcblx0XHR0aGlzLl90aWxlWm9vbSA9IHVuZGVmaW5lZDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udDogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIHRpbGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgdGlsZSBsYXllcnMuXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdERvbVV0aWwudG9Gcm9udCh0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1heCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIHRpbGUgbGF5ZXJzLlxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdERvbVV0aWwudG9CYWNrKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHR0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XG5cdC8vIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSB0aWxlcyBmb3IgdGhpcyBsYXllci5cblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSBbb3BhY2l0eV0oI2dyaWRsYXllci1vcGFjaXR5KSBvZiB0aGUgZ3JpZCBsYXllci5cblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG5cdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4KHpJbmRleDogTnVtYmVyKTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4XSgjZ3JpZGxheWVyLXppbmRleCkgb2YgdGhlIGdyaWQgbGF5ZXIuXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xuXHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSB6SW5kZXg7XG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzTG9hZGluZzogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgdGlsZSBpbiB0aGUgZ3JpZCBsYXllciBoYXMgbm90IGZpbmlzaGVkIGxvYWRpbmcuXG5cdGlzTG9hZGluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sb2FkaW5nO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVkcmF3OiB0aGlzXG5cdC8vIENhdXNlcyB0aGUgbGF5ZXIgdG8gY2xlYXIgYWxsIHRoZSB0aWxlcyBhbmQgcmVxdWVzdCB0aGVtIGFnYWluLlxuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXHRcdFx0dmFyIHRpbGVab29tID0gdGhpcy5fY2xhbXBab29tKHRoaXMuX21hcC5nZXRab29tKCkpO1xuXHRcdFx0aWYgKHRpbGVab29tICE9PSB0aGlzLl90aWxlWm9vbSkge1xuXHRcdFx0XHR0aGlzLl90aWxlWm9vbSA9IHRpbGVab29tO1xuXHRcdFx0XHR0aGlzLl91cGRhdGVMZXZlbHMoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3ByZXJlc2V0OiB0aGlzLl9pbnZhbGlkYXRlQWxsLFxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHR6b29tOiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHRtb3ZlZW5kOiB0aGlzLl9vbk1vdmVFbmRcblx0XHR9O1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUpIHtcblx0XHRcdC8vIHVwZGF0ZSB0aWxlcyBvbiBtb3ZlLCBidXQgbm90IG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciBnaXZlbiBpbnRlcnZhbFxuXHRcdFx0aWYgKCF0aGlzLl9vbk1vdmUpIHtcblx0XHRcdFx0dGhpcy5fb25Nb3ZlID0gVXRpbC50aHJvdHRsZSh0aGlzLl9vbk1vdmVFbmQsIHRoaXMub3B0aW9ucy51cGRhdGVJbnRlcnZhbCwgdGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdGV2ZW50cy5tb3ZlID0gdGhpcy5fb25Nb3ZlO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcblx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgR3JpZExheWVyYCBzaGFsbCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cblx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBtdXN0IGJlIG92ZXJyaWRkZW4gYnkgY2xhc3NlcyBleHRlbmRpbmcgYEdyaWRMYXllcmAuXG5cdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gYGNvb3Jkc2AuIElmIHRoZSBgZG9uZWAgY2FsbGJhY2tcblx0Ly8gaXMgc3BlY2lmaWVkLCBpdCBtdXN0IGJlIGNhbGxlZCB3aGVuIHRoZSB0aWxlIGhhcyBmaW5pc2hlZCBsb2FkaW5nIGFuZCBkcmF3aW5nLlxuXHRjcmVhdGVUaWxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHR9LFxuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBtZXRob2QgZ2V0VGlsZVNpemU6IFBvaW50XG5cdC8vIE5vcm1hbGl6ZXMgdGhlIFt0aWxlU2l6ZSBvcHRpb25dKCNncmlkbGF5ZXItdGlsZXNpemUpIGludG8gYSBwb2ludC4gVXNlZCBieSB0aGUgYGNyZWF0ZVRpbGUoKWAgbWV0aG9kLlxuXHRnZXRUaWxlU2l6ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuXHRcdHJldHVybiBzIGluc3RhbmNlb2YgUG9pbnQgPyBzIDogbmV3IFBvaW50KHMsIHMpO1xuXHR9LFxuXG5cdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuekluZGV4ID0gdGhpcy5vcHRpb25zLnpJbmRleDtcblx0XHR9XG5cdH0sXG5cblx0X3NldEF1dG9aSW5kZXg6IGZ1bmN0aW9uIChjb21wYXJlKSB7XG5cdFx0Ly8gZ28gdGhyb3VnaCBhbGwgb3RoZXIgbGF5ZXJzIG9mIHRoZSBzYW1lIHBhbmUsIHNldCB6SW5kZXggdG8gbWF4ICsgMSAoZnJvbnQpIG9yIG1pbiAtIDEgKGJhY2spXG5cblx0XHR2YXIgbGF5ZXJzID0gdGhpcy5nZXRQYW5lKCkuY2hpbGRyZW4sXG5cdFx0ICAgIGVkZ2VaSW5kZXggPSAtY29tcGFyZSgtSW5maW5pdHksIEluZmluaXR5KTsgLy8gLUluZmluaXR5IGZvciBtYXgsIEluZmluaXR5IGZvciBtaW5cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoLCB6SW5kZXg7IGkgPCBsZW47IGkrKykge1xuXG5cdFx0XHR6SW5kZXggPSBsYXllcnNbaV0uc3R5bGUuekluZGV4O1xuXG5cdFx0XHRpZiAobGF5ZXJzW2ldICE9PSB0aGlzLl9jb250YWluZXIgJiYgekluZGV4KSB7XG5cdFx0XHRcdGVkZ2VaSW5kZXggPSBjb21wYXJlKGVkZ2VaSW5kZXgsICt6SW5kZXgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc0Zpbml0ZShlZGdlWkluZGV4KSkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IGVkZ2VaSW5kZXggKyBjb21wYXJlKC0xLCAxKTtcblx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0Ly8gSUUgZG9lc24ndCBpbmhlcml0IGZpbHRlciBvcGFjaXR5IHByb3Blcmx5LCBzbyB3ZSdyZSBmb3JjZWQgdG8gc2V0IGl0IG9uIHRpbGVzXG5cdFx0aWYgKEJyb3dzZXIuaWVsdDkpIHsgcmV0dXJuOyB9XG5cblx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cblx0XHR2YXIgbm93ID0gK25ldyBEYXRlKCksXG5cdFx0ICAgIG5leHRGcmFtZSA9IGZhbHNlLFxuXHRcdCAgICB3aWxsUHJ1bmUgPSBmYWxzZTtcblxuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0aWYgKCF0aWxlLmN1cnJlbnQgfHwgIXRpbGUubG9hZGVkKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdHZhciBmYWRlID0gTWF0aC5taW4oMSwgKG5vdyAtIHRpbGUubG9hZGVkKSAvIDIwMCk7XG5cblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aWxlLmVsLCBmYWRlKTtcblx0XHRcdGlmIChmYWRlIDwgMSkge1xuXHRcdFx0XHRuZXh0RnJhbWUgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRpbGUuYWN0aXZlKSB7XG5cdFx0XHRcdFx0d2lsbFBydW5lID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9vbk9wYXF1ZVRpbGUodGlsZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh3aWxsUHJ1bmUgJiYgIXRoaXMuX25vUHJ1bmUpIHsgdGhpcy5fcHJ1bmVUaWxlcygpOyB9XG5cblx0XHRpZiAobmV4dEZyYW1lKSB7XG5cdFx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mYWRlRnJhbWUpO1xuXHRcdFx0dGhpcy5fZmFkZUZyYW1lID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfb25PcGFxdWVUaWxlOiBVdGlsLmZhbHNlRm4sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWxheWVyICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykpO1xuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG5cdH0sXG5cblx0X3VwZGF0ZUxldmVsczogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHpvb20gPSB0aGlzLl90aWxlWm9vbSxcblx0XHQgICAgbWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tO1xuXG5cdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cblx0XHRmb3IgKHZhciB6IGluIHRoaXMuX2xldmVscykge1xuXHRcdFx0eiA9IE51bWJlcih6KTtcblx0XHRcdGlmICh0aGlzLl9sZXZlbHNbel0uZWwuY2hpbGRyZW4ubGVuZ3RoIHx8IHogPT09IHpvb20pIHtcblx0XHRcdFx0dGhpcy5fbGV2ZWxzW3pdLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb20gLSBNYXRoLmFicyh6b29tIC0geik7XG5cdFx0XHRcdHRoaXMuX29uVXBkYXRlTGV2ZWwoeik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVUaWxlc0F0Wm9vbSh6KTtcblx0XHRcdFx0dGhpcy5fb25SZW1vdmVMZXZlbCh6KTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2xldmVsc1t6XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0sXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdGlmICghbGV2ZWwpIHtcblx0XHRcdGxldmVsID0gdGhpcy5fbGV2ZWxzW3pvb21dID0ge307XG5cblx0XHRcdGxldmVsLmVsID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXRpbGUtY29udGFpbmVyIGxlYWZsZXQtem9vbS1hbmltYXRlZCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHRsZXZlbC5lbC5zdHlsZS56SW5kZXggPSBtYXhab29tO1xuXG5cdFx0XHRsZXZlbC5vcmlnaW4gPSBtYXAucHJvamVjdChtYXAudW5wcm9qZWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKSwgem9vbSkucm91bmQoKTtcblx0XHRcdGxldmVsLnpvb20gPSB6b29tO1xuXG5cdFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtKGxldmVsLCBtYXAuZ2V0Q2VudGVyKCksIG1hcC5nZXRab29tKCkpO1xuXG5cdFx0XHQvLyBmb3JjZSB0aGUgYnJvd3NlciB0byBjb25zaWRlciB0aGUgbmV3bHkgYWRkZWQgZWxlbWVudCBmb3IgdHJhbnNpdGlvblxuXHRcdFx0VXRpbC5mYWxzZUZuKGxldmVsLmVsLm9mZnNldFdpZHRoKTtcblxuXHRcdFx0dGhpcy5fb25DcmVhdGVMZXZlbChsZXZlbCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbGV2ZWwgPSBsZXZlbDtcblxuXHRcdHJldHVybiBsZXZlbDtcblx0fSxcblxuXHRfb25VcGRhdGVMZXZlbDogVXRpbC5mYWxzZUZuLFxuXG5cdF9vblJlbW92ZUxldmVsOiBVdGlsLmZhbHNlRm4sXG5cblx0X29uQ3JlYXRlTGV2ZWw6IFV0aWwuZmFsc2VGbixcblxuXHRfcHJ1bmVUaWxlczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGtleSwgdGlsZTtcblxuXHRcdHZhciB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblx0XHRpZiAoem9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tIHx8XG5cdFx0XHR6b29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcblx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0aWxlLmN1cnJlbnQ7XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0aWYgKHRpbGUuY3VycmVudCAmJiAhdGlsZS5hY3RpdmUpIHtcblx0XHRcdFx0dmFyIGNvb3JkcyA9IHRpbGUuY29vcmRzO1xuXHRcdFx0XHRpZiAoIXRoaXMuX3JldGFpblBhcmVudChjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiAtIDUpKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLnogKyAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAoIXRoaXMuX3RpbGVzW2tleV0ucmV0YWluKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVRpbGVzQXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0aWYgKHRoaXMuX3RpbGVzW2tleV0uY29vcmRzLnogIT09IHpvb20pIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVBbGxUaWxlczogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdH1cblx0fSxcblxuXHRfaW52YWxpZGF0ZUFsbDogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIHogaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuXHRcdFx0dGhpcy5fb25SZW1vdmVMZXZlbChOdW1iZXIoeikpO1xuXHRcdFx0ZGVsZXRlIHRoaXMuX2xldmVsc1t6XTtcblx0XHR9XG5cdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblxuXHRcdHRoaXMuX3RpbGVab29tID0gdW5kZWZpbmVkO1xuXHR9LFxuXG5cdF9yZXRhaW5QYXJlbnQ6IGZ1bmN0aW9uICh4LCB5LCB6LCBtaW5ab29tKSB7XG5cdFx0dmFyIHgyID0gTWF0aC5mbG9vcih4IC8gMiksXG5cdFx0ICAgIHkyID0gTWF0aC5mbG9vcih5IC8gMiksXG5cdFx0ICAgIHoyID0geiAtIDEsXG5cdFx0ICAgIGNvb3JkczIgPSBuZXcgUG9pbnQoK3gyLCAreTIpO1xuXHRcdGNvb3JkczIueiA9ICt6MjtcblxuXHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzMiksXG5cdFx0ICAgIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcblx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKHoyID4gbWluWm9vbSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JldGFpblBhcmVudCh4MiwgeTIsIHoyLCBtaW5ab29tKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X3JldGFpbkNoaWxkcmVuOiBmdW5jdGlvbiAoeCwgeSwgeiwgbWF4Wm9vbSkge1xuXG5cdFx0Zm9yICh2YXIgaSA9IDIgKiB4OyBpIDwgMiAqIHggKyAyOyBpKyspIHtcblx0XHRcdGZvciAodmFyIGogPSAyICogeTsgaiA8IDIgKiB5ICsgMjsgaisrKSB7XG5cblx0XHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBQb2ludChpLCBqKTtcblx0XHRcdFx0Y29vcmRzLnogPSB6ICsgMTtcblxuXHRcdFx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyksXG5cdFx0XHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdFx0XHRpZiAodGlsZSAmJiB0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcblx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoeiArIDEgPCBtYXhab29tKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oaSwgaiwgeiArIDEsIG1heFpvb20pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGFuaW1hdGluZyA9IGUgJiYgKGUucGluY2ggfHwgZS5mbHlUbyk7XG5cdFx0dGhpcy5fc2V0Vmlldyh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCksIGFuaW1hdGluZywgYW5pbWF0aW5nKTtcblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5fc2V0VmlldyhlLmNlbnRlciwgZS56b29tLCB0cnVlLCBlLm5vVXBkYXRlKTtcblx0fSxcblxuXHRfY2xhbXBab29tOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5taW5OYXRpdmVab29tICYmIHpvb20gPCBvcHRpb25zLm1pbk5hdGl2ZVpvb20pIHtcblx0XHRcdHJldHVybiBvcHRpb25zLm1pbk5hdGl2ZVpvb207XG5cdFx0fVxuXG5cdFx0aWYgKHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5tYXhOYXRpdmVab29tICYmIG9wdGlvbnMubWF4TmF0aXZlWm9vbSA8IHpvb20pIHtcblx0XHRcdHJldHVybiBvcHRpb25zLm1heE5hdGl2ZVpvb207XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHpvb207XG5cdH0sXG5cblx0X3NldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG5vUHJ1bmUsIG5vVXBkYXRlKSB7XG5cdFx0dmFyIHRpbGVab29tID0gTWF0aC5yb3VuZCh6b29tKTtcblx0XHRpZiAoKHRoaXMub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkgfHxcblx0XHQgICAgKHRoaXMub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkpIHtcblx0XHRcdHRpbGVab29tID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aWxlWm9vbSA9IHRoaXMuX2NsYW1wWm9vbSh0aWxlWm9vbSk7XG5cdFx0fVxuXG5cdFx0dmFyIHRpbGVab29tQ2hhbmdlZCA9IHRoaXMub3B0aW9ucy51cGRhdGVXaGVuWm9vbWluZyAmJiAodGlsZVpvb20gIT09IHRoaXMuX3RpbGVab29tKTtcblxuXHRcdGlmICghbm9VcGRhdGUgfHwgdGlsZVpvb21DaGFuZ2VkKSB7XG5cblx0XHRcdHRoaXMuX3RpbGVab29tID0gdGlsZVpvb207XG5cblx0XHRcdGlmICh0aGlzLl9hYm9ydExvYWRpbmcpIHtcblx0XHRcdFx0dGhpcy5fYWJvcnRMb2FkaW5nKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3VwZGF0ZUxldmVscygpO1xuXHRcdFx0dGhpcy5fcmVzZXRHcmlkKCk7XG5cblx0XHRcdGlmICh0aWxlWm9vbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZShjZW50ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIW5vUHJ1bmUpIHtcblx0XHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGbGFnIHRvIHByZXZlbnQgX3VwZGF0ZU9wYWNpdHkgZnJvbSBwcnVuaW5nIHRpbGVzIGR1cmluZ1xuXHRcdFx0Ly8gYSB6b29tIGFuaW0gb3IgYSBwaW5jaCBnZXN0dXJlXG5cdFx0XHR0aGlzLl9ub1BydW5lID0gISFub1BydW5lO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm1zKGNlbnRlciwgem9vbSk7XG5cdH0sXG5cblx0X3NldFpvb21UcmFuc2Zvcm1zOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0odGhpcy5fbGV2ZWxzW2ldLCBjZW50ZXIsIHpvb20pO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Wm9vbVRyYW5zZm9ybTogZnVuY3Rpb24gKGxldmVsLCBjZW50ZXIsIHpvb20pIHtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIGxldmVsLnpvb20pLFxuXHRcdCAgICB0cmFuc2xhdGUgPSBsZXZlbC5vcmlnaW4ubXVsdGlwbHlCeShzY2FsZSlcblx0XHQgICAgICAgIC5zdWJ0cmFjdCh0aGlzLl9tYXAuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkpLnJvdW5kKCk7XG5cblx0XHRpZiAoQnJvd3Nlci5hbnkzZCkge1xuXHRcdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0obGV2ZWwuZWwsIHRyYW5zbGF0ZSwgc2NhbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKGxldmVsLmVsLCB0cmFuc2xhdGUpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVzZXRHcmlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzLFxuXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuX3RpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuXHRcdCAgICB0aWxlWm9vbSA9IHRoaXMuX3RpbGVab29tO1xuXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKHRoaXMuX3RpbGVab29tKTtcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR0aGlzLl9nbG9iYWxUaWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKGJvdW5kcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fd3JhcFggPSBjcnMud3JhcExuZyAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG5cdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1swXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueCksXG5cdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoWzAsIGNycy53cmFwTG5nWzFdXSwgdGlsZVpvb20pLnggLyB0aWxlU2l6ZS55KVxuXHRcdF07XG5cdFx0dGhpcy5fd3JhcFkgPSBjcnMud3JhcExhdCAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG5cdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFswXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueCksXG5cdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoW2Nycy53cmFwTGF0WzFdLCAwXSwgdGlsZVpvb20pLnkgLyB0aWxlU2l6ZS55KVxuXHRcdF07XG5cdH0sXG5cblx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF9nZXRUaWxlZFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgbWFwWm9vbSA9IG1hcC5fYW5pbWF0aW5nWm9vbSA/IE1hdGgubWF4KG1hcC5fYW5pbWF0ZVRvWm9vbSwgbWFwLmdldFpvb20oKSkgOiBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBzY2FsZSA9IG1hcC5nZXRab29tU2NhbGUobWFwWm9vbSwgdGhpcy5fdGlsZVpvb20pLFxuXHRcdCAgICBwaXhlbENlbnRlciA9IG1hcC5wcm9qZWN0KGNlbnRlciwgdGhpcy5fdGlsZVpvb20pLmZsb29yKCksXG5cdFx0ICAgIGhhbGZTaXplID0gbWFwLmdldFNpemUoKS5kaXZpZGVCeShzY2FsZSAqIDIpO1xuXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMocGl4ZWxDZW50ZXIuc3VidHJhY3QoaGFsZlNpemUpLCBwaXhlbENlbnRlci5hZGQoaGFsZlNpemUpKTtcblx0fSxcblxuXHQvLyBQcml2YXRlIG1ldGhvZCB0byBsb2FkIHRpbGVzIGluIHRoZSBncmlkJ3MgYWN0aXZlIHpvb20gbGV2ZWwgYWNjb3JkaW5nIHRvIG1hcCBib3VuZHNcblx0X3VwZGF0ZTogZnVuY3Rpb24gKGNlbnRlcikge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdFx0aWYgKCFtYXApIHsgcmV0dXJuOyB9XG5cdFx0dmFyIHpvb20gPSB0aGlzLl9jbGFtcFpvb20obWFwLmdldFpvb20oKSk7XG5cblx0XHRpZiAoY2VudGVyID09PSB1bmRlZmluZWQpIHsgY2VudGVyID0gbWFwLmdldENlbnRlcigpOyB9XG5cdFx0aWYgKHRoaXMuX3RpbGVab29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XHQvLyBpZiBvdXQgb2YgbWluem9vbS9tYXh6b29tXG5cblx0XHR2YXIgcGl4ZWxCb3VuZHMgPSB0aGlzLl9nZXRUaWxlZFBpeGVsQm91bmRzKGNlbnRlciksXG5cdFx0ICAgIHRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UocGl4ZWxCb3VuZHMpLFxuXHRcdCAgICB0aWxlQ2VudGVyID0gdGlsZVJhbmdlLmdldENlbnRlcigpLFxuXHRcdCAgICBxdWV1ZSA9IFtdLFxuXHRcdCAgICBtYXJnaW4gPSB0aGlzLm9wdGlvbnMua2VlcEJ1ZmZlcixcblx0XHQgICAgbm9QcnVuZVJhbmdlID0gbmV3IEJvdW5kcyh0aWxlUmFuZ2UuZ2V0Qm90dG9tTGVmdCgpLnN1YnRyYWN0KFttYXJnaW4sIC1tYXJnaW5dKSxcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlUmFuZ2UuZ2V0VG9wUmlnaHQoKS5hZGQoW21hcmdpbiwgLW1hcmdpbl0pKTtcblxuXHRcdC8vIFNhbml0eSBjaGVjazogcGFuaWMgaWYgdGhlIHRpbGUgcmFuZ2UgY29udGFpbnMgSW5maW5pdHkgc29tZXdoZXJlLlxuXHRcdGlmICghKGlzRmluaXRlKHRpbGVSYW5nZS5taW4ueCkgJiZcblx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWluLnkpICYmXG5cdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1heC54KSAmJlxuXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5tYXgueSkpKSB7IHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGxvYWQgYW4gaW5maW5pdGUgbnVtYmVyIG9mIHRpbGVzJyk7IH1cblxuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dmFyIGMgPSB0aGlzLl90aWxlc1trZXldLmNvb3Jkcztcblx0XHRcdGlmIChjLnogIT09IHRoaXMuX3RpbGVab29tIHx8ICFub1BydW5lUmFuZ2UuY29udGFpbnMobmV3IFBvaW50KGMueCwgYy55KSkpIHtcblx0XHRcdFx0dGhpcy5fdGlsZXNba2V5XS5jdXJyZW50ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gX3VwZGF0ZSBqdXN0IGxvYWRzIG1vcmUgdGlsZXMuIElmIHRoZSB0aWxlIHpvb20gbGV2ZWwgZGlmZmVycyB0b28gbXVjaFxuXHRcdC8vIGZyb20gdGhlIG1hcCdzLCBsZXQgX3NldFZpZXcgcmVzZXQgbGV2ZWxzIGFuZCBwcnVuZSBvbGQgdGlsZXMuXG5cdFx0aWYgKE1hdGguYWJzKHpvb20gLSB0aGlzLl90aWxlWm9vbSkgPiAxKSB7IHRoaXMuX3NldFZpZXcoY2VudGVyLCB6b29tKTsgcmV0dXJuOyB9XG5cblx0XHQvLyBjcmVhdGUgYSBxdWV1ZSBvZiBjb29yZGluYXRlcyB0byBsb2FkIHRpbGVzIGZyb21cblx0XHRmb3IgKHZhciBqID0gdGlsZVJhbmdlLm1pbi55OyBqIDw9IHRpbGVSYW5nZS5tYXgueTsgaisrKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gdGlsZVJhbmdlLm1pbi54OyBpIDw9IHRpbGVSYW5nZS5tYXgueDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgUG9pbnQoaSwgaik7XG5cdFx0XHRcdGNvb3Jkcy56ID0gdGhpcy5fdGlsZVpvb207XG5cblx0XHRcdFx0aWYgKCF0aGlzLl9pc1ZhbGlkVGlsZShjb29yZHMpKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1t0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKV07XG5cdFx0XHRcdGlmICh0aWxlKSB7XG5cdFx0XHRcdFx0dGlsZS5jdXJyZW50ID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKGNvb3Jkcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzb3J0IHRpbGUgcXVldWUgdG8gbG9hZCB0aWxlcyBpbiBvcmRlciBvZiB0aGVpciBkaXN0YW5jZSB0byBjZW50ZXJcblx0XHRxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYS5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpIC0gYi5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKHF1ZXVlLmxlbmd0aCAhPT0gMCkge1xuXHRcdFx0Ly8gaWYgaXQncyB0aGUgZmlyc3QgYmF0Y2ggb2YgdGlsZXMgdG8gbG9hZFxuXHRcdFx0aWYgKCF0aGlzLl9sb2FkaW5nKSB7XG5cdFx0XHRcdHRoaXMuX2xvYWRpbmcgPSB0cnVlO1xuXHRcdFx0XHQvLyBAZXZlbnQgbG9hZGluZzogRXZlbnRcblx0XHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBzdGFydHMgbG9hZGluZyB0aWxlcy5cblx0XHRcdFx0dGhpcy5maXJlKCdsb2FkaW5nJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNyZWF0ZSBET00gZnJhZ21lbnQgdG8gYXBwZW5kIHRpbGVzIGluIG9uZSBiYXRjaFxuXHRcdFx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fYWRkVGlsZShxdWV1ZVtpXSwgZnJhZ21lbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9sZXZlbC5lbC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pc1ZhbGlkVGlsZTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBjcnMgPSB0aGlzLl9tYXAub3B0aW9ucy5jcnM7XG5cblx0XHRpZiAoIWNycy5pbmZpbml0ZSkge1xuXHRcdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0J3Mgb3V0IG9mIGJvdW5kcyBhbmQgbm90IHdyYXBwZWRcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2U7XG5cdFx0XHRpZiAoKCFjcnMud3JhcExuZyAmJiAoY29vcmRzLnggPCBib3VuZHMubWluLnggfHwgY29vcmRzLnggPiBib3VuZHMubWF4LngpKSB8fFxuXHRcdFx0ICAgICghY3JzLndyYXBMYXQgJiYgKGNvb3Jkcy55IDwgYm91bmRzLm1pbi55IHx8IGNvb3Jkcy55ID4gYm91bmRzLm1heC55KSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYm91bmRzKSB7IHJldHVybiB0cnVlOyB9XG5cblx0XHQvLyBkb24ndCBsb2FkIHRpbGUgaWYgaXQgZG9lc24ndCBpbnRlcnNlY3QgdGhlIGJvdW5kcyBpbiBvcHRpb25zXG5cdFx0dmFyIHRpbGVCb3VuZHMgPSB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHMoY29vcmRzKTtcblx0XHRyZXR1cm4gbGF0TG5nQm91bmRzKHRoaXMub3B0aW9ucy5ib3VuZHMpLm92ZXJsYXBzKHRpbGVCb3VuZHMpO1xuXHR9LFxuXG5cdF9rZXlUb0JvdW5kczogZnVuY3Rpb24gKGtleSkge1xuXHRcdHJldHVybiB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHModGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSkpO1xuXHR9LFxuXG5cdF90aWxlQ29vcmRzVG9Od1NlOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCksXG5cdFx0ICAgIG53UG9pbnQgPSBjb29yZHMuc2NhbGVCeSh0aWxlU2l6ZSksXG5cdFx0ICAgIHNlUG9pbnQgPSBud1BvaW50LmFkZCh0aWxlU2l6ZSksXG5cdFx0ICAgIG53ID0gbWFwLnVucHJvamVjdChud1BvaW50LCBjb29yZHMueiksXG5cdFx0ICAgIHNlID0gbWFwLnVucHJvamVjdChzZVBvaW50LCBjb29yZHMueik7XG5cdFx0cmV0dXJuIFtudywgc2VdO1xuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8gaXRzIGdlb2dyYXBoaWNhbCBib3VuZHNcblx0X3RpbGVDb29yZHNUb0JvdW5kczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBicCA9IHRoaXMuX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSxcblx0XHQgICAgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcyhicFswXSwgYnBbMV0pO1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMubm9XcmFwKSB7XG5cdFx0XHRib3VuZHMgPSB0aGlzLl9tYXAud3JhcExhdExuZ0JvdW5kcyhib3VuZHMpO1xuXHRcdH1cblx0XHRyZXR1cm4gYm91bmRzO1xuXHR9LFxuXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGtleSBmb3IgdGhlIHRpbGUgY2FjaGVcblx0X3RpbGVDb29yZHNUb0tleTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHJldHVybiBjb29yZHMueCArICc6JyArIGNvb3Jkcy55ICsgJzonICsgY29vcmRzLno7XG5cdH0sXG5cblx0Ly8gY29udmVydHMgdGlsZSBjYWNoZSBrZXkgdG8gY29vcmRpbmF0ZXNcblx0X2tleVRvVGlsZUNvb3JkczogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciBrID0ga2V5LnNwbGl0KCc6JyksXG5cdFx0ICAgIGNvb3JkcyA9IG5ldyBQb2ludCgra1swXSwgK2tbMV0pO1xuXHRcdGNvb3Jkcy56ID0gK2tbMl07XG5cdFx0cmV0dXJuIGNvb3Jkcztcblx0fSxcblxuXHRfcmVtb3ZlVGlsZTogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cblx0XHREb21VdGlsLnJlbW92ZSh0aWxlLmVsKTtcblxuXHRcdGRlbGV0ZSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0Ly8gQGV2ZW50IHRpbGV1bmxvYWQ6IFRpbGVFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlbW92ZWQgKGUuZy4gd2hlbiBhIHRpbGUgZ29lcyBvZmYgdGhlIHNjcmVlbikuXG5cdFx0dGhpcy5maXJlKCd0aWxldW5sb2FkJywge1xuXHRcdFx0dGlsZTogdGlsZS5lbCxcblx0XHRcdGNvb3JkczogdGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSlcblx0XHR9KTtcblx0fSxcblxuXHRfaW5pdFRpbGU6IGZ1bmN0aW9uICh0aWxlKSB7XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aWxlLCAnbGVhZmxldC10aWxlJyk7XG5cblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG5cdFx0dGlsZS5zdHlsZS53aWR0aCA9IHRpbGVTaXplLnggKyAncHgnO1xuXHRcdHRpbGUuc3R5bGUuaGVpZ2h0ID0gdGlsZVNpemUueSArICdweCc7XG5cblx0XHR0aWxlLm9uc2VsZWN0c3RhcnQgPSBVdGlsLmZhbHNlRm47XG5cdFx0dGlsZS5vbm1vdXNlbW92ZSA9IFV0aWwuZmFsc2VGbjtcblxuXHRcdC8vIHVwZGF0ZSBvcGFjaXR5IG9uIHRpbGVzIGluIElFNy04IGJlY2F1c2Ugb2YgZmlsdGVyIGluaGVyaXRhbmNlIHByb2JsZW1zXG5cdFx0aWYgKEJyb3dzZXIuaWVsdDkgJiYgdGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGlsZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgY29udGFpbmVyKSB7XG5cdFx0dmFyIHRpbGVQb3MgPSB0aGlzLl9nZXRUaWxlUG9zKGNvb3JkcyksXG5cdFx0ICAgIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG5cdFx0dmFyIHRpbGUgPSB0aGlzLmNyZWF0ZVRpbGUodGhpcy5fd3JhcENvb3Jkcyhjb29yZHMpLCBVdGlsLmJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMpKTtcblxuXHRcdHRoaXMuX2luaXRUaWxlKHRpbGUpO1xuXG5cdFx0Ly8gaWYgY3JlYXRlVGlsZSBpcyBkZWZpbmVkIHdpdGggYSBzZWNvbmQgYXJndW1lbnQgKFwiZG9uZVwiIGNhbGxiYWNrKSxcblx0XHQvLyB3ZSBrbm93IHRoYXQgdGlsZSBpcyBhc3luYyBhbmQgd2lsbCBiZSByZWFkeSBsYXRlcjsgb3RoZXJ3aXNlXG5cdFx0aWYgKHRoaXMuY3JlYXRlVGlsZS5sZW5ndGggPCAyKSB7XG5cdFx0XHQvLyBtYXJrIHRpbGUgYXMgcmVhZHksIGJ1dCBkZWxheSBvbmUgZnJhbWUgZm9yIG9wYWNpdHkgYW5pbWF0aW9uIHRvIGhhcHBlblxuXHRcdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKFV0aWwuYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcywgbnVsbCwgdGlsZSkpO1xuXHRcdH1cblxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGlsZSwgdGlsZVBvcyk7XG5cblx0XHQvLyBzYXZlIHRpbGUgaW4gY2FjaGVcblx0XHR0aGlzLl90aWxlc1trZXldID0ge1xuXHRcdFx0ZWw6IHRpbGUsXG5cdFx0XHRjb29yZHM6IGNvb3Jkcyxcblx0XHRcdGN1cnJlbnQ6IHRydWVcblx0XHR9O1xuXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHRpbGUpO1xuXHRcdC8vIEBldmVudCB0aWxlbG9hZHN0YXJ0OiBUaWxlRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZXF1ZXN0ZWQgYW5kIHN0YXJ0cyBsb2FkaW5nLlxuXHRcdHRoaXMuZmlyZSgndGlsZWxvYWRzdGFydCcsIHtcblx0XHRcdHRpbGU6IHRpbGUsXG5cdFx0XHRjb29yZHM6IGNvb3Jkc1xuXHRcdH0pO1xuXHR9LFxuXG5cdF90aWxlUmVhZHk6IGZ1bmN0aW9uIChjb29yZHMsIGVyciwgdGlsZSkge1xuXHRcdGlmIChlcnIpIHtcblx0XHRcdC8vIEBldmVudCB0aWxlZXJyb3I6IFRpbGVFcnJvckV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZXJlIGlzIGFuIGVycm9yIGxvYWRpbmcgYSB0aWxlLlxuXHRcdFx0dGhpcy5maXJlKCd0aWxlZXJyb3InLCB7XG5cdFx0XHRcdGVycm9yOiBlcnIsXG5cdFx0XHRcdHRpbGU6IHRpbGUsXG5cdFx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcyk7XG5cblx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cblx0XHR0aWxlLmxvYWRlZCA9ICtuZXcgRGF0ZSgpO1xuXHRcdGlmICh0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUuZWwsIDApO1xuXHRcdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcblx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVPcGFjaXR5LCB0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuXHRcdH1cblxuXHRcdGlmICghZXJyKSB7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRpbGUuZWwsICdsZWFmbGV0LXRpbGUtbG9hZGVkJyk7XG5cblx0XHRcdC8vIEBldmVudCB0aWxlbG9hZDogVGlsZUV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBsb2Fkcy5cblx0XHRcdHRoaXMuZmlyZSgndGlsZWxvYWQnLCB7XG5cdFx0XHRcdHRpbGU6IHRpbGUuZWwsXG5cdFx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbm9UaWxlc1RvTG9hZCgpKSB7XG5cdFx0XHR0aGlzLl9sb2FkaW5nID0gZmFsc2U7XG5cdFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgbG9hZGVkIGFsbCB2aXNpYmxlIHRpbGVzLlxuXHRcdFx0dGhpcy5maXJlKCdsb2FkJyk7XG5cblx0XHRcdGlmIChCcm93c2VyLmllbHQ5IHx8ICF0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuXHRcdFx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBXYWl0IGEgYml0IG1vcmUgdGhhbiAwLjIgc2VjcyAodGhlIGR1cmF0aW9uIG9mIHRoZSB0aWxlIGZhZGUtaW4pXG5cdFx0XHRcdC8vIHRvIHRyaWdnZXIgYSBwcnVuaW5nLlxuXHRcdFx0XHRzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKSwgMjUwKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2dldFRpbGVQb3M6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHRyZXR1cm4gY29vcmRzLnNjYWxlQnkodGhpcy5nZXRUaWxlU2l6ZSgpKS5zdWJ0cmFjdCh0aGlzLl9sZXZlbC5vcmlnaW4pO1xuXHR9LFxuXG5cdF93cmFwQ29vcmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIG5ld0Nvb3JkcyA9IG5ldyBQb2ludChcblx0XHRcdHRoaXMuX3dyYXBYID8gVXRpbC53cmFwTnVtKGNvb3Jkcy54LCB0aGlzLl93cmFwWCkgOiBjb29yZHMueCxcblx0XHRcdHRoaXMuX3dyYXBZID8gVXRpbC53cmFwTnVtKGNvb3Jkcy55LCB0aGlzLl93cmFwWSkgOiBjb29yZHMueSk7XG5cdFx0bmV3Q29vcmRzLnogPSBjb29yZHMuejtcblx0XHRyZXR1cm4gbmV3Q29vcmRzO1xuXHR9LFxuXG5cdF9weEJvdW5kc1RvVGlsZVJhbmdlOiBmdW5jdGlvbiAoYm91bmRzKSB7XG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuXHRcdHJldHVybiBuZXcgQm91bmRzKFxuXHRcdFx0Ym91bmRzLm1pbi51bnNjYWxlQnkodGlsZVNpemUpLmZsb29yKCksXG5cdFx0XHRib3VuZHMubWF4LnVuc2NhbGVCeSh0aWxlU2l6ZSkuY2VpbCgpLnN1YnRyYWN0KFsxLCAxXSkpO1xuXHR9LFxuXG5cdF9ub1RpbGVzVG9Mb2FkOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAoIXRoaXMuX3RpbGVzW2tleV0ubG9hZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuZ3JpZExheWVyKG9wdGlvbnM/OiBHcmlkTGF5ZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgR3JpZExheWVyIHdpdGggdGhlIHN1cHBsaWVkIG9wdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gZ3JpZExheWVyKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBHcmlkTGF5ZXIob3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge0dyaWRMYXllcn0gZnJvbSAnLi9HcmlkTGF5ZXInO1xyXG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBUaWxlTGF5ZXJcclxuICogQGluaGVyaXRzIEdyaWRMYXllclxyXG4gKiBAYWthIEwuVGlsZUxheWVyXHJcbiAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSB0aWxlIGxheWVycyBvbiB0aGUgbWFwLiBOb3RlIHRoYXQgbW9zdCB0aWxlIHNlcnZlcnMgcmVxdWlyZSBhdHRyaWJ1dGlvbiwgd2hpY2ggeW91IGNhbiBzZXQgdW5kZXIgYExheWVyYC4gRXh0ZW5kcyBgR3JpZExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC50aWxlTGF5ZXIoJ2h0dHBzOi8vdGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmc/e2Zvb30nLCB7Zm9vOiAnYmFyJywgYXR0cmlidXRpb246ICcmY29weTsgPGEgaHJlZj1cImh0dHBzOi8vd3d3Lm9wZW5zdHJlZXRtYXAub3JnL2NvcHlyaWdodFwiPk9wZW5TdHJlZXRNYXA8L2E+IGNvbnRyaWJ1dG9ycyd9KS5hZGRUbyhtYXApO1xuICogYGBgXHJcbiAqXHJcbiAqIEBzZWN0aW9uIFVSTCB0ZW1wbGF0ZVxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBBIHN0cmluZyBvZiB0aGUgZm9sbG93aW5nIGZvcm06XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiAnaHR0cHM6Ly97c30uc29tZWRvbWFpbi5jb20vYmxhYmxhL3t6fS97eH0ve3l9e3J9LnBuZydcclxuICogYGBgXHJcbiAqXHJcbiAqIGB7c31gIG1lYW5zIG9uZSBvZiB0aGUgYXZhaWxhYmxlIHN1YmRvbWFpbnMgKHVzZWQgc2VxdWVudGlhbGx5IHRvIGhlbHAgd2l0aCBicm93c2VyIHBhcmFsbGVsIHJlcXVlc3RzIHBlciBkb21haW4gbGltaXRhdGlvbjsgc3ViZG9tYWluIHZhbHVlcyBhcmUgc3BlY2lmaWVkIGluIG9wdGlvbnM7IGBhYCwgYGJgIG9yIGBjYCBieSBkZWZhdWx0LCBjYW4gYmUgb21pdHRlZCksIGB7en1gIOKAlCB6b29tIGxldmVsLCBge3h9YCBhbmQgYHt5fWAg4oCUIHRpbGUgY29vcmRpbmF0ZXMuIGB7cn1gIGNhbiBiZSB1c2VkIHRvIGFkZCBcIiZjb21tYXQ7MnhcIiB0byB0aGUgVVJMIHRvIGxvYWQgcmV0aW5hIHRpbGVzLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHVzZSBjdXN0b20ga2V5cyBpbiB0aGUgdGVtcGxhdGUsIHdoaWNoIHdpbGwgYmUgW2V2YWx1YXRlZF0oI3V0aWwtdGVtcGxhdGUpIGZyb20gVGlsZUxheWVyIG9wdGlvbnMsIGxpa2UgdGhpczpcclxuICpcclxuICogYGBgXHJcbiAqIEwudGlsZUxheWVyKCdodHRwczovL3tzfS5zb21lZG9tYWluLmNvbS97Zm9vfS97en0ve3h9L3t5fS5wbmcnLCB7Zm9vOiAnYmFyJ30pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuZXhwb3J0IHZhciBUaWxlTGF5ZXIgPSBHcmlkTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFRpbGVMYXllciBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAwXHJcblx0XHQvLyBUaGUgbWluaW11bSB6b29tIGxldmVsIGRvd24gdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cclxuXHRcdG1pblpvb206IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAxOFxyXG5cdFx0Ly8gVGhlIG1heGltdW0gem9vbSBsZXZlbCB1cCB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxyXG5cdFx0bWF4Wm9vbTogMTgsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzdWJkb21haW5zOiBTdHJpbmd8U3RyaW5nW10gPSAnYWJjJ1xyXG5cdFx0Ly8gU3ViZG9tYWlucyBvZiB0aGUgdGlsZSBzZXJ2aWNlLiBDYW4gYmUgcGFzc2VkIGluIHRoZSBmb3JtIG9mIG9uZSBzdHJpbmcgKHdoZXJlIGVhY2ggbGV0dGVyIGlzIGEgc3ViZG9tYWluIG5hbWUpIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXHJcblx0XHRzdWJkb21haW5zOiAnYWJjJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGVycm9yVGlsZVVybDogU3RyaW5nID0gJydcclxuXHRcdC8vIFVSTCB0byB0aGUgdGlsZSBpbWFnZSB0byBzaG93IGluIHBsYWNlIG9mIHRoZSB0aWxlIHRoYXQgZmFpbGVkIHRvIGxvYWQuXHJcblx0XHRlcnJvclRpbGVVcmw6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU9mZnNldDogTnVtYmVyID0gMFxyXG5cdFx0Ly8gVGhlIHpvb20gbnVtYmVyIHVzZWQgaW4gdGlsZSBVUkxzIHdpbGwgYmUgb2Zmc2V0IHdpdGggdGhpcyB2YWx1ZS5cclxuXHRcdHpvb21PZmZzZXQ6IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0bXM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCBpbnZlcnNlcyBZIGF4aXMgbnVtYmVyaW5nIGZvciB0aWxlcyAodHVybiB0aGlzIG9uIGZvciBbVE1TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcykuXHJcblx0XHR0bXM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbVJldmVyc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgc2V0IHRvIHRydWUsIHRoZSB6b29tIG51bWJlciB1c2VkIGluIHRpbGUgVVJMcyB3aWxsIGJlIHJldmVyc2VkIChgbWF4Wm9vbSAtIHpvb21gIGluc3RlYWQgb2YgYHpvb21gKVxyXG5cdFx0em9vbVJldmVyc2U6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZGV0ZWN0UmV0aW5hOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCBhbmQgdXNlciBpcyBvbiBhIHJldGluYSBkaXNwbGF5LCBpdCB3aWxsIHJlcXVlc3QgZm91ciB0aWxlcyBvZiBoYWxmIHRoZSBzcGVjaWZpZWQgc2l6ZSBhbmQgYSBiaWdnZXIgem9vbSBsZXZlbCBpbiBwbGFjZSBvZiBvbmUgdG8gdXRpbGl6ZSB0aGUgaGlnaCByZXNvbHV0aW9uLlxyXG5cdFx0ZGV0ZWN0UmV0aW5hOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgdGlsZXMuXHJcblx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgYWxsIHRpbGVzIHdpbGwgaGF2ZSB0aGVpciBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyB0aWxlIHBpeGVsIGRhdGEuXHJcblx0XHQvLyBSZWZlciB0byBbQ09SUyBTZXR0aW5nc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXMpIGZvciB2YWxpZCBTdHJpbmcgdmFsdWVzLlxyXG5cdFx0Y3Jvc3NPcmlnaW46IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmVmZXJyZXJQb2xpY3k6IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHJlZmVycmVyUG9saWN5IGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0aWxlcy5cclxuXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCBhbGwgdGlsZXMgd2lsbCBoYXZlIHRoZWlyIHJlZmVycmVyUG9saWN5IGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC5cclxuXHRcdC8vIFRoaXMgbWF5IGJlIG5lZWRlZCBpZiB5b3VyIG1hcCdzIHJlbmRlcmluZyBjb250ZXh0IGhhcyBhIHN0cmljdCBkZWZhdWx0IGJ1dCB5b3VyIHRpbGUgcHJvdmlkZXIgZXhwZWN0cyBhIHZhbGlkIHJlZmVycmVyXHJcblx0XHQvLyAoZS5nLiB0byB2YWxpZGF0ZSBhbiBBUEkgdG9rZW4pLlxyXG5cdFx0Ly8gUmVmZXIgdG8gW0hUTUxJbWFnZUVsZW1lbnQucmVmZXJyZXJQb2xpY3ldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MSW1hZ2VFbGVtZW50L3JlZmVycmVyUG9saWN5KSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuXHRcdHJlZmVycmVyUG9saWN5OiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0b3B0aW9ucyA9IFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHQvLyBkZXRlY3RpbmcgcmV0aW5hIGRpc3BsYXlzLCBhZGp1c3RpbmcgdGlsZVNpemUgYW5kIHpvb20gbGV2ZWxzXHJcblx0XHRpZiAob3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgQnJvd3Nlci5yZXRpbmEgJiYgb3B0aW9ucy5tYXhab29tID4gMCkge1xyXG5cclxuXHRcdFx0b3B0aW9ucy50aWxlU2l6ZSA9IE1hdGguZmxvb3Iob3B0aW9ucy50aWxlU2l6ZSAvIDIpO1xyXG5cclxuXHRcdFx0aWYgKCFvcHRpb25zLnpvb21SZXZlcnNlKSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0Kys7XHJcblx0XHRcdFx0b3B0aW9ucy5tYXhab29tID0gTWF0aC5tYXgob3B0aW9ucy5taW5ab29tLCBvcHRpb25zLm1heFpvb20gLSAxKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvcHRpb25zLnpvb21PZmZzZXQtLTtcclxuXHRcdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1pbihvcHRpb25zLm1heFpvb20sIG9wdGlvbnMubWluWm9vbSArIDEpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1heCgwLCBvcHRpb25zLm1pblpvb20pO1xyXG5cdFx0fSBlbHNlIGlmICghb3B0aW9ucy56b29tUmV2ZXJzZSkge1xyXG5cdFx0XHQvLyBtYWtlIHN1cmUgbWF4Wm9vbSBpcyBndGUgbWluWm9vbVxyXG5cdFx0XHRvcHRpb25zLm1heFpvb20gPSBNYXRoLm1heChvcHRpb25zLm1pblpvb20sIG9wdGlvbnMubWF4Wm9vbSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBtYWtlIHN1cmUgbWluWm9vbSBpcyBsdGUgbWF4Wm9vbVxyXG5cdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1pbihvcHRpb25zLm1heFpvb20sIG9wdGlvbnMubWluWm9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zLnN1YmRvbWFpbnMgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdG9wdGlvbnMuc3ViZG9tYWlucyA9IG9wdGlvbnMuc3ViZG9tYWlucy5zcGxpdCgnJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vbigndGlsZXVubG9hZCcsIHRoaXMuX29uVGlsZVJlbW92ZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBVcGRhdGVzIHRoZSBsYXllcidzIFVSTCB0ZW1wbGF0ZSBhbmQgcmVkcmF3cyBpdCAodW5sZXNzIGBub1JlZHJhd2AgaXMgc2V0IHRvIGB0cnVlYCkuXHJcblx0Ly8gSWYgdGhlIFVSTCBkb2VzIG5vdCBjaGFuZ2UsIHRoZSBsYXllciB3aWxsIG5vdCBiZSByZWRyYXduIHVubGVzc1xyXG5cdC8vIHRoZSBub1JlZHJhdyBwYXJhbWV0ZXIgaXMgc2V0IHRvIGZhbHNlLlxyXG5cdHNldFVybDogZnVuY3Rpb24gKHVybCwgbm9SZWRyYXcpIHtcclxuXHRcdGlmICh0aGlzLl91cmwgPT09IHVybCAmJiBub1JlZHJhdyA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdG5vUmVkcmF3ID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0aWYgKCFub1JlZHJhdykge1xyXG5cdFx0XHR0aGlzLnJlZHJhdygpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxyXG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIG92ZXJyaWRlcyBHcmlkTGF5ZXIncyBbYGNyZWF0ZVRpbGUoKWBdKCNncmlkbGF5ZXItY3JlYXRldGlsZSlcclxuXHQvLyB0byByZXR1cm4gYW4gYDxpbWc+YCBIVE1MIGVsZW1lbnQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgaW1hZ2UgVVJMIGdpdmVuIGBjb29yZHNgLiBUaGUgYGRvbmVgXHJcblx0Ly8gY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIHRpbGUgaGFzIGJlZW4gbG9hZGVkLlxyXG5cdGNyZWF0ZVRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGRvbmUpIHtcclxuXHRcdHZhciB0aWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblxyXG5cdFx0RG9tRXZlbnQub24odGlsZSwgJ2xvYWQnLCBVdGlsLmJpbmQodGhpcy5fdGlsZU9uTG9hZCwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG5cdFx0RG9tRXZlbnQub24odGlsZSwgJ2Vycm9yJywgVXRpbC5iaW5kKHRoaXMuX3RpbGVPbkVycm9yLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcblx0XHRcdHRpbGUuY3Jvc3NPcmlnaW4gPSB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IHRydWUgPyAnJyA6IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBmb3IgdGhpcyBuZXcgb3B0aW9uIHdlIGZvbGxvdyB0aGUgZG9jdW1lbnRlZCBiZWhhdmlvclxyXG5cdFx0Ly8gbW9yZSBjbG9zZWx5IGJ5IG9ubHkgc2V0dGluZyB0aGUgcHJvcGVydHkgd2hlbiBzdHJpbmdcclxuXHRcdGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnJlZmVycmVyUG9saWN5ID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHR0aWxlLnJlZmVycmVyUG9saWN5ID0gdGhpcy5vcHRpb25zLnJlZmVycmVyUG9saWN5O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRoZSBhbHQgYXR0cmlidXRlIGlzIHNldCB0byB0aGUgZW1wdHkgc3RyaW5nLFxyXG5cdFx0Ly8gYWxsb3dpbmcgc2NyZWVuIHJlYWRlcnMgdG8gaWdub3JlIHRoZSBkZWNvcmF0aXZlIGltYWdlIHRpbGVzLlxyXG5cdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1dBSS90dXRvcmlhbHMvaW1hZ2VzL2RlY29yYXRpdmUvXHJcblx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbC1hcmlhLyNlbC1pbWctZW1wdHktYWx0XHJcblx0XHR0aWxlLmFsdCA9ICcnO1xyXG5cclxuXHRcdHRpbGUuc3JjID0gdGhpcy5nZXRUaWxlVXJsKGNvb3Jkcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRpbGU7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcclxuXHQvLyBAdW5pbmhlcml0YWJsZVxyXG5cdC8vIExheWVycyBleHRlbmRpbmcgYFRpbGVMYXllcmAgbWlnaHQgcmVpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2QuXHJcblx0Ly8gQG1ldGhvZCBnZXRUaWxlVXJsKGNvb3JkczogT2JqZWN0KTogU3RyaW5nXHJcblx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgcmV0dXJucyB0aGUgVVJMIGZvciBhIHRpbGUgZ2l2ZW4gaXRzIGNvb3JkaW5hdGVzLlxyXG5cdC8vIENsYXNzZXMgZXh0ZW5kaW5nIGBUaWxlTGF5ZXJgIGNhbiBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIHRvIHByb3ZpZGUgY3VzdG9tIHRpbGUgVVJMIG5hbWluZyBzY2hlbWVzLlxyXG5cdGdldFRpbGVVcmw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRyOiBCcm93c2VyLnJldGluYSA/ICdAMngnIDogJycsXHJcblx0XHRcdHM6IHRoaXMuX2dldFN1YmRvbWFpbihjb29yZHMpLFxyXG5cdFx0XHR4OiBjb29yZHMueCxcclxuXHRcdFx0eTogY29vcmRzLnksXHJcblx0XHRcdHo6IHRoaXMuX2dldFpvb21Gb3JVcmwoKVxyXG5cdFx0fTtcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgIXRoaXMuX21hcC5vcHRpb25zLmNycy5pbmZpbml0ZSkge1xyXG5cdFx0XHR2YXIgaW52ZXJ0ZWRZID0gdGhpcy5fZ2xvYmFsVGlsZVJhbmdlLm1heC55IC0gY29vcmRzLnk7XHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMudG1zKSB7XHJcblx0XHRcdFx0ZGF0YVsneSddID0gaW52ZXJ0ZWRZO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRhdGFbJy15J10gPSBpbnZlcnRlZFk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFV0aWwudGVtcGxhdGUodGhpcy5fdXJsLCBVdGlsLmV4dGVuZChkYXRhLCB0aGlzLm9wdGlvbnMpKTtcclxuXHR9LFxyXG5cclxuXHRfdGlsZU9uTG9hZDogZnVuY3Rpb24gKGRvbmUsIHRpbGUpIHtcclxuXHRcdC8vIEZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zMzMyXHJcblx0XHRpZiAoQnJvd3Nlci5pZWx0OSkge1xyXG5cdFx0XHRzZXRUaW1lb3V0KFV0aWwuYmluZChkb25lLCB0aGlzLCBudWxsLCB0aWxlKSwgMCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRkb25lKG51bGwsIHRpbGUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF90aWxlT25FcnJvcjogZnVuY3Rpb24gKGRvbmUsIHRpbGUsIGUpIHtcclxuXHRcdHZhciBlcnJvclVybCA9IHRoaXMub3B0aW9ucy5lcnJvclRpbGVVcmw7XHJcblx0XHRpZiAoZXJyb3JVcmwgJiYgdGlsZS5nZXRBdHRyaWJ1dGUoJ3NyYycpICE9PSBlcnJvclVybCkge1xyXG5cdFx0XHR0aWxlLnNyYyA9IGVycm9yVXJsO1xyXG5cdFx0fVxyXG5cdFx0ZG9uZShlLCB0aWxlKTtcclxuXHR9LFxyXG5cclxuXHRfb25UaWxlUmVtb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0ZS50aWxlLm9ubG9hZCA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X2dldFpvb21Gb3JVcmw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXHJcblx0XHRtYXhab29tID0gdGhpcy5vcHRpb25zLm1heFpvb20sXHJcblx0XHR6b29tUmV2ZXJzZSA9IHRoaXMub3B0aW9ucy56b29tUmV2ZXJzZSxcclxuXHRcdHpvb21PZmZzZXQgPSB0aGlzLm9wdGlvbnMuem9vbU9mZnNldDtcclxuXHJcblx0XHRpZiAoem9vbVJldmVyc2UpIHtcclxuXHRcdFx0em9vbSA9IG1heFpvb20gLSB6b29tO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB6b29tICsgem9vbU9mZnNldDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0U3ViZG9tYWluOiBmdW5jdGlvbiAodGlsZVBvaW50KSB7XHJcblx0XHR2YXIgaW5kZXggPSBNYXRoLmFicyh0aWxlUG9pbnQueCArIHRpbGVQb2ludC55KSAlIHRoaXMub3B0aW9ucy5zdWJkb21haW5zLmxlbmd0aDtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc3ViZG9tYWluc1tpbmRleF07XHJcblx0fSxcclxuXHJcblx0Ly8gc3RvcHMgbG9hZGluZyBhbGwgdGlsZXMgaW4gdGhlIGJhY2tncm91bmQgbGF5ZXJcclxuXHRfYWJvcnRMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaSwgdGlsZTtcclxuXHRcdGZvciAoaSBpbiB0aGlzLl90aWxlcykge1xyXG5cdFx0XHRpZiAodGhpcy5fdGlsZXNbaV0uY29vcmRzLnogIT09IHRoaXMuX3RpbGVab29tKSB7XHJcblx0XHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2ldLmVsO1xyXG5cclxuXHRcdFx0XHR0aWxlLm9ubG9hZCA9IFV0aWwuZmFsc2VGbjtcclxuXHRcdFx0XHR0aWxlLm9uZXJyb3IgPSBVdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0XHRcdGlmICghdGlsZS5jb21wbGV0ZSkge1xyXG5cdFx0XHRcdFx0dGlsZS5zcmMgPSBVdGlsLmVtcHR5SW1hZ2VVcmw7XHJcblx0XHRcdFx0XHR2YXIgY29vcmRzID0gdGhpcy5fdGlsZXNbaV0uY29vcmRzO1xyXG5cdFx0XHRcdFx0RG9tVXRpbC5yZW1vdmUodGlsZSk7XHJcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fdGlsZXNbaV07XHJcblx0XHRcdFx0XHQvLyBAZXZlbnQgdGlsZWFib3J0OiBUaWxlRXZlbnRcclxuXHRcdFx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIHdhcyBsb2FkaW5nIGJ1dCBpcyBub3cgbm90IHdhbnRlZC5cclxuXHRcdFx0XHRcdHRoaXMuZmlyZSgndGlsZWFib3J0Jywge1xyXG5cdFx0XHRcdFx0XHR0aWxlOiB0aWxlLFxyXG5cdFx0XHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcclxuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcclxuXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBDYW5jZWxzIGFueSBwZW5kaW5nIGh0dHAgcmVxdWVzdHMgYXNzb2NpYXRlZCB3aXRoIHRoZSB0aWxlXHJcblx0XHR0aWxlLmVsLnNldEF0dHJpYnV0ZSgnc3JjJywgVXRpbC5lbXB0eUltYWdlVXJsKTtcclxuXHJcblx0XHRyZXR1cm4gR3JpZExheWVyLnByb3RvdHlwZS5fcmVtb3ZlVGlsZS5jYWxsKHRoaXMsIGtleSk7XHJcblx0fSxcclxuXHJcblx0X3RpbGVSZWFkeTogZnVuY3Rpb24gKGNvb3JkcywgZXJyLCB0aWxlKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCB8fCAodGlsZSAmJiB0aWxlLmdldEF0dHJpYnV0ZSgnc3JjJykgPT09IFV0aWwuZW1wdHlJbWFnZVVybCkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBHcmlkTGF5ZXIucHJvdG90eXBlLl90aWxlUmVhZHkuY2FsbCh0aGlzLCBjb29yZHMsIGVyciwgdGlsZSk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLnRpbGVsYXllcih1cmxUZW1wbGF0ZTogU3RyaW5nLCBvcHRpb25zPzogVGlsZUxheWVyIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIHRpbGUgbGF5ZXIgb2JqZWN0IGdpdmVuIGEgYFVSTCB0ZW1wbGF0ZWAgYW5kIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGlsZUxheWVyKHVybCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVGlsZUxheWVyKHVybCwgb3B0aW9ucyk7XHJcbn1cclxuIiwiaW1wb3J0IHtUaWxlTGF5ZXJ9IGZyb20gJy4vVGlsZUxheWVyJztcclxuaW1wb3J0IHtleHRlbmQsIHNldE9wdGlvbnMsIGdldFBhcmFtU3RyaW5nfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQge0VQU0c0MzI2fSBmcm9tICcuLi8uLi9nZW8vY3JzL0NSUy5FUFNHNDMyNic7XHJcbmltcG9ydCB7dG9Cb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgVGlsZUxheWVyLldNU1xyXG4gKiBAaW5oZXJpdHMgVGlsZUxheWVyXHJcbiAqIEBha2EgTC5UaWxlTGF5ZXIuV01TXHJcbiAqIFVzZWQgdG8gZGlzcGxheSBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzIGFzIHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIEV4dGVuZHMgYFRpbGVMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBuZXhyYWQgPSBMLnRpbGVMYXllci53bXMoXCJodHRwOi8vbWVzb25ldC5hZ3Jvbi5pYXN0YXRlLmVkdS9jZ2ktYmluL3dtcy9uZXhyYWQvbjByLmNnaVwiLCB7XHJcbiAqIFx0bGF5ZXJzOiAnbmV4cmFkLW4wci05MDA5MTMnLFxyXG4gKiBcdGZvcm1hdDogJ2ltYWdlL3BuZycsXHJcbiAqIFx0dHJhbnNwYXJlbnQ6IHRydWUsXHJcbiAqIFx0YXR0cmlidXRpb246IFwiV2VhdGhlciBkYXRhIMKpIDIwMTIgSUVNIE5leHJhZFwiXHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIFRpbGVMYXllcldNUyA9IFRpbGVMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgVGlsZUxheWVyLldNUyBvcHRpb25zXHJcblx0Ly8gSWYgYW55IGN1c3RvbSBvcHRpb25zIG5vdCBkb2N1bWVudGVkIGhlcmUgYXJlIHVzZWQsIHRoZXkgd2lsbCBiZSBzZW50IHRvIHRoZVxyXG5cdC8vIFdNUyBzZXJ2ZXIgYXMgZXh0cmEgcGFyYW1ldGVycyBpbiBlYWNoIHJlcXVlc3QgVVJMLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yXHJcblx0Ly8gW25vbi1zdGFuZGFyZCB2ZW5kb3IgV01TIHBhcmFtZXRlcnNdKGh0dHBzOi8vZG9jcy5nZW9zZXJ2ZXIub3JnL3N0YWJsZS9lbi91c2VyL3NlcnZpY2VzL3dtcy92ZW5kb3IuaHRtbCkuXHJcblx0ZGVmYXVsdFdtc1BhcmFtczoge1xyXG5cdFx0c2VydmljZTogJ1dNUycsXHJcblx0XHRyZXF1ZXN0OiAnR2V0TWFwJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxheWVyczogU3RyaW5nID0gJydcclxuXHRcdC8vICoqKHJlcXVpcmVkKSoqIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBsYXllcnMgdG8gc2hvdy5cclxuXHRcdGxheWVyczogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzdHlsZXM6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgc3R5bGVzLlxyXG5cdFx0c3R5bGVzOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGZvcm1hdDogU3RyaW5nID0gJ2ltYWdlL2pwZWcnXHJcblx0XHQvLyBXTVMgaW1hZ2UgZm9ybWF0ICh1c2UgYCdpbWFnZS9wbmcnYCBmb3IgbGF5ZXJzIHdpdGggdHJhbnNwYXJlbmN5KS5cclxuXHRcdGZvcm1hdDogJ2ltYWdlL2pwZWcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhbnNwYXJlbnQ6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgV01TIHNlcnZpY2Ugd2lsbCByZXR1cm4gaW1hZ2VzIHdpdGggdHJhbnNwYXJlbmN5LlxyXG5cdFx0dHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdmVyc2lvbjogU3RyaW5nID0gJzEuMS4xJ1xyXG5cdFx0Ly8gVmVyc2lvbiBvZiB0aGUgV01TIHNlcnZpY2UgdG8gdXNlXHJcblx0XHR2ZXJzaW9uOiAnMS4xLjEnXHJcblx0fSxcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IG51bGxcclxuXHRcdC8vIENvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbSB0byB1c2UgZm9yIHRoZSBXTVMgcmVxdWVzdHMsIGRlZmF1bHRzIHRvXHJcblx0XHQvLyBtYXAgQ1JTLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90IHN1cmUgd2hhdCBpdCBtZWFucy5cclxuXHRcdGNyczogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHVwcGVyY2FzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIFdNUyByZXF1ZXN0IHBhcmFtZXRlciBrZXlzIHdpbGwgYmUgdXBwZXJjYXNlLlxyXG5cdFx0dXBwZXJjYXNlOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0dmFyIHdtc1BhcmFtcyA9IGV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0V21zUGFyYW1zKTtcclxuXHJcblx0XHQvLyBhbGwga2V5cyB0aGF0IGFyZSBub3QgVGlsZUxheWVyIG9wdGlvbnMgZ28gdG8gV01TIHBhcmFtc1xyXG5cdFx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcblx0XHRcdGlmICghKGkgaW4gdGhpcy5vcHRpb25zKSkge1xyXG5cdFx0XHRcdHdtc1BhcmFtc1tpXSA9IG9wdGlvbnNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR2YXIgcmVhbFJldGluYSA9IG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIEJyb3dzZXIucmV0aW5hID8gMiA6IDE7XHJcblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XHJcblx0XHR3bXNQYXJhbXMud2lkdGggPSB0aWxlU2l6ZS54ICogcmVhbFJldGluYTtcclxuXHRcdHdtc1BhcmFtcy5oZWlnaHQgPSB0aWxlU2l6ZS55ICogcmVhbFJldGluYTtcclxuXHJcblx0XHR0aGlzLndtc1BhcmFtcyA9IHdtc1BhcmFtcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cclxuXHRcdHRoaXMuX2NycyA9IHRoaXMub3B0aW9ucy5jcnMgfHwgbWFwLm9wdGlvbnMuY3JzO1xyXG5cdFx0dGhpcy5fd21zVmVyc2lvbiA9IHBhcnNlRmxvYXQodGhpcy53bXNQYXJhbXMudmVyc2lvbik7XHJcblxyXG5cdFx0dmFyIHByb2plY3Rpb25LZXkgPSB0aGlzLl93bXNWZXJzaW9uID49IDEuMyA/ICdjcnMnIDogJ3Nycyc7XHJcblx0XHR0aGlzLndtc1BhcmFtc1twcm9qZWN0aW9uS2V5XSA9IHRoaXMuX2Nycy5jb2RlO1xyXG5cclxuXHRcdFRpbGVMYXllci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdGdldFRpbGVVcmw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuXHJcblx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSxcclxuXHRcdCAgICBjcnMgPSB0aGlzLl9jcnMsXHJcblx0XHQgICAgYm91bmRzID0gdG9Cb3VuZHMoY3JzLnByb2plY3QodGlsZUJvdW5kc1swXSksIGNycy5wcm9qZWN0KHRpbGVCb3VuZHNbMV0pKSxcclxuXHRcdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heCA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgYmJveCA9ICh0aGlzLl93bXNWZXJzaW9uID49IDEuMyAmJiB0aGlzLl9jcnMgPT09IEVQU0c0MzI2ID9cclxuXHRcdCAgICBbbWluLnksIG1pbi54LCBtYXgueSwgbWF4LnhdIDpcclxuXHRcdCAgICBbbWluLngsIG1pbi55LCBtYXgueCwgbWF4LnldKS5qb2luKCcsJyksXHJcblx0XHQgICAgdXJsID0gVGlsZUxheWVyLnByb3RvdHlwZS5nZXRUaWxlVXJsLmNhbGwodGhpcywgY29vcmRzKTtcclxuXHRcdHJldHVybiB1cmwgK1xyXG5cdFx0XHRnZXRQYXJhbVN0cmluZyh0aGlzLndtc1BhcmFtcywgdXJsLCB0aGlzLm9wdGlvbnMudXBwZXJjYXNlKSArXHJcblx0XHRcdCh0aGlzLm9wdGlvbnMudXBwZXJjYXNlID8gJyZCQk9YPScgOiAnJmJib3g9JykgKyBiYm94O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UGFyYW1zKHBhcmFtczogT2JqZWN0LCBub1JlZHJhdz86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gTWVyZ2VzIGFuIG9iamVjdCB3aXRoIHRoZSBuZXcgcGFyYW1ldGVycyBhbmQgcmUtcmVxdWVzdHMgdGlsZXMgb24gdGhlIGN1cnJlbnQgc2NyZWVuICh1bmxlc3MgYG5vUmVkcmF3YCB3YXMgc2V0IHRvIHRydWUpLlxyXG5cdHNldFBhcmFtczogZnVuY3Rpb24gKHBhcmFtcywgbm9SZWRyYXcpIHtcclxuXHJcblx0XHRleHRlbmQodGhpcy53bXNQYXJhbXMsIHBhcmFtcyk7XHJcblxyXG5cdFx0aWYgKCFub1JlZHJhdykge1xyXG5cdFx0XHR0aGlzLnJlZHJhdygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC50aWxlTGF5ZXIud21zKGJhc2VVcmw6IFN0cmluZywgb3B0aW9uczogVGlsZUxheWVyLldNUyBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBXTVMgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBiYXNlIFVSTCBvZiB0aGUgV01TIHNlcnZpY2UgYW5kIGEgV01TIHBhcmFtZXRlcnMvb3B0aW9ucyBvYmplY3QuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBUaWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKTtcclxufVxyXG4iLCJleHBvcnQge0dyaWRMYXllciwgZ3JpZExheWVyfSBmcm9tICcuL0dyaWRMYXllcic7XG5pbXBvcnQge1RpbGVMYXllciwgdGlsZUxheWVyfSBmcm9tICcuL1RpbGVMYXllcic7XG5pbXBvcnQge1RpbGVMYXllcldNUywgdGlsZUxheWVyV01TfSBmcm9tICcuL1RpbGVMYXllci5XTVMnO1xuVGlsZUxheWVyLldNUyA9IFRpbGVMYXllcldNUztcbnRpbGVMYXllci53bXMgPSB0aWxlTGF5ZXJXTVM7XG5leHBvcnQge1RpbGVMYXllciwgdGlsZUxheWVyfTtcbiIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG5cblxuLypcbiAqIEBjbGFzcyBSZW5kZXJlclxuICogQGluaGVyaXRzIExheWVyXG4gKiBAYWthIEwuUmVuZGVyZXJcbiAqXG4gKiBCYXNlIGNsYXNzIGZvciB2ZWN0b3IgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zIChgU1ZHYCwgYENhbnZhc2ApLiBIYW5kbGVzIHRoZVxuICogRE9NIGNvbnRhaW5lciBvZiB0aGUgcmVuZGVyZXIsIGl0cyBib3VuZHMsIGFuZCBpdHMgem9vbSBhbmltYXRpb24uXG4gKlxuICogQSBgUmVuZGVyZXJgIHdvcmtzIGFzIGFuIGltcGxpY2l0IGxheWVyIGdyb3VwIGZvciBhbGwgYFBhdGhgcyAtIHRoZSByZW5kZXJlclxuICogaXRzZWxmIGNhbiBiZSBhZGRlZCBvciByZW1vdmVkIHRvIHRoZSBtYXAuIEFsbCBwYXRocyB1c2UgYSByZW5kZXJlciwgd2hpY2ggY2FuXG4gKiBiZSBpbXBsaWNpdCAodGhlIG1hcCB3aWxsIGRlY2lkZSB0aGUgdHlwZSBvZiByZW5kZXJlciBhbmQgdXNlIGl0IGF1dG9tYXRpY2FsbHkpXG4gKiBvciBleHBsaWNpdCAodXNpbmcgdGhlIFtgcmVuZGVyZXJgXSgjcGF0aC1yZW5kZXJlcikgb3B0aW9uIG9mIHRoZSBwYXRoKS5cbiAqXG4gKiBEbyBub3QgdXNlIHRoaXMgY2xhc3MgZGlyZWN0bHksIHVzZSBgU1ZHYCBhbmQgYENhbnZhc2AgaW5zdGVhZC5cbiAqXG4gKiBAZXZlbnQgdXBkYXRlOiBFdmVudFxuICogRmlyZWQgd2hlbiB0aGUgcmVuZGVyZXIgdXBkYXRlcyBpdHMgYm91bmRzLCBjZW50ZXIgYW5kIHpvb20sIGZvciBleGFtcGxlIHdoZW5cbiAqIGl0cyBtYXAgaGFzIG1vdmVkXG4gKi9cblxuZXhwb3J0IHZhciBSZW5kZXJlciA9IExheWVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBSZW5kZXJlciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhZGRpbmc6IE51bWJlciA9IDAuMVxuXHRcdC8vIEhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgY2xpcCBhcmVhIGFyb3VuZCB0aGUgbWFwIHZpZXcgKHJlbGF0aXZlIHRvIGl0cyBzaXplKVxuXHRcdC8vIGUuZy4gMC4xIHdvdWxkIGJlIDEwJSBvZiBtYXAgdmlldyBpbiBlYWNoIGRpcmVjdGlvblxuXHRcdHBhZGRpbmc6IDAuMVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdFV0aWwuc3RhbXAodGhpcyk7XG5cdFx0dGhpcy5fbGF5ZXJzID0gdGhpcy5fbGF5ZXJzIHx8IHt9O1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcblx0XHRcdHRoaXMuX2luaXRDb250YWluZXIoKTsgLy8gZGVmaW5lZCBieSByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnNcblxuXHRcdFx0Ly8gYWx3YXlzIGtlZXAgdHJhbnNmb3JtLW9yaWdpbiBhcyAwIDBcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHR0aGlzLm9uKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLm9mZigndXBkYXRlJywgdGhpcy5fdXBkYXRlUGF0aHMsIHRoaXMpO1xuXHRcdHRoaXMuX2Rlc3Ryb3lDb250YWluZXIoKTtcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldCxcblx0XHRcdHpvb206IHRoaXMuX29uWm9vbSxcblx0XHRcdG1vdmVlbmQ6IHRoaXMuX3VwZGF0ZSxcblx0XHRcdHpvb21lbmQ6IHRoaXMuX29uWm9vbUVuZFxuXHRcdH07XG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fb25BbmltWm9vbTtcblx0XHR9XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfb25BbmltWm9vbTogZnVuY3Rpb24gKGV2KSB7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKGV2LmNlbnRlciwgZXYuem9vbSk7XG5cdH0sXG5cblx0X29uWm9vbTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCkpO1xuXHR9LFxuXG5cdF91cGRhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIHRoaXMuX3pvb20pLFxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuX21hcC5nZXRTaXplKCkubXVsdGlwbHlCeSgwLjUgKyB0aGlzLm9wdGlvbnMucGFkZGluZyksXG5cdFx0ICAgIGN1cnJlbnRDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KHRoaXMuX2NlbnRlciwgem9vbSksXG5cblx0XHQgICAgdG9wTGVmdE9mZnNldCA9IHZpZXdIYWxmLm11bHRpcGx5QnkoLXNjYWxlKS5hZGQoY3VycmVudENlbnRlclBvaW50KVxuXHRcdFx0XHQgIC5zdWJ0cmFjdCh0aGlzLl9tYXAuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkpO1xuXG5cdFx0aWYgKEJyb3dzZXIuYW55M2QpIHtcblx0XHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCwgc2NhbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20pO1xuXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9yZXNldCgpO1xuXHRcdH1cblx0fSxcblxuXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9wcm9qZWN0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoczogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fdXBkYXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBVcGRhdGUgcGl4ZWwgYm91bmRzIG9mIHJlbmRlcmVyIGNvbnRhaW5lciAoZm9yIHBvc2l0aW9uaW5nL3NpemluZy9jbGlwcGluZyBsYXRlcilcblx0XHQvLyBTdWJjbGFzc2VzIGFyZSByZXNwb25zaWJsZSBvZiBmaXJpbmcgdGhlICd1cGRhdGUnIGV2ZW50LlxuXHRcdHZhciBwID0gdGhpcy5vcHRpb25zLnBhZGRpbmcsXG5cdFx0ICAgIHNpemUgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtaW4gPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoc2l6ZS5tdWx0aXBseUJ5KC1wKSkucm91bmQoKTtcblxuXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBCb3VuZHMobWluLCBtaW4uYWRkKHNpemUubXVsdGlwbHlCeSgxICsgcCAqIDIpKS5yb3VuZCgpKTtcblxuXHRcdHRoaXMuX2NlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcblx0XHR0aGlzLl96b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuLypcbiAqIEBjbGFzcyBDYW52YXNcbiAqIEBpbmhlcml0cyBSZW5kZXJlclxuICogQGFrYSBMLkNhbnZhc1xuICpcbiAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXG4gKiBJbmhlcml0cyBgUmVuZGVyZXJgLlxuICpcbiAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwczovL2Nhbml1c2UuY29tL2NhbnZhcyksIENhbnZhcyBpcyBub3RcbiAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IElFOCwgYW5kIG92ZXJsYXBwaW5nIGdlb21ldHJpZXMgbWlnaHRcbiAqIG5vdCBkaXNwbGF5IHByb3Blcmx5IGluIHNvbWUgZWRnZSBjYXNlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIFVzZSBDYW52YXMgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICogXHRyZW5kZXJlcjogTC5jYW52YXMoKVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBVc2UgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAqIHZhciBteVJlbmRlcmVyID0gTC5jYW52YXMoeyBwYWRkaW5nOiAwLjUgfSk7XG4gKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgQ2FudmFzID0gUmVuZGVyZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIENhbnZhcyBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHRvbGVyYW5jZTogTnVtYmVyID0gMFxuXHRcdC8vIEhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgY2xpY2sgdG9sZXJhbmNlIGFyb3VuZCBhIHBhdGgvb2JqZWN0IG9uIHRoZSBtYXAuXG5cdFx0dG9sZXJhbmNlOiAwXG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IFJlbmRlcmVyLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblx0XHRldmVudHMudmlld3ByZXJlc2V0ID0gdGhpcy5fb25WaWV3UHJlUmVzZXQ7XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfb25WaWV3UHJlUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBTZXQgYSBmbGFnIHNvIHRoYXQgYSB2aWV3cHJlcmVzZXQrbW92ZWVuZCt2aWV3cmVzZXQgb25seSB1cGRhdGVzJnJlZHJhd3Mgb25jZVxuXHRcdHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMgPSB0cnVlO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcyk7XG5cblx0XHQvLyBSZWRyYXcgdmVjdG9ycyBzaW5jZSBjYW52YXMgaXMgY2xlYXJlZCB1cG9uIHJlbW92YWwsXG5cdFx0Ly8gaW4gY2FzZSBvZiByZW1vdmluZyB0aGUgcmVuZGVyZXIgaXRzZWxmIGZyb20gdGhlIG1hcC5cblx0XHR0aGlzLl9kcmF3KCk7XG5cdH0sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcyk7XG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgY29udGV4dG1lbnUnLCB0aGlzLl9vbkNsaWNrLCB0aGlzKTtcblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdtb3VzZW91dCcsIHRoaXMuX2hhbmRsZU1vdXNlT3V0LCB0aGlzKTtcblx0XHRjb250YWluZXJbJ19sZWFmbGV0X2Rpc2FibGVfZXZlbnRzJ10gPSB0cnVlO1xuXG5cdFx0dGhpcy5fY3R4ID0gY29udGFpbmVyLmdldENvbnRleHQoJzJkJyk7XG5cdH0sXG5cblx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZWRyYXdSZXF1ZXN0KTtcblx0XHRkZWxldGUgdGhpcy5fY3R4O1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcjtcblx0fSxcblxuXHRfdXBkYXRlUGF0aHM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocykgeyByZXR1cm47IH1cblxuXHRcdHZhciBsYXllcjtcblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSBudWxsO1xuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuXHRcdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHRcdH1cblx0XHR0aGlzLl9yZWRyYXcoKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHsgcmV0dXJuOyB9XG5cblx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG5cdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcblx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtID0gQnJvd3Nlci5yZXRpbmEgPyAyIDogMTtcblxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG5cblx0XHQvLyBzZXQgY2FudmFzIHNpemUgKGFsc28gY2xlYXJpbmcgaXQpOyB1c2UgZG91YmxlIHNpemUgb24gcmV0aW5hXG5cdFx0Y29udGFpbmVyLndpZHRoID0gbSAqIHNpemUueDtcblx0XHRjb250YWluZXIuaGVpZ2h0ID0gbSAqIHNpemUueTtcblx0XHRjb250YWluZXIuc3R5bGUud2lkdGggPSBzaXplLnggKyAncHgnO1xuXHRcdGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuXG5cdFx0aWYgKEJyb3dzZXIucmV0aW5hKSB7XG5cdFx0XHR0aGlzLl9jdHguc2NhbGUoMiwgMik7XG5cdFx0fVxuXG5cdFx0Ly8gdHJhbnNsYXRlIHNvIHdlIHVzZSB0aGUgc2FtZSBwYXRoIGNvb3JkaW5hdGVzIGFmdGVyIGNhbnZhcyBlbGVtZW50IG1vdmVzXG5cdFx0dGhpcy5fY3R4LnRyYW5zbGF0ZSgtYi5taW4ueCwgLWIubWluLnkpO1xuXG5cdFx0Ly8gVGVsbCBwYXRocyB0byByZWRyYXcgdGhlbXNlbHZlc1xuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl9yZXNldC5jYWxsKHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHtcblx0XHRcdHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3VwZGF0ZVBhdGhzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcblx0XHR0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildID0gbGF5ZXI7XG5cblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXIgPSB7XG5cdFx0XHRsYXllcjogbGF5ZXIsXG5cdFx0XHRwcmV2OiB0aGlzLl9kcmF3TGFzdCxcblx0XHRcdG5leHQ6IG51bGxcblx0XHR9O1xuXHRcdGlmICh0aGlzLl9kcmF3TGFzdCkgeyB0aGlzLl9kcmF3TGFzdC5uZXh0ID0gb3JkZXI7IH1cblx0XHR0aGlzLl9kcmF3TGFzdCA9IG9yZGVyO1xuXHRcdHRoaXMuX2RyYXdGaXJzdCA9IHRoaXMuX2RyYXdGaXJzdCB8fCB0aGlzLl9kcmF3TGFzdDtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2RyYXdMYXN0ID0gcHJldjtcblx0XHR9XG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2RyYXdGaXJzdCA9IG5leHQ7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIGxheWVyLl9vcmRlcjtcblxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildO1xuXG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdC8vIFJlZHJhdyB0aGUgdW5pb24gb2YgdGhlIGxheWVyJ3Mgb2xkIHBpeGVsXG5cdFx0Ly8gYm91bmRzIGFuZCB0aGUgbmV3IHBpeGVsIGJvdW5kcy5cblx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuXHRcdGxheWVyLl9wcm9qZWN0KCk7XG5cdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHRcdC8vIFRoZSByZWRyYXcgd2lsbCBleHRlbmQgdGhlIHJlZHJhdyBib3VuZHNcblx0XHQvLyB3aXRoIHRoZSBuZXcgcGl4ZWwgYm91bmRzLlxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlRGFzaEFycmF5OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAodHlwZW9mIGxheWVyLm9wdGlvbnMuZGFzaEFycmF5ID09PSAnc3RyaW5nJykge1xuXHRcdFx0dmFyIHBhcnRzID0gbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXkuc3BsaXQoL1ssIF0rLyksXG5cdFx0XHQgICAgZGFzaEFycmF5ID0gW10sXG5cdFx0XHQgICAgZGFzaFZhbHVlLFxuXHRcdFx0ICAgIGk7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZGFzaFZhbHVlID0gTnVtYmVyKHBhcnRzW2ldKTtcblx0XHRcdFx0Ly8gSWdub3JlIGRhc2ggYXJyYXkgY29udGFpbmluZyBpbnZhbGlkIGxlbmd0aHNcblx0XHRcdFx0aWYgKGlzTmFOKGRhc2hWYWx1ZSkpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdGRhc2hBcnJheS5wdXNoKGRhc2hWYWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgPSBkYXNoQXJyYXk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSA9IGxheWVyLm9wdGlvbnMuZGFzaEFycmF5O1xuXHRcdH1cblx0fSxcblxuXHRfcmVxdWVzdFJlZHJhdzogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSB0aGlzLl9yZWRyYXdSZXF1ZXN0IHx8IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9yZWRyYXcsIHRoaXMpO1xuXHR9LFxuXG5cdF9leHRlbmRSZWRyYXdCb3VuZHM6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmIChsYXllci5fcHhCb3VuZHMpIHtcblx0XHRcdHZhciBwYWRkaW5nID0gKGxheWVyLm9wdGlvbnMud2VpZ2h0IHx8IDApICsgMTtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcyB8fCBuZXcgQm91bmRzKCk7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5taW4uc3VidHJhY3QoW3BhZGRpbmcsIHBhZGRpbmddKSk7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5tYXguYWRkKFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IG51bGw7XG5cblx0XHRpZiAodGhpcy5fcmVkcmF3Qm91bmRzKSB7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMubWluLl9mbG9vcigpO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLm1heC5fY2VpbCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NsZWFyKCk7IC8vIGNsZWFyIGxheWVycyBpbiByZWRyYXcgYm91bmRzXG5cdFx0dGhpcy5fZHJhdygpOyAvLyBkcmF3IGxheWVyc1xuXG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcblx0fSxcblxuXHRfY2xlYXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuXHRcdGlmIChib3VuZHMpIHtcblx0XHRcdHZhciBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblx0XHRcdHRoaXMuX2N0eC5jbGVhclJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY3R4LnNhdmUoKTtcblx0XHRcdHRoaXMuX2N0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cdFx0XHR0aGlzLl9jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2NvbnRhaW5lci53aWR0aCwgdGhpcy5fY29udGFpbmVyLmhlaWdodCk7XG5cdFx0XHR0aGlzLl9jdHgucmVzdG9yZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBsYXllciwgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuXHRcdHRoaXMuX2N0eC5zYXZlKCk7XG5cdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0dmFyIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXHRcdFx0dGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0dGhpcy5fY3R4LnJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcblx0XHRcdHRoaXMuX2N0eC5jbGlwKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhd2luZyA9IHRydWU7XG5cblx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcblx0XHRcdGlmICghYm91bmRzIHx8IChsYXllci5fcHhCb3VuZHMgJiYgbGF5ZXIuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkpIHtcblx0XHRcdFx0bGF5ZXIuX3VwZGF0ZVBhdGgoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9kcmF3aW5nID0gZmFsc2U7XG5cblx0XHR0aGlzLl9jdHgucmVzdG9yZSgpOyAgLy8gUmVzdG9yZSBzdGF0ZSBiZWZvcmUgY2xpcHBpbmcuXG5cdH0sXG5cblx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG5cdFx0aWYgKCF0aGlzLl9kcmF3aW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGksIGosIGxlbjIsIHAsXG5cdFx0ICAgIHBhcnRzID0gbGF5ZXIuX3BhcnRzLFxuXHRcdCAgICBsZW4gPSBwYXJ0cy5sZW5ndGgsXG5cdFx0ICAgIGN0eCA9IHRoaXMuX2N0eDtcblxuXHRcdGlmICghbGVuKSB7IHJldHVybjsgfVxuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydHNbaV0ubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG5cdFx0XHRcdHAgPSBwYXJ0c1tpXVtqXTtcblx0XHRcdFx0Y3R4W2ogPyAnbGluZVRvJyA6ICdtb3ZlVG8nXShwLngsIHAueSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuXG5cdFx0Ly8gVE9ETyBvcHRpbWl6YXRpb246IDEgZmlsbC9zdHJva2UgZm9yIGFsbCBmZWF0dXJlcyB3aXRoIGVxdWFsIHN0eWxlIGluc3RlYWQgb2YgMSBmb3IgZWFjaCBmZWF0dXJlXG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cblx0XHRpZiAoIXRoaXMuX2RyYXdpbmcgfHwgbGF5ZXIuX2VtcHR5KCkpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcblx0XHQgICAgY3R4ID0gdGhpcy5fY3R4LFxuXHRcdCAgICByID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSwgMSksXG5cdFx0ICAgIHMgPSAoTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSksIDEpIHx8IHIpIC8gcjtcblxuXHRcdGlmIChzICE9PSAxKSB7XG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0Y3R4LnNjYWxlKDEsIHMpO1xuXHRcdH1cblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHguYXJjKHAueCwgcC55IC8gcywgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcblxuXHRcdGlmIChzICE9PSAxKSB7XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2ZpbGxTdHJva2UoY3R4LCBsYXllcik7XG5cdH0sXG5cblx0X2ZpbGxTdHJva2U6IGZ1bmN0aW9uIChjdHgsIGxheWVyKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5maWxsT3BhY2l0eTtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xuXHRcdFx0Y3R4LmZpbGwob3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSAmJiBvcHRpb25zLndlaWdodCAhPT0gMCkge1xuXHRcdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuXHRcdFx0XHRjdHguc2V0TGluZURhc2gobGF5ZXIub3B0aW9ucyAmJiBsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgfHwgW10pO1xuXHRcdFx0fVxuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5vcGFjaXR5O1xuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMud2VpZ2h0O1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5jb2xvcjtcblx0XHRcdGN0eC5saW5lQ2FwID0gb3B0aW9ucy5saW5lQ2FwO1xuXHRcdFx0Y3R4LmxpbmVKb2luID0gb3B0aW9ucy5saW5lSm9pbjtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ2FudmFzIG9idmlvdXNseSBkb2Vzbid0IGhhdmUgbW91c2UgZXZlbnRzIGZvciBpbmRpdmlkdWFsIGRyYXduIG9iamVjdHMsXG5cdC8vIHNvIHdlIGVtdWxhdGUgdGhhdCBieSBjYWxjdWxhdGluZyB3aGF0J3MgdW5kZXIgdGhlIG1vdXNlIG9uIG1vdXNlbW92ZS9jbGljayBtYW51YWxseVxuXG5cdF9vbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpLCBsYXllciwgY2xpY2tlZExheWVyO1xuXG5cdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG5cdFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpIHtcblx0XHRcdFx0aWYgKCEoZS50eXBlID09PSAnY2xpY2snIHx8IGUudHlwZSA9PT0gJ3ByZWNsaWNrJykgfHwgIXRoaXMuX21hcC5fZHJhZ2dhYmxlTW92ZWQobGF5ZXIpKSB7XG5cdFx0XHRcdFx0Y2xpY2tlZExheWVyID0gbGF5ZXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fZmlyZUV2ZW50KGNsaWNrZWRMYXllciA/IFtjbGlja2VkTGF5ZXJdIDogZmFsc2UsIGUpO1xuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuZHJhZ2dpbmcubW92aW5nKCkgfHwgdGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSk7XG5cdFx0dGhpcy5faGFuZGxlTW91c2VIb3ZlcihlLCBwb2ludCk7XG5cdH0sXG5cblxuXHRfaGFuZGxlTW91c2VPdXQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxheWVyID0gdGhpcy5faG92ZXJlZExheWVyO1xuXHRcdGlmIChsYXllcikge1xuXHRcdFx0Ly8gaWYgd2UncmUgbGVhdmluZyB0aGUgbGF5ZXIsIGZpcmUgbW91c2VvdXRcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuXHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtsYXllcl0sIGUsICdtb3VzZW91dCcpO1xuXHRcdFx0dGhpcy5faG92ZXJlZExheWVyID0gbnVsbDtcblx0XHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSBmYWxzZTtcblx0XHR9XG5cdH0sXG5cblx0X2hhbmRsZU1vdXNlSG92ZXI6IGZ1bmN0aW9uIChlLCBwb2ludCkge1xuXHRcdGlmICh0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGxheWVyLCBjYW5kaWRhdGVIb3ZlcmVkTGF5ZXI7XG5cblx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcblx0XHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlICYmIGxheWVyLl9jb250YWluc1BvaW50KHBvaW50KSkge1xuXHRcdFx0XHRjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIgPSBsYXllcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoY2FuZGlkYXRlSG92ZXJlZExheWVyICE9PSB0aGlzLl9ob3ZlcmVkTGF5ZXIpIHtcblx0XHRcdHRoaXMuX2hhbmRsZU1vdXNlT3V0KGUpO1xuXG5cdFx0XHRpZiAoY2FuZGlkYXRlSG92ZXJlZExheWVyKSB7XG5cdFx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpOyAvLyBjaGFuZ2UgY3Vyc29yXG5cdFx0XHRcdHRoaXMuX2ZpcmVFdmVudChbY2FuZGlkYXRlSG92ZXJlZExheWVyXSwgZSwgJ21vdXNlb3ZlcicpO1xuXHRcdFx0XHR0aGlzLl9ob3ZlcmVkTGF5ZXIgPSBjYW5kaWRhdGVIb3ZlcmVkTGF5ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmlyZUV2ZW50KHRoaXMuX2hvdmVyZWRMYXllciA/IFt0aGlzLl9ob3ZlcmVkTGF5ZXJdIDogZmFsc2UsIGUpO1xuXG5cdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IHRydWU7XG5cdFx0c2V0VGltZW91dChVdGlsLmJpbmQoZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IGZhbHNlO1xuXHRcdH0sIHRoaXMpLCAzMik7XG5cdH0sXG5cblx0X2ZpcmVFdmVudDogZnVuY3Rpb24gKGxheWVycywgZSwgdHlwZSkge1xuXHRcdHRoaXMuX21hcC5fZmlyZURPTUV2ZW50KGUsIHR5cGUgfHwgZS50eXBlLCBsYXllcnMpO1xuXHR9LFxuXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblxuXHRcdGlmICghb3JkZXIpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEFscmVhZHkgbGFzdFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAocHJldikge1xuXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHR9IGVsc2UgaWYgKG5leHQpIHtcblx0XHRcdC8vIFVwZGF0ZSBmaXJzdCBlbnRyeSB1bmxlc3MgdGhpcyBpcyB0aGVcblx0XHRcdC8vIHNpbmdsZSBlbnRyeVxuXHRcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gbmV4dDtcblx0XHR9XG5cblx0XHRvcmRlci5wcmV2ID0gdGhpcy5fZHJhd0xhc3Q7XG5cdFx0dGhpcy5fZHJhd0xhc3QubmV4dCA9IG9yZGVyO1xuXG5cdFx0b3JkZXIubmV4dCA9IG51bGw7XG5cdFx0dGhpcy5fZHJhd0xhc3QgPSBvcmRlcjtcblxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXG5cdFx0aWYgKCFvcmRlcikgeyByZXR1cm47IH1cblxuXHRcdHZhciBuZXh0ID0gb3JkZXIubmV4dDtcblx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cblx0XHRpZiAocHJldikge1xuXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQWxyZWFkeSBmaXJzdFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAobmV4dCkge1xuXHRcdFx0bmV4dC5wcmV2ID0gcHJldjtcblx0XHR9IGVsc2UgaWYgKHByZXYpIHtcblx0XHRcdC8vIFVwZGF0ZSBsYXN0IGVudHJ5IHVubGVzcyB0aGlzIGlzIHRoZVxuXHRcdFx0Ly8gc2luZ2xlIGVudHJ5XG5cdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG5cdFx0fVxuXG5cdFx0b3JkZXIucHJldiA9IG51bGw7XG5cblx0XHRvcmRlci5uZXh0ID0gdGhpcy5fZHJhd0ZpcnN0O1xuXHRcdHRoaXMuX2RyYXdGaXJzdC5wcmV2ID0gb3JkZXI7XG5cdFx0dGhpcy5fZHJhd0ZpcnN0ID0gb3JkZXI7XG5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuY2FudmFzKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIENhbnZhcyByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIGNhbnZhcyhvcHRpb25zKSB7XG5cdHJldHVybiBCcm93c2VyLmNhbnZhcyA/IG5ldyBDYW52YXMob3B0aW9ucykgOiBudWxsO1xufVxuIiwiaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcblxuLypcbiAqIFRoYW5rcyB0byBEbWl0cnkgQmFyYW5vdnNreSBhbmQgaGlzIFJhcGhhZWwgbGlicmFyeSBmb3IgaW5zcGlyYXRpb24hXG4gKi9cblxuXG5leHBvcnQgdmFyIHZtbENyZWF0ZSA9IChmdW5jdGlvbiAoKSB7XG5cdHRyeSB7XG5cdFx0ZG9jdW1lbnQubmFtZXNwYWNlcy5hZGQoJ2x2bWwnLCAndXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWwnKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8bHZtbDonICsgbmFtZSArICcgY2xhc3M9XCJsdm1sXCI+Jyk7XG5cdFx0fTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIERvIG5vdCByZXR1cm4gZm4gZnJvbSBjYXRjaCBibG9jayBzbyBgZWAgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvcHVsbC83Mjc5XG5cdH1cblx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzwnICsgbmFtZSArICcgeG1sbnM9XCJ1cm46c2NoZW1hcy1taWNyb3NvZnQuY29tOnZtbFwiIGNsYXNzPVwibHZtbFwiPicpO1xuXHR9O1xufSkoKTtcblxuXG4vKlxuICogQGNsYXNzIFNWR1xuICpcbiAqXG4gKiBWTUwgd2FzIGRlcHJlY2F0ZWQgaW4gMjAxMiwgd2hpY2ggbWVhbnMgVk1MIGZ1bmN0aW9uYWxpdHkgZXhpc3RzIG9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gKiB3aXRoIG9sZCB2ZXJzaW9ucyBvZiBJbnRlcm5ldCBFeHBsb3Jlci5cbiAqL1xuXG4vLyBtaXhpbiB0byByZWRlZmluZSBzb21lIFNWRyBtZXRob2RzIHRvIGhhbmRsZSBWTUwgc3ludGF4IHdoaWNoIGlzIHNpbWlsYXIgYnV0IHdpdGggc29tZSBkaWZmZXJlbmNlc1xuZXhwb3J0IHZhciB2bWxNaXhpbiA9IHtcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC12bWwtY29udGFpbmVyJyk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuXHR9LFxuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXIgPSB2bWxDcmVhdGUoJ3NoYXBlJyk7XG5cblx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdm1sLXNoYXBlICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykpO1xuXG5cdFx0Y29udGFpbmVyLmNvb3Jkc2l6ZSA9ICcxIDEnO1xuXG5cdFx0bGF5ZXIuX3BhdGggPSB2bWxDcmVhdGUoJ3BhdGgnKTtcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQobGF5ZXIuX3BhdGgpO1xuXG5cdFx0dGhpcy5fdXBkYXRlU3R5bGUobGF5ZXIpO1xuXHRcdHRoaXMuX2xheWVyc1tVdGlsLnN0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuXHRcdFx0bGF5ZXIuYWRkSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXHRcdERvbVV0aWwucmVtb3ZlKGNvbnRhaW5lcik7XG5cdFx0bGF5ZXIucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXTtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBzdHJva2UgPSBsYXllci5fc3Ryb2tlLFxuXHRcdCAgICBmaWxsID0gbGF5ZXIuX2ZpbGwsXG5cdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zLFxuXHRcdCAgICBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXG5cdFx0Y29udGFpbmVyLnN0cm9rZWQgPSAhIW9wdGlvbnMuc3Ryb2tlO1xuXHRcdGNvbnRhaW5lci5maWxsZWQgPSAhIW9wdGlvbnMuZmlsbDtcblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xuXHRcdFx0aWYgKCFzdHJva2UpIHtcblx0XHRcdFx0c3Ryb2tlID0gbGF5ZXIuX3N0cm9rZSA9IHZtbENyZWF0ZSgnc3Ryb2tlJyk7XG5cdFx0XHR9XG5cdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc3Ryb2tlKTtcblx0XHRcdHN0cm9rZS53ZWlnaHQgPSBvcHRpb25zLndlaWdodCArICdweCc7XG5cdFx0XHRzdHJva2UuY29sb3IgPSBvcHRpb25zLmNvbG9yO1xuXHRcdFx0c3Ryb2tlLm9wYWNpdHkgPSBvcHRpb25zLm9wYWNpdHk7XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hBcnJheSkge1xuXHRcdFx0XHRzdHJva2UuZGFzaFN0eWxlID0gVXRpbC5pc0FycmF5KG9wdGlvbnMuZGFzaEFycmF5KSA/XG5cdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5qb2luKCcgJykgOlxuXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkucmVwbGFjZSgvKCAqLCAqKS9nLCAnICcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9ICcnO1xuXHRcdFx0fVxuXHRcdFx0c3Ryb2tlLmVuZGNhcCA9IG9wdGlvbnMubGluZUNhcC5yZXBsYWNlKCdidXR0JywgJ2ZsYXQnKTtcblx0XHRcdHN0cm9rZS5qb2luc3R5bGUgPSBvcHRpb25zLmxpbmVKb2luO1xuXG5cdFx0fSBlbHNlIGlmIChzdHJva2UpIHtcblx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChzdHJva2UpO1xuXHRcdFx0bGF5ZXIuX3N0cm9rZSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0aWYgKCFmaWxsKSB7XG5cdFx0XHRcdGZpbGwgPSBsYXllci5fZmlsbCA9IHZtbENyZWF0ZSgnZmlsbCcpO1xuXHRcdFx0fVxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGZpbGwpO1xuXHRcdFx0ZmlsbC5jb2xvciA9IG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRmaWxsLm9wYWNpdHkgPSBvcHRpb25zLmZpbGxPcGFjaXR5O1xuXG5cdFx0fSBlbHNlIGlmIChmaWxsKSB7XG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoZmlsbCk7XG5cdFx0XHRsYXllci5fZmlsbCA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LnJvdW5kKCksXG5cdFx0ICAgIHIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLFxuXHRcdCAgICByMiA9IE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kgfHwgcik7XG5cblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBsYXllci5fZW1wdHkoKSA/ICdNMCAwJyA6XG5cdFx0XHQnQUwgJyArIHAueCArICcsJyArIHAueSArICcgJyArIHIgKyAnLCcgKyByMiArICcgMCwnICsgKDY1NTM1ICogMzYwKSk7XG5cdH0sXG5cblx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuXHRcdGxheWVyLl9wYXRoLnYgPSBwYXRoO1xuXHR9LFxuXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwudG9Gcm9udChsYXllci5fY29udGFpbmVyKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwudG9CYWNrKGxheWVyLl9jb250YWluZXIpO1xuXHR9XG59O1xuIiwiaW1wb3J0IHtSZW5kZXJlcn0gZnJvbSAnLi9SZW5kZXJlcic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0IHtzdGFtcH0gZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7c3ZnQ3JlYXRlLCBwb2ludHNUb1BhdGh9IGZyb20gJy4vU1ZHLlV0aWwnO1xuZXhwb3J0IHtwb2ludHNUb1BhdGh9O1xuaW1wb3J0IHt2bWxNaXhpbiwgdm1sQ3JlYXRlfSBmcm9tICcuL1NWRy5WTUwnO1xuXG5leHBvcnQgdmFyIGNyZWF0ZSA9IEJyb3dzZXIudm1sID8gdm1sQ3JlYXRlIDogc3ZnQ3JlYXRlO1xuXG4vKlxuICogQGNsYXNzIFNWR1xuICogQGluaGVyaXRzIFJlbmRlcmVyXG4gKiBAYWthIEwuU1ZHXG4gKlxuICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW1NWR10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHKS5cbiAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gKlxuICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHBzOi8vY2FuaXVzZS5jb20vc3ZnKSwgU1ZHIGlzIG5vdFxuICogYXZhaWxhYmxlIGluIGFsbCB3ZWIgYnJvd3NlcnMsIG5vdGFibHkgQW5kcm9pZCAyLnggYW5kIDMueC5cbiAqXG4gKiBBbHRob3VnaCBTVkcgaXMgbm90IGF2YWlsYWJsZSBvbiBJRTcgYW5kIElFOCwgdGhlc2UgYnJvd3NlcnMgc3VwcG9ydFxuICogW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSlcbiAqIChhIG5vdyBkZXByZWNhdGVkIHRlY2hub2xvZ3kpLCBhbmQgdGhlIFNWRyByZW5kZXJlciB3aWxsIGZhbGwgYmFjayB0byBWTUwgaW5cbiAqIHRoaXMgY2FzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIFVzZSBTVkcgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICogXHRyZW5kZXJlcjogTC5zdmcoKVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBVc2UgYSBTVkcgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAqIHZhciBteVJlbmRlcmVyID0gTC5zdmcoeyBwYWRkaW5nOiAwLjUgfSk7XG4gKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgU1ZHID0gUmVuZGVyZXIuZXh0ZW5kKHtcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSgnc3ZnJyk7XG5cblx0XHQvLyBtYWtlcyBpdCBwb3NzaWJsZSB0byBjbGljayB0aHJvdWdoIHN2ZyByb290OyB3ZSdsbCByZXNldCBpdCBiYWNrIGluIGluZGl2aWR1YWwgcGF0aHNcblx0XHR0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKCdwb2ludGVyLWV2ZW50cycsICdub25lJyk7XG5cblx0XHR0aGlzLl9yb290R3JvdXAgPSBjcmVhdGUoJ2cnKTtcblx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcm9vdEdyb3VwKTtcblx0fSxcblxuXHRfZGVzdHJveUNvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcjtcblx0XHRkZWxldGUgdGhpcy5fcm9vdEdyb3VwO1xuXHRcdGRlbGV0ZSB0aGlzLl9zdmdTaXplO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykgeyByZXR1cm47IH1cblxuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cblx0XHR2YXIgYiA9IHRoaXMuX2JvdW5kcyxcblx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XG5cblx0XHQvLyBzZXQgc2l6ZSBvZiBzdmctY29udGFpbmVyIGlmIGNoYW5nZWRcblx0XHRpZiAoIXRoaXMuX3N2Z1NpemUgfHwgIXRoaXMuX3N2Z1NpemUuZXF1YWxzKHNpemUpKSB7XG5cdFx0XHR0aGlzLl9zdmdTaXplID0gc2l6ZTtcblx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgc2l6ZS54KTtcblx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHNpemUueSk7XG5cdFx0fVxuXG5cdFx0Ly8gbW92ZW1lbnQ6IHVwZGF0ZSBjb250YWluZXIgdmlld0JveCBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY2hhbmdlIGNvb3JkaW5hdGVzIG9mIGluZGl2aWR1YWwgbGF5ZXJzXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihjb250YWluZXIsIGIubWluKTtcblx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgW2IubWluLngsIGIubWluLnksIHNpemUueCwgc2l6ZS55XS5qb2luKCcgJykpO1xuXG5cdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0fSxcblxuXHQvLyBtZXRob2RzIGJlbG93IGFyZSBjYWxsZWQgYnkgdmVjdG9yIGxheWVycyBpbXBsZW1lbnRhdGlvbnNcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGggPSBjcmVhdGUoJ3BhdGgnKTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgUGF0aFxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQ3VzdG9tIGNsYXNzIG5hbWUgc2V0IG9uIGFuIGVsZW1lbnQuIE9ubHkgZm9yIFNWRyByZW5kZXJlci5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpIHtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MocGF0aCwgbGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpO1xuXHRcdH1cblxuXHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlKSB7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHBhdGgsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXBkYXRlU3R5bGUobGF5ZXIpO1xuXHRcdHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildID0gbGF5ZXI7XG5cdH0sXG5cblx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmICghdGhpcy5fcm9vdEdyb3VwKSB7IHRoaXMuX2luaXRDb250YWluZXIoKTsgfVxuXHRcdHRoaXMuX3Jvb3RHcm91cC5hcHBlbmRDaGlsZChsYXllci5fcGF0aCk7XG5cdFx0bGF5ZXIuYWRkSW50ZXJhY3RpdmVUYXJnZXQobGF5ZXIuX3BhdGgpO1xuXHR9LFxuXG5cdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnJlbW92ZShsYXllci5fcGF0aCk7XG5cdFx0bGF5ZXIucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQobGF5ZXIuX3BhdGgpO1xuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXTtcblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0bGF5ZXIuX3Byb2plY3QoKTtcblx0XHRsYXllci5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoLFxuXHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuXHRcdGlmICghcGF0aCkgeyByZXR1cm47IH1cblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIG9wdGlvbnMuY29sb3IpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1vcGFjaXR5Jywgb3B0aW9ucy5vcGFjaXR5KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBvcHRpb25zLndlaWdodCk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCBvcHRpb25zLmxpbmVDYXApO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsIG9wdGlvbnMubGluZUpvaW4pO1xuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBvcHRpb25zLmRhc2hBcnJheSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoT2Zmc2V0KSB7XG5cdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcsIG9wdGlvbnMuZGFzaE9mZnNldCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICdub25lJyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yKTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCBvcHRpb25zLmZpbGxPcGFjaXR5KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLXJ1bGUnLCBvcHRpb25zLmZpbGxSdWxlIHx8ICdldmVub2RkJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgcG9pbnRzVG9QYXRoKGxheWVyLl9wYXJ0cywgY2xvc2VkKSk7XG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQsXG5cdFx0ICAgIHIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLCAxKSxcblx0XHQgICAgcjIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZKSwgMSkgfHwgcixcblx0XHQgICAgYXJjID0gJ2EnICsgciArICcsJyArIHIyICsgJyAwIDEsMCAnO1xuXG5cdFx0Ly8gZHJhd2luZyBhIGNpcmNsZSB3aXRoIHR3byBoYWxmLWFyY3Ncblx0XHR2YXIgZCA9IGxheWVyLl9lbXB0eSgpID8gJ00wIDAnIDpcblx0XHRcdCdNJyArIChwLnggLSByKSArICcsJyArIHAueSArXG5cdFx0XHRhcmMgKyAociAqIDIpICsgJywwICcgK1xuXHRcdFx0YXJjICsgKC1yICogMikgKyAnLDAgJztcblxuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIGQpO1xuXHR9LFxuXG5cdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcblx0XHRsYXllci5fcGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCBwYXRoKTtcblx0fSxcblxuXHQvLyBTVkcgZG9lcyBub3QgaGF2ZSB0aGUgY29uY2VwdCBvZiB6SW5kZXggc28gd2UgcmVzb3J0IHRvIGNoYW5naW5nIHRoZSBET00gb3JkZXIgb2YgZWxlbWVudHNcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC50b0Zyb250KGxheWVyLl9wYXRoKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwudG9CYWNrKGxheWVyLl9wYXRoKTtcblx0fVxufSk7XG5cbmlmIChCcm93c2VyLnZtbCkge1xuXHRTVkcuaW5jbHVkZSh2bWxNaXhpbik7XG59XG5cbi8vIEBuYW1lc3BhY2UgU1ZHXG4vLyBAZmFjdG9yeSBMLnN2ZyhvcHRpb25zPzogUmVuZGVyZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBTVkcgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBzdmcob3B0aW9ucykge1xuXHRyZXR1cm4gQnJvd3Nlci5zdmcgfHwgQnJvd3Nlci52bWwgPyBuZXcgU1ZHKG9wdGlvbnMpIDogbnVsbDtcbn1cbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi8uLi9tYXAvTWFwJztcbmltcG9ydCB7Y2FudmFzfSBmcm9tICcuL0NhbnZhcyc7XG5pbXBvcnQge3N2Z30gZnJvbSAnLi9TVkcnO1xuXG5NYXAuaW5jbHVkZSh7XG5cdC8vIEBuYW1lc3BhY2UgTWFwOyBAbWV0aG9kIGdldFJlbmRlcmVyKGxheWVyOiBQYXRoKTogUmVuZGVyZXJcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgYFJlbmRlcmVyYCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlbmRlciB0aGUgZ2l2ZW5cblx0Ly8gYFBhdGhgLiBJdCB3aWxsIGVuc3VyZSB0aGF0IHRoZSBgcmVuZGVyZXJgIG9wdGlvbnMgb2YgdGhlIG1hcCBhbmQgcGF0aHNcblx0Ly8gYXJlIHJlc3BlY3RlZCwgYW5kIHRoYXQgdGhlIHJlbmRlcmVycyBkbyBleGlzdCBvbiB0aGUgbWFwLlxuXHRnZXRSZW5kZXJlcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0Ly8gQG5hbWVzcGFjZSBQYXRoOyBAb3B0aW9uIHJlbmRlcmVyOiBSZW5kZXJlclxuXHRcdC8vIFVzZSB0aGlzIHNwZWNpZmljIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgZm9yIHRoaXMgcGF0aC4gVGFrZXNcblx0XHQvLyBwcmVjZWRlbmNlIG92ZXIgdGhlIG1hcCdzIFtkZWZhdWx0IHJlbmRlcmVyXSgjbWFwLXJlbmRlcmVyKS5cblx0XHR2YXIgcmVuZGVyZXIgPSBsYXllci5vcHRpb25zLnJlbmRlcmVyIHx8IHRoaXMuX2dldFBhbmVSZW5kZXJlcihsYXllci5vcHRpb25zLnBhbmUpIHx8IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9yZW5kZXJlcjtcblxuXHRcdGlmICghcmVuZGVyZXIpIHtcblx0XHRcdHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXIgPSB0aGlzLl9jcmVhdGVSZW5kZXJlcigpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5oYXNMYXllcihyZW5kZXJlcikpIHtcblx0XHRcdHRoaXMuYWRkTGF5ZXIocmVuZGVyZXIpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVuZGVyZXI7XG5cdH0sXG5cblx0X2dldFBhbmVSZW5kZXJlcjogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAobmFtZSA9PT0gJ292ZXJsYXlQYW5lJyB8fCBuYW1lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLl9wYW5lUmVuZGVyZXJzW25hbWVdO1xuXHRcdGlmIChyZW5kZXJlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZW5kZXJlciA9IHRoaXMuX2NyZWF0ZVJlbmRlcmVyKHtwYW5lOiBuYW1lfSk7XG5cdFx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzW25hbWVdID0gcmVuZGVyZXI7XG5cdFx0fVxuXHRcdHJldHVybiByZW5kZXJlcjtcblx0fSxcblxuXHRfY3JlYXRlUmVuZGVyZXI6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXA7IEBvcHRpb24gcHJlZmVyQ2FudmFzOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBXaGV0aGVyIGBQYXRoYHMgc2hvdWxkIGJlIHJlbmRlcmVkIG9uIGEgYENhbnZhc2AgcmVuZGVyZXIuXG5cdFx0Ly8gQnkgZGVmYXVsdCwgYWxsIGBQYXRoYHMgYXJlIHJlbmRlcmVkIGluIGEgYFNWR2AgcmVuZGVyZXIuXG5cdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMucHJlZmVyQ2FudmFzICYmIGNhbnZhcyhvcHRpb25zKSkgfHwgc3ZnKG9wdGlvbnMpO1xuXHR9XG59KTtcbiIsImltcG9ydCB7UG9seWdvbn0gZnJvbSAnLi9Qb2x5Z29uJztcbmltcG9ydCB7dG9MYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuXG4vKlxuICogTC5SZWN0YW5nbGUgZXh0ZW5kcyBQb2x5Z29uIGFuZCBjcmVhdGVzIGEgcmVjdGFuZ2xlIHdoZW4gcGFzc2VkIGEgTGF0TG5nQm91bmRzIG9iamVjdC5cbiAqL1xuXG4vKlxuICogQGNsYXNzIFJlY3RhbmdsZVxuICogQGFrYSBMLlJlY3RhbmdsZVxuICogQGluaGVyaXRzIFBvbHlnb25cbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHJlY3RhbmdsZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUG9seWdvbmAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gZGVmaW5lIHJlY3RhbmdsZSBnZW9ncmFwaGljYWwgYm91bmRzXG4gKiB2YXIgYm91bmRzID0gW1s1NC41NTkzMjIsIC01Ljc2NzgyMl0sIFs1Ni4xMjEwNjA0LCAtMy4wMjEyNDBdXTtcbiAqXG4gKiAvLyBjcmVhdGUgYW4gb3JhbmdlIHJlY3RhbmdsZVxuICogTC5yZWN0YW5nbGUoYm91bmRzLCB7Y29sb3I6IFwiI2ZmNzgwMFwiLCB3ZWlnaHQ6IDF9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcmVjdGFuZ2xlIGJvdW5kc1xuICogbWFwLmZpdEJvdW5kcyhib3VuZHMpO1xuICogYGBgXG4gKlxuICovXG5cblxuZXhwb3J0IHZhciBSZWN0YW5nbGUgPSBQb2x5Z29uLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMsIG9wdGlvbnMpIHtcblx0XHRQb2x5Z29uLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgdGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcyksIG9wdGlvbnMpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0Qm91bmRzKGxhdExuZ0JvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xuXHQvLyBSZWRyYXdzIHRoZSByZWN0YW5nbGUgd2l0aCB0aGUgcGFzc2VkIGJvdW5kcy5cblx0c2V0Qm91bmRzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0TGF0TG5ncyh0aGlzLl9ib3VuZHNUb0xhdExuZ3MobGF0TG5nQm91bmRzKSk7XG5cdH0sXG5cblx0X2JvdW5kc1RvTGF0TG5nczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcykge1xuXHRcdGxhdExuZ0JvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGxhdExuZ0JvdW5kcyk7XG5cdFx0cmV0dXJuIFtcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXRTb3V0aFdlc3QoKSxcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXROb3J0aFdlc3QoKSxcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXROb3J0aEVhc3QoKSxcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXRTb3V0aEVhc3QoKVxuXHRcdF07XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwucmVjdGFuZ2xlKGxhdExuZ0JvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbmV4cG9ydCBmdW5jdGlvbiByZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgUmVjdGFuZ2xlKGxhdExuZ0JvdW5kcywgb3B0aW9ucyk7XG59XG4iLCJleHBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcbmV4cG9ydCB7Q2FudmFzLCBjYW52YXN9IGZyb20gJy4vQ2FudmFzJztcbmltcG9ydCB7U1ZHLCBjcmVhdGUsIHBvaW50c1RvUGF0aCwgc3ZnfSBmcm9tICcuL1NWRyc7XG5TVkcuY3JlYXRlID0gY3JlYXRlO1xuU1ZHLnBvaW50c1RvUGF0aCA9IHBvaW50c1RvUGF0aDtcbmV4cG9ydCB7U1ZHLCBzdmd9O1xuaW1wb3J0ICcuL1JlbmRlcmVyLmdldFJlbmRlcmVyJztcdC8vIFRoaXMgaXMgYSBiaXQgb2YgYSBoYWNrLCBidXQgbmVlZGVkIGJlY2F1c2UgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG5cbmV4cG9ydCB7UGF0aH0gZnJvbSAnLi9QYXRoJztcbmV4cG9ydCB7Q2lyY2xlTWFya2VyLCBjaXJjbGVNYXJrZXJ9IGZyb20gJy4vQ2lyY2xlTWFya2VyJztcbmV4cG9ydCB7Q2lyY2xlLCBjaXJjbGV9IGZyb20gJy4vQ2lyY2xlJztcbmV4cG9ydCB7UG9seWxpbmUsIHBvbHlsaW5lfSBmcm9tICcuL1BvbHlsaW5lJztcbmV4cG9ydCB7UG9seWdvbiwgcG9seWdvbn0gZnJvbSAnLi9Qb2x5Z29uJztcbmV4cG9ydCB7UmVjdGFuZ2xlLCByZWN0YW5nbGV9IGZyb20gJy4vUmVjdGFuZ2xlJztcbiIsImV4cG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xuZXhwb3J0IHtMYXllckdyb3VwLCBsYXllckdyb3VwfSBmcm9tICcuL0xheWVyR3JvdXAnO1xuZXhwb3J0IHtGZWF0dXJlR3JvdXAsIGZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xuaW1wb3J0IHtHZW9KU09OLCBnZW9KU09OLCBnZW9Kc29uLCBnZW9tZXRyeVRvTGF5ZXIsIGNvb3Jkc1RvTGF0TG5nLCBjb29yZHNUb0xhdExuZ3MsIGxhdExuZ1RvQ29vcmRzLCBsYXRMbmdzVG9Db29yZHMsIGdldEZlYXR1cmUsIGFzRmVhdHVyZX0gZnJvbSAnLi9HZW9KU09OJztcbkdlb0pTT04uZ2VvbWV0cnlUb0xheWVyID0gZ2VvbWV0cnlUb0xheWVyO1xuR2VvSlNPTi5jb29yZHNUb0xhdExuZyA9IGNvb3Jkc1RvTGF0TG5nO1xuR2VvSlNPTi5jb29yZHNUb0xhdExuZ3MgPSBjb29yZHNUb0xhdExuZ3M7XG5HZW9KU09OLmxhdExuZ1RvQ29vcmRzID0gbGF0TG5nVG9Db29yZHM7XG5HZW9KU09OLmxhdExuZ3NUb0Nvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcztcbkdlb0pTT04uZ2V0RmVhdHVyZSA9IGdldEZlYXR1cmU7XG5HZW9KU09OLmFzRmVhdHVyZSA9IGFzRmVhdHVyZTtcbmV4cG9ydCB7R2VvSlNPTiwgZ2VvSlNPTiwgZ2VvSnNvbn07XG5cbmV4cG9ydCB7SW1hZ2VPdmVybGF5LCBpbWFnZU92ZXJsYXl9IGZyb20gJy4vSW1hZ2VPdmVybGF5JztcbmV4cG9ydCB7VmlkZW9PdmVybGF5LCB2aWRlb092ZXJsYXl9IGZyb20gJy4vVmlkZW9PdmVybGF5JztcbmV4cG9ydCB7U1ZHT3ZlcmxheSwgc3ZnT3ZlcmxheX0gZnJvbSAnLi9TVkdPdmVybGF5JztcblxuZXhwb3J0IHtEaXZPdmVybGF5fSBmcm9tICcuL0Rpdk92ZXJsYXknO1xuZXhwb3J0IHtQb3B1cCwgcG9wdXB9IGZyb20gJy4vUG9wdXAnO1xuZXhwb3J0IHtUb29sdGlwLCB0b29sdGlwfSBmcm9tICcuL1Rvb2x0aXAnO1xuXG5leHBvcnQgKiBmcm9tICcuL21hcmtlci9pbmRleCc7XG5leHBvcnQgKiBmcm9tICcuL3RpbGUvaW5kZXgnO1xuZXhwb3J0ICogZnJvbSAnLi92ZWN0b3IvaW5kZXgnO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuLypcbiAqIEwuSGFuZGxlci5Cb3hab29tIGlzIHVzZWQgdG8gYWRkIHNoaWZ0LWRyYWcgem9vbSBpbnRlcmFjdGlvbiB0byB0aGUgbWFwXG4gKiAoem9vbSB0byBhIHNlbGVjdGVkIGJvdW5kaW5nIGJveCksIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gYm94Wm9vbTogQm9vbGVhbiA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgdG8gYSByZWN0YW5ndWxhciBhcmVhIHNwZWNpZmllZCBieVxuXHQvLyBkcmFnZ2luZyB0aGUgbW91c2Ugd2hpbGUgcHJlc3NpbmcgdGhlIHNoaWZ0IGtleS5cblx0Ym94Wm9vbTogdHJ1ZVxufSk7XG5cbmV4cG9ydCB2YXIgQm94Wm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl9jb250YWluZXIgPSBtYXAuX2NvbnRhaW5lcjtcblx0XHR0aGlzLl9wYW5lID0gbWFwLl9wYW5lcy5vdmVybGF5UGFuZTtcblx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG5cdFx0bWFwLm9uKCd1bmxvYWQnLCB0aGlzLl9kZXN0cm95LCB0aGlzKTtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbW92ZWQ7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9wYW5lKTtcblx0XHRkZWxldGUgdGhpcy5fcGFuZTtcblx0fSxcblxuXHRfcmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuXHR9LFxuXG5cdF9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZXNldFN0YXRlVGltZW91dCAhPT0gMCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0KTtcblx0XHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHR9XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gQ2xlYXIgdGhlIGRlZmVycmVkIHJlc2V0U3RhdGUgaWYgaXQgaGFzbid0IGV4ZWN1dGVkIHlldCwgb3RoZXJ3aXNlIGl0XG5cdFx0Ly8gd2lsbCBpbnRlcnJ1cHQgdGhlIGludGVyYWN0aW9uIGFuZCBvcnBoYW4gYSBib3ggZWxlbWVudCBpbiB0aGUgY29udGFpbmVyLlxuXHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZSgpO1xuXG5cdFx0RG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuXHRcdERvbVV0aWwuZGlzYWJsZUltYWdlRHJhZygpO1xuXG5cdFx0dGhpcy5fc3RhcnRQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCB7XG5cdFx0XHRjb250ZXh0bWVudTogRG9tRXZlbnQuc3RvcCxcblx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG5cdFx0XHRtb3VzZXVwOiB0aGlzLl9vbk1vdXNlVXAsXG5cdFx0XHRrZXlkb3duOiB0aGlzLl9vbktleURvd25cblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXG5cdFx0XHR0aGlzLl9ib3ggPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtem9vbS1ib3gnLCB0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuXG5cdFx0XHR0aGlzLl9tYXAuZmlyZSgnYm94em9vbXN0YXJ0Jyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHR2YXIgYm91bmRzID0gbmV3IEJvdW5kcyh0aGlzLl9wb2ludCwgdGhpcy5fc3RhcnRQb2ludCksXG5cdFx0ICAgIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9ib3gsIGJvdW5kcy5taW4pO1xuXG5cdFx0dGhpcy5fYm94LnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XG5cdFx0dGhpcy5fYm94LnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG5cdH0sXG5cblx0X2ZpbmlzaDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tb3ZlZCkge1xuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fYm94KTtcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcblx0XHR9XG5cblx0XHREb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcblx0XHREb21VdGlsLmVuYWJsZUltYWdlRHJhZygpO1xuXG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCB7XG5cdFx0XHRjb250ZXh0bWVudTogRG9tRXZlbnQuc3RvcCxcblx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG5cdFx0XHRtb3VzZXVwOiB0aGlzLl9vbk1vdXNlVXAsXG5cdFx0XHRrZXlkb3duOiB0aGlzLl9vbktleURvd25cblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2ZpbmlzaCgpO1xuXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkgeyByZXR1cm47IH1cblx0XHQvLyBQb3N0cG9uZSB0byBuZXh0IEpTIHRpY2sgc28gaW50ZXJuYWwgY2xpY2sgZXZlbnQgaGFuZGxpbmdcblx0XHQvLyBzdGlsbCBzZWUgaXQgYXMgXCJtb3ZlZFwiLlxuXHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9yZXNldFN0YXRlLCB0aGlzKSwgMCk7XG5cblx0XHR2YXIgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcyhcblx0XHQgICAgICAgIHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3N0YXJ0UG9pbnQpLFxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQpKTtcblxuXHRcdHRoaXMuX21hcFxuXHRcdFx0LmZpdEJvdW5kcyhib3VuZHMpXG5cdFx0XHQuZmlyZSgnYm94em9vbWVuZCcsIHtib3hab29tQm91bmRzOiBib3VuZHN9KTtcblx0fSxcblxuXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG5cdFx0XHR0aGlzLl9maW5pc2goKTtcblx0XHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG5cdFx0XHR0aGlzLl9yZXNldFN0YXRlKCk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBib3hab29tOiBIYW5kbGVyXG4vLyBCb3ggKHNoaWZ0LWRyYWcgd2l0aCBtb3VzZSkgem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2JveFpvb20nLCBCb3hab29tKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuXG4vKlxuICogTC5IYW5kbGVyLkRvdWJsZUNsaWNrWm9vbSBpcyB1c2VkIHRvIGhhbmRsZSBkb3VibGUtY2xpY2sgem9vbSBvbiB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcblxuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gZG91YmxlQ2xpY2tab29tOiBCb29sZWFufFN0cmluZyA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgaW4gYnkgZG91YmxlIGNsaWNraW5nIG9uIGl0IGFuZFxuXHQvLyB6b29tZWQgb3V0IGJ5IGRvdWJsZSBjbGlja2luZyB3aGlsZSBob2xkaW5nIHNoaWZ0LiBJZiBwYXNzZWRcblx0Ly8gYCdjZW50ZXInYCwgZG91YmxlLWNsaWNrIHpvb20gd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlXG5cdC8vICB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cblx0ZG91YmxlQ2xpY2tab29tOiB0cnVlXG59KTtcblxuZXhwb3J0IHZhciBEb3VibGVDbGlja1pvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9uKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9mZignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcblx0fSxcblxuXHRfb25Eb3VibGVDbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvbGRab29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgZGVsdGEgPSBtYXAub3B0aW9ucy56b29tRGVsdGEsXG5cdFx0ICAgIHpvb20gPSBlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkgPyBvbGRab29tIC0gZGVsdGEgOiBvbGRab29tICsgZGVsdGE7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuZG91YmxlQ2xpY2tab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0bWFwLnNldFpvb20oem9vbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKGUuY29udGFpbmVyUG9pbnQsIHpvb20pO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vL1xuLy8gTWFwIHByb3BlcnRpZXMgaW5jbHVkZSBpbnRlcmFjdGlvbiBoYW5kbGVycyB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sXG4vLyBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoXG4vLyBhcyBkcmFnZ2luZyBvciB0b3VjaCB6b29tIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBGb3IgZXhhbXBsZTpcbi8vXG4vLyBgYGBqc1xuLy8gbWFwLmRvdWJsZUNsaWNrWm9vbS5kaXNhYmxlKCk7XG4vLyBgYGBcbi8vXG4vLyBAcHJvcGVydHkgZG91YmxlQ2xpY2tab29tOiBIYW5kbGVyXG4vLyBEb3VibGUgY2xpY2sgem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RvdWJsZUNsaWNrWm9vbScsIERvdWJsZUNsaWNrWm9vbSk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCB7RHJhZ2dhYmxlfSBmcm9tICcuLi8uLi9kb20vRHJhZ2dhYmxlJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0IHt0b0xhdExuZ0JvdW5kcyBhcyBsYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHt0b0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuLypcbiAqIEwuSGFuZGxlci5NYXBEcmFnIGlzIHVzZWQgdG8gbWFrZSB0aGUgbWFwIGRyYWdnYWJsZSAod2l0aCBwYW5uaW5nIGluZXJ0aWEpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGRyYWdnaW5nOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgaXMgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxuXHRkcmFnZ2luZzogdHJ1ZSxcblxuXHQvLyBAc2VjdGlvbiBQYW5uaW5nIEluZXJ0aWEgT3B0aW9uc1xuXHQvLyBAb3B0aW9uIGluZXJ0aWE6IEJvb2xlYW4gPSAqXG5cdC8vIElmIGVuYWJsZWQsIHBhbm5pbmcgb2YgdGhlIG1hcCB3aWxsIGhhdmUgYW4gaW5lcnRpYSBlZmZlY3Qgd2hlcmVcblx0Ly8gdGhlIG1hcCBidWlsZHMgbW9tZW50dW0gd2hpbGUgZHJhZ2dpbmcgYW5kIGNvbnRpbnVlcyBtb3ZpbmcgaW5cblx0Ly8gdGhlIHNhbWUgZGlyZWN0aW9uIGZvciBzb21lIHRpbWUuIEZlZWxzIGVzcGVjaWFsbHkgbmljZSBvbiB0b3VjaFxuXHQvLyBkZXZpY2VzLiBFbmFibGVkIGJ5IGRlZmF1bHQuXG5cdGluZXJ0aWE6IHRydWUsXG5cblx0Ly8gQG9wdGlvbiBpbmVydGlhRGVjZWxlcmF0aW9uOiBOdW1iZXIgPSAzMDAwXG5cdC8vIFRoZSByYXRlIHdpdGggd2hpY2ggdGhlIGluZXJ0aWFsIG1vdmVtZW50IHNsb3dzIGRvd24sIGluIHBpeGVscy9zZWNvbmTCsi5cblx0aW5lcnRpYURlY2VsZXJhdGlvbjogMzQwMCwgLy8gcHgvc14yXG5cblx0Ly8gQG9wdGlvbiBpbmVydGlhTWF4U3BlZWQ6IE51bWJlciA9IEluZmluaXR5XG5cdC8vIE1heCBzcGVlZCBvZiB0aGUgaW5lcnRpYWwgbW92ZW1lbnQsIGluIHBpeGVscy9zZWNvbmQuXG5cdGluZXJ0aWFNYXhTcGVlZDogSW5maW5pdHksIC8vIHB4L3NcblxuXHQvLyBAb3B0aW9uIGVhc2VMaW5lYXJpdHk6IE51bWJlciA9IDAuMlxuXHRlYXNlTGluZWFyaXR5OiAwLjIsXG5cblx0Ly8gVE9ETyByZWZhY3RvciwgbW92ZSB0byBDUlNcblx0Ly8gQG9wdGlvbiB3b3JsZENvcHlKdW1wOiBCb29sZWFuID0gZmFsc2Vcblx0Ly8gV2l0aCB0aGlzIG9wdGlvbiBlbmFibGVkLCB0aGUgbWFwIHRyYWNrcyB3aGVuIHlvdSBwYW4gdG8gYW5vdGhlciBcImNvcHlcIlxuXHQvLyBvZiB0aGUgd29ybGQgYW5kIHNlYW1sZXNzbHkganVtcHMgdG8gdGhlIG9yaWdpbmFsIG9uZSBzbyB0aGF0IGFsbCBvdmVybGF5c1xuXHQvLyBsaWtlIG1hcmtlcnMgYW5kIHZlY3RvciBsYXllcnMgYXJlIHN0aWxsIHZpc2libGUuXG5cdHdvcmxkQ29weUp1bXA6IGZhbHNlLFxuXG5cdC8vIEBvcHRpb24gbWF4Qm91bmRzVmlzY29zaXR5OiBOdW1iZXIgPSAwLjBcblx0Ly8gSWYgYG1heEJvdW5kc2AgaXMgc2V0LCB0aGlzIG9wdGlvbiB3aWxsIGNvbnRyb2wgaG93IHNvbGlkIHRoZSBib3VuZHNcblx0Ly8gYXJlIHdoZW4gZHJhZ2dpbmcgdGhlIG1hcCBhcm91bmQuIFRoZSBkZWZhdWx0IHZhbHVlIG9mIGAwLjBgIGFsbG93cyB0aGVcblx0Ly8gdXNlciB0byBkcmFnIG91dHNpZGUgdGhlIGJvdW5kcyBhdCBub3JtYWwgc3BlZWQsIGhpZ2hlciB2YWx1ZXMgd2lsbFxuXHQvLyBzbG93IGRvd24gbWFwIGRyYWdnaW5nIG91dHNpZGUgYm91bmRzLCBhbmQgYDEuMGAgbWFrZXMgdGhlIGJvdW5kcyBmdWxseVxuXHQvLyBzb2xpZCwgcHJldmVudGluZyB0aGUgdXNlciBmcm9tIGRyYWdnaW5nIG91dHNpZGUgdGhlIGJvdW5kcy5cblx0bWF4Qm91bmRzVmlzY29zaXR5OiAwLjBcbn0pO1xuXG5leHBvcnQgdmFyIERyYWcgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9kcmFnZ2FibGUpIHtcblx0XHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUobWFwLl9tYXBQYW5lLCBtYXAuX2NvbnRhaW5lcik7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG5cdFx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0XHR9LCB0aGlzKTtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKCdwcmVkcmFnJywgdGhpcy5fb25QcmVEcmFnTGltaXQsIHRoaXMpO1xuXHRcdFx0aWYgKG1hcC5vcHRpb25zLndvcmxkQ29weUp1bXApIHtcblx0XHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKCdwcmVkcmFnJywgdGhpcy5fb25QcmVEcmFnV3JhcCwgdGhpcyk7XG5cdFx0XHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX29uWm9vbUVuZCwgdGhpcyk7XG5cblx0XHRcdFx0bWFwLndoZW5SZWFkeSh0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC1ncmFiIGxlYWZsZXQtdG91Y2gtZHJhZycpO1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5lbmFibGUoKTtcblx0XHR0aGlzLl9wb3NpdGlvbnMgPSBbXTtcblx0XHR0aGlzLl90aW1lcyA9IFtdO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtZ3JhYicpO1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLWRyYWcnKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuZGlzYWJsZSgpO1xuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdG1vdmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3Zpbmc7XG5cdH0sXG5cblx0X29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdG1hcC5fc3RvcCgpO1xuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMgJiYgdGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzVmlzY29zaXR5KSB7XG5cdFx0XHR2YXIgYm91bmRzID0gbGF0TG5nQm91bmRzKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cblx0XHRcdHRoaXMuX29mZnNldExpbWl0ID0gdG9Cb3VuZHMoXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXROb3J0aFdlc3QoKSkubXVsdGlwbHlCeSgtMSksXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXRTb3V0aEVhc3QoKSkubXVsdGlwbHlCeSgtMSlcblx0XHRcdFx0XHQuYWRkKHRoaXMuX21hcC5nZXRTaXplKCkpKTtcblxuXHRcdFx0dGhpcy5fdmlzY29zaXR5ID0gTWF0aC5taW4oMS4wLCBNYXRoLm1heCgwLjAsIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0bWFwXG5cdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuXHRcdFx0dGhpcy5fcG9zaXRpb25zID0gW107XG5cdFx0XHR0aGlzLl90aW1lcyA9IFtdO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5pbmVydGlhKSB7XG5cdFx0XHR2YXIgdGltZSA9IHRoaXMuX2xhc3RUaW1lID0gK25ldyBEYXRlKCksXG5cdFx0XHQgICAgcG9zID0gdGhpcy5fbGFzdFBvcyA9IHRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zIHx8IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zO1xuXG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMucHVzaChwb3MpO1xuXHRcdFx0dGhpcy5fdGltZXMucHVzaCh0aW1lKTtcblxuXHRcdFx0dGhpcy5fcHJ1bmVQb3NpdGlvbnModGltZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbWFwXG5cdFx0ICAgIC5maXJlKCdtb3ZlJywgZSlcblx0XHQgICAgLmZpcmUoJ2RyYWcnLCBlKTtcblx0fSxcblxuXHRfcHJ1bmVQb3NpdGlvbnM6IGZ1bmN0aW9uICh0aW1lKSB7XG5cdFx0d2hpbGUgKHRoaXMuX3Bvc2l0aW9ucy5sZW5ndGggPiAxICYmIHRpbWUgLSB0aGlzLl90aW1lc1swXSA+IDUwKSB7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMuc2hpZnQoKTtcblx0XHRcdHRoaXMuX3RpbWVzLnNoaWZ0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vblpvb21FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHhDZW50ZXIgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxuXHRcdCAgICBweFdvcmxkQ2VudGVyID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChbMCwgMF0pO1xuXG5cdFx0dGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0ID0gcHhXb3JsZENlbnRlci5zdWJ0cmFjdChweENlbnRlcikueDtcblx0XHR0aGlzLl93b3JsZFdpZHRoID0gdGhpcy5fbWFwLmdldFBpeGVsV29ybGRCb3VuZHMoKS5nZXRTaXplKCkueDtcblx0fSxcblxuXHRfdmlzY291c0xpbWl0OiBmdW5jdGlvbiAodmFsdWUsIHRocmVzaG9sZCkge1xuXHRcdHJldHVybiB2YWx1ZSAtICh2YWx1ZSAtIHRocmVzaG9sZCkgKiB0aGlzLl92aXNjb3NpdHk7XG5cdH0sXG5cblx0X29uUHJlRHJhZ0xpbWl0OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl92aXNjb3NpdHkgfHwgIXRoaXMuX29mZnNldExpbWl0KSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnN1YnRyYWN0KHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MpO1xuXG5cdFx0dmFyIGxpbWl0ID0gdGhpcy5fb2Zmc2V0TGltaXQ7XG5cdFx0aWYgKG9mZnNldC54IDwgbGltaXQubWluLngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1pbi54KTsgfVxuXHRcdGlmIChvZmZzZXQueSA8IGxpbWl0Lm1pbi55KSB7IG9mZnNldC55ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC55LCBsaW1pdC5taW4ueSk7IH1cblx0XHRpZiAob2Zmc2V0LnggPiBsaW1pdC5tYXgueCkgeyBvZmZzZXQueCA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueCwgbGltaXQubWF4LngpOyB9XG5cdFx0aWYgKG9mZnNldC55ID4gbGltaXQubWF4LnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1heC55KTsgfVxuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zLmFkZChvZmZzZXQpO1xuXHR9LFxuXG5cdF9vblByZURyYWdXcmFwOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVE9ETyByZWZhY3RvciB0byBiZSBhYmxlIHRvIGFkanVzdCBtYXAgcGFuZSBwb3NpdGlvbiBhZnRlciB6b29tXG5cdFx0dmFyIHdvcmxkV2lkdGggPSB0aGlzLl93b3JsZFdpZHRoLFxuXHRcdCAgICBoYWxmV2lkdGggPSBNYXRoLnJvdW5kKHdvcmxkV2lkdGggLyAyKSxcblx0XHQgICAgZHggPSB0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQsXG5cdFx0ICAgIHggPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54LFxuXHRcdCAgICBuZXdYMSA9ICh4IC0gaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCArIGhhbGZXaWR0aCAtIGR4LFxuXHRcdCAgICBuZXdYMiA9ICh4ICsgaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCAtIGhhbGZXaWR0aCAtIGR4LFxuXHRcdCAgICBuZXdYID0gTWF0aC5hYnMobmV3WDEgKyBkeCkgPCBNYXRoLmFicyhuZXdYMiArIGR4KSA/IG5ld1gxIDogbmV3WDI7XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLmNsb25lKCk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCA9IG5ld1g7XG5cdH0sXG5cblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvcHRpb25zID0gbWFwLm9wdGlvbnMsXG5cblx0XHQgICAgbm9JbmVydGlhID0gIW9wdGlvbnMuaW5lcnRpYSB8fCBlLm5vSW5lcnRpYSB8fCB0aGlzLl90aW1lcy5sZW5ndGggPCAyO1xuXG5cdFx0bWFwLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblxuXHRcdGlmIChub0luZXJ0aWEpIHtcblx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcHJ1bmVQb3NpdGlvbnMoK25ldyBEYXRlKCkpO1xuXG5cdFx0XHR2YXIgZGlyZWN0aW9uID0gdGhpcy5fbGFzdFBvcy5zdWJ0cmFjdCh0aGlzLl9wb3NpdGlvbnNbMF0pLFxuXHRcdFx0ICAgIGR1cmF0aW9uID0gKHRoaXMuX2xhc3RUaW1lIC0gdGhpcy5fdGltZXNbMF0pIC8gMTAwMCxcblx0XHRcdCAgICBlYXNlID0gb3B0aW9ucy5lYXNlTGluZWFyaXR5LFxuXG5cdFx0XHQgICAgc3BlZWRWZWN0b3IgPSBkaXJlY3Rpb24ubXVsdGlwbHlCeShlYXNlIC8gZHVyYXRpb24pLFxuXHRcdFx0ICAgIHNwZWVkID0gc3BlZWRWZWN0b3IuZGlzdGFuY2VUbyhbMCwgMF0pLFxuXG5cdFx0XHQgICAgbGltaXRlZFNwZWVkID0gTWF0aC5taW4ob3B0aW9ucy5pbmVydGlhTWF4U3BlZWQsIHNwZWVkKSxcblx0XHRcdCAgICBsaW1pdGVkU3BlZWRWZWN0b3IgPSBzcGVlZFZlY3Rvci5tdWx0aXBseUJ5KGxpbWl0ZWRTcGVlZCAvIHNwZWVkKSxcblxuXHRcdFx0ICAgIGRlY2VsZXJhdGlvbkR1cmF0aW9uID0gbGltaXRlZFNwZWVkIC8gKG9wdGlvbnMuaW5lcnRpYURlY2VsZXJhdGlvbiAqIGVhc2UpLFxuXHRcdFx0ICAgIG9mZnNldCA9IGxpbWl0ZWRTcGVlZFZlY3Rvci5tdWx0aXBseUJ5KC1kZWNlbGVyYXRpb25EdXJhdGlvbiAvIDIpLnJvdW5kKCk7XG5cblx0XHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XG5cdFx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9mZnNldCA9IG1hcC5fbGltaXRPZmZzZXQob2Zmc2V0LCBtYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG5cdFx0XHRcdFV0aWwucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bWFwLnBhbkJ5KG9mZnNldCwge1xuXHRcdFx0XHRcdFx0ZHVyYXRpb246IGRlY2VsZXJhdGlvbkR1cmF0aW9uLFxuXHRcdFx0XHRcdFx0ZWFzZUxpbmVhcml0eTogZWFzZSxcblx0XHRcdFx0XHRcdG5vTW92ZVN0YXJ0OiB0cnVlLFxuXHRcdFx0XHRcdFx0YW5pbWF0ZTogdHJ1ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGRyYWdnaW5nOiBIYW5kbGVyXG4vLyBNYXAgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RyYWdnaW5nJywgRHJhZyk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCB7b24sIG9mZiwgc3RvcH0gZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCB7dG9Qb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuXG5cbi8qXG4gKiBMLk1hcC5LZXlib2FyZCBpcyBoYW5kbGluZyBrZXlib2FyZCBpbnRlcmFjdGlvbiB3aXRoIHRoZSBtYXAsIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gS2V5Ym9hcmQgTmF2aWdhdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcblx0Ly8gTWFrZXMgdGhlIG1hcCBmb2N1c2FibGUgYW5kIGFsbG93cyB1c2VycyB0byBuYXZpZ2F0ZSB0aGUgbWFwIHdpdGgga2V5Ym9hcmRcblx0Ly8gYXJyb3dzIGFuZCBgK2AvYC1gIGtleXMuXG5cdGtleWJvYXJkOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24ga2V5Ym9hcmRQYW5EZWx0YTogTnVtYmVyID0gODBcblx0Ly8gQW1vdW50IG9mIHBpeGVscyB0byBwYW4gd2hlbiBwcmVzc2luZyBhbiBhcnJvdyBrZXkuXG5cdGtleWJvYXJkUGFuRGVsdGE6IDgwXG59KTtcblxuZXhwb3J0IHZhciBLZXlib2FyZCA9IEhhbmRsZXIuZXh0ZW5kKHtcblxuXHRrZXlDb2Rlczoge1xuXHRcdGxlZnQ6ICAgIFszN10sXG5cdFx0cmlnaHQ6ICAgWzM5XSxcblx0XHRkb3duOiAgICBbNDBdLFxuXHRcdHVwOiAgICAgIFszOF0sXG5cdFx0em9vbUluOiAgWzE4NywgMTA3LCA2MSwgMTcxXSxcblx0XHR6b29tT3V0OiBbMTg5LCAxMDksIDU0LCAxNzNdXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblxuXHRcdHRoaXMuX3NldFBhbkRlbHRhKG1hcC5vcHRpb25zLmtleWJvYXJkUGFuRGVsdGEpO1xuXHRcdHRoaXMuX3NldFpvb21EZWx0YShtYXAub3B0aW9ucy56b29tRGVsdGEpO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX21hcC5fY29udGFpbmVyO1xuXG5cdFx0Ly8gbWFrZSB0aGUgY29udGFpbmVyIGZvY3VzYWJsZSBieSB0YWJiaW5nXG5cdFx0aWYgKGNvbnRhaW5lci50YWJJbmRleCA8PSAwKSB7XG5cdFx0XHRjb250YWluZXIudGFiSW5kZXggPSAnMCc7XG5cdFx0fVxuXG5cdFx0b24oY29udGFpbmVyLCB7XG5cdFx0XHRmb2N1czogdGhpcy5fb25Gb2N1cyxcblx0XHRcdGJsdXI6IHRoaXMuX29uQmx1cixcblx0XHRcdG1vdXNlZG93bjogdGhpcy5fb25Nb3VzZURvd25cblx0XHR9LCB0aGlzKTtcblxuXHRcdHRoaXMuX21hcC5vbih7XG5cdFx0XHRmb2N1czogdGhpcy5fYWRkSG9va3MsXG5cdFx0XHRibHVyOiB0aGlzLl9yZW1vdmVIb29rc1xuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVtb3ZlSG9va3MoKTtcblxuXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwge1xuXHRcdFx0Zm9jdXM6IHRoaXMuX29uRm9jdXMsXG5cdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG5cdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXAub2ZmKHtcblx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcblx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2ZvY3VzZWQpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgYm9keSA9IGRvY3VtZW50LmJvZHksXG5cdFx0ICAgIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdCAgICB0b3AgPSBib2R5LnNjcm9sbFRvcCB8fCBkb2NFbC5zY3JvbGxUb3AsXG5cdFx0ICAgIGxlZnQgPSBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWwuc2Nyb2xsTGVmdDtcblxuXHRcdHRoaXMuX21hcC5fY29udGFpbmVyLmZvY3VzKCk7XG5cblx0XHR3aW5kb3cuc2Nyb2xsVG8obGVmdCwgdG9wKTtcblx0fSxcblxuXHRfb25Gb2N1czogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2ZvY3VzZWQgPSB0cnVlO1xuXHRcdHRoaXMuX21hcC5maXJlKCdmb2N1cycpO1xuXHR9LFxuXG5cdF9vbkJsdXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9mb2N1c2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2JsdXInKTtcblx0fSxcblxuXHRfc2V0UGFuRGVsdGE6IGZ1bmN0aW9uIChwYW5EZWx0YSkge1xuXHRcdHZhciBrZXlzID0gdGhpcy5fcGFuS2V5cyA9IHt9LFxuXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG5cdFx0ICAgIGksIGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmxlZnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMubGVmdFtpXV0gPSBbLTEgKiBwYW5EZWx0YSwgMF07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnJpZ2h0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnJpZ2h0W2ldXSA9IFtwYW5EZWx0YSwgMF07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmRvd24ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuZG93bltpXV0gPSBbMCwgcGFuRGVsdGFdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy51cC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy51cFtpXV0gPSBbMCwgLTEgKiBwYW5EZWx0YV07XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRab29tRGVsdGE6IGZ1bmN0aW9uICh6b29tRGVsdGEpIHtcblx0XHR2YXIga2V5cyA9IHRoaXMuX3pvb21LZXlzID0ge30sXG5cdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2Rlcyxcblx0XHQgICAgaSwgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbUluLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnpvb21JbltpXV0gPSB6b29tRGVsdGE7XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21PdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuem9vbU91dFtpXV0gPSAtem9vbURlbHRhO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRvbihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9yZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdG9mZihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIga2V5ID0gZS5rZXlDb2RlLFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9mZnNldDtcblxuXHRcdGlmIChrZXkgaW4gdGhpcy5fcGFuS2V5cykge1xuXHRcdFx0aWYgKCFtYXAuX3BhbkFuaW0gfHwgIW1hcC5fcGFuQW5pbS5faW5Qcm9ncmVzcykge1xuXHRcdFx0XHRvZmZzZXQgPSB0aGlzLl9wYW5LZXlzW2tleV07XG5cdFx0XHRcdGlmIChlLnNoaWZ0S2V5KSB7XG5cdFx0XHRcdFx0b2Zmc2V0ID0gdG9Qb2ludChvZmZzZXQpLm11bHRpcGx5QnkoMyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobWFwLm9wdGlvbnMubWF4Qm91bmRzKSB7XG5cdFx0XHRcdFx0b2Zmc2V0ID0gbWFwLl9saW1pdE9mZnNldCh0b1BvaW50KG9mZnNldCksIG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobWFwLm9wdGlvbnMud29ybGRDb3B5SnVtcCkge1xuXHRcdFx0XHRcdHZhciBuZXdMYXRMbmcgPSBtYXAud3JhcExhdExuZyhtYXAudW5wcm9qZWN0KG1hcC5wcm9qZWN0KG1hcC5nZXRDZW50ZXIoKSkuYWRkKG9mZnNldCkpKTtcblx0XHRcdFx0XHRtYXAucGFuVG8obmV3TGF0TG5nKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtYXAucGFuQnkob2Zmc2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoa2V5IGluIHRoaXMuX3pvb21LZXlzKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbShtYXAuZ2V0Wm9vbSgpICsgKGUuc2hpZnRLZXkgPyAzIDogMSkgKiB0aGlzLl96b29tS2V5c1trZXldKTtcblxuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAyNyAmJiBtYXAuX3BvcHVwICYmIG1hcC5fcG9wdXAub3B0aW9ucy5jbG9zZU9uRXNjYXBlS2V5KSB7XG5cdFx0XHRtYXAuY2xvc2VQb3B1cCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRzdG9wKGUpO1xuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkga2V5Ym9hcmQ6IEhhbmRsZXJcbi8vIEtleWJvYXJkIG5hdmlnYXRpb24gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdrZXlib2FyZCcsIEtleWJvYXJkKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEwuSGFuZGxlci5TY3JvbGxXaGVlbFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBlbmFibGUgbW91c2Ugc2Nyb2xsIHdoZWVsIHpvb20gb24gdGhlIG1hcC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIE1vdXNlIHdoZWVsIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiBzY3JvbGxXaGVlbFpvb206IEJvb2xlYW58U3RyaW5nID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB1c2luZyB0aGUgbW91c2Ugd2hlZWwuIElmIHBhc3NlZCBgJ2NlbnRlcidgLFxuXHQvLyBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBtb3VzZSB3YXMuXG5cdHNjcm9sbFdoZWVsWm9vbTogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIHdoZWVsRGVib3VuY2VUaW1lOiBOdW1iZXIgPSA0MFxuXHQvLyBMaW1pdHMgdGhlIHJhdGUgYXQgd2hpY2ggYSB3aGVlbCBjYW4gZmlyZSAoaW4gbWlsbGlzZWNvbmRzKS4gQnkgZGVmYXVsdFxuXHQvLyB1c2VyIGNhbid0IHpvb20gdmlhIHdoZWVsIG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciA0MCBtcy5cblx0d2hlZWxEZWJvdW5jZVRpbWU6IDQwLFxuXG5cdC8vIEBvcHRpb24gd2hlZWxQeFBlclpvb21MZXZlbDogTnVtYmVyID0gNjBcblx0Ly8gSG93IG1hbnkgc2Nyb2xsIHBpeGVscyAoYXMgcmVwb3J0ZWQgYnkgW0wuRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YV0oI2RvbWV2ZW50LWdldHdoZWVsZGVsdGEpKVxuXHQvLyBtZWFuIGEgY2hhbmdlIG9mIG9uZSBmdWxsIHpvb20gbGV2ZWwuIFNtYWxsZXIgdmFsdWVzIHdpbGwgbWFrZSB3aGVlbC16b29taW5nXG5cdC8vIGZhc3RlciAoYW5kIHZpY2UgdmVyc2EpLlxuXHR3aGVlbFB4UGVyWm9vbUxldmVsOiA2MFxufSk7XG5cbmV4cG9ydCB2YXIgU2Nyb2xsV2hlZWxab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAnd2hlZWwnLCB0aGlzLl9vbldoZWVsU2Nyb2xsLCB0aGlzKTtcblxuXHRcdHRoaXMuX2RlbHRhID0gMDtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3doZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCwgdGhpcyk7XG5cdH0sXG5cblx0X29uV2hlZWxTY3JvbGw6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGRlbHRhID0gRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YShlKTtcblxuXHRcdHZhciBkZWJvdW5jZSA9IHRoaXMuX21hcC5vcHRpb25zLndoZWVsRGVib3VuY2VUaW1lO1xuXG5cdFx0dGhpcy5fZGVsdGEgKz0gZGVsdGE7XG5cdFx0dGhpcy5fbGFzdE1vdXNlUG9zID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0aWYgKCF0aGlzLl9zdGFydFRpbWUpIHtcblx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXHRcdH1cblxuXHRcdHZhciBsZWZ0ID0gTWF0aC5tYXgoZGVib3VuY2UgLSAoK25ldyBEYXRlKCkgLSB0aGlzLl9zdGFydFRpbWUpLCAwKTtcblxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG5cdFx0dGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9wZXJmb3JtWm9vbSwgdGhpcyksIGxlZnQpO1xuXG5cdFx0RG9tRXZlbnQuc3RvcChlKTtcblx0fSxcblxuXHRfcGVyZm9ybVpvb206IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB6b29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgc25hcCA9IHRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwIHx8IDA7XG5cblx0XHRtYXAuX3N0b3AoKTsgLy8gc3RvcCBwYW5uaW5nIGFuZCBmbHkgYW5pbWF0aW9ucyBpZiBhbnlcblxuXHRcdC8vIG1hcCB0aGUgZGVsdGEgd2l0aCBhIHNpZ21vaWQgZnVuY3Rpb24gdG8gLTQuLjQgcmFuZ2UgbGVhbmluZyBvbiAtMS4uMVxuXHRcdHZhciBkMiA9IHRoaXMuX2RlbHRhIC8gKHRoaXMuX21hcC5vcHRpb25zLndoZWVsUHhQZXJab29tTGV2ZWwgKiA0KSxcblx0XHQgICAgZDMgPSA0ICogTWF0aC5sb2coMiAvICgxICsgTWF0aC5leHAoLU1hdGguYWJzKGQyKSkpKSAvIE1hdGguTE4yLFxuXHRcdCAgICBkNCA9IHNuYXAgPyBNYXRoLmNlaWwoZDMgLyBzbmFwKSAqIHNuYXAgOiBkMyxcblx0XHQgICAgZGVsdGEgPSBtYXAuX2xpbWl0Wm9vbSh6b29tICsgKHRoaXMuX2RlbHRhID4gMCA/IGQ0IDogLWQ0KSkgLSB6b29tO1xuXG5cdFx0dGhpcy5fZGVsdGEgPSAwO1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG5cblx0XHRpZiAoIWRlbHRhKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKG1hcC5vcHRpb25zLnNjcm9sbFdoZWVsWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdG1hcC5zZXRab29tKHpvb20gKyBkZWx0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKHRoaXMuX2xhc3RNb3VzZVBvcywgem9vbSArIGRlbHRhKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHNjcm9sbFdoZWVsWm9vbTogSGFuZGxlclxuLy8gU2Nyb2xsIHdoZWVsIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdzY3JvbGxXaGVlbFpvb20nLCBTY3JvbGxXaGVlbFpvb20pO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcblxuLypcbiAqIEwuTWFwLlRhcEhvbGQgaXMgdXNlZCB0byBzaW11bGF0ZSBgY29udGV4dG1lbnVgIGV2ZW50IG9uIGxvbmcgaG9sZCxcbiAqIHdoaWNoIG90aGVyd2lzZSBpcyBub3QgZmlyZWQgYnkgbW9iaWxlIFNhZmFyaS5cbiAqL1xuXG52YXIgdGFwSG9sZERlbGF5ID0gNjAwO1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiB0YXBIb2xkOiBCb29sZWFuXG5cdC8vIEVuYWJsZXMgc2ltdWxhdGlvbiBvZiBgY29udGV4dG1lbnVgIGV2ZW50LCBkZWZhdWx0IGlzIGB0cnVlYCBmb3IgbW9iaWxlIFNhZmFyaS5cblx0dGFwSG9sZDogQnJvd3Nlci50b3VjaE5hdGl2ZSAmJiBCcm93c2VyLnNhZmFyaSAmJiBCcm93c2VyLm1vYmlsZSxcblxuXHQvLyBAb3B0aW9uIHRhcFRvbGVyYW5jZTogTnVtYmVyID0gMTVcblx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgaGlzIGZpbmdlciBkdXJpbmcgdG91Y2hcblx0Ly8gZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYSB2YWxpZCB0YXAuXG5cdHRhcFRvbGVyYW5jZTogMTVcbn0pO1xuXG5leHBvcnQgdmFyIFRhcEhvbGQgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblx0XHRpZiAoZS50b3VjaGVzLmxlbmd0aCAhPT0gMSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXTtcblx0XHR0aGlzLl9zdGFydFBvcyA9IHRoaXMuX25ld1BvcyA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblxuXHRcdHRoaXMuX2hvbGRUaW1lb3V0ID0gc2V0VGltZW91dChVdGlsLmJpbmQoZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fY2FuY2VsKCk7XG5cdFx0XHRpZiAoIXRoaXMuX2lzVGFwVmFsaWQoKSkgeyByZXR1cm47IH1cblxuXHRcdFx0Ly8gcHJldmVudCBzaW11bGF0ZWQgbW91c2UgZXZlbnRzIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby90b3VjaC1ldmVudHMvI21vdXNlLWV2ZW50c1xuXHRcdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsICd0b3VjaGVuZCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcblx0XHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCB0aGlzLl9jYW5jZWxDbGlja1ByZXZlbnQpO1xuXHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnY29udGV4dG1lbnUnLCBmaXJzdCk7XG5cdFx0fSwgdGhpcyksIHRhcEhvbGREZWxheSk7XG5cblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsIGNvbnRleHRtZW51JywgdGhpcy5fY2FuY2VsLCB0aGlzKTtcblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgdGhpcyk7XG5cdH0sXG5cblx0X2NhbmNlbENsaWNrUHJldmVudDogZnVuY3Rpb24gY2FuY2VsQ2xpY2tQcmV2ZW50KCkge1xuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgY2FuY2VsQ2xpY2tQcmV2ZW50KTtcblx0fSxcblxuXHRfY2FuY2VsOiBmdW5jdGlvbiAoKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCBjb250ZXh0bWVudScsIHRoaXMuX2NhbmNlbCwgdGhpcyk7XG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXTtcblx0XHR0aGlzLl9uZXdQb3MgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cdH0sXG5cblx0X2lzVGFwVmFsaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpIDw9IHRoaXMuX21hcC5vcHRpb25zLnRhcFRvbGVyYW5jZTtcblx0fSxcblxuXHRfc2ltdWxhdGVFdmVudDogZnVuY3Rpb24gKHR5cGUsIGUpIHtcblx0XHR2YXIgc2ltdWxhdGVkRXZlbnQgPSBuZXcgTW91c2VFdmVudCh0eXBlLCB7XG5cdFx0XHRidWJibGVzOiB0cnVlLFxuXHRcdFx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0XHRcdHZpZXc6IHdpbmRvdyxcblx0XHRcdC8vIGRldGFpbDogMSxcblx0XHRcdHNjcmVlblg6IGUuc2NyZWVuWCxcblx0XHRcdHNjcmVlblk6IGUuc2NyZWVuWSxcblx0XHRcdGNsaWVudFg6IGUuY2xpZW50WCxcblx0XHRcdGNsaWVudFk6IGUuY2xpZW50WSxcblx0XHRcdC8vIGJ1dHRvbjogMixcblx0XHRcdC8vIGJ1dHRvbnM6IDJcblx0XHR9KTtcblxuXHRcdHNpbXVsYXRlZEV2ZW50Ll9zaW11bGF0ZWQgPSB0cnVlO1xuXG5cdFx0ZS50YXJnZXQuZGlzcGF0Y2hFdmVudChzaW11bGF0ZWRFdmVudCk7XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHRhcEhvbGQ6IEhhbmRsZXJcbi8vIExvbmcgdGFwIGhhbmRsZXIgdG8gc2ltdWxhdGUgYGNvbnRleHRtZW51YCBldmVudCAodXNlZnVsIGluIG1vYmlsZSBTYWZhcmkpLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RhcEhvbGQnLCBUYXBIb2xkKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcblxuLypcbiAqIEwuSGFuZGxlci5Ub3VjaFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBhZGQgcGluY2ggem9vbSBvbiBzdXBwb3J0ZWQgbW9iaWxlIGJyb3dzZXJzLlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQHNlY3Rpb24gVG91Y2ggaW50ZXJhY3Rpb24gb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHRvdWNoWm9vbTogQm9vbGVhbnxTdHJpbmcgPSAqXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGJ5IHRvdWNoLWRyYWdnaW5nIHdpdGggdHdvIGZpbmdlcnMuIElmXG5cdC8vIHBhc3NlZCBgJ2NlbnRlcidgLCBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mXG5cdC8vIHdoZXJlIHRoZSB0b3VjaCBldmVudHMgKGZpbmdlcnMpIHdlcmUuIEVuYWJsZWQgZm9yIHRvdWNoLWNhcGFibGUgd2ViXG5cdC8vIGJyb3dzZXJzLlxuXHR0b3VjaFpvb206IEJyb3dzZXIudG91Y2gsXG5cblx0Ly8gQG9wdGlvbiBib3VuY2VBdFpvb21MaW1pdHM6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFNldCBpdCB0byBmYWxzZSBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgbWFwIHRvIHpvb20gYmV5b25kIG1pbi9tYXggem9vbVxuXHQvLyBhbmQgdGhlbiBib3VuY2UgYmFjayB3aGVuIHBpbmNoLXpvb21pbmcuXG5cdGJvdW5jZUF0Wm9vbUxpbWl0czogdHJ1ZVxufSk7XG5cbmV4cG9ydCB2YXIgVG91Y2hab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLXpvb20nKTtcblx0XHREb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuXHR9LFxuXG5cdF9vblRvdWNoU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8IG1hcC5fYW5pbWF0aW5nWm9vbSB8fCB0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG5cdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSk7XG5cblx0XHR0aGlzLl9jZW50ZXJQb2ludCA9IG1hcC5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xuXHRcdHRoaXMuX3N0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fY2VudGVyUG9pbnQpO1xuXHRcdGlmIChtYXAub3B0aW9ucy50b3VjaFpvb20gIT09ICdjZW50ZXInKSB7XG5cdFx0XHR0aGlzLl9waW5jaFN0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcocDEuYWRkKHAyKS5fZGl2aWRlQnkoMikpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3N0YXJ0RGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuXHRcdHRoaXMuX3N0YXJ0Wm9vbSA9IG1hcC5nZXRab29tKCk7XG5cblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3pvb21pbmcgPSB0cnVlO1xuXG5cdFx0bWFwLl9zdG9wKCk7XG5cblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKTtcblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cblx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0fSxcblxuXHRfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCAhdGhpcy5fem9vbWluZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG5cdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSksXG5cdFx0ICAgIHNjYWxlID0gcDEuZGlzdGFuY2VUbyhwMikgLyB0aGlzLl9zdGFydERpc3Q7XG5cblx0XHR0aGlzLl96b29tID0gbWFwLmdldFNjYWxlWm9vbShzY2FsZSwgdGhpcy5fc3RhcnRab29tKTtcblxuXHRcdGlmICghbWFwLm9wdGlvbnMuYm91bmNlQXRab29tTGltaXRzICYmIChcblx0XHRcdCh0aGlzLl96b29tIDwgbWFwLmdldE1pblpvb20oKSAmJiBzY2FsZSA8IDEpIHx8XG5cdFx0XHQodGhpcy5fem9vbSA+IG1hcC5nZXRNYXhab29tKCkgJiYgc2NhbGUgPiAxKSkpIHtcblx0XHRcdHRoaXMuX3pvb20gPSBtYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKTtcblx0XHR9XG5cblx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fc3RhcnRMYXRMbmc7XG5cdFx0XHRpZiAoc2NhbGUgPT09IDEpIHsgcmV0dXJuOyB9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEdldCBkZWx0YSBmcm9tIHBpbmNoIHRvIGNlbnRlciwgc28gY2VudGVyTGF0TG5nIGlzIGRlbHRhIGFwcGxpZWQgdG8gaW5pdGlhbCBwaW5jaExhdExuZ1xuXHRcdFx0dmFyIGRlbHRhID0gcDEuX2FkZChwMikuX2RpdmlkZUJ5KDIpLl9zdWJ0cmFjdCh0aGlzLl9jZW50ZXJQb2ludCk7XG5cdFx0XHRpZiAoc2NhbGUgPT09IDEgJiYgZGVsdGEueCA9PT0gMCAmJiBkZWx0YS55ID09PSAwKSB7IHJldHVybjsgfVxuXHRcdFx0dGhpcy5fY2VudGVyID0gbWFwLnVucHJvamVjdChtYXAucHJvamVjdCh0aGlzLl9waW5jaFN0YXJ0TGF0TG5nLCB0aGlzLl96b29tKS5zdWJ0cmFjdChkZWx0YSksIHRoaXMuX3pvb20pO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcblx0XHRcdG1hcC5fbW92ZVN0YXJ0KHRydWUsIGZhbHNlKTtcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cblx0XHR2YXIgbW92ZUZuID0gVXRpbC5iaW5kKG1hcC5fbW92ZSwgbWFwLCB0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20sIHtwaW5jaDogdHJ1ZSwgcm91bmQ6IGZhbHNlfSwgdW5kZWZpbmVkKTtcblx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZShtb3ZlRm4sIHRoaXMsIHRydWUpO1xuXG5cdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdH0sXG5cblx0X29uVG91Y2hFbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21vdmVkIHx8ICF0aGlzLl96b29taW5nKSB7XG5cdFx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcblxuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKTtcblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIHRoaXMuX29uVG91Y2hFbmQsIHRoaXMpO1xuXG5cdFx0Ly8gUGluY2ggdXBkYXRlcyBHcmlkTGF5ZXJzJyBsZXZlbHMgb25seSB3aGVuIHpvb21TbmFwIGlzIG9mZiwgc28gem9vbVNuYXAgYmVjb21lcyBub1VwZGF0ZS5cblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuem9vbUFuaW1hdGlvbikge1xuXHRcdFx0dGhpcy5fbWFwLl9hbmltYXRlWm9vbSh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pLCB0cnVlLCB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX21hcC5fcmVzZXRWaWV3KHRoaXMuX2NlbnRlciwgdGhpcy5fbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSkpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgdG91Y2hab29tOiBIYW5kbGVyXG4vLyBUb3VjaCB6b29tIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndG91Y2hab29tJywgVG91Y2hab29tKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuL01hcCc7XG5pbXBvcnQge0JveFpvb219IGZyb20gJy4vaGFuZGxlci9NYXAuQm94Wm9vbSc7XG5NYXAuQm94Wm9vbSA9IEJveFpvb207XG5pbXBvcnQge0RvdWJsZUNsaWNrWm9vbX0gZnJvbSAnLi9oYW5kbGVyL01hcC5Eb3VibGVDbGlja1pvb20nO1xuTWFwLkRvdWJsZUNsaWNrWm9vbSA9IERvdWJsZUNsaWNrWm9vbTtcbmltcG9ydCB7RHJhZ30gZnJvbSAnLi9oYW5kbGVyL01hcC5EcmFnJztcbk1hcC5EcmFnID0gRHJhZztcbmltcG9ydCB7S2V5Ym9hcmR9IGZyb20gJy4vaGFuZGxlci9NYXAuS2V5Ym9hcmQnO1xuTWFwLktleWJvYXJkID0gS2V5Ym9hcmQ7XG5pbXBvcnQge1Njcm9sbFdoZWVsWm9vbX0gZnJvbSAnLi9oYW5kbGVyL01hcC5TY3JvbGxXaGVlbFpvb20nO1xuTWFwLlNjcm9sbFdoZWVsWm9vbSA9IFNjcm9sbFdoZWVsWm9vbTtcbmltcG9ydCB7VGFwSG9sZH0gZnJvbSAnLi9oYW5kbGVyL01hcC5UYXBIb2xkJztcbk1hcC5UYXBIb2xkID0gVGFwSG9sZDtcbmltcG9ydCB7VG91Y2hab29tfSBmcm9tICcuL2hhbmRsZXIvTWFwLlRvdWNoWm9vbSc7XG5NYXAuVG91Y2hab29tID0gVG91Y2hab29tO1xuXG5leHBvcnQge01hcCwgY3JlYXRlTWFwIGFzIG1hcH0gZnJvbSAnLi9NYXAnO1xuIl0sIm5hbWVzIjpbImV4dGVuZCIsImRlc3QiLCJpIiwiaiIsImxlbiIsInNyYyIsImFyZ3VtZW50cyIsImxlbmd0aCIsImNyZWF0ZSQyIiwiT2JqZWN0IiwiY3JlYXRlIiwiRiIsInByb3RvIiwicHJvdG90eXBlIiwiYmluZCIsImZuIiwib2JqIiwic2xpY2UiLCJBcnJheSIsImFwcGx5IiwiY2FsbCIsImFyZ3MiLCJjb25jYXQiLCJsYXN0SWQiLCJzdGFtcCIsIl9sZWFmbGV0X2lkIiwidGhyb3R0bGUiLCJ0aW1lIiwiY29udGV4dCIsImxvY2siLCJ3cmFwcGVyRm4iLCJsYXRlciIsInNldFRpbWVvdXQiLCJ3cmFwTnVtIiwieCIsInJhbmdlIiwiaW5jbHVkZU1heCIsIm1heCIsIm1pbiIsImQiLCJmYWxzZUZuIiwiZm9ybWF0TnVtIiwibnVtIiwicHJlY2lzaW9uIiwicG93IiwiTWF0aCIsInVuZGVmaW5lZCIsInJvdW5kIiwidHJpbSIsInN0ciIsInJlcGxhY2UiLCJzcGxpdFdvcmRzIiwic3BsaXQiLCJzZXRPcHRpb25zIiwib3B0aW9ucyIsImhhc093blByb3BlcnR5IiwiZ2V0UGFyYW1TdHJpbmciLCJleGlzdGluZ1VybCIsInVwcGVyY2FzZSIsInBhcmFtcyIsInB1c2giLCJlbmNvZGVVUklDb21wb25lbnQiLCJ0b1VwcGVyQ2FzZSIsImluZGV4T2YiLCJqb2luIiwidGVtcGxhdGVSZSIsInRlbXBsYXRlIiwiZGF0YSIsImtleSIsInZhbHVlIiwiRXJyb3IiLCJpc0FycmF5IiwidG9TdHJpbmciLCJhcnJheSIsImVsIiwiZW1wdHlJbWFnZVVybCIsImdldFByZWZpeGVkIiwibmFtZSIsIndpbmRvdyIsImxhc3RUaW1lIiwidGltZW91dERlZmVyIiwiRGF0ZSIsInRpbWVUb0NhbGwiLCJyZXF1ZXN0Rm4iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxGbiIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiaWQiLCJjbGVhclRpbWVvdXQiLCJyZXF1ZXN0QW5pbUZyYW1lIiwiaW1tZWRpYXRlIiwiY2FuY2VsQW5pbUZyYW1lIiwiQ2xhc3MiLCJwcm9wcyIsIk5ld0NsYXNzIiwiaW5pdGlhbGl6ZSIsImNhbGxJbml0SG9va3MiLCJwYXJlbnRQcm90byIsIl9fc3VwZXJfXyIsImNvbnN0cnVjdG9yIiwic3RhdGljcyIsImluY2x1ZGVzIiwiY2hlY2tEZXByZWNhdGVkTWl4aW5FdmVudHMiLCJfaW5pdEhvb2tzIiwiX2luaXRIb29rc0NhbGxlZCIsImluY2x1ZGUiLCJwYXJlbnRPcHRpb25zIiwibWVyZ2VPcHRpb25zIiwiYWRkSW5pdEhvb2siLCJpbml0IiwiTCIsIk1peGluIiwiRXZlbnRzIiwiY29uc29sZSIsIndhcm4iLCJzdGFjayIsIm9uIiwidHlwZXMiLCJfdHlwZW9mIiwidHlwZSIsIl9vbiIsIm9mZiIsIl9ldmVudHMiLCJfb2ZmIiwicmVtb3ZlQWxsIiwiX29uY2UiLCJfbGlzdGVucyIsIm5ld0xpc3RlbmVyIiwiY3R4Iiwib25jZSIsImxpc3RlbmVycyIsIl9maXJpbmdDb3VudCIsImluZGV4IiwibGlzdGVuZXIiLCJzcGxpY2UiLCJmaXJlIiwicHJvcGFnYXRlIiwibGlzdGVucyIsImV2ZW50IiwidGFyZ2V0Iiwic291cmNlVGFyZ2V0IiwibCIsIl9wcm9wYWdhdGVFdmVudCIsIl9mbiIsIl9ldmVudFBhcmVudHMiLCJhZGRFdmVudFBhcmVudCIsInJlbW92ZUV2ZW50UGFyZW50IiwiZSIsImxheWVyIiwicHJvcGFnYXRlZEZyb20iLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMiLCJhZGRPbmVUaW1lRXZlbnRMaXN0ZW5lciIsImZpcmVFdmVudCIsImhhc0V2ZW50TGlzdGVuZXJzIiwiRXZlbnRlZCIsIlBvaW50IiwieSIsInRydW5jIiwidiIsImZsb29yIiwiY2VpbCIsImNsb25lIiwiYWRkIiwicG9pbnQiLCJfYWRkIiwidG9Qb2ludCIsInN1YnRyYWN0IiwiX3N1YnRyYWN0IiwiZGl2aWRlQnkiLCJfZGl2aWRlQnkiLCJtdWx0aXBseUJ5IiwiX211bHRpcGx5QnkiLCJzY2FsZUJ5IiwidW5zY2FsZUJ5IiwiX3JvdW5kIiwiX2Zsb29yIiwiX2NlaWwiLCJfdHJ1bmMiLCJkaXN0YW5jZVRvIiwic3FydCIsImVxdWFscyIsImNvbnRhaW5zIiwiYWJzIiwiQm91bmRzIiwiYSIsImIiLCJwb2ludHMiLCJtaW4yIiwibWF4MiIsInRvQm91bmRzIiwiZ2V0Q2VudGVyIiwiZ2V0Qm90dG9tTGVmdCIsImdldFRvcFJpZ2h0IiwiZ2V0VG9wTGVmdCIsImdldEJvdHRvbVJpZ2h0IiwiZ2V0U2l6ZSIsImludGVyc2VjdHMiLCJib3VuZHMiLCJ4SW50ZXJzZWN0cyIsInlJbnRlcnNlY3RzIiwib3ZlcmxhcHMiLCJ4T3ZlcmxhcHMiLCJ5T3ZlcmxhcHMiLCJpc1ZhbGlkIiwicGFkIiwiYnVmZmVyUmF0aW8iLCJoZWlnaHRCdWZmZXIiLCJ3aWR0aEJ1ZmZlciIsIkxhdExuZ0JvdW5kcyIsImNvcm5lcjEiLCJjb3JuZXIyIiwibGF0bG5ncyIsInN3IiwiX3NvdXRoV2VzdCIsIm5lIiwiX25vcnRoRWFzdCIsInN3MiIsIm5lMiIsIkxhdExuZyIsInRvTGF0TG5nIiwidG9MYXRMbmdCb3VuZHMiLCJsYXQiLCJsbmciLCJnZXRTb3V0aFdlc3QiLCJnZXROb3J0aEVhc3QiLCJnZXROb3J0aFdlc3QiLCJnZXROb3J0aCIsImdldFdlc3QiLCJnZXRTb3V0aEVhc3QiLCJnZXRTb3V0aCIsImdldEVhc3QiLCJsYXRJbnRlcnNlY3RzIiwibG5nSW50ZXJzZWN0cyIsImxhdE92ZXJsYXBzIiwibG5nT3ZlcmxhcHMiLCJ0b0JCb3hTdHJpbmciLCJtYXhNYXJnaW4iLCJhbHQiLCJpc05hTiIsIm1hcmdpbiIsIm90aGVyIiwiRWFydGgiLCJkaXN0YW5jZSIsIndyYXAiLCJ3cmFwTGF0TG5nIiwic2l6ZUluTWV0ZXJzIiwibGF0QWNjdXJhY3kiLCJsbmdBY2N1cmFjeSIsImNvcyIsIlBJIiwiYyIsImxvbiIsIkNSUyIsImxhdExuZ1RvUG9pbnQiLCJsYXRsbmciLCJ6b29tIiwicHJvamVjdGVkUG9pbnQiLCJwcm9qZWN0aW9uIiwicHJvamVjdCIsInNjYWxlIiwidHJhbnNmb3JtYXRpb24iLCJfdHJhbnNmb3JtIiwicG9pbnRUb0xhdExuZyIsInVudHJhbnNmb3JtZWRQb2ludCIsInVudHJhbnNmb3JtIiwidW5wcm9qZWN0IiwibG9nIiwiTE4yIiwiZ2V0UHJvamVjdGVkQm91bmRzIiwiaW5maW5pdGUiLCJzIiwidHJhbnNmb3JtIiwid3JhcExuZyIsIndyYXBMYXQiLCJ3cmFwTGF0TG5nQm91bmRzIiwiY2VudGVyIiwibmV3Q2VudGVyIiwibGF0U2hpZnQiLCJsbmdTaGlmdCIsIm5ld1N3IiwibmV3TmUiLCJSIiwibGF0bG5nMSIsImxhdGxuZzIiLCJyYWQiLCJsYXQxIiwibGF0MiIsInNpbkRMYXQiLCJzaW4iLCJzaW5ETG9uIiwiYXRhbjIiLCJlYXJ0aFJhZGl1cyIsIlNwaGVyaWNhbE1lcmNhdG9yIiwiTUFYX0xBVElUVURFIiwiYXRhbiIsImV4cCIsIlRyYW5zZm9ybWF0aW9uIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJ0b1RyYW5zZm9ybWF0aW9uIiwiRVBTRzM4NTciLCJjb2RlIiwiRVBTRzkwMDkxMyIsInN2Z0NyZWF0ZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudE5TIiwicG9pbnRzVG9QYXRoIiwicmluZ3MiLCJjbG9zZWQiLCJsZW4yIiwicCIsIkJyb3dzZXIiLCJzdmciLCJzdHlsZSIsImRvY3VtZW50RWxlbWVudCIsImllIiwiaWVsdDkiLCJlZGdlIiwibmF2aWdhdG9yIiwid2Via2l0IiwidXNlckFnZW50Q29udGFpbnMiLCJhbmRyb2lkIiwiYW5kcm9pZDIzIiwid2Via2l0VmVyIiwicGFyc2VJbnQiLCJleGVjIiwidXNlckFnZW50IiwiYW5kcm9pZFN0b2NrIiwib3BlcmEiLCJjaHJvbWUiLCJnZWNrbyIsInNhZmFyaSIsInBoYW50b20iLCJvcGVyYTEyIiwid2luIiwicGxhdGZvcm0iLCJpZTNkIiwid2Via2l0M2QiLCJXZWJLaXRDU1NNYXRyaXgiLCJnZWNrbzNkIiwiYW55M2QiLCJMX0RJU0FCTEVfM0QiLCJtb2JpbGUiLCJvcmllbnRhdGlvbiIsIm1vYmlsZVdlYmtpdCIsIm1vYmlsZVdlYmtpdDNkIiwibXNQb2ludGVyIiwiUG9pbnRlckV2ZW50IiwiTVNQb2ludGVyRXZlbnQiLCJwb2ludGVyIiwidG91Y2hOYXRpdmUiLCJUb3VjaEV2ZW50IiwidG91Y2giLCJMX05PX1RPVUNIIiwibW9iaWxlT3BlcmEiLCJtb2JpbGVHZWNrbyIsInJldGluYSIsImRldmljZVBpeGVsUmF0aW8iLCJzY3JlZW4iLCJkZXZpY2VYRFBJIiwibG9naWNhbFhEUEkiLCJwYXNzaXZlRXZlbnRzIiwic3VwcG9ydHNQYXNzaXZlT3B0aW9uIiwib3B0cyIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiY2FudmFzJDEiLCJjcmVhdGVFbGVtZW50IiwiZ2V0Q29udGV4dCIsInN2ZyQxIiwiY3JlYXRlU1ZHUmVjdCIsImlubGluZVN2ZyIsImRpdiIsImlubmVySFRNTCIsImZpcnN0Q2hpbGQiLCJuYW1lc3BhY2VVUkkiLCJ2bWwiLCJzaGFwZSIsImJlaGF2aW9yIiwiYWRqIiwibWFjIiwibGludXgiLCJ0b0xvd2VyQ2FzZSIsImNhbnZhcyIsIlBPSU5URVJfRE9XTiIsIlBPSU5URVJfTU9WRSIsIlBPSU5URVJfVVAiLCJQT0lOVEVSX0NBTkNFTCIsInBFdmVudCIsInRvdWNoc3RhcnQiLCJ0b3VjaG1vdmUiLCJ0b3VjaGVuZCIsInRvdWNoY2FuY2VsIiwiaGFuZGxlIiwiX29uUG9pbnRlclN0YXJ0IiwiX2hhbmRsZVBvaW50ZXIiLCJfcG9pbnRlcnMiLCJfcG9pbnRlckRvY0xpc3RlbmVyIiwiYWRkUG9pbnRlckxpc3RlbmVyIiwiaGFuZGxlciIsIl9hZGRQb2ludGVyRG9jTGlzdGVuZXIiLCJyZW1vdmVQb2ludGVyTGlzdGVuZXIiLCJfZ2xvYmFsUG9pbnRlckRvd24iLCJwb2ludGVySWQiLCJfZ2xvYmFsUG9pbnRlck1vdmUiLCJfZ2xvYmFsUG9pbnRlclVwIiwicG9pbnRlclR5cGUiLCJNU1BPSU5URVJfVFlQRV9NT1VTRSIsInRvdWNoZXMiLCJjaGFuZ2VkVG91Y2hlcyIsIk1TUE9JTlRFUl9UWVBFX1RPVUNIIiwicHJldmVudERlZmF1bHQiLCJtYWtlRGJsY2xpY2siLCJuZXdFdmVudCIsInByb3AiLCJkZXRhaWwiLCJpc1RydXN0ZWQiLCJfc2ltdWxhdGVkIiwiZGVsYXkiLCJhZGREb3VibGVUYXBMaXN0ZW5lciIsImxhc3QiLCJzaW1EYmxjbGljayIsInNvdXJjZUNhcGFiaWxpdGllcyIsImZpcmVzVG91Y2hFdmVudHMiLCJwYXRoIiwiZ2V0UHJvcGFnYXRpb25QYXRoIiwic29tZSIsIkhUTUxMYWJlbEVsZW1lbnQiLCJhdHRyaWJ1dGVzIiwiSFRNTElucHV0RWxlbWVudCIsIkhUTUxTZWxlY3RFbGVtZW50Iiwibm93IiwiZGJsY2xpY2siLCJyZW1vdmVEb3VibGVUYXBMaXN0ZW5lciIsImhhbmRsZXJzIiwiVFJBTlNGT1JNIiwidGVzdFByb3AiLCJUUkFOU0lUSU9OIiwiVFJBTlNJVElPTl9FTkQiLCJnZXRFbGVtZW50QnlJZCIsImdldFN0eWxlIiwiY3VycmVudFN0eWxlIiwiZGVmYXVsdFZpZXciLCJjc3MiLCJnZXRDb21wdXRlZFN0eWxlIiwiY3JlYXRlJDEiLCJ0YWdOYW1lIiwiY2xhc3NOYW1lIiwiY29udGFpbmVyIiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmUiLCJwYXJlbnQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJlbXB0eSIsInRvRnJvbnQiLCJsYXN0Q2hpbGQiLCJ0b0JhY2siLCJpbnNlcnRCZWZvcmUiLCJoYXNDbGFzcyIsImNsYXNzTGlzdCIsImdldENsYXNzIiwiUmVnRXhwIiwidGVzdCIsImFkZENsYXNzIiwiY2xhc3NlcyIsInNldENsYXNzIiwicmVtb3ZlQ2xhc3MiLCJiYXNlVmFsIiwiY29ycmVzcG9uZGluZ0VsZW1lbnQiLCJzZXRPcGFjaXR5Iiwib3BhY2l0eSIsIl9zZXRPcGFjaXR5SUUiLCJmaWx0ZXIiLCJmaWx0ZXJOYW1lIiwiZmlsdGVycyIsIml0ZW0iLCJFbmFibGVkIiwiT3BhY2l0eSIsInNldFRyYW5zZm9ybSIsIm9mZnNldCIsInBvcyIsInNldFBvc2l0aW9uIiwiX2xlYWZsZXRfcG9zIiwibGVmdCIsInRvcCIsImdldFBvc2l0aW9uIiwiZGlzYWJsZVRleHRTZWxlY3Rpb24iLCJlbmFibGVUZXh0U2VsZWN0aW9uIiwiX3VzZXJTZWxlY3QiLCJ1c2VyU2VsZWN0UHJvcGVydHkiLCJkaXNhYmxlSW1hZ2VEcmFnIiwiZW5hYmxlSW1hZ2VEcmFnIiwiX291dGxpbmVFbGVtZW50IiwiX291dGxpbmVTdHlsZSIsInByZXZlbnRPdXRsaW5lIiwiZWxlbWVudCIsInRhYkluZGV4IiwicmVzdG9yZU91dGxpbmUiLCJvdXRsaW5lU3R5bGUiLCJnZXRTaXplZFBhcmVudE5vZGUiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsImJvZHkiLCJnZXRTY2FsZSIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aWR0aCIsImhlaWdodCIsImJvdW5kaW5nQ2xpZW50UmVjdCIsImFkZE9uZSIsImV2ZW50c0tleSIsImJhdGNoUmVtb3ZlIiwicmVtb3ZlT25lIiwiZmlsdGVyRm4iLCJtb3VzZVN1YnN0IiwibW91c2VlbnRlciIsIm1vdXNlbGVhdmUiLCJ3aGVlbCIsIm9yaWdpbmFsSGFuZGxlciIsInBhc3NpdmUiLCJpc0V4dGVybmFsVGFyZ2V0IiwiYXR0YWNoRXZlbnQiLCJkZXRhY2hFdmVudCIsInN0b3BQcm9wYWdhdGlvbiIsIm9yaWdpbmFsRXZlbnQiLCJfc3RvcHBlZCIsImNhbmNlbEJ1YmJsZSIsImRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbiIsImRpc2FibGVDbGlja1Byb3BhZ2F0aW9uIiwicmV0dXJuVmFsdWUiLCJzdG9wIiwiZXYiLCJjb21wb3NlZFBhdGgiLCJnZXRNb3VzZVBvc2l0aW9uIiwiY2xpZW50WCIsImNsaWVudFkiLCJjbGllbnRMZWZ0IiwiY2xpZW50VG9wIiwid2hlZWxQeEZhY3RvciIsImdldFdoZWVsRGVsdGEiLCJ3aGVlbERlbHRhWSIsImRlbHRhWSIsImRlbHRhTW9kZSIsImRlbHRhWCIsImRlbHRhWiIsIndoZWVsRGVsdGEiLCJyZWxhdGVkIiwicmVsYXRlZFRhcmdldCIsImVyciIsIlBvc0FuaW1hdGlvbiIsInJ1biIsIm5ld1BvcyIsImR1cmF0aW9uIiwiZWFzZUxpbmVhcml0eSIsIl9lbCIsIl9pblByb2dyZXNzIiwiX2R1cmF0aW9uIiwiX2Vhc2VPdXRQb3dlciIsIl9zdGFydFBvcyIsIl9vZmZzZXQiLCJfc3RhcnRUaW1lIiwiX2FuaW1hdGUiLCJfc3RlcCIsIl9jb21wbGV0ZSIsIl9hbmltSWQiLCJlbGFwc2VkIiwiX3J1bkZyYW1lIiwiX2Vhc2VPdXQiLCJwcm9ncmVzcyIsInQiLCJNYXAiLCJjcnMiLCJtaW5ab29tIiwibWF4Wm9vbSIsImxheWVycyIsIm1heEJvdW5kcyIsInJlbmRlcmVyIiwiem9vbUFuaW1hdGlvbiIsInpvb21BbmltYXRpb25UaHJlc2hvbGQiLCJmYWRlQW5pbWF0aW9uIiwibWFya2VyWm9vbUFuaW1hdGlvbiIsInRyYW5zZm9ybTNETGltaXQiLCJ6b29tU25hcCIsInpvb21EZWx0YSIsInRyYWNrUmVzaXplIiwiX2hhbmRsZXJzIiwiX2xheWVycyIsIl96b29tQm91bmRMYXllcnMiLCJfc2l6ZUNoYW5nZWQiLCJfaW5pdENvbnRhaW5lciIsIl9pbml0TGF5b3V0IiwiX29uUmVzaXplIiwiX2luaXRFdmVudHMiLCJzZXRNYXhCb3VuZHMiLCJfem9vbSIsIl9saW1pdFpvb20iLCJzZXRWaWV3IiwicmVzZXQiLCJfem9vbUFuaW1hdGVkIiwiX2NyZWF0ZUFuaW1Qcm94eSIsIl9wcm94eSIsIl9jYXRjaFRyYW5zaXRpb25FbmQiLCJfYWRkTGF5ZXJzIiwiX2xpbWl0Q2VudGVyIiwiX3N0b3AiLCJfbG9hZGVkIiwiYW5pbWF0ZSIsInBhbiIsIm1vdmVkIiwiX3RyeUFuaW1hdGVkWm9vbSIsIl90cnlBbmltYXRlZFBhbiIsIl9zaXplVGltZXIiLCJfcmVzZXRWaWV3Iiwibm9Nb3ZlU3RhcnQiLCJzZXRab29tIiwiem9vbUluIiwiZGVsdGEiLCJ6b29tT3V0Iiwic2V0Wm9vbUFyb3VuZCIsImdldFpvb21TY2FsZSIsInZpZXdIYWxmIiwiY29udGFpbmVyUG9pbnQiLCJsYXRMbmdUb0NvbnRhaW5lclBvaW50IiwiY2VudGVyT2Zmc2V0IiwiY29udGFpbmVyUG9pbnRUb0xhdExuZyIsIl9nZXRCb3VuZHNDZW50ZXJab29tIiwiZ2V0Qm91bmRzIiwicGFkZGluZ1RMIiwicGFkZGluZ1RvcExlZnQiLCJwYWRkaW5nIiwicGFkZGluZ0JSIiwicGFkZGluZ0JvdHRvbVJpZ2h0IiwiZ2V0Qm91bmRzWm9vbSIsIkluZmluaXR5IiwicGFkZGluZ09mZnNldCIsInN3UG9pbnQiLCJuZVBvaW50IiwiZml0Qm91bmRzIiwiZml0V29ybGQiLCJwYW5UbyIsInBhbkJ5IiwiZ2V0Wm9vbSIsIl9wYW5BbmltIiwiX29uUGFuVHJhbnNpdGlvblN0ZXAiLCJfb25QYW5UcmFuc2l0aW9uRW5kIiwiX21hcFBhbmUiLCJfZ2V0TWFwUGFuZVBvcyIsIl9yYXdQYW5CeSIsImZseVRvIiwidGFyZ2V0Q2VudGVyIiwidGFyZ2V0Wm9vbSIsImZyb20iLCJ0byIsInNpemUiLCJzdGFydFpvb20iLCJ3MCIsIncxIiwidTEiLCJyaG8iLCJyaG8yIiwiciIsInMxIiwiczIiLCJ0MSIsImIxIiwic3EiLCJzaW5oIiwibiIsImNvc2giLCJ0YW5oIiwicjAiLCJ3IiwidSIsImVhc2VPdXQiLCJzdGFydCIsIlMiLCJmcmFtZSIsIl9mbHlUb0ZyYW1lIiwiX21vdmUiLCJnZXRTY2FsZVpvb20iLCJfbW92ZUVuZCIsIl9tb3ZlU3RhcnQiLCJmbHlUb0JvdW5kcyIsIl9wYW5JbnNpZGVNYXhCb3VuZHMiLCJzZXRNaW5ab29tIiwib2xkWm9vbSIsInNldE1heFpvb20iLCJwYW5JbnNpZGVCb3VuZHMiLCJfZW5mb3JjaW5nQm91bmRzIiwicGFuSW5zaWRlIiwicGl4ZWxDZW50ZXIiLCJwaXhlbFBvaW50IiwicGl4ZWxCb3VuZHMiLCJnZXRQaXhlbEJvdW5kcyIsInBhZGRlZEJvdW5kcyIsInBhZGRlZFNpemUiLCJpbnZhbGlkYXRlU2l6ZSIsIm9sZFNpemUiLCJfbGFzdENlbnRlciIsIm5ld1NpemUiLCJvbGRDZW50ZXIiLCJkZWJvdW5jZU1vdmVlbmQiLCJsb2NhdGUiLCJfbG9jYXRlT3B0aW9ucyIsInRpbWVvdXQiLCJ3YXRjaCIsIl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yIiwibWVzc2FnZSIsIm9uUmVzcG9uc2UiLCJfaGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZSIsIm9uRXJyb3IiLCJfbG9jYXRpb25XYXRjaElkIiwiZ2VvbG9jYXRpb24iLCJ3YXRjaFBvc2l0aW9uIiwiZ2V0Q3VycmVudFBvc2l0aW9uIiwic3RvcExvY2F0ZSIsImNsZWFyV2F0Y2giLCJlcnJvciIsIl9jb250YWluZXIiLCJjb29yZHMiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsImFjY3VyYWN5IiwidGltZXN0YW1wIiwiYWRkSGFuZGxlciIsIkhhbmRsZXJDbGFzcyIsImVuYWJsZSIsIl9jb250YWluZXJJZCIsIl9jbGVhckNvbnRyb2xQb3MiLCJfcmVzaXplUmVxdWVzdCIsIl9jbGVhckhhbmRsZXJzIiwiX3BhbmVzIiwiX3JlbmRlcmVyIiwiY3JlYXRlUGFuZSIsInBhbmUiLCJfY2hlY2tJZkxvYWRlZCIsIl9tb3ZlZCIsImxheWVyUG9pbnRUb0xhdExuZyIsIl9nZXRDZW50ZXJMYXllclBvaW50IiwiZ2V0TWluWm9vbSIsIl9sYXllcnNNaW5ab29tIiwiZ2V0TWF4Wm9vbSIsIl9sYXllcnNNYXhab29tIiwiaW5zaWRlIiwibnciLCJzZSIsImJvdW5kc1NpemUiLCJzbmFwIiwic2NhbGV4Iiwic2NhbGV5IiwiX3NpemUiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsInRvcExlZnRQb2ludCIsIl9nZXRUb3BMZWZ0UG9pbnQiLCJnZXRQaXhlbE9yaWdpbiIsIl9waXhlbE9yaWdpbiIsImdldFBpeGVsV29ybGRCb3VuZHMiLCJnZXRQYW5lIiwiZ2V0UGFuZXMiLCJnZXRDb250YWluZXIiLCJ0b1pvb20iLCJmcm9tWm9vbSIsImxhdExuZ1RvTGF5ZXJQb2ludCIsImNvbnRhaW5lclBvaW50VG9MYXllclBvaW50IiwibGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQiLCJsYXllclBvaW50IiwibW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQiLCJtb3VzZUV2ZW50VG9MYXllclBvaW50IiwibW91c2VFdmVudFRvTGF0TG5nIiwiX29uU2Nyb2xsIiwiX2ZhZGVBbmltYXRlZCIsInBvc2l0aW9uIiwiX2luaXRQYW5lcyIsIl9pbml0Q29udHJvbFBvcyIsInBhbmVzIiwiX3BhbmVSZW5kZXJlcnMiLCJtYXJrZXJQYW5lIiwic2hhZG93UGFuZSIsImxvYWRpbmciLCJ6b29tQ2hhbmdlZCIsInN1cHJlc3NFdmVudCIsIl9nZXROZXdQaXhlbE9yaWdpbiIsInBpbmNoIiwiX2dldFpvb21TcGFuIiwiX3RhcmdldHMiLCJvbk9mZiIsIl9oYW5kbGVET01FdmVudCIsIl9vbk1vdmVFbmQiLCJzY3JvbGxUb3AiLCJzY3JvbGxMZWZ0IiwiX2ZpbmRFdmVudFRhcmdldHMiLCJ0YXJnZXRzIiwiaXNIb3ZlciIsInNyY0VsZW1lbnQiLCJkcmFnZ2luZyIsIl9kcmFnZ2FibGVNb3ZlZCIsIl9pc0NsaWNrRGlzYWJsZWQiLCJfZmlyZURPTUV2ZW50IiwiX21vdXNlRXZlbnRzIiwiY2FudmFzVGFyZ2V0cyIsInN5bnRoIiwiZmlsdGVyZWQiLCJpc01hcmtlciIsImdldExhdExuZyIsIl9yYWRpdXMiLCJidWJibGluZ01vdXNlRXZlbnRzIiwiZW5hYmxlZCIsImJveFpvb20iLCJkaXNhYmxlIiwid2hlblJlYWR5IiwiY2FsbGJhY2siLCJwaXhlbE9yaWdpbiIsIl9sYXRMbmdUb05ld0xheWVyUG9pbnQiLCJ0b3BMZWZ0IiwiX2xhdExuZ0JvdW5kc1RvTmV3TGF5ZXJCb3VuZHMiLCJsYXRMbmdCb3VuZHMiLCJfZ2V0Q2VudGVyT2Zmc2V0IiwiY2VudGVyUG9pbnQiLCJ2aWV3Qm91bmRzIiwiX2dldEJvdW5kc09mZnNldCIsIl9saW1pdE9mZnNldCIsIm5ld0JvdW5kcyIsInB4Qm91bmRzIiwicHJvamVjdGVkTWF4Qm91bmRzIiwibWluT2Zmc2V0IiwibWF4T2Zmc2V0IiwiZHgiLCJfcmVib3VuZCIsImR5IiwicmlnaHQiLCJwcm94eSIsIm1hcFBhbmUiLCJfYW5pbWF0aW5nWm9vbSIsIl9vblpvb21UcmFuc2l0aW9uRW5kIiwiX2FuaW1Nb3ZlRW5kIiwiX2Rlc3Ryb3lBbmltUHJveHkiLCJ6IiwicHJvcGVydHlOYW1lIiwiX25vdGhpbmdUb0FuaW1hdGUiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwiX2FuaW1hdGVab29tIiwic3RhcnRBbmltIiwibm9VcGRhdGUiLCJfYW5pbWF0ZVRvQ2VudGVyIiwiX2FuaW1hdGVUb1pvb20iLCJfdGVtcEZpcmVab29tRXZlbnQiLCJjcmVhdGVNYXAiLCJDb250cm9sIiwibWFwIiwiX21hcCIsInJlbW92ZUNvbnRyb2wiLCJhZGRDb250cm9sIiwiYWRkVG8iLCJvbkFkZCIsImNvcm5lciIsIl9jb250cm9sQ29ybmVycyIsIm9uUmVtb3ZlIiwiX3JlZm9jdXNPbk1hcCIsInNjcmVlblgiLCJzY3JlZW5ZIiwiZm9jdXMiLCJjb250cm9sIiwiY29ybmVycyIsIl9jb250cm9sQ29udGFpbmVyIiwiY3JlYXRlQ29ybmVyIiwidlNpZGUiLCJoU2lkZSIsIkxheWVycyIsImNvbGxhcHNlZCIsImF1dG9aSW5kZXgiLCJoaWRlU2luZ2xlQmFzZSIsInNvcnRMYXllcnMiLCJzb3J0RnVuY3Rpb24iLCJsYXllckEiLCJsYXllckIiLCJuYW1lQSIsIm5hbWVCIiwiYmFzZUxheWVycyIsIm92ZXJsYXlzIiwiX2xheWVyQ29udHJvbElucHV0cyIsIl9sYXN0WkluZGV4IiwiX2hhbmRsaW5nQ2xpY2siLCJfcHJldmVudENsaWNrIiwiX2FkZExheWVyIiwiX3VwZGF0ZSIsIl9jaGVja0Rpc2FibGVkTGF5ZXJzIiwiX29uTGF5ZXJDaGFuZ2UiLCJfZXhwYW5kSWZOb3RDb2xsYXBzZWQiLCJhZGRCYXNlTGF5ZXIiLCJhZGRPdmVybGF5IiwicmVtb3ZlTGF5ZXIiLCJfZ2V0TGF5ZXIiLCJleHBhbmQiLCJfc2VjdGlvbiIsImFjY2VwdGFibGVIZWlnaHQiLCJvZmZzZXRUb3AiLCJjb2xsYXBzZSIsInNldEF0dHJpYnV0ZSIsInNlY3Rpb24iLCJfZXhwYW5kU2FmZWx5IiwibGluayIsIl9sYXllcnNMaW5rIiwiaHJlZiIsInRpdGxlIiwia2V5ZG93biIsImtleUNvZGUiLCJjbGljayIsIl9iYXNlTGF5ZXJzTGlzdCIsIl9zZXBhcmF0b3IiLCJfb3ZlcmxheXNMaXN0Iiwib3ZlcmxheSIsInNvcnQiLCJzZXRaSW5kZXgiLCJiYXNlTGF5ZXJzUHJlc2VudCIsIm92ZXJsYXlzUHJlc2VudCIsImJhc2VMYXllcnNDb3VudCIsIl9hZGRJdGVtIiwiZGlzcGxheSIsIl9jcmVhdGVSYWRpb0VsZW1lbnQiLCJjaGVja2VkIiwicmFkaW9IdG1sIiwicmFkaW9GcmFnbWVudCIsImxhYmVsIiwiaGFzTGF5ZXIiLCJpbnB1dCIsImRlZmF1bHRDaGVja2VkIiwibGF5ZXJJZCIsIl9vbklucHV0Q2xpY2siLCJob2xkZXIiLCJpbnB1dHMiLCJhZGRlZExheWVycyIsInJlbW92ZWRMYXllcnMiLCJhZGRMYXllciIsImRpc2FibGVkIiwidGhhdCIsIlpvb20iLCJ6b29tSW5UZXh0Iiwiem9vbUluVGl0bGUiLCJ6b29tT3V0VGV4dCIsInpvb21PdXRUaXRsZSIsInpvb21OYW1lIiwiX3pvb21JbkJ1dHRvbiIsIl9jcmVhdGVCdXR0b24iLCJfem9vbUluIiwiX3pvb21PdXRCdXR0b24iLCJfem9vbU91dCIsIl91cGRhdGVEaXNhYmxlZCIsIl9kaXNhYmxlZCIsInNoaWZ0S2V5IiwiaHRtbCIsInpvb21Db250cm9sIiwiU2NhbGUiLCJtYXhXaWR0aCIsIm1ldHJpYyIsImltcGVyaWFsIiwiX2FkZFNjYWxlcyIsInVwZGF0ZVdoZW5JZGxlIiwiX21TY2FsZSIsIl9pU2NhbGUiLCJtYXhNZXRlcnMiLCJfdXBkYXRlU2NhbGVzIiwiX3VwZGF0ZU1ldHJpYyIsIl91cGRhdGVJbXBlcmlhbCIsIm1ldGVycyIsIl9nZXRSb3VuZE51bSIsIl91cGRhdGVTY2FsZSIsIm1heEZlZXQiLCJtYXhNaWxlcyIsIm1pbGVzIiwiZmVldCIsInRleHQiLCJyYXRpbyIsInBvdzEwIiwidWtyYWluaWFuRmxhZyIsIkF0dHJpYnV0aW9uIiwicHJlZml4IiwiX2F0dHJpYnV0aW9ucyIsImF0dHJpYnV0aW9uQ29udHJvbCIsImdldEF0dHJpYnV0aW9uIiwiYWRkQXR0cmlidXRpb24iLCJfYWRkQXR0cmlidXRpb24iLCJyZW1vdmVBdHRyaWJ1dGlvbiIsInNldFByZWZpeCIsImF0dHJpYnMiLCJwcmVmaXhBbmRBdHRyaWJzIiwiYXR0cmlidXRpb24iLCJIYW5kbGVyIiwiX2VuYWJsZWQiLCJhZGRIb29rcyIsInJlbW92ZUhvb2tzIiwiU1RBUlQiLCJEcmFnZ2FibGUiLCJjbGlja1RvbGVyYW5jZSIsImRyYWdTdGFydFRhcmdldCIsIl9lbGVtZW50IiwiX2RyYWdTdGFydFRhcmdldCIsIl9wcmV2ZW50T3V0bGluZSIsIl9vbkRvd24iLCJfZHJhZ2dpbmciLCJmaW5pc2hEcmFnIiwid2hpY2giLCJidXR0b24iLCJfbW92aW5nIiwiZmlyc3QiLCJzaXplZFBhcmVudCIsIl9zdGFydFBvaW50IiwiX3BhcmVudFNjYWxlIiwibW91c2VldmVudCIsIl9vbk1vdmUiLCJfb25VcCIsIl9sYXN0VGFyZ2V0IiwiU1ZHRWxlbWVudEluc3RhbmNlIiwiY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQiLCJfbmV3UG9zIiwiX2xhc3RFdmVudCIsIl91cGRhdGVQb3NpdGlvbiIsIm5vSW5lcnRpYSIsImZpcmVEcmFnZW5kIiwiY2xpcFBvbHlnb24iLCJjbGlwcGVkUG9pbnRzIiwiZWRnZXMiLCJrIiwiX2NvZGUiLCJfZ2V0Qml0Q29kZSIsIl9nZXRFZGdlSW50ZXJzZWN0aW9uIiwicG9seWdvbkNlbnRlciIsInAxIiwicDIiLCJmIiwiYXJlYSIsImlzRmxhdCIsImNlbnRyb2lkTGF0TG5nIiwiYXJlYUJvdW5kcyIsImNlbnRyb2lkIiwibGF0bG5nQ2VudGVyIiwibGF0U3VtIiwibG5nU3VtIiwic2ltcGxpZnkiLCJ0b2xlcmFuY2UiLCJzcVRvbGVyYW5jZSIsIl9yZWR1Y2VQb2ludHMiLCJfc2ltcGxpZnlEUCIsInBvaW50VG9TZWdtZW50RGlzdGFuY2UiLCJfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQiLCJjbG9zZXN0UG9pbnRPblNlZ21lbnQiLCJBcnJheUNvbnN0cnVjdG9yIiwiVWludDhBcnJheSIsIm1hcmtlcnMiLCJfc2ltcGxpZnlEUFN0ZXAiLCJuZXdQb2ludHMiLCJtYXhTcURpc3QiLCJzcURpc3QiLCJyZWR1Y2VkUG9pbnRzIiwicHJldiIsIl9zcURpc3QiLCJfbGFzdENvZGUiLCJjbGlwU2VnbWVudCIsInVzZUxhc3RDb2RlIiwiY29kZUEiLCJjb2RlQiIsImNvZGVPdXQiLCJuZXdDb2RlIiwiZG90IiwiX2ZsYXQiLCJwb2x5bGluZUNlbnRlciIsImhhbGZEaXN0Iiwic2VnRGlzdCIsImRpc3QiLCJMb25MYXQiLCJNZXJjYXRvciIsIlJfTUlOT1IiLCJ0bXAiLCJjb24iLCJ0cyIsInRhbiIsInBoaSIsImRwaGkiLCJFUFNHMzM5NSIsIkVQU0c0MzI2IiwiU2ltcGxlIiwiTGF5ZXIiLCJyZW1vdmVGcm9tIiwiX21hcFRvQWRkIiwiYWRkSW50ZXJhY3RpdmVUYXJnZXQiLCJ0YXJnZXRFbCIsInJlbW92ZUludGVyYWN0aXZlVGFyZ2V0IiwiX2xheWVyQWRkIiwiZ2V0RXZlbnRzIiwiZXZlbnRzIiwiYmVmb3JlQWRkIiwiZWFjaExheWVyIiwibWV0aG9kIiwiX2FkZFpvb21MaW1pdCIsIl91cGRhdGVab29tTGV2ZWxzIiwiX3JlbW92ZVpvb21MaW1pdCIsIm9sZFpvb21TcGFuIiwiTGF5ZXJHcm91cCIsImdldExheWVySWQiLCJjbGVhckxheWVycyIsImludm9rZSIsIm1ldGhvZE5hbWUiLCJnZXRMYXllciIsImdldExheWVycyIsInpJbmRleCIsImxheWVyR3JvdXAiLCJGZWF0dXJlR3JvdXAiLCJzZXRTdHlsZSIsImJyaW5nVG9Gcm9udCIsImJyaW5nVG9CYWNrIiwiZmVhdHVyZUdyb3VwIiwiSWNvbiIsInBvcHVwQW5jaG9yIiwidG9vbHRpcEFuY2hvciIsImNyb3NzT3JpZ2luIiwiY3JlYXRlSWNvbiIsIm9sZEljb24iLCJfY3JlYXRlSWNvbiIsImNyZWF0ZVNoYWRvdyIsIl9nZXRJY29uVXJsIiwiaW1nIiwiX2NyZWF0ZUltZyIsIl9zZXRJY29uU3R5bGVzIiwic2l6ZU9wdGlvbiIsImFuY2hvciIsInNoYWRvd0FuY2hvciIsImljb25BbmNob3IiLCJtYXJnaW5MZWZ0IiwibWFyZ2luVG9wIiwiaWNvbiIsIkljb25EZWZhdWx0IiwiaWNvblVybCIsImljb25SZXRpbmFVcmwiLCJzaGFkb3dVcmwiLCJpY29uU2l6ZSIsInNoYWRvd1NpemUiLCJpbWFnZVBhdGgiLCJfZGV0ZWN0SWNvblBhdGgiLCJfc3RyaXBVcmwiLCJzdHJpcCIsInJlIiwiaWR4IiwibWF0Y2giLCJxdWVyeVNlbGVjdG9yIiwic3Vic3RyaW5nIiwiTWFya2VyRHJhZyIsIm1hcmtlciIsIl9tYXJrZXIiLCJfaWNvbiIsIl9kcmFnZ2FibGUiLCJkcmFnc3RhcnQiLCJfb25EcmFnU3RhcnQiLCJwcmVkcmFnIiwiX29uUHJlRHJhZyIsImRyYWciLCJfb25EcmFnIiwiZHJhZ2VuZCIsIl9vbkRyYWdFbmQiLCJfYWRqdXN0UGFuIiwic3BlZWQiLCJhdXRvUGFuU3BlZWQiLCJhdXRvUGFuUGFkZGluZyIsImljb25Qb3MiLCJvcmlnaW4iLCJwYW5Cb3VuZHMiLCJtb3ZlbWVudCIsIl9wYW5SZXF1ZXN0IiwiX29sZExhdExuZyIsImNsb3NlUG9wdXAiLCJhdXRvUGFuIiwic2hhZG93IiwiX3NoYWRvdyIsIl9sYXRsbmciLCJvbGRMYXRMbmciLCJNYXJrZXIiLCJpbnRlcmFjdGl2ZSIsImtleWJvYXJkIiwiekluZGV4T2Zmc2V0IiwicmlzZU9uSG92ZXIiLCJyaXNlT2Zmc2V0IiwiYXV0b1Bhbk9uRm9jdXMiLCJkcmFnZ2FibGUiLCJfaW5pdEljb24iLCJ1cGRhdGUiLCJfcmVtb3ZlSWNvbiIsIl9yZW1vdmVTaGFkb3ciLCJ2aWV3cmVzZXQiLCJzZXRMYXRMbmciLCJzZXRaSW5kZXhPZmZzZXQiLCJnZXRJY29uIiwic2V0SWNvbiIsIl9wb3B1cCIsImJpbmRQb3B1cCIsImdldEVsZW1lbnQiLCJfc2V0UG9zIiwiY2xhc3NUb0FkZCIsImFkZEljb24iLCJtb3VzZW92ZXIiLCJfYnJpbmdUb0Zyb250IiwibW91c2VvdXQiLCJfcmVzZXRaSW5kZXgiLCJfcGFuT25Gb2N1cyIsIm5ld1NoYWRvdyIsImFkZFNoYWRvdyIsIl91cGRhdGVPcGFjaXR5IiwiX2luaXRJbnRlcmFjdGlvbiIsIl96SW5kZXgiLCJfdXBkYXRlWkluZGV4Iiwib3B0IiwiaWNvbk9wdHMiLCJfZ2V0UG9wdXBBbmNob3IiLCJfZ2V0VG9vbHRpcEFuY2hvciIsIlBhdGgiLCJzdHJva2UiLCJjb2xvciIsIndlaWdodCIsImxpbmVDYXAiLCJsaW5lSm9pbiIsImRhc2hBcnJheSIsImRhc2hPZmZzZXQiLCJmaWxsIiwiZmlsbENvbG9yIiwiZmlsbE9wYWNpdHkiLCJmaWxsUnVsZSIsImdldFJlbmRlcmVyIiwiX2luaXRQYXRoIiwiX3Jlc2V0IiwiX2FkZFBhdGgiLCJfcmVtb3ZlUGF0aCIsInJlZHJhdyIsIl91cGRhdGVQYXRoIiwiX3VwZGF0ZVN0eWxlIiwiX3VwZGF0ZUJvdW5kcyIsIl9icmluZ1RvQmFjayIsIl9wYXRoIiwiX3Byb2plY3QiLCJfY2xpY2tUb2xlcmFuY2UiLCJDaXJjbGVNYXJrZXIiLCJyYWRpdXMiLCJzZXRSYWRpdXMiLCJnZXRSYWRpdXMiLCJfcG9pbnQiLCJyMiIsIl9yYWRpdXNZIiwiX3B4Qm91bmRzIiwiX3VwZGF0ZUNpcmNsZSIsIl9lbXB0eSIsIl9ib3VuZHMiLCJfY29udGFpbnNQb2ludCIsImNpcmNsZU1hcmtlciIsIkNpcmNsZSIsImxlZ2FjeU9wdGlvbnMiLCJfbVJhZGl1cyIsImhhbGYiLCJsYXRSIiwiYm90dG9tIiwibG5nUiIsImFjb3MiLCJjaXJjbGUiLCJQb2x5bGluZSIsInNtb290aEZhY3RvciIsIm5vQ2xpcCIsIl9zZXRMYXRMbmdzIiwiZ2V0TGF0TG5ncyIsIl9sYXRsbmdzIiwic2V0TGF0TG5ncyIsImlzRW1wdHkiLCJjbG9zZXN0TGF5ZXJQb2ludCIsIm1pbkRpc3RhbmNlIiwibWluUG9pbnQiLCJjbG9zZXN0IiwiakxlbiIsIl9wYXJ0cyIsIl9kZWZhdWx0U2hhcGUiLCJhZGRMYXRMbmciLCJfY29udmVydExhdExuZ3MiLCJyZXN1bHQiLCJmbGF0IiwiX3JpbmdzIiwiX3Byb2plY3RMYXRsbmdzIiwiX3Jhd1B4Qm91bmRzIiwicHJvamVjdGVkQm91bmRzIiwicmluZyIsIl9jbGlwUG9pbnRzIiwicGFydHMiLCJzZWdtZW50IiwiX3NpbXBsaWZ5UG9pbnRzIiwiX3VwZGF0ZVBvbHkiLCJwYXJ0IiwicG9seWxpbmUiLCJQb2x5Z29uIiwicG9wIiwiY2xpcHBlZCIsInBvbHlnb24iLCJHZW9KU09OIiwiZ2VvanNvbiIsImFkZERhdGEiLCJmZWF0dXJlcyIsImZlYXR1cmUiLCJnZW9tZXRyaWVzIiwiZ2VvbWV0cnkiLCJjb29yZGluYXRlcyIsImdlb21ldHJ5VG9MYXllciIsImFzRmVhdHVyZSIsImRlZmF1bHRPcHRpb25zIiwicmVzZXRTdHlsZSIsIm9uRWFjaEZlYXR1cmUiLCJfc2V0TGF5ZXJTdHlsZSIsInBvaW50VG9MYXllciIsIl9jb29yZHNUb0xhdExuZyIsImNvb3Jkc1RvTGF0TG5nIiwiX3BvaW50VG9MYXllciIsImNvb3Jkc1RvTGF0TG5ncyIsImdlb0xheWVyIiwicHJvcGVydGllcyIsImZlYXR1cmVMYXllciIsInBvaW50VG9MYXllckZuIiwibWFya2Vyc0luaGVyaXRPcHRpb25zIiwibGV2ZWxzRGVlcCIsImxhdExuZ1RvQ29vcmRzIiwibGF0TG5nc1RvQ29vcmRzIiwiZ2V0RmVhdHVyZSIsIm5ld0dlb21ldHJ5IiwiUG9pbnRUb0dlb0pTT04iLCJ0b0dlb0pTT04iLCJtdWx0aSIsImhvbGVzIiwidG9NdWx0aVBvaW50IiwiaXNHZW9tZXRyeUNvbGxlY3Rpb24iLCJqc29ucyIsImpzb24iLCJnZW9KU09OIiwiZ2VvSnNvbiIsIkltYWdlT3ZlcmxheSIsImVycm9yT3ZlcmxheVVybCIsInVybCIsIl91cmwiLCJfaW1hZ2UiLCJfaW5pdEltYWdlIiwic3R5bGVPcHRzIiwic2V0VXJsIiwic2V0Qm91bmRzIiwiem9vbWFuaW0iLCJ3YXNFbGVtZW50U3VwcGxpZWQiLCJvbnNlbGVjdHN0YXJ0Iiwib25tb3VzZW1vdmUiLCJvbmxvYWQiLCJvbmVycm9yIiwiX292ZXJsYXlPbkVycm9yIiwiaW1hZ2UiLCJlcnJvclVybCIsImltYWdlT3ZlcmxheSIsIlZpZGVvT3ZlcmxheSIsImF1dG9wbGF5IiwibG9vcCIsImtlZXBBc3BlY3RSYXRpbyIsIm11dGVkIiwicGxheXNJbmxpbmUiLCJ2aWQiLCJvbmxvYWRlZGRhdGEiLCJzb3VyY2VFbGVtZW50cyIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwic291cmNlcyIsInNvdXJjZSIsInZpZGVvT3ZlcmxheSIsInZpZGVvIiwiU1ZHT3ZlcmxheSIsInN2Z092ZXJsYXkiLCJEaXZPdmVybGF5IiwiY29udGVudCIsIl9zb3VyY2UiLCJfY29udGVudCIsIm9wZW5PbiIsImNsb3NlIiwidG9nZ2xlIiwiX3ByZXBhcmVPcGVuIiwiX3JlbW92ZVRpbWVvdXQiLCJnZXRDb250ZW50Iiwic2V0Q29udGVudCIsInZpc2liaWxpdHkiLCJfdXBkYXRlQ29udGVudCIsIl91cGRhdGVMYXlvdXQiLCJpc09wZW4iLCJub2RlIiwiX2NvbnRlbnROb2RlIiwiaGFzQ2hpbGROb2RlcyIsIl9nZXRBbmNob3IiLCJfY29udGFpbmVyQm90dG9tIiwiX2NvbnRhaW5lckxlZnQiLCJfY29udGFpbmVyV2lkdGgiLCJfaW5pdE92ZXJsYXkiLCJPdmVybGF5Q2xhc3MiLCJvbGQiLCJQb3B1cCIsIm1pbldpZHRoIiwibWF4SGVpZ2h0IiwiYXV0b1BhblBhZGRpbmdUb3BMZWZ0IiwiYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodCIsImtlZXBJblZpZXciLCJjbG9zZUJ1dHRvbiIsImF1dG9DbG9zZSIsImNsb3NlT25Fc2NhcGVLZXkiLCJwb3B1cCIsImNsb3NlT25DbGljayIsImNsb3NlUG9wdXBPbkNsaWNrIiwicHJlY2xpY2siLCJtb3ZlZW5kIiwid3JhcHBlciIsIl93cmFwcGVyIiwiX3RpcENvbnRhaW5lciIsIl90aXAiLCJfY2xvc2VCdXR0b24iLCJ3aGl0ZVNwYWNlIiwic2Nyb2xsZWRDbGFzcyIsIl9hdXRvcGFubmluZyIsIm1hcmdpbkJvdHRvbSIsImNvbnRhaW5lckhlaWdodCIsImNvbnRhaW5lcldpZHRoIiwibGF5ZXJQb3MiLCJjb250YWluZXJQb3MiLCJvcGVuUG9wdXAiLCJfcG9wdXBIYW5kbGVyc0FkZGVkIiwiX29wZW5Qb3B1cCIsImtleXByZXNzIiwiX29uS2V5UHJlc3MiLCJtb3ZlIiwiX21vdmVQb3B1cCIsInVuYmluZFBvcHVwIiwidG9nZ2xlUG9wdXAiLCJpc1BvcHVwT3BlbiIsInNldFBvcHVwQ29udGVudCIsImdldFBvcHVwIiwiVG9vbHRpcCIsImRpcmVjdGlvbiIsInBlcm1hbmVudCIsInN0aWNreSIsInRvb2x0aXAiLCJfc2V0UG9zaXRpb24iLCJzdWJYIiwic3ViWSIsInRvb2x0aXBQb2ludCIsInRvb2x0aXBXaWR0aCIsInRvb2x0aXBIZWlnaHQiLCJvcGVuVG9vbHRpcCIsImNsb3NlVG9vbHRpcCIsImJpbmRUb29sdGlwIiwiX3Rvb2x0aXAiLCJpc1Rvb2x0aXBPcGVuIiwidW5iaW5kVG9vbHRpcCIsIl9pbml0VG9vbHRpcEludGVyYWN0aW9ucyIsIl90b29sdGlwSGFuZGxlcnNBZGRlZCIsIl9tb3ZlVG9vbHRpcCIsIl9vcGVuVG9vbHRpcCIsIl9hZGRGb2N1c0xpc3RlbmVycyIsIm1vdXNlbW92ZSIsIl9zZXRBcmlhRGVzY3JpYmVkQnlPbkxheWVyIiwidG9nZ2xlVG9vbHRpcCIsInNldFRvb2x0aXBDb250ZW50IiwiZ2V0VG9vbHRpcCIsIl9hZGRGb2N1c0xpc3RlbmVyc09uTGF5ZXIiLCJtb3ZpbmciLCJfb3Blbk9uY2VGbGFnIiwiRGl2SWNvbiIsImJnUG9zIiwiRWxlbWVudCIsImJhY2tncm91bmRQb3NpdGlvbiIsImRpdkljb24iLCJEZWZhdWx0IiwiR3JpZExheWVyIiwidGlsZVNpemUiLCJ1cGRhdGVXaGVuWm9vbWluZyIsInVwZGF0ZUludGVydmFsIiwibWF4TmF0aXZlWm9vbSIsIm1pbk5hdGl2ZVpvb20iLCJub1dyYXAiLCJrZWVwQnVmZmVyIiwiX2xldmVscyIsIl90aWxlcyIsIl9yZW1vdmVBbGxUaWxlcyIsIl90aWxlWm9vbSIsIl9zZXRBdXRvWkluZGV4IiwiaXNMb2FkaW5nIiwiX2xvYWRpbmciLCJ0aWxlWm9vbSIsIl9jbGFtcFpvb20iLCJfdXBkYXRlTGV2ZWxzIiwidmlld3ByZXJlc2V0IiwiX2ludmFsaWRhdGVBbGwiLCJjcmVhdGVUaWxlIiwiZ2V0VGlsZVNpemUiLCJjb21wYXJlIiwiY2hpbGRyZW4iLCJlZGdlWkluZGV4IiwiaXNGaW5pdGUiLCJuZXh0RnJhbWUiLCJ3aWxsUHJ1bmUiLCJ0aWxlIiwiY3VycmVudCIsImxvYWRlZCIsImZhZGUiLCJhY3RpdmUiLCJfb25PcGFxdWVUaWxlIiwiX25vUHJ1bmUiLCJfcHJ1bmVUaWxlcyIsIl9mYWRlRnJhbWUiLCJOdW1iZXIiLCJfb25VcGRhdGVMZXZlbCIsIl9yZW1vdmVUaWxlc0F0Wm9vbSIsIl9vblJlbW92ZUxldmVsIiwibGV2ZWwiLCJfc2V0Wm9vbVRyYW5zZm9ybSIsIl9vbkNyZWF0ZUxldmVsIiwiX2xldmVsIiwicmV0YWluIiwiX3JldGFpblBhcmVudCIsIl9yZXRhaW5DaGlsZHJlbiIsIl9yZW1vdmVUaWxlIiwieDIiLCJ5MiIsInoyIiwiY29vcmRzMiIsIl90aWxlQ29vcmRzVG9LZXkiLCJhbmltYXRpbmciLCJfc2V0VmlldyIsIm5vUHJ1bmUiLCJ0aWxlWm9vbUNoYW5nZWQiLCJfYWJvcnRMb2FkaW5nIiwiX3Jlc2V0R3JpZCIsIl9zZXRab29tVHJhbnNmb3JtcyIsInRyYW5zbGF0ZSIsIl90aWxlU2l6ZSIsIl9nbG9iYWxUaWxlUmFuZ2UiLCJfcHhCb3VuZHNUb1RpbGVSYW5nZSIsIl93cmFwWCIsIl93cmFwWSIsIl9nZXRUaWxlZFBpeGVsQm91bmRzIiwibWFwWm9vbSIsImhhbGZTaXplIiwidGlsZVJhbmdlIiwidGlsZUNlbnRlciIsInF1ZXVlIiwibm9QcnVuZVJhbmdlIiwiX2lzVmFsaWRUaWxlIiwiZnJhZ21lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiX2FkZFRpbGUiLCJ0aWxlQm91bmRzIiwiX3RpbGVDb29yZHNUb0JvdW5kcyIsIl9rZXlUb0JvdW5kcyIsIl9rZXlUb1RpbGVDb29yZHMiLCJfdGlsZUNvb3Jkc1RvTndTZSIsIm53UG9pbnQiLCJzZVBvaW50IiwiYnAiLCJfaW5pdFRpbGUiLCJ0aWxlUG9zIiwiX2dldFRpbGVQb3MiLCJfd3JhcENvb3JkcyIsIl90aWxlUmVhZHkiLCJfbm9UaWxlc1RvTG9hZCIsIm5ld0Nvb3JkcyIsImdyaWRMYXllciIsIlRpbGVMYXllciIsInN1YmRvbWFpbnMiLCJlcnJvclRpbGVVcmwiLCJ6b29tT2Zmc2V0IiwidG1zIiwiem9vbVJldmVyc2UiLCJkZXRlY3RSZXRpbmEiLCJyZWZlcnJlclBvbGljeSIsIl9vblRpbGVSZW1vdmUiLCJub1JlZHJhdyIsImRvbmUiLCJfdGlsZU9uTG9hZCIsIl90aWxlT25FcnJvciIsImdldFRpbGVVcmwiLCJfZ2V0U3ViZG9tYWluIiwiX2dldFpvb21Gb3JVcmwiLCJpbnZlcnRlZFkiLCJnZXRBdHRyaWJ1dGUiLCJ0aWxlUG9pbnQiLCJjb21wbGV0ZSIsInRpbGVMYXllciIsIlRpbGVMYXllcldNUyIsImRlZmF1bHRXbXNQYXJhbXMiLCJzZXJ2aWNlIiwicmVxdWVzdCIsInN0eWxlcyIsImZvcm1hdCIsInRyYW5zcGFyZW50IiwidmVyc2lvbiIsIndtc1BhcmFtcyIsInJlYWxSZXRpbmEiLCJfY3JzIiwiX3dtc1ZlcnNpb24iLCJwYXJzZUZsb2F0IiwicHJvamVjdGlvbktleSIsImJib3giLCJzZXRQYXJhbXMiLCJ0aWxlTGF5ZXJXTVMiLCJXTVMiLCJ3bXMiLCJSZW5kZXJlciIsIl91cGRhdGVQYXRocyIsIl9kZXN0cm95Q29udGFpbmVyIiwiX29uWm9vbSIsInpvb21lbmQiLCJfb25ab29tRW5kIiwiX29uQW5pbVpvb20iLCJfdXBkYXRlVHJhbnNmb3JtIiwiY3VycmVudENlbnRlclBvaW50IiwiX2NlbnRlciIsInRvcExlZnRPZmZzZXQiLCJDYW52YXMiLCJfb25WaWV3UHJlUmVzZXQiLCJfcG9zdHBvbmVVcGRhdGVQYXRocyIsIl9kcmF3IiwiX29uTW91c2VNb3ZlIiwiX29uQ2xpY2siLCJfaGFuZGxlTW91c2VPdXQiLCJfY3R4IiwiX3JlZHJhd1JlcXVlc3QiLCJfcmVkcmF3Qm91bmRzIiwiX3JlZHJhdyIsIm0iLCJfdXBkYXRlRGFzaEFycmF5Iiwib3JkZXIiLCJfb3JkZXIiLCJfZHJhd0xhc3QiLCJuZXh0IiwiX2RyYXdGaXJzdCIsIl9yZXF1ZXN0UmVkcmF3IiwiX2V4dGVuZFJlZHJhd0JvdW5kcyIsImRhc2hWYWx1ZSIsIl9kYXNoQXJyYXkiLCJfY2xlYXIiLCJjbGVhclJlY3QiLCJzYXZlIiwicmVzdG9yZSIsImJlZ2luUGF0aCIsImNsaXAiLCJfZHJhd2luZyIsImNsb3NlUGF0aCIsIl9maWxsU3Ryb2tlIiwiYXJjIiwiZ2xvYmFsQWxwaGEiLCJmaWxsU3R5bGUiLCJzZXRMaW5lRGFzaCIsImxpbmVXaWR0aCIsInN0cm9rZVN0eWxlIiwiY2xpY2tlZExheWVyIiwiX2ZpcmVFdmVudCIsIl9oYW5kbGVNb3VzZUhvdmVyIiwiX2hvdmVyZWRMYXllciIsIl9tb3VzZUhvdmVyVGhyb3R0bGVkIiwiY2FuZGlkYXRlSG92ZXJlZExheWVyIiwidm1sQ3JlYXRlIiwibmFtZXNwYWNlcyIsInZtbE1peGluIiwiY29vcmRzaXplIiwiX3N0cm9rZSIsIl9maWxsIiwic3Ryb2tlZCIsImZpbGxlZCIsImRhc2hTdHlsZSIsImVuZGNhcCIsImpvaW5zdHlsZSIsIl9zZXRQYXRoIiwiU1ZHIiwiX3Jvb3RHcm91cCIsIl9zdmdTaXplIiwicmVtb3ZlQXR0cmlidXRlIiwiX2dldFBhbmVSZW5kZXJlciIsIl9jcmVhdGVSZW5kZXJlciIsInByZWZlckNhbnZhcyIsIlJlY3RhbmdsZSIsIl9ib3VuZHNUb0xhdExuZ3MiLCJyZWN0YW5nbGUiLCJCb3hab29tIiwiX3BhbmUiLCJvdmVybGF5UGFuZSIsIl9yZXNldFN0YXRlVGltZW91dCIsIl9kZXN0cm95IiwiX29uTW91c2VEb3duIiwiX3Jlc2V0U3RhdGUiLCJfY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUiLCJjb250ZXh0bWVudSIsIm1vdXNldXAiLCJfb25Nb3VzZVVwIiwiX29uS2V5RG93biIsIl9ib3giLCJfZmluaXNoIiwiYm94Wm9vbUJvdW5kcyIsImRvdWJsZUNsaWNrWm9vbSIsIkRvdWJsZUNsaWNrWm9vbSIsIl9vbkRvdWJsZUNsaWNrIiwiaW5lcnRpYSIsImluZXJ0aWFEZWNlbGVyYXRpb24iLCJpbmVydGlhTWF4U3BlZWQiLCJ3b3JsZENvcHlKdW1wIiwibWF4Qm91bmRzVmlzY29zaXR5IiwiRHJhZyIsIl9vblByZURyYWdMaW1pdCIsIl9vblByZURyYWdXcmFwIiwiX3Bvc2l0aW9ucyIsIl90aW1lcyIsIl9vZmZzZXRMaW1pdCIsIl92aXNjb3NpdHkiLCJfbGFzdFRpbWUiLCJfbGFzdFBvcyIsIl9hYnNQb3MiLCJfcHJ1bmVQb3NpdGlvbnMiLCJzaGlmdCIsInB4Q2VudGVyIiwicHhXb3JsZENlbnRlciIsIl9pbml0aWFsV29ybGRPZmZzZXQiLCJfd29ybGRXaWR0aCIsIl92aXNjb3VzTGltaXQiLCJ0aHJlc2hvbGQiLCJsaW1pdCIsIndvcmxkV2lkdGgiLCJoYWxmV2lkdGgiLCJuZXdYMSIsIm5ld1gyIiwibmV3WCIsImVhc2UiLCJzcGVlZFZlY3RvciIsImxpbWl0ZWRTcGVlZCIsImxpbWl0ZWRTcGVlZFZlY3RvciIsImRlY2VsZXJhdGlvbkR1cmF0aW9uIiwia2V5Ym9hcmRQYW5EZWx0YSIsIktleWJvYXJkIiwia2V5Q29kZXMiLCJkb3duIiwidXAiLCJfc2V0UGFuRGVsdGEiLCJfc2V0Wm9vbURlbHRhIiwiX29uRm9jdXMiLCJibHVyIiwiX29uQmx1ciIsIm1vdXNlZG93biIsIl9hZGRIb29rcyIsIl9yZW1vdmVIb29rcyIsIl9mb2N1c2VkIiwiZG9jRWwiLCJzY3JvbGxUbyIsInBhbkRlbHRhIiwia2V5cyIsIl9wYW5LZXlzIiwiY29kZXMiLCJfem9vbUtleXMiLCJhbHRLZXkiLCJjdHJsS2V5IiwibWV0YUtleSIsIm5ld0xhdExuZyIsInNjcm9sbFdoZWVsWm9vbSIsIndoZWVsRGVib3VuY2VUaW1lIiwid2hlZWxQeFBlclpvb21MZXZlbCIsIlNjcm9sbFdoZWVsWm9vbSIsIl9vbldoZWVsU2Nyb2xsIiwiX2RlbHRhIiwiZGVib3VuY2UiLCJfbGFzdE1vdXNlUG9zIiwiX3RpbWVyIiwiX3BlcmZvcm1ab29tIiwiZDIiLCJkMyIsImQ0IiwidGFwSG9sZERlbGF5IiwidGFwSG9sZCIsInRhcFRvbGVyYW5jZSIsIlRhcEhvbGQiLCJfaG9sZFRpbWVvdXQiLCJfY2FuY2VsIiwiX2lzVGFwVmFsaWQiLCJfY2FuY2VsQ2xpY2tQcmV2ZW50IiwiX3NpbXVsYXRlRXZlbnQiLCJjYW5jZWxDbGlja1ByZXZlbnQiLCJzaW11bGF0ZWRFdmVudCIsIk1vdXNlRXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsInZpZXciLCJkaXNwYXRjaEV2ZW50IiwidG91Y2hab29tIiwiYm91bmNlQXRab29tTGltaXRzIiwiVG91Y2hab29tIiwiX29uVG91Y2hTdGFydCIsIl96b29taW5nIiwiX2NlbnRlclBvaW50IiwiX3N0YXJ0TGF0TG5nIiwiX3BpbmNoU3RhcnRMYXRMbmciLCJfc3RhcnREaXN0IiwiX3N0YXJ0Wm9vbSIsIl9vblRvdWNoTW92ZSIsIl9vblRvdWNoRW5kIiwiX2FuaW1SZXF1ZXN0IiwibW92ZUZuIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/leaflet/dist/leaflet-src.js\n"));

/***/ })

}]);