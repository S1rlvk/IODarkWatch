/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/leaflet";
exports.ids = ["vendor-chunks/leaflet"];
exports.modules = {

/***/ "(ssr)/./node_modules/leaflet/dist/leaflet-src.js":
/*!**************************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet-src.js ***!
  \**************************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n/* @preserve\n * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com\n * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade\n */\n\n(function (global, factory) {\n  ( false ? 0 : _typeof(exports)) === 'object' && \"object\" !== 'undefined' ? factory(exports) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n})(this, function (exports) {\n  'use strict';\n\n  var version = \"1.9.4\";\n\n  /*\r\n   * @namespace Util\r\n   *\r\n   * Various utility functions, used by Leaflet internally.\r\n   */\n\n  // @function extend(dest: Object, src?: Object): Object\n  // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.\n  function extend(dest) {\n    var i, j, len, src;\n    for (j = 1, len = arguments.length; j < len; j++) {\n      src = arguments[j];\n      for (i in src) {\n        dest[i] = src[i];\n      }\n    }\n    return dest;\n  }\n\n  // @function create(proto: Object, properties?: Object): Object\n  // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)\n  var create$2 = Object.create || function () {\n    function F() {}\n    return function (proto) {\n      F.prototype = proto;\n      return new F();\n    };\n  }();\n\n  // @function bind(fn: Function, …): Function\n  // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n  // Has a `L.bind()` shortcut.\n  function bind(fn, obj) {\n    var slice = Array.prototype.slice;\n    if (fn.bind) {\n      return fn.bind.apply(fn, slice.call(arguments, 1));\n    }\n    var args = slice.call(arguments, 2);\n    return function () {\n      return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);\n    };\n  }\n\n  // @property lastId: Number\n  // Last unique ID used by [`stamp()`](#util-stamp)\n  var lastId = 0;\n\n  // @function stamp(obj: Object): Number\n  // Returns the unique ID of an object, assigning it one if it doesn't have it.\n  function stamp(obj) {\n    if (!('_leaflet_id' in obj)) {\n      obj['_leaflet_id'] = ++lastId;\n    }\n    return obj._leaflet_id;\n  }\n\n  // @function throttle(fn: Function, time: Number, context: Object): Function\n  // Returns a function which executes function `fn` with the given scope `context`\n  // (so that the `this` keyword refers to `context` inside `fn`'s code). The function\n  // `fn` will be called no more than one time per given amount of `time`. The arguments\n  // received by the bound function will be any arguments passed when binding the\n  // function, followed by any arguments passed when invoking the bound function.\n  // Has an `L.throttle` shortcut.\n  function throttle(fn, time, context) {\n    var lock, args, wrapperFn, later;\n    later = function later() {\n      // reset lock and call if queued\n      lock = false;\n      if (args) {\n        wrapperFn.apply(context, args);\n        args = false;\n      }\n    };\n    wrapperFn = function wrapperFn() {\n      if (lock) {\n        // called too soon, queue to call later\n        args = arguments;\n      } else {\n        // call and lock until later\n        fn.apply(context, arguments);\n        setTimeout(later, time);\n        lock = true;\n      }\n    };\n    return wrapperFn;\n  }\n\n  // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number\n  // Returns the number `num` modulo `range` in such a way so it lies within\n  // `range[0]` and `range[1]`. The returned value will be always smaller than\n  // `range[1]` unless `includeMax` is set to `true`.\n  function wrapNum(x, range, includeMax) {\n    var max = range[1],\n      min = range[0],\n      d = max - min;\n    return x === max && includeMax ? x : ((x - min) % d + d) % d + min;\n  }\n\n  // @function falseFn(): Function\n  // Returns a function which always returns `false`.\n  function falseFn() {\n    return false;\n  }\n\n  // @function formatNum(num: Number, precision?: Number|false): Number\n  // Returns the number `num` rounded with specified `precision`.\n  // The default `precision` value is 6 decimal places.\n  // `false` can be passed to skip any processing (can be useful to avoid round-off errors).\n  function formatNum(num, precision) {\n    if (precision === false) {\n      return num;\n    }\n    var pow = Math.pow(10, precision === undefined ? 6 : precision);\n    return Math.round(num * pow) / pow;\n  }\n\n  // @function trim(str: String): String\n  // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)\n  function trim(str) {\n    return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n  }\n\n  // @function splitWords(str: String): String[]\n  // Trims and splits the string on whitespace and returns the array of parts.\n  function splitWords(str) {\n    return trim(str).split(/\\s+/);\n  }\n\n  // @function setOptions(obj: Object, options: Object): Object\n  // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.\n  function setOptions(obj, options) {\n    if (!Object.prototype.hasOwnProperty.call(obj, 'options')) {\n      obj.options = obj.options ? create$2(obj.options) : {};\n    }\n    for (var i in options) {\n      obj.options[i] = options[i];\n    }\n    return obj.options;\n  }\n\n  // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String\n  // Converts an object into a parameter URL string, e.g. `{a: \"foo\", b: \"bar\"}`\n  // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will\n  // be appended at the end. If `uppercase` is `true`, the parameter names will\n  // be uppercased (e.g. `'?A=foo&B=bar'`)\n  function getParamString(obj, existingUrl, uppercase) {\n    var params = [];\n    for (var i in obj) {\n      params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\n    }\n    return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');\n  }\n  var templateRe = /\\{ *([\\w_ -]+) *\\}/g;\n\n  // @function template(str: String, data: Object): String\n  // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`\n  // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string\n  // `('Hello foo, bar')`. You can also specify functions instead of strings for\n  // data values — they will be evaluated passing `data` as an argument.\n  function template(str, data) {\n    return str.replace(templateRe, function (str, key) {\n      var value = data[key];\n      if (value === undefined) {\n        throw new Error('No value provided for variable ' + str);\n      } else if (typeof value === 'function') {\n        value = value(data);\n      }\n      return value;\n    });\n  }\n\n  // @function isArray(obj): Boolean\n  // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)\n  var isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  };\n\n  // @function indexOf(array: Array, el: Object): Number\n  // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)\n  function indexOf(array, el) {\n    for (var i = 0; i < array.length; i++) {\n      if (array[i] === el) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  // @property emptyImageUrl: String\n  // Data URI string containing a base64-encoded empty GIF image.\n  // Used as a hack to free memory from unused images on WebKit-powered\n  // mobile devices (by setting image `src` to this string).\n  var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';\n\n  // inspired by https://paulirish.com/2011/requestanimationframe-for-smart-animating/\n\n  function getPrefixed(name) {\n    return window['webkit' + name] || window['moz' + name] || window['ms' + name];\n  }\n  var lastTime = 0;\n\n  // fallback for IE 7-8\n  function timeoutDefer(fn) {\n    var time = +new Date(),\n      timeToCall = Math.max(0, 16 - (time - lastTime));\n    lastTime = time + timeToCall;\n    return window.setTimeout(fn, timeToCall);\n  }\n  var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;\n  var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function (id) {\n    window.clearTimeout(id);\n  };\n\n  // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number\n  // Schedules `fn` to be executed when the browser repaints. `fn` is bound to\n  // `context` if given. When `immediate` is set, `fn` is called immediately if\n  // the browser doesn't have native support for\n  // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),\n  // otherwise it's delayed. Returns a request ID that can be used to cancel the request.\n  function requestAnimFrame(fn, context, immediate) {\n    if (immediate && requestFn === timeoutDefer) {\n      fn.call(context);\n    } else {\n      return requestFn.call(window, bind(fn, context));\n    }\n  }\n\n  // @function cancelAnimFrame(id: Number): undefined\n  // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).\n  function cancelAnimFrame(id) {\n    if (id) {\n      cancelFn.call(window, id);\n    }\n  }\n  var Util = {\n    __proto__: null,\n    extend: extend,\n    create: create$2,\n    bind: bind,\n    get lastId() {\n      return lastId;\n    },\n    stamp: stamp,\n    throttle: throttle,\n    wrapNum: wrapNum,\n    falseFn: falseFn,\n    formatNum: formatNum,\n    trim: trim,\n    splitWords: splitWords,\n    setOptions: setOptions,\n    getParamString: getParamString,\n    template: template,\n    isArray: isArray,\n    indexOf: indexOf,\n    emptyImageUrl: emptyImageUrl,\n    requestFn: requestFn,\n    cancelFn: cancelFn,\n    requestAnimFrame: requestAnimFrame,\n    cancelAnimFrame: cancelAnimFrame\n  };\n\n  // @class Class\n  // @aka L.Class\n\n  // @section\n  // @uninheritable\n\n  // Thanks to John Resig and Dean Edwards for inspiration!\n\n  function Class() {}\n  Class.extend = function (props) {\n    // @function extend(props: Object): Function\n    // [Extends the current class](#class-inheritance) given the properties to be included.\n    // Returns a Javascript function that is a class constructor (to be called with `new`).\n    var NewClass = function NewClass() {\n      setOptions(this);\n\n      // call the constructor\n      if (this.initialize) {\n        this.initialize.apply(this, arguments);\n      }\n\n      // call all constructor hooks\n      this.callInitHooks();\n    };\n    var parentProto = NewClass.__super__ = this.prototype;\n    var proto = create$2(parentProto);\n    proto.constructor = NewClass;\n    NewClass.prototype = proto;\n\n    // inherit parent's statics\n    for (var i in this) {\n      if (Object.prototype.hasOwnProperty.call(this, i) && i !== 'prototype' && i !== '__super__') {\n        NewClass[i] = this[i];\n      }\n    }\n\n    // mix static properties into the class\n    if (props.statics) {\n      extend(NewClass, props.statics);\n    }\n\n    // mix includes into the prototype\n    if (props.includes) {\n      checkDeprecatedMixinEvents(props.includes);\n      extend.apply(null, [proto].concat(props.includes));\n    }\n\n    // mix given properties into the prototype\n    extend(proto, props);\n    delete proto.statics;\n    delete proto.includes;\n\n    // merge options\n    if (proto.options) {\n      proto.options = parentProto.options ? create$2(parentProto.options) : {};\n      extend(proto.options, props.options);\n    }\n    proto._initHooks = [];\n\n    // add method for calling all hooks\n    proto.callInitHooks = function () {\n      if (this._initHooksCalled) {\n        return;\n      }\n      if (parentProto.callInitHooks) {\n        parentProto.callInitHooks.call(this);\n      }\n      this._initHooksCalled = true;\n      for (var i = 0, len = proto._initHooks.length; i < len; i++) {\n        proto._initHooks[i].call(this);\n      }\n    };\n    return NewClass;\n  };\n\n  // @function include(properties: Object): this\n  // [Includes a mixin](#class-includes) into the current class.\n  Class.include = function (props) {\n    var parentOptions = this.prototype.options;\n    extend(this.prototype, props);\n    if (props.options) {\n      this.prototype.options = parentOptions;\n      this.mergeOptions(props.options);\n    }\n    return this;\n  };\n\n  // @function mergeOptions(options: Object): this\n  // [Merges `options`](#class-options) into the defaults of the class.\n  Class.mergeOptions = function (options) {\n    extend(this.prototype.options, options);\n    return this;\n  };\n\n  // @function addInitHook(fn: Function): this\n  // Adds a [constructor hook](#class-constructor-hooks) to the class.\n  Class.addInitHook = function (fn) {\n    // (Function) || (String, args...)\n    var args = Array.prototype.slice.call(arguments, 1);\n    var init = typeof fn === 'function' ? fn : function () {\n      this[fn].apply(this, args);\n    };\n    this.prototype._initHooks = this.prototype._initHooks || [];\n    this.prototype._initHooks.push(init);\n    return this;\n  };\n  function checkDeprecatedMixinEvents(includes) {\n    /* global L: true */\n    if (typeof L === 'undefined' || !L || !L.Mixin) {\n      return;\n    }\n    includes = isArray(includes) ? includes : [includes];\n    for (var i = 0; i < includes.length; i++) {\n      if (includes[i] === L.Mixin.Events) {\n        console.warn('Deprecated include of L.Mixin.Events: ' + 'this property will be removed in future releases, ' + 'please inherit from L.Evented instead.', new Error().stack);\n      }\n    }\n  }\n\n  /*\r\n   * @class Evented\r\n   * @aka L.Evented\r\n   * @inherits Class\r\n   *\r\n   * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * map.on('click', function(e) {\r\n   * \talert(e.latlng);\r\n   * } );\r\n   * ```\r\n   *\r\n   * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:\r\n   *\r\n   * ```js\r\n   * function onClick(e) { ... }\r\n   *\r\n   * map.on('click', onClick);\r\n   * map.off('click', onClick);\r\n   * ```\r\n   */\n\n  var Events = {\n    /* @method on(type: String, fn: Function, context?: Object): this\r\n     * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).\r\n     *\r\n     * @alternative\r\n     * @method on(eventMap: Object): this\r\n     * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\n     */\n    on: function on(types, fn, context) {\n      // types can be a map of types/handlers\n      if (_typeof(types) === 'object') {\n        for (var type in types) {\n          // we don't process space-separated events here for performance;\n          // it's a hot path since Layer uses the on(obj) syntax\n          this._on(type, types[type], fn);\n        }\n      } else {\n        // types can be a string of space-separated words\n        types = splitWords(types);\n        for (var i = 0, len = types.length; i < len; i++) {\n          this._on(types[i], fn, context);\n        }\n      }\n      return this;\n    },\n    /* @method off(type: String, fn?: Function, context?: Object): this\r\n     * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.\r\n     *\r\n     * @alternative\r\n     * @method off(eventMap: Object): this\r\n     * Removes a set of type/listener pairs.\r\n     *\r\n     * @alternative\r\n     * @method off: this\r\n     * Removes all listeners to all events on the object. This includes implicitly attached events.\r\n     */\n    off: function off(types, fn, context) {\n      if (!arguments.length) {\n        // clear all listeners if called without arguments\n        delete this._events;\n      } else if (_typeof(types) === 'object') {\n        for (var type in types) {\n          this._off(type, types[type], fn);\n        }\n      } else {\n        types = splitWords(types);\n        var removeAll = arguments.length === 1;\n        for (var i = 0, len = types.length; i < len; i++) {\n          if (removeAll) {\n            this._off(types[i]);\n          } else {\n            this._off(types[i], fn, context);\n          }\n        }\n      }\n      return this;\n    },\n    // attach listener (without syntactic sugar now)\n    _on: function _on(type, fn, context, _once) {\n      if (typeof fn !== 'function') {\n        console.warn('wrong listener type: ' + _typeof(fn));\n        return;\n      }\n\n      // check if fn already there\n      if (this._listens(type, fn, context) !== false) {\n        return;\n      }\n      if (context === this) {\n        // Less memory footprint.\n        context = undefined;\n      }\n      var newListener = {\n        fn: fn,\n        ctx: context\n      };\n      if (_once) {\n        newListener.once = true;\n      }\n      this._events = this._events || {};\n      this._events[type] = this._events[type] || [];\n      this._events[type].push(newListener);\n    },\n    _off: function _off(type, fn, context) {\n      var listeners, i, len;\n      if (!this._events) {\n        return;\n      }\n      listeners = this._events[type];\n      if (!listeners) {\n        return;\n      }\n      if (arguments.length === 1) {\n        // remove all\n        if (this._firingCount) {\n          // Set all removed listeners to noop\n          // so they are not called if remove happens in fire\n          for (i = 0, len = listeners.length; i < len; i++) {\n            listeners[i].fn = falseFn;\n          }\n        }\n        // clear all listeners for a type if function isn't specified\n        delete this._events[type];\n        return;\n      }\n      if (typeof fn !== 'function') {\n        console.warn('wrong listener type: ' + _typeof(fn));\n        return;\n      }\n\n      // find fn and remove it\n      var index = this._listens(type, fn, context);\n      if (index !== false) {\n        var listener = listeners[index];\n        if (this._firingCount) {\n          // set the removed listener to noop so that's not called if remove happens in fire\n          listener.fn = falseFn;\n\n          /* copy array in case events are being fired */\n          this._events[type] = listeners = listeners.slice();\n        }\n        listeners.splice(index, 1);\n      }\n    },\n    // @method fire(type: String, data?: Object, propagate?: Boolean): this\n    // Fires an event of the specified type. You can optionally provide a data\n    // object — the first argument of the listener function will contain its\n    // properties. The event can optionally be propagated to event parents.\n    fire: function fire(type, data, propagate) {\n      if (!this.listens(type, propagate)) {\n        return this;\n      }\n      var event = extend({}, data, {\n        type: type,\n        target: this,\n        sourceTarget: data && data.sourceTarget || this\n      });\n      if (this._events) {\n        var listeners = this._events[type];\n        if (listeners) {\n          this._firingCount = this._firingCount + 1 || 1;\n          for (var i = 0, len = listeners.length; i < len; i++) {\n            var l = listeners[i];\n            // off overwrites l.fn, so we need to copy fn to a var\n            var fn = l.fn;\n            if (l.once) {\n              this.off(type, fn, l.ctx);\n            }\n            fn.call(l.ctx || this, event);\n          }\n          this._firingCount--;\n        }\n      }\n      if (propagate) {\n        // propagate the event to parents (set with addEventParent)\n        this._propagateEvent(event);\n      }\n      return this;\n    },\n    // @method listens(type: String, propagate?: Boolean): Boolean\n    // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean\n    // Returns `true` if a particular event type has any listeners attached to it.\n    // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.\n    listens: function listens(type, fn, context, propagate) {\n      if (typeof type !== 'string') {\n        console.warn('\"string\" type argument expected');\n      }\n\n      // we don't overwrite the input `fn` value, because we need to use it for propagation\n      var _fn = fn;\n      if (typeof fn !== 'function') {\n        propagate = !!fn;\n        _fn = undefined;\n        context = undefined;\n      }\n      var listeners = this._events && this._events[type];\n      if (listeners && listeners.length) {\n        if (this._listens(type, _fn, context) !== false) {\n          return true;\n        }\n      }\n      if (propagate) {\n        // also check parents for listeners if event propagates\n        for (var id in this._eventParents) {\n          if (this._eventParents[id].listens(type, fn, context, propagate)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    },\n    // returns the index (number) or false\n    _listens: function _listens(type, fn, context) {\n      if (!this._events) {\n        return false;\n      }\n      var listeners = this._events[type] || [];\n      if (!fn) {\n        return !!listeners.length;\n      }\n      if (context === this) {\n        // Less memory footprint.\n        context = undefined;\n      }\n      for (var i = 0, len = listeners.length; i < len; i++) {\n        if (listeners[i].fn === fn && listeners[i].ctx === context) {\n          return i;\n        }\n      }\n      return false;\n    },\n    // @method once(…): this\n    // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.\n    once: function once(types, fn, context) {\n      // types can be a map of types/handlers\n      if (_typeof(types) === 'object') {\n        for (var type in types) {\n          // we don't process space-separated events here for performance;\n          // it's a hot path since Layer uses the on(obj) syntax\n          this._on(type, types[type], fn, true);\n        }\n      } else {\n        // types can be a string of space-separated words\n        types = splitWords(types);\n        for (var i = 0, len = types.length; i < len; i++) {\n          this._on(types[i], fn, context, true);\n        }\n      }\n      return this;\n    },\n    // @method addEventParent(obj: Evented): this\n    // Adds an event parent - an `Evented` that will receive propagated events\n    addEventParent: function addEventParent(obj) {\n      this._eventParents = this._eventParents || {};\n      this._eventParents[stamp(obj)] = obj;\n      return this;\n    },\n    // @method removeEventParent(obj: Evented): this\n    // Removes an event parent, so it will stop receiving propagated events\n    removeEventParent: function removeEventParent(obj) {\n      if (this._eventParents) {\n        delete this._eventParents[stamp(obj)];\n      }\n      return this;\n    },\n    _propagateEvent: function _propagateEvent(e) {\n      for (var id in this._eventParents) {\n        this._eventParents[id].fire(e.type, extend({\n          layer: e.target,\n          propagatedFrom: e.target\n        }, e), true);\n      }\n    }\n  };\n\n  // aliases; we should ditch those eventually\n\n  // @method addEventListener(…): this\n  // Alias to [`on(…)`](#evented-on)\n  Events.addEventListener = Events.on;\n\n  // @method removeEventListener(…): this\n  // Alias to [`off(…)`](#evented-off)\n\n  // @method clearAllEventListeners(…): this\n  // Alias to [`off()`](#evented-off)\n  Events.removeEventListener = Events.clearAllEventListeners = Events.off;\n\n  // @method addOneTimeEventListener(…): this\n  // Alias to [`once(…)`](#evented-once)\n  Events.addOneTimeEventListener = Events.once;\n\n  // @method fireEvent(…): this\n  // Alias to [`fire(…)`](#evented-fire)\n  Events.fireEvent = Events.fire;\n\n  // @method hasEventListeners(…): Boolean\n  // Alias to [`listens(…)`](#evented-listens)\n  Events.hasEventListeners = Events.listens;\n  var Evented = Class.extend(Events);\n\n  /*\r\n   * @class Point\r\n   * @aka L.Point\r\n   *\r\n   * Represents a point with `x` and `y` coordinates in pixels.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var point = L.point(200, 300);\r\n   * ```\r\n   *\r\n   * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```js\r\n   * map.panBy([200, 300]);\r\n   * map.panBy(L.point(200, 300));\r\n   * ```\r\n   *\r\n   * Note that `Point` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n  function Point(x, y, round) {\n    // @property x: Number; The `x` coordinate of the point\n    this.x = round ? Math.round(x) : x;\n    // @property y: Number; The `y` coordinate of the point\n    this.y = round ? Math.round(y) : y;\n  }\n  var trunc = Math.trunc || function (v) {\n    return v > 0 ? Math.floor(v) : Math.ceil(v);\n  };\n  Point.prototype = {\n    // @method clone(): Point\n    // Returns a copy of the current point.\n    clone: function clone() {\n      return new Point(this.x, this.y);\n    },\n    // @method add(otherPoint: Point): Point\n    // Returns the result of addition of the current and the given points.\n    add: function add(point) {\n      // non-destructive, returns a new point\n      return this.clone()._add(toPoint(point));\n    },\n    _add: function _add(point) {\n      // destructive, used directly for performance in situations where it's safe to modify existing point\n      this.x += point.x;\n      this.y += point.y;\n      return this;\n    },\n    // @method subtract(otherPoint: Point): Point\n    // Returns the result of subtraction of the given point from the current.\n    subtract: function subtract(point) {\n      return this.clone()._subtract(toPoint(point));\n    },\n    _subtract: function _subtract(point) {\n      this.x -= point.x;\n      this.y -= point.y;\n      return this;\n    },\n    // @method divideBy(num: Number): Point\n    // Returns the result of division of the current point by the given number.\n    divideBy: function divideBy(num) {\n      return this.clone()._divideBy(num);\n    },\n    _divideBy: function _divideBy(num) {\n      this.x /= num;\n      this.y /= num;\n      return this;\n    },\n    // @method multiplyBy(num: Number): Point\n    // Returns the result of multiplication of the current point by the given number.\n    multiplyBy: function multiplyBy(num) {\n      return this.clone()._multiplyBy(num);\n    },\n    _multiplyBy: function _multiplyBy(num) {\n      this.x *= num;\n      this.y *= num;\n      return this;\n    },\n    // @method scaleBy(scale: Point): Point\n    // Multiply each coordinate of the current point by each coordinate of\n    // `scale`. In linear algebra terms, multiply the point by the\n    // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)\n    // defined by `scale`.\n    scaleBy: function scaleBy(point) {\n      return new Point(this.x * point.x, this.y * point.y);\n    },\n    // @method unscaleBy(scale: Point): Point\n    // Inverse of `scaleBy`. Divide each coordinate of the current point by\n    // each coordinate of `scale`.\n    unscaleBy: function unscaleBy(point) {\n      return new Point(this.x / point.x, this.y / point.y);\n    },\n    // @method round(): Point\n    // Returns a copy of the current point with rounded coordinates.\n    round: function round() {\n      return this.clone()._round();\n    },\n    _round: function _round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      return this;\n    },\n    // @method floor(): Point\n    // Returns a copy of the current point with floored coordinates (rounded down).\n    floor: function floor() {\n      return this.clone()._floor();\n    },\n    _floor: function _floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      return this;\n    },\n    // @method ceil(): Point\n    // Returns a copy of the current point with ceiled coordinates (rounded up).\n    ceil: function ceil() {\n      return this.clone()._ceil();\n    },\n    _ceil: function _ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      return this;\n    },\n    // @method trunc(): Point\n    // Returns a copy of the current point with truncated coordinates (rounded towards zero).\n    trunc: function trunc() {\n      return this.clone()._trunc();\n    },\n    _trunc: function _trunc() {\n      this.x = trunc(this.x);\n      this.y = trunc(this.y);\n      return this;\n    },\n    // @method distanceTo(otherPoint: Point): Number\n    // Returns the cartesian distance between the current and the given points.\n    distanceTo: function distanceTo(point) {\n      point = toPoint(point);\n      var x = point.x - this.x,\n        y = point.y - this.y;\n      return Math.sqrt(x * x + y * y);\n    },\n    // @method equals(otherPoint: Point): Boolean\n    // Returns `true` if the given point has the same coordinates.\n    equals: function equals(point) {\n      point = toPoint(point);\n      return point.x === this.x && point.y === this.y;\n    },\n    // @method contains(otherPoint: Point): Boolean\n    // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).\n    contains: function contains(point) {\n      point = toPoint(point);\n      return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);\n    },\n    // @method toString(): String\n    // Returns a string representation of the point for debugging purposes.\n    toString: function toString() {\n      return 'Point(' + formatNum(this.x) + ', ' + formatNum(this.y) + ')';\n    }\n  };\n\n  // @factory L.point(x: Number, y: Number, round?: Boolean)\n  // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.\n\n  // @alternative\n  // @factory L.point(coords: Number[])\n  // Expects an array of the form `[x, y]` instead.\n\n  // @alternative\n  // @factory L.point(coords: Object)\n  // Expects a plain object of the form `{x: Number, y: Number}` instead.\n  function toPoint(x, y, round) {\n    if (x instanceof Point) {\n      return x;\n    }\n    if (isArray(x)) {\n      return new Point(x[0], x[1]);\n    }\n    if (x === undefined || x === null) {\n      return x;\n    }\n    if (_typeof(x) === 'object' && 'x' in x && 'y' in x) {\n      return new Point(x.x, x.y);\n    }\n    return new Point(x, y, round);\n  }\n\n  /*\r\n   * @class Bounds\r\n   * @aka L.Bounds\r\n   *\r\n   * Represents a rectangular area in pixel coordinates.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var p1 = L.point(10, 10),\r\n   * p2 = L.point(40, 60),\r\n   * bounds = L.bounds(p1, p2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * otherBounds.intersects([[10, 10], [40, 60]]);\r\n   * ```\r\n   *\r\n   * Note that `Bounds` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n  function Bounds(a, b) {\n    if (!a) {\n      return;\n    }\n    var points = b ? [a, b] : a;\n    for (var i = 0, len = points.length; i < len; i++) {\n      this.extend(points[i]);\n    }\n  }\n  Bounds.prototype = {\n    // @method extend(point: Point): this\n    // Extends the bounds to contain the given point.\n\n    // @alternative\n    // @method extend(otherBounds: Bounds): this\n    // Extend the bounds to contain the given bounds\n    extend: function extend(obj) {\n      var min2, max2;\n      if (!obj) {\n        return this;\n      }\n      if (obj instanceof Point || typeof obj[0] === 'number' || 'x' in obj) {\n        min2 = max2 = toPoint(obj);\n      } else {\n        obj = toBounds(obj);\n        min2 = obj.min;\n        max2 = obj.max;\n        if (!min2 || !max2) {\n          return this;\n        }\n      }\n\n      // @property min: Point\n      // The top left corner of the rectangle.\n      // @property max: Point\n      // The bottom right corner of the rectangle.\n      if (!this.min && !this.max) {\n        this.min = min2.clone();\n        this.max = max2.clone();\n      } else {\n        this.min.x = Math.min(min2.x, this.min.x);\n        this.max.x = Math.max(max2.x, this.max.x);\n        this.min.y = Math.min(min2.y, this.min.y);\n        this.max.y = Math.max(max2.y, this.max.y);\n      }\n      return this;\n    },\n    // @method getCenter(round?: Boolean): Point\n    // Returns the center point of the bounds.\n    getCenter: function getCenter(round) {\n      return toPoint((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);\n    },\n    // @method getBottomLeft(): Point\n    // Returns the bottom-left point of the bounds.\n    getBottomLeft: function getBottomLeft() {\n      return toPoint(this.min.x, this.max.y);\n    },\n    // @method getTopRight(): Point\n    // Returns the top-right point of the bounds.\n    getTopRight: function getTopRight() {\n      // -> Point\n      return toPoint(this.max.x, this.min.y);\n    },\n    // @method getTopLeft(): Point\n    // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).\n    getTopLeft: function getTopLeft() {\n      return this.min; // left, top\n    },\n    // @method getBottomRight(): Point\n    // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).\n    getBottomRight: function getBottomRight() {\n      return this.max; // right, bottom\n    },\n    // @method getSize(): Point\n    // Returns the size of the given bounds\n    getSize: function getSize() {\n      return this.max.subtract(this.min);\n    },\n    // @method contains(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle contains the given one.\n    // @alternative\n    // @method contains(point: Point): Boolean\n    // Returns `true` if the rectangle contains the given point.\n    contains: function contains(obj) {\n      var min, max;\n      if (typeof obj[0] === 'number' || obj instanceof Point) {\n        obj = toPoint(obj);\n      } else {\n        obj = toBounds(obj);\n      }\n      if (obj instanceof Bounds) {\n        min = obj.min;\n        max = obj.max;\n      } else {\n        min = max = obj;\n      }\n      return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;\n    },\n    // @method intersects(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle intersects the given bounds. Two bounds\n    // intersect if they have at least one point in common.\n    intersects: function intersects(bounds) {\n      // (Bounds) -> Boolean\n      bounds = toBounds(bounds);\n      var min = this.min,\n        max = this.max,\n        min2 = bounds.min,\n        max2 = bounds.max,\n        xIntersects = max2.x >= min.x && min2.x <= max.x,\n        yIntersects = max2.y >= min.y && min2.y <= max.y;\n      return xIntersects && yIntersects;\n    },\n    // @method overlaps(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle overlaps the given bounds. Two bounds\n    // overlap if their intersection is an area.\n    overlaps: function overlaps(bounds) {\n      // (Bounds) -> Boolean\n      bounds = toBounds(bounds);\n      var min = this.min,\n        max = this.max,\n        min2 = bounds.min,\n        max2 = bounds.max,\n        xOverlaps = max2.x > min.x && min2.x < max.x,\n        yOverlaps = max2.y > min.y && min2.y < max.y;\n      return xOverlaps && yOverlaps;\n    },\n    // @method isValid(): Boolean\n    // Returns `true` if the bounds are properly initialized.\n    isValid: function isValid() {\n      return !!(this.min && this.max);\n    },\n    // @method pad(bufferRatio: Number): Bounds\n    // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.\n    // For example, a ratio of 0.5 extends the bounds by 50% in each direction.\n    // Negative values will retract the bounds.\n    pad: function pad(bufferRatio) {\n      var min = this.min,\n        max = this.max,\n        heightBuffer = Math.abs(min.x - max.x) * bufferRatio,\n        widthBuffer = Math.abs(min.y - max.y) * bufferRatio;\n      return toBounds(toPoint(min.x - heightBuffer, min.y - widthBuffer), toPoint(max.x + heightBuffer, max.y + widthBuffer));\n    },\n    // @method equals(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle is equivalent to the given bounds.\n    equals: function equals(bounds) {\n      if (!bounds) {\n        return false;\n      }\n      bounds = toBounds(bounds);\n      return this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight());\n    }\n  };\n\n  // @factory L.bounds(corner1: Point, corner2: Point)\n  // Creates a Bounds object from two corners coordinate pairs.\n  // @alternative\n  // @factory L.bounds(points: Point[])\n  // Creates a Bounds object from the given array of points.\n  function toBounds(a, b) {\n    if (!a || a instanceof Bounds) {\n      return a;\n    }\n    return new Bounds(a, b);\n  }\n\n  /*\r\n   * @class LatLngBounds\r\n   * @aka L.LatLngBounds\r\n   *\r\n   * Represents a rectangular geographical area on a map.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var corner1 = L.latLng(40.712, -74.227),\r\n   * corner2 = L.latLng(40.774, -74.125),\r\n   * bounds = L.latLngBounds(corner1, corner2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * map.fitBounds([\r\n   * \t[40.712, -74.227],\r\n   * \t[40.774, -74.125]\r\n   * ]);\r\n   * ```\r\n   *\r\n   * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.\r\n   *\r\n   * Note that `LatLngBounds` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n  function LatLngBounds(corner1, corner2) {\n    // (LatLng, LatLng) or (LatLng[])\n    if (!corner1) {\n      return;\n    }\n    var latlngs = corner2 ? [corner1, corner2] : corner1;\n    for (var i = 0, len = latlngs.length; i < len; i++) {\n      this.extend(latlngs[i]);\n    }\n  }\n  LatLngBounds.prototype = {\n    // @method extend(latlng: LatLng): this\n    // Extend the bounds to contain the given point\n\n    // @alternative\n    // @method extend(otherBounds: LatLngBounds): this\n    // Extend the bounds to contain the given bounds\n    extend: function extend(obj) {\n      var sw = this._southWest,\n        ne = this._northEast,\n        sw2,\n        ne2;\n      if (obj instanceof LatLng) {\n        sw2 = obj;\n        ne2 = obj;\n      } else if (obj instanceof LatLngBounds) {\n        sw2 = obj._southWest;\n        ne2 = obj._northEast;\n        if (!sw2 || !ne2) {\n          return this;\n        }\n      } else {\n        return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;\n      }\n      if (!sw && !ne) {\n        this._southWest = new LatLng(sw2.lat, sw2.lng);\n        this._northEast = new LatLng(ne2.lat, ne2.lng);\n      } else {\n        sw.lat = Math.min(sw2.lat, sw.lat);\n        sw.lng = Math.min(sw2.lng, sw.lng);\n        ne.lat = Math.max(ne2.lat, ne.lat);\n        ne.lng = Math.max(ne2.lng, ne.lng);\n      }\n      return this;\n    },\n    // @method pad(bufferRatio: Number): LatLngBounds\n    // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.\n    // For example, a ratio of 0.5 extends the bounds by 50% in each direction.\n    // Negative values will retract the bounds.\n    pad: function pad(bufferRatio) {\n      var sw = this._southWest,\n        ne = this._northEast,\n        heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\n        widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\n      return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\n    },\n    // @method getCenter(): LatLng\n    // Returns the center point of the bounds.\n    getCenter: function getCenter() {\n      return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);\n    },\n    // @method getSouthWest(): LatLng\n    // Returns the south-west point of the bounds.\n    getSouthWest: function getSouthWest() {\n      return this._southWest;\n    },\n    // @method getNorthEast(): LatLng\n    // Returns the north-east point of the bounds.\n    getNorthEast: function getNorthEast() {\n      return this._northEast;\n    },\n    // @method getNorthWest(): LatLng\n    // Returns the north-west point of the bounds.\n    getNorthWest: function getNorthWest() {\n      return new LatLng(this.getNorth(), this.getWest());\n    },\n    // @method getSouthEast(): LatLng\n    // Returns the south-east point of the bounds.\n    getSouthEast: function getSouthEast() {\n      return new LatLng(this.getSouth(), this.getEast());\n    },\n    // @method getWest(): Number\n    // Returns the west longitude of the bounds\n    getWest: function getWest() {\n      return this._southWest.lng;\n    },\n    // @method getSouth(): Number\n    // Returns the south latitude of the bounds\n    getSouth: function getSouth() {\n      return this._southWest.lat;\n    },\n    // @method getEast(): Number\n    // Returns the east longitude of the bounds\n    getEast: function getEast() {\n      return this._northEast.lng;\n    },\n    // @method getNorth(): Number\n    // Returns the north latitude of the bounds\n    getNorth: function getNorth() {\n      return this._northEast.lat;\n    },\n    // @method contains(otherBounds: LatLngBounds): Boolean\n    // Returns `true` if the rectangle contains the given one.\n\n    // @alternative\n    // @method contains (latlng: LatLng): Boolean\n    // Returns `true` if the rectangle contains the given point.\n    contains: function contains(obj) {\n      // (LatLngBounds) or (LatLng) -> Boolean\n      if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {\n        obj = toLatLng(obj);\n      } else {\n        obj = toLatLngBounds(obj);\n      }\n      var sw = this._southWest,\n        ne = this._northEast,\n        sw2,\n        ne2;\n      if (obj instanceof LatLngBounds) {\n        sw2 = obj.getSouthWest();\n        ne2 = obj.getNorthEast();\n      } else {\n        sw2 = ne2 = obj;\n      }\n      return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;\n    },\n    // @method intersects(otherBounds: LatLngBounds): Boolean\n    // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.\n    intersects: function intersects(bounds) {\n      bounds = toLatLngBounds(bounds);\n      var sw = this._southWest,\n        ne = this._northEast,\n        sw2 = bounds.getSouthWest(),\n        ne2 = bounds.getNorthEast(),\n        latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat,\n        lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;\n      return latIntersects && lngIntersects;\n    },\n    // @method overlaps(otherBounds: LatLngBounds): Boolean\n    // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.\n    overlaps: function overlaps(bounds) {\n      bounds = toLatLngBounds(bounds);\n      var sw = this._southWest,\n        ne = this._northEast,\n        sw2 = bounds.getSouthWest(),\n        ne2 = bounds.getNorthEast(),\n        latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat,\n        lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;\n      return latOverlaps && lngOverlaps;\n    },\n    // @method toBBoxString(): String\n    // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.\n    toBBoxString: function toBBoxString() {\n      return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\n    },\n    // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean\n    // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.\n    equals: function equals(bounds, maxMargin) {\n      if (!bounds) {\n        return false;\n      }\n      bounds = toLatLngBounds(bounds);\n      return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);\n    },\n    // @method isValid(): Boolean\n    // Returns `true` if the bounds are properly initialized.\n    isValid: function isValid() {\n      return !!(this._southWest && this._northEast);\n    }\n  };\n\n  // TODO International date line?\n\n  // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)\n  // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.\n\n  // @alternative\n  // @factory L.latLngBounds(latlngs: LatLng[])\n  // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).\n  function toLatLngBounds(a, b) {\n    if (a instanceof LatLngBounds) {\n      return a;\n    }\n    return new LatLngBounds(a, b);\n  }\n\n  /* @class LatLng\r\n   * @aka L.LatLng\r\n   *\r\n   * Represents a geographical point with a certain latitude and longitude.\r\n   *\r\n   * @example\r\n   *\r\n   * ```\r\n   * var latlng = L.latLng(50.5, 30.5);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```\r\n   * map.panTo([50, 30]);\r\n   * map.panTo({lon: 30, lat: 50});\r\n   * map.panTo({lat: 50, lng: 30});\r\n   * map.panTo(L.latLng(50, 30));\r\n   * ```\r\n   *\r\n   * Note that `LatLng` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n  function LatLng(lat, lng, alt) {\n    if (isNaN(lat) || isNaN(lng)) {\n      throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\n    }\n\n    // @property lat: Number\n    // Latitude in degrees\n    this.lat = +lat;\n\n    // @property lng: Number\n    // Longitude in degrees\n    this.lng = +lng;\n\n    // @property alt: Number\n    // Altitude in meters (optional)\n    if (alt !== undefined) {\n      this.alt = +alt;\n    }\n  }\n  LatLng.prototype = {\n    // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean\n    // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.\n    equals: function equals(obj, maxMargin) {\n      if (!obj) {\n        return false;\n      }\n      obj = toLatLng(obj);\n      var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));\n      return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);\n    },\n    // @method toString(): String\n    // Returns a string representation of the point (for debugging purposes).\n    toString: function toString(precision) {\n      return 'LatLng(' + formatNum(this.lat, precision) + ', ' + formatNum(this.lng, precision) + ')';\n    },\n    // @method distanceTo(otherLatLng: LatLng): Number\n    // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).\n    distanceTo: function distanceTo(other) {\n      return Earth.distance(this, toLatLng(other));\n    },\n    // @method wrap(): LatLng\n    // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.\n    wrap: function wrap() {\n      return Earth.wrapLatLng(this);\n    },\n    // @method toBounds(sizeInMeters: Number): LatLngBounds\n    // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.\n    toBounds: function toBounds(sizeInMeters) {\n      var latAccuracy = 180 * sizeInMeters / 40075017,\n        lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);\n      return toLatLngBounds([this.lat - latAccuracy, this.lng - lngAccuracy], [this.lat + latAccuracy, this.lng + lngAccuracy]);\n    },\n    clone: function clone() {\n      return new LatLng(this.lat, this.lng, this.alt);\n    }\n  };\n\n  // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng\n  // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).\n\n  // @alternative\n  // @factory L.latLng(coords: Array): LatLng\n  // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.\n\n  // @alternative\n  // @factory L.latLng(coords: Object): LatLng\n  // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.\n\n  function toLatLng(a, b, c) {\n    if (a instanceof LatLng) {\n      return a;\n    }\n    if (isArray(a) && _typeof(a[0]) !== 'object') {\n      if (a.length === 3) {\n        return new LatLng(a[0], a[1], a[2]);\n      }\n      if (a.length === 2) {\n        return new LatLng(a[0], a[1]);\n      }\n      return null;\n    }\n    if (a === undefined || a === null) {\n      return a;\n    }\n    if (_typeof(a) === 'object' && 'lat' in a) {\n      return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);\n    }\n    if (b === undefined) {\n      return null;\n    }\n    return new LatLng(a, b, c);\n  }\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.Base\r\n   * Object that defines coordinate reference systems for projecting\r\n   * geographical points into pixel (screen) coordinates and back (and to\r\n   * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See\r\n   * [spatial reference system](https://en.wikipedia.org/wiki/Spatial_reference_system).\r\n   *\r\n   * Leaflet defines the most usual CRSs by default. If you want to use a\r\n   * CRS not defined by default, take a look at the\r\n   * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.\r\n   *\r\n   * Note that the CRS instances do not inherit from Leaflet's `Class` object,\r\n   * and can't be instantiated. Also, new classes can't inherit from them,\r\n   * and methods can't be added to them with the `include` function.\r\n   */\n\n  var CRS = {\n    // @method latLngToPoint(latlng: LatLng, zoom: Number): Point\n    // Projects geographical coordinates into pixel coordinates for a given zoom.\n    latLngToPoint: function latLngToPoint(latlng, zoom) {\n      var projectedPoint = this.projection.project(latlng),\n        scale = this.scale(zoom);\n      return this.transformation._transform(projectedPoint, scale);\n    },\n    // @method pointToLatLng(point: Point, zoom: Number): LatLng\n    // The inverse of `latLngToPoint`. Projects pixel coordinates on a given\n    // zoom into geographical coordinates.\n    pointToLatLng: function pointToLatLng(point, zoom) {\n      var scale = this.scale(zoom),\n        untransformedPoint = this.transformation.untransform(point, scale);\n      return this.projection.unproject(untransformedPoint);\n    },\n    // @method project(latlng: LatLng): Point\n    // Projects geographical coordinates into coordinates in units accepted for\n    // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).\n    project: function project(latlng) {\n      return this.projection.project(latlng);\n    },\n    // @method unproject(point: Point): LatLng\n    // Given a projected coordinate returns the corresponding LatLng.\n    // The inverse of `project`.\n    unproject: function unproject(point) {\n      return this.projection.unproject(point);\n    },\n    // @method scale(zoom: Number): Number\n    // Returns the scale used when transforming projected coordinates into\n    // pixel coordinates for a particular zoom. For example, it returns\n    // `256 * 2^zoom` for Mercator-based CRS.\n    scale: function scale(zoom) {\n      return 256 * Math.pow(2, zoom);\n    },\n    // @method zoom(scale: Number): Number\n    // Inverse of `scale()`, returns the zoom level corresponding to a scale\n    // factor of `scale`.\n    zoom: function zoom(scale) {\n      return Math.log(scale / 256) / Math.LN2;\n    },\n    // @method getProjectedBounds(zoom: Number): Bounds\n    // Returns the projection's bounds scaled and transformed for the provided `zoom`.\n    getProjectedBounds: function getProjectedBounds(zoom) {\n      if (this.infinite) {\n        return null;\n      }\n      var b = this.projection.bounds,\n        s = this.scale(zoom),\n        min = this.transformation.transform(b.min, s),\n        max = this.transformation.transform(b.max, s);\n      return new Bounds(min, max);\n    },\n    // @method distance(latlng1: LatLng, latlng2: LatLng): Number\n    // Returns the distance between two geographical coordinates.\n\n    // @property code: String\n    // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)\n    //\n    // @property wrapLng: Number[]\n    // An array of two numbers defining whether the longitude (horizontal) coordinate\n    // axis wraps around a given range and how. Defaults to `[-180, 180]` in most\n    // geographical CRSs. If `undefined`, the longitude axis does not wrap around.\n    //\n    // @property wrapLat: Number[]\n    // Like `wrapLng`, but for the latitude (vertical) axis.\n\n    // wrapLng: [min, max],\n    // wrapLat: [min, max],\n\n    // @property infinite: Boolean\n    // If true, the coordinate space will be unbounded (infinite in both axes)\n    infinite: false,\n    // @method wrapLatLng(latlng: LatLng): LatLng\n    // Returns a `LatLng` where lat and lng has been wrapped according to the\n    // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.\n    wrapLatLng: function wrapLatLng(latlng) {\n      var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,\n        lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,\n        alt = latlng.alt;\n      return new LatLng(lat, lng, alt);\n    },\n    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\n    // Returns a `LatLngBounds` with the same size as the given one, ensuring\n    // that its center is within the CRS's bounds.\n    // Only accepts actual `L.LatLngBounds` instances, not arrays.\n    wrapLatLngBounds: function wrapLatLngBounds(bounds) {\n      var center = bounds.getCenter(),\n        newCenter = this.wrapLatLng(center),\n        latShift = center.lat - newCenter.lat,\n        lngShift = center.lng - newCenter.lng;\n      if (latShift === 0 && lngShift === 0) {\n        return bounds;\n      }\n      var sw = bounds.getSouthWest(),\n        ne = bounds.getNorthEast(),\n        newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),\n        newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);\n      return new LatLngBounds(newSw, newNe);\n    }\n  };\n\n  /*\n   * @namespace CRS\n   * @crs L.CRS.Earth\n   *\n   * Serves as the base for CRS that are global such that they cover the earth.\n   * Can only be used as the base for other CRS and cannot be used directly,\n   * since it does not have a `code`, `projection` or `transformation`. `distance()` returns\n   * meters.\n   */\n\n  var Earth = extend({}, CRS, {\n    wrapLng: [-180, 180],\n    // Mean Earth Radius, as recommended for use by\n    // the International Union of Geodesy and Geophysics,\n    // see https://rosettacode.org/wiki/Haversine_formula\n    R: 6371000,\n    // distance between two geographical points using spherical law of cosines approximation\n    distance: function distance(latlng1, latlng2) {\n      var rad = Math.PI / 180,\n        lat1 = latlng1.lat * rad,\n        lat2 = latlng2.lat * rad,\n        sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),\n        sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),\n        a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,\n        c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n      return this.R * c;\n    }\n  });\n\n  /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.SphericalMercator\r\n   *\r\n   * Spherical Mercator projection — the most common projection for online maps,\r\n   * used by almost all free and commercial tile providers. Assumes that Earth is\r\n   * a sphere. Used by the `EPSG:3857` CRS.\r\n   */\n\n  var earthRadius = 6378137;\n  var SphericalMercator = {\n    R: earthRadius,\n    MAX_LATITUDE: 85.0511287798,\n    project: function project(latlng) {\n      var d = Math.PI / 180,\n        max = this.MAX_LATITUDE,\n        lat = Math.max(Math.min(max, latlng.lat), -max),\n        sin = Math.sin(lat * d);\n      return new Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);\n    },\n    unproject: function unproject(point) {\n      var d = 180 / Math.PI;\n      return new LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);\n    },\n    bounds: function () {\n      var d = earthRadius * Math.PI;\n      return new Bounds([-d, -d], [d, d]);\n    }()\n  };\n\n  /*\r\n   * @class Transformation\r\n   * @aka L.Transformation\r\n   *\r\n   * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`\r\n   * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing\r\n   * the reverse. Used by Leaflet in its projections code.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var transformation = L.transformation(2, 5, -1, 10),\r\n   * \tp = L.point(1, 2),\r\n   * \tp2 = transformation.transform(p), //  L.point(7, 8)\r\n   * \tp3 = transformation.untransform(p2); //  L.point(1, 2)\r\n   * ```\r\n   */\n\n  // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)\n  // Creates a `Transformation` object with the given coefficients.\n  function Transformation(a, b, c, d) {\n    if (isArray(a)) {\n      // use array properties\n      this._a = a[0];\n      this._b = a[1];\n      this._c = a[2];\n      this._d = a[3];\n      return;\n    }\n    this._a = a;\n    this._b = b;\n    this._c = c;\n    this._d = d;\n  }\n  Transformation.prototype = {\n    // @method transform(point: Point, scale?: Number): Point\n    // Returns a transformed point, optionally multiplied by the given scale.\n    // Only accepts actual `L.Point` instances, not arrays.\n    transform: function transform(point, scale) {\n      // (Point, Number) -> Point\n      return this._transform(point.clone(), scale);\n    },\n    // destructive transform (faster)\n    _transform: function _transform(point, scale) {\n      scale = scale || 1;\n      point.x = scale * (this._a * point.x + this._b);\n      point.y = scale * (this._c * point.y + this._d);\n      return point;\n    },\n    // @method untransform(point: Point, scale?: Number): Point\n    // Returns the reverse transformation of the given point, optionally divided\n    // by the given scale. Only accepts actual `L.Point` instances, not arrays.\n    untransform: function untransform(point, scale) {\n      scale = scale || 1;\n      return new Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);\n    }\n  };\n\n  // factory L.transformation(a: Number, b: Number, c: Number, d: Number)\n\n  // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)\n  // Instantiates a Transformation object with the given coefficients.\n\n  // @alternative\n  // @factory L.transformation(coefficients: Array): Transformation\n  // Expects an coefficients array of the form\n  // `[a: Number, b: Number, c: Number, d: Number]`.\n\n  function toTransformation(a, b, c, d) {\n    return new Transformation(a, b, c, d);\n  }\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3857\r\n   *\r\n   * The most common CRS for online maps, used by almost all free and commercial\r\n   * tile providers. Uses Spherical Mercator projection. Set in by default in\r\n   * Map's `crs` option.\r\n   */\n\n  var EPSG3857 = extend({}, Earth, {\n    code: 'EPSG:3857',\n    projection: SphericalMercator,\n    transformation: function () {\n      var scale = 0.5 / (Math.PI * SphericalMercator.R);\n      return toTransformation(scale, 0.5, -scale, 0.5);\n    }()\n  });\n  var EPSG900913 = extend({}, EPSG3857, {\n    code: 'EPSG:900913'\n  });\n\n  // @namespace SVG; @section\n  // There are several static functions which can be called without instantiating L.SVG:\n\n  // @function create(name: String): SVGElement\n  // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),\n  // corresponding to the class name passed. For example, using 'line' will return\n  // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).\n  function svgCreate(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n  }\n\n  // @function pointsToPath(rings: Point[], closed: Boolean): String\n  // Generates a SVG path string for multiple rings, with each ring turning\n  // into \"M..L..L..\" instructions\n  function pointsToPath(rings, closed) {\n    var str = '',\n      i,\n      j,\n      len,\n      len2,\n      points,\n      p;\n    for (i = 0, len = rings.length; i < len; i++) {\n      points = rings[i];\n      for (j = 0, len2 = points.length; j < len2; j++) {\n        p = points[j];\n        str += (j ? 'L' : 'M') + p.x + ' ' + p.y;\n      }\n\n      // closes the ring for polygons; \"x\" is VML syntax\n      str += closed ? Browser.svg ? 'z' : 'x' : '';\n    }\n\n    // SVG complains about empty path strings\n    return str || 'M0 0';\n  }\n\n  /*\r\n   * @namespace Browser\r\n   * @aka L.Browser\r\n   *\r\n   * A namespace with static properties for browser/feature detection used by Leaflet internally.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * if (L.Browser.ielt9) {\r\n   *   alert('Upgrade your browser, dude!');\r\n   * }\r\n   * ```\r\n   */\n\n  var style = document.documentElement.style;\n\n  // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).\n  var ie = 'ActiveXObject' in window;\n\n  // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.\n  var ielt9 = ie && !document.addEventListener;\n\n  // @property edge: Boolean; `true` for the Edge web browser.\n  var edge = 'msLaunchUri' in navigator && !('documentMode' in document);\n\n  // @property webkit: Boolean;\n  // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).\n  var webkit = userAgentContains('webkit');\n\n  // @property android: Boolean\n  // **Deprecated.** `true` for any browser running on an Android platform.\n  var android = userAgentContains('android');\n\n  // @property android23: Boolean; **Deprecated.** `true` for browsers running on Android 2 or Android 3.\n  var android23 = userAgentContains('android 2') || userAgentContains('android 3');\n\n  /* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */\n  var webkitVer = parseInt(/WebKit\\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit\n  // @property androidStock: Boolean; **Deprecated.** `true` for the Android stock browser (i.e. not Chrome)\n  var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window);\n\n  // @property opera: Boolean; `true` for the Opera browser\n  var opera = !!window.opera;\n\n  // @property chrome: Boolean; `true` for the Chrome browser.\n  var chrome = !edge && userAgentContains('chrome');\n\n  // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.\n  var gecko = userAgentContains('gecko') && !webkit && !opera && !ie;\n\n  // @property safari: Boolean; `true` for the Safari browser.\n  var safari = !chrome && userAgentContains('safari');\n  var phantom = userAgentContains('phantom');\n\n  // @property opera12: Boolean\n  // `true` for the Opera browser supporting CSS transforms (version 12 or later).\n  var opera12 = 'OTransition' in style;\n\n  // @property win: Boolean; `true` when the browser is running in a Windows platform\n  var win = navigator.platform.indexOf('Win') === 0;\n\n  // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.\n  var ie3d = ie && 'transition' in style;\n\n  // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.\n  var webkit3d = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() && !android23;\n\n  // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.\n  var gecko3d = 'MozPerspective' in style;\n\n  // @property any3d: Boolean\n  // `true` for all browsers supporting CSS transforms.\n  var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;\n\n  // @property mobile: Boolean; `true` for all browsers running in a mobile device.\n  var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');\n\n  // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.\n  var mobileWebkit = mobile && webkit;\n\n  // @property mobileWebkit3d: Boolean\n  // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.\n  var mobileWebkit3d = mobile && webkit3d;\n\n  // @property msPointer: Boolean\n  // `true` for browsers implementing the Microsoft touch events model (notably IE10).\n  var msPointer = !window.PointerEvent && window.MSPointerEvent;\n\n  // @property pointer: Boolean\n  // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).\n  var pointer = !!(window.PointerEvent || msPointer);\n\n  // @property touchNative: Boolean\n  // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).\n  // **This does not necessarily mean** that the browser is running in a computer with\n  // a touchscreen, it only means that the browser is capable of understanding\n  // touch events.\n  var touchNative = 'ontouchstart' in window || !!window.TouchEvent;\n\n  // @property touch: Boolean\n  // `true` for all browsers supporting either [touch](#browser-touch) or [pointer](#browser-pointer) events.\n  // Note: pointer events will be preferred (if available), and processed for all `touch*` listeners.\n  var touch = !window.L_NO_TOUCH && (touchNative || pointer);\n\n  // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.\n  var mobileOpera = mobile && opera;\n\n  // @property mobileGecko: Boolean\n  // `true` for gecko-based browsers running in a mobile device.\n  var mobileGecko = mobile && gecko;\n\n  // @property retina: Boolean\n  // `true` for browsers on a high-resolution \"retina\" screen or on any screen when browser's display zoom is more than 100%.\n  var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;\n\n  // @property passiveEvents: Boolean\n  // `true` for browsers that support passive events.\n  var passiveEvents = function () {\n    var supportsPassiveOption = false;\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function get() {\n          // eslint-disable-line getter-return\n          supportsPassiveOption = true;\n        }\n      });\n      window.addEventListener('testPassiveEventSupport', falseFn, opts);\n      window.removeEventListener('testPassiveEventSupport', falseFn, opts);\n    } catch (e) {\n      // Errors can safely be ignored since this is only a browser support test.\n    }\n    return supportsPassiveOption;\n  }();\n\n  // @property canvas: Boolean\n  // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n  var canvas$1 = function () {\n    return !!document.createElement('canvas').getContext;\n  }();\n\n  // @property svg: Boolean\n  // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).\n  var svg$1 = !!(document.createElementNS && svgCreate('svg').createSVGRect);\n  var inlineSvg = !!svg$1 && function () {\n    var div = document.createElement('div');\n    div.innerHTML = '<svg/>';\n    return (div.firstChild && div.firstChild.namespaceURI) === 'http://www.w3.org/2000/svg';\n  }();\n\n  // @property vml: Boolean\n  // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).\n  var vml = !svg$1 && function () {\n    try {\n      var div = document.createElement('div');\n      div.innerHTML = '<v:shape adj=\"1\"/>';\n      var shape = div.firstChild;\n      shape.style.behavior = 'url(#default#VML)';\n      return shape && _typeof(shape.adj) === 'object';\n    } catch (e) {\n      return false;\n    }\n  }();\n\n  // @property mac: Boolean; `true` when the browser is running in a Mac platform\n  var mac = navigator.platform.indexOf('Mac') === 0;\n\n  // @property mac: Boolean; `true` when the browser is running in a Linux platform\n  var linux = navigator.platform.indexOf('Linux') === 0;\n  function userAgentContains(str) {\n    return navigator.userAgent.toLowerCase().indexOf(str) >= 0;\n  }\n  var Browser = {\n    ie: ie,\n    ielt9: ielt9,\n    edge: edge,\n    webkit: webkit,\n    android: android,\n    android23: android23,\n    androidStock: androidStock,\n    opera: opera,\n    chrome: chrome,\n    gecko: gecko,\n    safari: safari,\n    phantom: phantom,\n    opera12: opera12,\n    win: win,\n    ie3d: ie3d,\n    webkit3d: webkit3d,\n    gecko3d: gecko3d,\n    any3d: any3d,\n    mobile: mobile,\n    mobileWebkit: mobileWebkit,\n    mobileWebkit3d: mobileWebkit3d,\n    msPointer: msPointer,\n    pointer: pointer,\n    touch: touch,\n    touchNative: touchNative,\n    mobileOpera: mobileOpera,\n    mobileGecko: mobileGecko,\n    retina: retina,\n    passiveEvents: passiveEvents,\n    canvas: canvas$1,\n    svg: svg$1,\n    vml: vml,\n    inlineSvg: inlineSvg,\n    mac: mac,\n    linux: linux\n  };\n\n  /*\n   * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n   */\n\n  var POINTER_DOWN = Browser.msPointer ? 'MSPointerDown' : 'pointerdown';\n  var POINTER_MOVE = Browser.msPointer ? 'MSPointerMove' : 'pointermove';\n  var POINTER_UP = Browser.msPointer ? 'MSPointerUp' : 'pointerup';\n  var POINTER_CANCEL = Browser.msPointer ? 'MSPointerCancel' : 'pointercancel';\n  var pEvent = {\n    touchstart: POINTER_DOWN,\n    touchmove: POINTER_MOVE,\n    touchend: POINTER_UP,\n    touchcancel: POINTER_CANCEL\n  };\n  var handle = {\n    touchstart: _onPointerStart,\n    touchmove: _handlePointer,\n    touchend: _handlePointer,\n    touchcancel: _handlePointer\n  };\n  var _pointers = {};\n  var _pointerDocListener = false;\n\n  // Provides a touch events wrapper for (ms)pointer events.\n  // ref https://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\n  function addPointerListener(obj, type, handler) {\n    if (type === 'touchstart') {\n      _addPointerDocListener();\n    }\n    if (!handle[type]) {\n      console.warn('wrong event specified:', type);\n      return falseFn;\n    }\n    handler = handle[type].bind(this, handler);\n    obj.addEventListener(pEvent[type], handler, false);\n    return handler;\n  }\n  function removePointerListener(obj, type, handler) {\n    if (!pEvent[type]) {\n      console.warn('wrong event specified:', type);\n      return;\n    }\n    obj.removeEventListener(pEvent[type], handler, false);\n  }\n  function _globalPointerDown(e) {\n    _pointers[e.pointerId] = e;\n  }\n  function _globalPointerMove(e) {\n    if (_pointers[e.pointerId]) {\n      _pointers[e.pointerId] = e;\n    }\n  }\n  function _globalPointerUp(e) {\n    delete _pointers[e.pointerId];\n  }\n  function _addPointerDocListener() {\n    // need to keep track of what pointers and how many are active to provide e.touches emulation\n    if (!_pointerDocListener) {\n      // we listen document as any drags that end by moving the touch off the screen get fired there\n      document.addEventListener(POINTER_DOWN, _globalPointerDown, true);\n      document.addEventListener(POINTER_MOVE, _globalPointerMove, true);\n      document.addEventListener(POINTER_UP, _globalPointerUp, true);\n      document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);\n      _pointerDocListener = true;\n    }\n  }\n  function _handlePointer(handler, e) {\n    if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || 'mouse')) {\n      return;\n    }\n    e.touches = [];\n    for (var i in _pointers) {\n      e.touches.push(_pointers[i]);\n    }\n    e.changedTouches = [e];\n    handler(e);\n  }\n  function _onPointerStart(handler, e) {\n    // IE10 specific: MsTouch needs preventDefault. See #2000\n    if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {\n      preventDefault(e);\n    }\n    _handlePointer(handler, e);\n  }\n\n  /*\r\n   * Extends the event handling code with double tap support for mobile browsers.\r\n   *\r\n   * Note: currently most browsers fire native dblclick, with only a few exceptions\r\n   * (see https://github.com/Leaflet/Leaflet/issues/7012#issuecomment-595087386)\r\n   */\n\n  function makeDblclick(event) {\n    // in modern browsers `type` cannot be just overridden:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only\n    var newEvent = {},\n      prop,\n      i;\n    for (i in event) {\n      prop = event[i];\n      newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;\n    }\n    event = newEvent;\n    newEvent.type = 'dblclick';\n    newEvent.detail = 2;\n    newEvent.isTrusted = false;\n    newEvent._simulated = true; // for debug purposes\n    return newEvent;\n  }\n  var delay = 200;\n  function addDoubleTapListener(obj, handler) {\n    // Most browsers handle double tap natively\n    obj.addEventListener('dblclick', handler);\n\n    // On some platforms the browser doesn't fire native dblclicks for touch events.\n    // It seems that in all such cases `detail` property of `click` event is always `1`.\n    // So here we rely on that fact to avoid excessive 'dblclick' simulation when not needed.\n    var last = 0,\n      detail;\n    function simDblclick(e) {\n      if (e.detail !== 1) {\n        detail = e.detail; // keep in sync to avoid false dblclick in some cases\n        return;\n      }\n      if (e.pointerType === 'mouse' || e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents) {\n        return;\n      }\n\n      // When clicking on an <input>, the browser generates a click on its\n      // <label> (and vice versa) triggering two clicks in quick succession.\n      // This ignores clicks on elements which are a label with a 'for'\n      // attribute (or children of such a label), but not children of\n      // a <input>.\n      var path = getPropagationPath(e);\n      if (path.some(function (el) {\n        return el instanceof HTMLLabelElement && el.attributes[\"for\"];\n      }) && !path.some(function (el) {\n        return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;\n      })) {\n        return;\n      }\n      var now = Date.now();\n      if (now - last <= delay) {\n        detail++;\n        if (detail === 2) {\n          handler(makeDblclick(e));\n        }\n      } else {\n        detail = 1;\n      }\n      last = now;\n    }\n    obj.addEventListener('click', simDblclick);\n    return {\n      dblclick: handler,\n      simDblclick: simDblclick\n    };\n  }\n  function removeDoubleTapListener(obj, handlers) {\n    obj.removeEventListener('dblclick', handlers.dblclick);\n    obj.removeEventListener('click', handlers.simDblclick);\n  }\n\n  /*\r\n   * @namespace DomUtil\r\n   *\r\n   * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)\r\n   * tree, used by Leaflet internally.\r\n   *\r\n   * Most functions expecting or returning a `HTMLElement` also work for\r\n   * SVG elements. The only difference is that classes refer to CSS classes\r\n   * in HTML and SVG classes in SVG.\r\n   */\n\n  // @property TRANSFORM: String\n  // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).\n  var TRANSFORM = testProp(['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']);\n\n  // webkitTransition comes first because some browser versions that drop vendor prefix don't do\n  // the same for the transitionend event, in particular the Android 4.1 stock browser\n\n  // @property TRANSITION: String\n  // Vendor-prefixed transition style name.\n  var TRANSITION = testProp(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);\n\n  // @property TRANSITION_END: String\n  // Vendor-prefixed transitionend event name.\n  var TRANSITION_END = TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';\n\n  // @function get(id: String|HTMLElement): HTMLElement\n  // Returns an element given its DOM id, or returns the element itself\n  // if it was passed directly.\n  function get(id) {\n    return typeof id === 'string' ? document.getElementById(id) : id;\n  }\n\n  // @function getStyle(el: HTMLElement, styleAttrib: String): String\n  // Returns the value for a certain style attribute on an element,\n  // including computed values or values set through CSS.\n  function getStyle(el, style) {\n    var value = el.style[style] || el.currentStyle && el.currentStyle[style];\n    if ((!value || value === 'auto') && document.defaultView) {\n      var css = document.defaultView.getComputedStyle(el, null);\n      value = css ? css[style] : null;\n    }\n    return value === 'auto' ? null : value;\n  }\n\n  // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement\n  // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.\n  function create$1(tagName, className, container) {\n    var el = document.createElement(tagName);\n    el.className = className || '';\n    if (container) {\n      container.appendChild(el);\n    }\n    return el;\n  }\n\n  // @function remove(el: HTMLElement)\n  // Removes `el` from its parent element\n  function _remove(el) {\n    var parent = el.parentNode;\n    if (parent) {\n      parent.removeChild(el);\n    }\n  }\n\n  // @function empty(el: HTMLElement)\n  // Removes all of `el`'s children elements from `el`\n  function empty(el) {\n    while (el.firstChild) {\n      el.removeChild(el.firstChild);\n    }\n  }\n\n  // @function toFront(el: HTMLElement)\n  // Makes `el` the last child of its parent, so it renders in front of the other children.\n  function toFront(el) {\n    var parent = el.parentNode;\n    if (parent && parent.lastChild !== el) {\n      parent.appendChild(el);\n    }\n  }\n\n  // @function toBack(el: HTMLElement)\n  // Makes `el` the first child of its parent, so it renders behind the other children.\n  function toBack(el) {\n    var parent = el.parentNode;\n    if (parent && parent.firstChild !== el) {\n      parent.insertBefore(el, parent.firstChild);\n    }\n  }\n\n  // @function hasClass(el: HTMLElement, name: String): Boolean\n  // Returns `true` if the element's class attribute contains `name`.\n  function hasClass(el, name) {\n    if (el.classList !== undefined) {\n      return el.classList.contains(name);\n    }\n    var className = getClass(el);\n    return className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\n  }\n\n  // @function addClass(el: HTMLElement, name: String)\n  // Adds `name` to the element's class attribute.\n  function addClass(el, name) {\n    if (el.classList !== undefined) {\n      var classes = splitWords(name);\n      for (var i = 0, len = classes.length; i < len; i++) {\n        el.classList.add(classes[i]);\n      }\n    } else if (!hasClass(el, name)) {\n      var className = getClass(el);\n      setClass(el, (className ? className + ' ' : '') + name);\n    }\n  }\n\n  // @function removeClass(el: HTMLElement, name: String)\n  // Removes `name` from the element's class attribute.\n  function removeClass(el, name) {\n    if (el.classList !== undefined) {\n      el.classList.remove(name);\n    } else {\n      setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\n    }\n  }\n\n  // @function setClass(el: HTMLElement, name: String)\n  // Sets the element's class.\n  function setClass(el, name) {\n    if (el.className.baseVal === undefined) {\n      el.className = name;\n    } else {\n      // in case of SVG element\n      el.className.baseVal = name;\n    }\n  }\n\n  // @function getClass(el: HTMLElement): String\n  // Returns the element's class.\n  function getClass(el) {\n    // Check if the element is an SVGElementInstance and use the correspondingElement instead\n    // (Required for linked SVG elements in IE11.)\n    if (el.correspondingElement) {\n      el = el.correspondingElement;\n    }\n    return el.className.baseVal === undefined ? el.className : el.className.baseVal;\n  }\n\n  // @function setOpacity(el: HTMLElement, opacity: Number)\n  // Set the opacity of an element (including old IE support).\n  // `opacity` must be a number from `0` to `1`.\n  function _setOpacity(el, value) {\n    if ('opacity' in el.style) {\n      el.style.opacity = value;\n    } else if ('filter' in el.style) {\n      _setOpacityIE(el, value);\n    }\n  }\n  function _setOpacityIE(el, value) {\n    var filter = false,\n      filterName = 'DXImageTransform.Microsoft.Alpha';\n\n    // filters collection throws an error if we try to retrieve a filter that doesn't exist\n    try {\n      filter = el.filters.item(filterName);\n    } catch (e) {\n      // don't set opacity to 1 if we haven't already set an opacity,\n      // it isn't needed and breaks transparent pngs.\n      if (value === 1) {\n        return;\n      }\n    }\n    value = Math.round(value * 100);\n    if (filter) {\n      filter.Enabled = value !== 100;\n      filter.Opacity = value;\n    } else {\n      el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\n    }\n  }\n\n  // @function testProp(props: String[]): String|false\n  // Goes through the array of style names and returns the first name\n  // that is a valid style name for an element. If no such name is found,\n  // it returns false. Useful for vendor-prefixed styles like `transform`.\n  function testProp(props) {\n    var style = document.documentElement.style;\n    for (var i = 0; i < props.length; i++) {\n      if (props[i] in style) {\n        return props[i];\n      }\n    }\n    return false;\n  }\n\n  // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)\n  // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels\n  // and optionally scaled by `scale`. Does not have an effect if the\n  // browser doesn't support 3D CSS transforms.\n  function setTransform(el, offset, scale) {\n    var pos = offset || new Point(0, 0);\n    el.style[TRANSFORM] = (Browser.ie3d ? 'translate(' + pos.x + 'px,' + pos.y + 'px)' : 'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') + (scale ? ' scale(' + scale + ')' : '');\n  }\n\n  // @function setPosition(el: HTMLElement, position: Point)\n  // Sets the position of `el` to coordinates specified by `position`,\n  // using CSS translate or top/left positioning depending on the browser\n  // (used by Leaflet internally to position its layers).\n  function setPosition(el, point) {\n    /*eslint-disable */\n    el._leaflet_pos = point;\n    /* eslint-enable */\n\n    if (Browser.any3d) {\n      setTransform(el, point);\n    } else {\n      el.style.left = point.x + 'px';\n      el.style.top = point.y + 'px';\n    }\n  }\n\n  // @function getPosition(el: HTMLElement): Point\n  // Returns the coordinates of an element previously positioned with setPosition.\n  function getPosition(el) {\n    // this method is only used for elements previously positioned using setPosition,\n    // so it's safe to cache the position for performance\n\n    return el._leaflet_pos || new Point(0, 0);\n  }\n\n  // @function disableTextSelection()\n  // Prevents the user from generating `selectstart` DOM events, usually generated\n  // when the user drags the mouse through a page with text. Used internally\n  // by Leaflet to override the behaviour of any click-and-drag interaction on\n  // the map. Affects drag interactions on the whole document.\n\n  // @function enableTextSelection()\n  // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).\n  var disableTextSelection;\n  var enableTextSelection;\n  var _userSelect;\n  if ('onselectstart' in document) {\n    disableTextSelection = function disableTextSelection() {\n      on(window, 'selectstart', preventDefault);\n    };\n    enableTextSelection = function enableTextSelection() {\n      off(window, 'selectstart', preventDefault);\n    };\n  } else {\n    var userSelectProperty = testProp(['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\n    disableTextSelection = function disableTextSelection() {\n      if (userSelectProperty) {\n        var style = document.documentElement.style;\n        _userSelect = style[userSelectProperty];\n        style[userSelectProperty] = 'none';\n      }\n    };\n    enableTextSelection = function enableTextSelection() {\n      if (userSelectProperty) {\n        document.documentElement.style[userSelectProperty] = _userSelect;\n        _userSelect = undefined;\n      }\n    };\n  }\n\n  // @function disableImageDrag()\n  // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but\n  // for `dragstart` DOM events, usually generated when the user drags an image.\n  function disableImageDrag() {\n    on(window, 'dragstart', preventDefault);\n  }\n\n  // @function enableImageDrag()\n  // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).\n  function enableImageDrag() {\n    off(window, 'dragstart', preventDefault);\n  }\n  var _outlineElement, _outlineStyle;\n  // @function preventOutline(el: HTMLElement)\n  // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)\n  // of the element `el` invisible. Used internally by Leaflet to prevent\n  // focusable elements from displaying an outline when the user performs a\n  // drag interaction on them.\n  function preventOutline(element) {\n    while (element.tabIndex === -1) {\n      element = element.parentNode;\n    }\n    if (!element.style) {\n      return;\n    }\n    restoreOutline();\n    _outlineElement = element;\n    _outlineStyle = element.style.outlineStyle;\n    element.style.outlineStyle = 'none';\n    on(window, 'keydown', restoreOutline);\n  }\n\n  // @function restoreOutline()\n  // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().\n  function restoreOutline() {\n    if (!_outlineElement) {\n      return;\n    }\n    _outlineElement.style.outlineStyle = _outlineStyle;\n    _outlineElement = undefined;\n    _outlineStyle = undefined;\n    off(window, 'keydown', restoreOutline);\n  }\n\n  // @function getSizedParentNode(el: HTMLElement): HTMLElement\n  // Finds the closest parent node which size (width and height) is not null.\n  function getSizedParentNode(element) {\n    do {\n      element = element.parentNode;\n    } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);\n    return element;\n  }\n\n  // @function getScale(el: HTMLElement): Object\n  // Computes the CSS scale currently applied on the element.\n  // Returns an object with `x` and `y` members as horizontal and vertical scales respectively,\n  // and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).\n  function getScale(element) {\n    var rect = element.getBoundingClientRect(); // Read-only in old browsers.\n\n    return {\n      x: rect.width / element.offsetWidth || 1,\n      y: rect.height / element.offsetHeight || 1,\n      boundingClientRect: rect\n    };\n  }\n  var DomUtil = {\n    __proto__: null,\n    TRANSFORM: TRANSFORM,\n    TRANSITION: TRANSITION,\n    TRANSITION_END: TRANSITION_END,\n    get: get,\n    getStyle: getStyle,\n    create: create$1,\n    remove: _remove,\n    empty: empty,\n    toFront: toFront,\n    toBack: toBack,\n    hasClass: hasClass,\n    addClass: addClass,\n    removeClass: removeClass,\n    setClass: setClass,\n    getClass: getClass,\n    setOpacity: _setOpacity,\n    testProp: testProp,\n    setTransform: setTransform,\n    setPosition: setPosition,\n    getPosition: getPosition,\n    get disableTextSelection() {\n      return disableTextSelection;\n    },\n    get enableTextSelection() {\n      return enableTextSelection;\n    },\n    disableImageDrag: disableImageDrag,\n    enableImageDrag: enableImageDrag,\n    preventOutline: preventOutline,\n    restoreOutline: restoreOutline,\n    getSizedParentNode: getSizedParentNode,\n    getScale: getScale\n  };\n\n  /*\r\n   * @namespace DomEvent\r\n   * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.\r\n   */\n\n  // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.\n\n  // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this\n  // Adds a listener function (`fn`) to a particular DOM event type of the\n  // element `el`. You can optionally specify the context of the listener\n  // (object the `this` keyword will point to). You can also pass several\n  // space-separated types (e.g. `'click dblclick'`).\n\n  // @alternative\n  // @function on(el: HTMLElement, eventMap: Object, context?: Object): this\n  // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\n  function on(obj, types, fn, context) {\n    if (types && _typeof(types) === 'object') {\n      for (var type in types) {\n        addOne(obj, type, types[type], fn);\n      }\n    } else {\n      types = splitWords(types);\n      for (var i = 0, len = types.length; i < len; i++) {\n        addOne(obj, types[i], fn, context);\n      }\n    }\n    return this;\n  }\n  var eventsKey = '_leaflet_events';\n\n  // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this\n  // Removes a previously added listener function.\n  // Note that if you passed a custom context to on, you must pass the same\n  // context to `off` in order to remove the listener.\n\n  // @alternative\n  // @function off(el: HTMLElement, eventMap: Object, context?: Object): this\n  // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\n\n  // @alternative\n  // @function off(el: HTMLElement, types: String): this\n  // Removes all previously added listeners of given types.\n\n  // @alternative\n  // @function off(el: HTMLElement): this\n  // Removes all previously added listeners from given HTMLElement\n  function off(obj, types, fn, context) {\n    if (arguments.length === 1) {\n      batchRemove(obj);\n      delete obj[eventsKey];\n    } else if (types && _typeof(types) === 'object') {\n      for (var type in types) {\n        removeOne(obj, type, types[type], fn);\n      }\n    } else {\n      types = splitWords(types);\n      if (arguments.length === 2) {\n        batchRemove(obj, function (type) {\n          return indexOf(types, type) !== -1;\n        });\n      } else {\n        for (var i = 0, len = types.length; i < len; i++) {\n          removeOne(obj, types[i], fn, context);\n        }\n      }\n    }\n    return this;\n  }\n  function batchRemove(obj, filterFn) {\n    for (var id in obj[eventsKey]) {\n      var type = id.split(/\\d/)[0];\n      if (!filterFn || filterFn(type)) {\n        removeOne(obj, type, null, null, id);\n      }\n    }\n  }\n  var mouseSubst = {\n    mouseenter: 'mouseover',\n    mouseleave: 'mouseout',\n    wheel: !('onwheel' in window) && 'mousewheel'\n  };\n  function addOne(obj, type, fn, context) {\n    var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');\n    if (obj[eventsKey] && obj[eventsKey][id]) {\n      return this;\n    }\n    var handler = function handler(e) {\n      return fn.call(context || obj, e || window.event);\n    };\n    var originalHandler = handler;\n    if (!Browser.touchNative && Browser.pointer && type.indexOf('touch') === 0) {\n      // Needs DomEvent.Pointer.js\n      handler = addPointerListener(obj, type, handler);\n    } else if (Browser.touch && type === 'dblclick') {\n      handler = addDoubleTapListener(obj, handler);\n    } else if ('addEventListener' in obj) {\n      if (type === 'touchstart' || type === 'touchmove' || type === 'wheel' || type === 'mousewheel') {\n        obj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? {\n          passive: false\n        } : false);\n      } else if (type === 'mouseenter' || type === 'mouseleave') {\n        handler = function handler(e) {\n          e = e || window.event;\n          if (isExternalTarget(obj, e)) {\n            originalHandler(e);\n          }\n        };\n        obj.addEventListener(mouseSubst[type], handler, false);\n      } else {\n        obj.addEventListener(type, originalHandler, false);\n      }\n    } else {\n      obj.attachEvent('on' + type, handler);\n    }\n    obj[eventsKey] = obj[eventsKey] || {};\n    obj[eventsKey][id] = handler;\n  }\n  function removeOne(obj, type, fn, context, id) {\n    id = id || type + stamp(fn) + (context ? '_' + stamp(context) : '');\n    var handler = obj[eventsKey] && obj[eventsKey][id];\n    if (!handler) {\n      return this;\n    }\n    if (!Browser.touchNative && Browser.pointer && type.indexOf('touch') === 0) {\n      removePointerListener(obj, type, handler);\n    } else if (Browser.touch && type === 'dblclick') {\n      removeDoubleTapListener(obj, handler);\n    } else if ('removeEventListener' in obj) {\n      obj.removeEventListener(mouseSubst[type] || type, handler, false);\n    } else {\n      obj.detachEvent('on' + type, handler);\n    }\n    obj[eventsKey][id] = null;\n  }\n\n  // @function stopPropagation(ev: DOMEvent): this\n  // Stop the given event from propagation to parent elements. Used inside the listener functions:\n  // ```js\n  // L.DomEvent.on(div, 'click', function (ev) {\n  // \tL.DomEvent.stopPropagation(ev);\n  // });\n  // ```\n  function stopPropagation(e) {\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    } else if (e.originalEvent) {\n      // In case of Leaflet event.\n      e.originalEvent._stopped = true;\n    } else {\n      e.cancelBubble = true;\n    }\n    return this;\n  }\n\n  // @function disableScrollPropagation(el: HTMLElement): this\n  // Adds `stopPropagation` to the element's `'wheel'` events (plus browser variants).\n  function disableScrollPropagation(el) {\n    addOne(el, 'wheel', stopPropagation);\n    return this;\n  }\n\n  // @function disableClickPropagation(el: HTMLElement): this\n  // Adds `stopPropagation` to the element's `'click'`, `'dblclick'`, `'contextmenu'`,\n  // `'mousedown'` and `'touchstart'` events (plus browser variants).\n  function disableClickPropagation(el) {\n    on(el, 'mousedown touchstart dblclick contextmenu', stopPropagation);\n    el['_leaflet_disable_click'] = true;\n    return this;\n  }\n\n  // @function preventDefault(ev: DOMEvent): this\n  // Prevents the default action of the DOM Event `ev` from happening (such as\n  // following a link in the href of the a element, or doing a POST request\n  // with page reload when a `<form>` is submitted).\n  // Use it inside listener functions.\n  function preventDefault(e) {\n    if (e.preventDefault) {\n      e.preventDefault();\n    } else {\n      e.returnValue = false;\n    }\n    return this;\n  }\n\n  // @function stop(ev: DOMEvent): this\n  // Does `stopPropagation` and `preventDefault` at the same time.\n  function stop(e) {\n    preventDefault(e);\n    stopPropagation(e);\n    return this;\n  }\n\n  // @function getPropagationPath(ev: DOMEvent): Array\n  // Compatibility polyfill for [`Event.composedPath()`](https://developer.mozilla.org/en-US/docs/Web/API/Event/composedPath).\n  // Returns an array containing the `HTMLElement`s that the given DOM event\n  // should propagate to (if not stopped).\n  function getPropagationPath(ev) {\n    if (ev.composedPath) {\n      return ev.composedPath();\n    }\n    var path = [];\n    var el = ev.target;\n    while (el) {\n      path.push(el);\n      el = el.parentNode;\n    }\n    return path;\n  }\n\n  // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point\n  // Gets normalized mouse position from a DOM event relative to the\n  // `container` (border excluded) or to the whole page if not specified.\n  function getMousePosition(e, container) {\n    if (!container) {\n      return new Point(e.clientX, e.clientY);\n    }\n    var scale = getScale(container),\n      offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)\n\n    return new Point(\n    // offset.left/top values are in page scale (like clientX/Y),\n    // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).\n    (e.clientX - offset.left) / scale.x - container.clientLeft, (e.clientY - offset.top) / scale.y - container.clientTop);\n  }\n\n  //  except , Safari and\n  // We need double the scroll pixels (see #7403 and #4538) for all Browsers\n  // except OSX (Mac) -> 3x, Chrome running on Linux 1x\n\n  var wheelPxFactor = Browser.linux && Browser.chrome ? window.devicePixelRatio : Browser.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;\n  // @function getWheelDelta(ev: DOMEvent): Number\n  // Gets normalized wheel delta from a wheel DOM event, in vertical\n  // pixels scrolled (negative if scrolling down).\n  // Events from pointing devices without precise scrolling are mapped to\n  // a best guess of 60 pixels.\n  function getWheelDelta(e) {\n    return Browser.edge ? e.wheelDeltaY / 2 :\n    // Don't trust window-geometry-based delta\n    e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor :\n    // Pixels\n    e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 :\n    // Lines\n    e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 :\n    // Pages\n    e.deltaX || e.deltaZ ? 0 :\n    // Skip horizontal/depth wheel events\n    e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 :\n    // Legacy IE pixels\n    e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 :\n    // Legacy Moz lines\n    e.detail ? e.detail / -32765 * 60 :\n    // Legacy Moz pages\n    0;\n  }\n\n  // check if element really left/entered the event target (for mouseenter/mouseleave)\n  function isExternalTarget(el, e) {\n    var related = e.relatedTarget;\n    if (!related) {\n      return true;\n    }\n    try {\n      while (related && related !== el) {\n        related = related.parentNode;\n      }\n    } catch (err) {\n      return false;\n    }\n    return related !== el;\n  }\n  var DomEvent = {\n    __proto__: null,\n    on: on,\n    off: off,\n    stopPropagation: stopPropagation,\n    disableScrollPropagation: disableScrollPropagation,\n    disableClickPropagation: disableClickPropagation,\n    preventDefault: preventDefault,\n    stop: stop,\n    getPropagationPath: getPropagationPath,\n    getMousePosition: getMousePosition,\n    getWheelDelta: getWheelDelta,\n    isExternalTarget: isExternalTarget,\n    addListener: on,\n    removeListener: off\n  };\n\n  /*\n   * @class PosAnimation\n   * @aka L.PosAnimation\n   * @inherits Evented\n   * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.\n   *\n   * @example\n   * ```js\n   * var myPositionMarker = L.marker([48.864716, 2.294694]).addTo(map);\n   *\n   * myPositionMarker.on(\"click\", function() {\n   * \tvar pos = map.latLngToLayerPoint(myPositionMarker.getLatLng());\n   * \tpos.y -= 25;\n   * \tvar fx = new L.PosAnimation();\n   *\n   * \tfx.once('end',function() {\n   * \t\tpos.y += 25;\n   * \t\tfx.run(myPositionMarker._icon, pos, 0.8);\n   * \t});\n   *\n   * \tfx.run(myPositionMarker._icon, pos, 0.3);\n   * });\n   *\n   * ```\n   *\n   * @constructor L.PosAnimation()\n   * Creates a `PosAnimation` object.\n   *\n   */\n\n  var PosAnimation = Evented.extend({\n    // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)\n    // Run an animation of a given element to a new position, optionally setting\n    // duration in seconds (`0.25` by default) and easing linearity factor (3rd\n    // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),\n    // `0.5` by default).\n    run: function run(el, newPos, duration, easeLinearity) {\n      this.stop();\n      this._el = el;\n      this._inProgress = true;\n      this._duration = duration || 0.25;\n      this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n      this._startPos = getPosition(el);\n      this._offset = newPos.subtract(this._startPos);\n      this._startTime = +new Date();\n\n      // @event start: Event\n      // Fired when the animation starts\n      this.fire('start');\n      this._animate();\n    },\n    // @method stop()\n    // Stops the animation (if currently running).\n    stop: function stop() {\n      if (!this._inProgress) {\n        return;\n      }\n      this._step(true);\n      this._complete();\n    },\n    _animate: function _animate() {\n      // animation loop\n      this._animId = requestAnimFrame(this._animate, this);\n      this._step();\n    },\n    _step: function _step(round) {\n      var elapsed = +new Date() - this._startTime,\n        duration = this._duration * 1000;\n      if (elapsed < duration) {\n        this._runFrame(this._easeOut(elapsed / duration), round);\n      } else {\n        this._runFrame(1);\n        this._complete();\n      }\n    },\n    _runFrame: function _runFrame(progress, round) {\n      var pos = this._startPos.add(this._offset.multiplyBy(progress));\n      if (round) {\n        pos._round();\n      }\n      setPosition(this._el, pos);\n\n      // @event step: Event\n      // Fired continuously during the animation.\n      this.fire('step');\n    },\n    _complete: function _complete() {\n      cancelAnimFrame(this._animId);\n      this._inProgress = false;\n      // @event end: Event\n      // Fired when the animation ends.\n      this.fire('end');\n    },\n    _easeOut: function _easeOut(t) {\n      return 1 - Math.pow(1 - t, this._easeOutPower);\n    }\n  });\n\n  /*\r\n   * @class Map\r\n   * @aka L.Map\r\n   * @inherits Evented\r\n   *\r\n   * The central class of the API — it is used to create a map on a page and manipulate it.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * // initialize the map on the \"map\" div with a given center and zoom\r\n   * var map = L.map('map', {\r\n   * \tcenter: [51.505, -0.09],\r\n   * \tzoom: 13\r\n   * });\r\n   * ```\r\n   *\r\n   */\n\n  var Map = Evented.extend({\n    options: {\n      // @section Map State Options\n      // @option crs: CRS = L.CRS.EPSG3857\n      // The [Coordinate Reference System](#crs) to use. Don't change this if you're not\n      // sure what it means.\n      crs: EPSG3857,\n      // @option center: LatLng = undefined\n      // Initial geographic center of the map\n      center: undefined,\n      // @option zoom: Number = undefined\n      // Initial map zoom level\n      zoom: undefined,\n      // @option minZoom: Number = *\n      // Minimum zoom level of the map.\n      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\n      // the lowest of their `minZoom` options will be used instead.\n      minZoom: undefined,\n      // @option maxZoom: Number = *\n      // Maximum zoom level of the map.\n      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\n      // the highest of their `maxZoom` options will be used instead.\n      maxZoom: undefined,\n      // @option layers: Layer[] = []\n      // Array of layers that will be added to the map initially\n      layers: [],\n      // @option maxBounds: LatLngBounds = null\n      // When this option is set, the map restricts the view to the given\n      // geographical bounds, bouncing the user back if the user tries to pan\n      // outside the view. To set the restriction dynamically, use\n      // [`setMaxBounds`](#map-setmaxbounds) method.\n      maxBounds: undefined,\n      // @option renderer: Renderer = *\n      // The default method for drawing vector layers on the map. `L.SVG`\n      // or `L.Canvas` by default depending on browser support.\n      renderer: undefined,\n      // @section Animation Options\n      // @option zoomAnimation: Boolean = true\n      // Whether the map zoom animation is enabled. By default it's enabled\n      // in all browsers that support CSS3 Transitions except Android.\n      zoomAnimation: true,\n      // @option zoomAnimationThreshold: Number = 4\n      // Won't animate zoom if the zoom difference exceeds this value.\n      zoomAnimationThreshold: 4,\n      // @option fadeAnimation: Boolean = true\n      // Whether the tile fade animation is enabled. By default it's enabled\n      // in all browsers that support CSS3 Transitions except Android.\n      fadeAnimation: true,\n      // @option markerZoomAnimation: Boolean = true\n      // Whether markers animate their zoom with the zoom animation, if disabled\n      // they will disappear for the length of the animation. By default it's\n      // enabled in all browsers that support CSS3 Transitions except Android.\n      markerZoomAnimation: true,\n      // @option transform3DLimit: Number = 2^23\n      // Defines the maximum size of a CSS translation transform. The default\n      // value should not be changed unless a web browser positions layers in\n      // the wrong place after doing a large `panBy`.\n      transform3DLimit: 8388608,\n      // Precision limit of a 32-bit float\n\n      // @section Interaction Options\n      // @option zoomSnap: Number = 1\n      // Forces the map's zoom level to always be a multiple of this, particularly\n      // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.\n      // By default, the zoom level snaps to the nearest integer; lower values\n      // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`\n      // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.\n      zoomSnap: 1,\n      // @option zoomDelta: Number = 1\n      // Controls how much the map's zoom level will change after a\n      // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`\n      // or `-` on the keyboard, or using the [zoom controls](#control-zoom).\n      // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.\n      zoomDelta: 1,\n      // @option trackResize: Boolean = true\n      // Whether the map automatically handles browser window resize to update itself.\n      trackResize: true\n    },\n    initialize: function initialize(id, options) {\n      // (HTMLElement or String, Object)\n      options = setOptions(this, options);\n\n      // Make sure to assign internal flags at the beginning,\n      // to avoid inconsistent state in some edge cases.\n      this._handlers = [];\n      this._layers = {};\n      this._zoomBoundLayers = {};\n      this._sizeChanged = true;\n      this._initContainer(id);\n      this._initLayout();\n\n      // hack for https://github.com/Leaflet/Leaflet/issues/1980\n      this._onResize = bind(this._onResize, this);\n      this._initEvents();\n      if (options.maxBounds) {\n        this.setMaxBounds(options.maxBounds);\n      }\n      if (options.zoom !== undefined) {\n        this._zoom = this._limitZoom(options.zoom);\n      }\n      if (options.center && options.zoom !== undefined) {\n        this.setView(toLatLng(options.center), options.zoom, {\n          reset: true\n        });\n      }\n      this.callInitHooks();\n\n      // don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n      this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;\n\n      // zoom transitions run with the same duration for all layers, so if one of transitionend events\n      // happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n      if (this._zoomAnimated) {\n        this._createAnimProxy();\n        on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);\n      }\n      this._addLayers(this.options.layers);\n    },\n    // @section Methods for modifying map state\n\n    // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this\n    // Sets the view of the map (geographical center and zoom) with the given\n    // animation options.\n    setView: function setView(center, zoom, options) {\n      zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n      center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);\n      options = options || {};\n      this._stop();\n      if (this._loaded && !options.reset && options !== true) {\n        if (options.animate !== undefined) {\n          options.zoom = extend({\n            animate: options.animate\n          }, options.zoom);\n          options.pan = extend({\n            animate: options.animate,\n            duration: options.duration\n          }, options.pan);\n        }\n\n        // try animating pan or zoom\n        var moved = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);\n        if (moved) {\n          // prevent resize handler call, the view will refresh after animation anyway\n          clearTimeout(this._sizeTimer);\n          return this;\n        }\n      }\n\n      // animation didn't start, just reset the map view\n      this._resetView(center, zoom, options.pan && options.pan.noMoveStart);\n      return this;\n    },\n    // @method setZoom(zoom: Number, options?: Zoom/pan options): this\n    // Sets the zoom of the map.\n    setZoom: function setZoom(zoom, options) {\n      if (!this._loaded) {\n        this._zoom = zoom;\n        return this;\n      }\n      return this.setView(this.getCenter(), zoom, {\n        zoom: options\n      });\n    },\n    // @method zoomIn(delta?: Number, options?: Zoom options): this\n    // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\n    zoomIn: function zoomIn(delta, options) {\n      delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);\n      return this.setZoom(this._zoom + delta, options);\n    },\n    // @method zoomOut(delta?: Number, options?: Zoom options): this\n    // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\n    zoomOut: function zoomOut(delta, options) {\n      delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);\n      return this.setZoom(this._zoom - delta, options);\n    },\n    // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this\n    // Zooms the map while keeping a specified geographical point on the map\n    // stationary (e.g. used internally for scroll zoom and double-click zoom).\n    // @alternative\n    // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this\n    // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.\n    setZoomAround: function setZoomAround(latlng, zoom, options) {\n      var scale = this.getZoomScale(zoom),\n        viewHalf = this.getSize().divideBy(2),\n        containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),\n        centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\n        newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\n      return this.setView(newCenter, zoom, {\n        zoom: options\n      });\n    },\n    _getBoundsCenterZoom: function _getBoundsCenterZoom(bounds, options) {\n      options = options || {};\n      bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);\n      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\n        paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\n        zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\n      zoom = typeof options.maxZoom === 'number' ? Math.min(options.maxZoom, zoom) : zoom;\n      if (zoom === Infinity) {\n        return {\n          center: bounds.getCenter(),\n          zoom: zoom\n        };\n      }\n      var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\n        swPoint = this.project(bounds.getSouthWest(), zoom),\n        nePoint = this.project(bounds.getNorthEast(), zoom),\n        center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\n      return {\n        center: center,\n        zoom: zoom\n      };\n    },\n    // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this\n    // Sets a map view that contains the given geographical bounds with the\n    // maximum zoom level possible.\n    fitBounds: function fitBounds(bounds, options) {\n      bounds = toLatLngBounds(bounds);\n      if (!bounds.isValid()) {\n        throw new Error('Bounds are not valid.');\n      }\n      var target = this._getBoundsCenterZoom(bounds, options);\n      return this.setView(target.center, target.zoom, options);\n    },\n    // @method fitWorld(options?: fitBounds options): this\n    // Sets a map view that mostly contains the whole world with the maximum\n    // zoom level possible.\n    fitWorld: function fitWorld(options) {\n      return this.fitBounds([[-90, -180], [90, 180]], options);\n    },\n    // @method panTo(latlng: LatLng, options?: Pan options): this\n    // Pans the map to a given center.\n    panTo: function panTo(center, options) {\n      // (LatLng)\n      return this.setView(center, this._zoom, {\n        pan: options\n      });\n    },\n    // @method panBy(offset: Point, options?: Pan options): this\n    // Pans the map by a given number of pixels (animated).\n    panBy: function panBy(offset, options) {\n      offset = toPoint(offset).round();\n      options = options || {};\n      if (!offset.x && !offset.y) {\n        return this.fire('moveend');\n      }\n      // If we pan too far, Chrome gets issues with tiles\n      // and makes them disappear or appear in the wrong place (slightly offset) #2602\n      if (options.animate !== true && !this.getSize().contains(offset)) {\n        this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());\n        return this;\n      }\n      if (!this._panAnim) {\n        this._panAnim = new PosAnimation();\n        this._panAnim.on({\n          'step': this._onPanTransitionStep,\n          'end': this._onPanTransitionEnd\n        }, this);\n      }\n\n      // don't fire movestart if animating inertia\n      if (!options.noMoveStart) {\n        this.fire('movestart');\n      }\n\n      // animate pan unless animate: false specified\n      if (options.animate !== false) {\n        addClass(this._mapPane, 'leaflet-pan-anim');\n        var newPos = this._getMapPanePos().subtract(offset).round();\n        this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n      } else {\n        this._rawPanBy(offset);\n        this.fire('move').fire('moveend');\n      }\n      return this;\n    },\n    // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this\n    // Sets the view of the map (geographical center and zoom) performing a smooth\n    // pan-zoom animation.\n    flyTo: function flyTo(targetCenter, targetZoom, options) {\n      options = options || {};\n      if (options.animate === false || !Browser.any3d) {\n        return this.setView(targetCenter, targetZoom, options);\n      }\n      this._stop();\n      var from = this.project(this.getCenter()),\n        to = this.project(targetCenter),\n        size = this.getSize(),\n        startZoom = this._zoom;\n      targetCenter = toLatLng(targetCenter);\n      targetZoom = targetZoom === undefined ? startZoom : targetZoom;\n      var w0 = Math.max(size.x, size.y),\n        w1 = w0 * this.getZoomScale(startZoom, targetZoom),\n        u1 = to.distanceTo(from) || 1,\n        rho = 1.42,\n        rho2 = rho * rho;\n      function r(i) {\n        var s1 = i ? -1 : 1,\n          s2 = i ? w1 : w0,\n          t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,\n          b1 = 2 * s2 * rho2 * u1,\n          b = t1 / b1,\n          sq = Math.sqrt(b * b + 1) - b;\n\n        // workaround for floating point precision bug when sq = 0, log = -Infinite,\n        // thus triggering an infinite loop in flyTo\n        var log = sq < 0.000000001 ? -18 : Math.log(sq);\n        return log;\n      }\n      function sinh(n) {\n        return (Math.exp(n) - Math.exp(-n)) / 2;\n      }\n      function cosh(n) {\n        return (Math.exp(n) + Math.exp(-n)) / 2;\n      }\n      function tanh(n) {\n        return sinh(n) / cosh(n);\n      }\n      var r0 = r(0);\n      function w(s) {\n        return w0 * (cosh(r0) / cosh(r0 + rho * s));\n      }\n      function u(s) {\n        return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;\n      }\n      function easeOut(t) {\n        return 1 - Math.pow(1 - t, 1.5);\n      }\n      var start = Date.now(),\n        S = (r(1) - r0) / rho,\n        duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;\n      function frame() {\n        var t = (Date.now() - start) / duration,\n          s = easeOut(t) * S;\n        if (t <= 1) {\n          this._flyToFrame = requestAnimFrame(frame, this);\n          this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), {\n            flyTo: true\n          });\n        } else {\n          this._move(targetCenter, targetZoom)._moveEnd(true);\n        }\n      }\n      this._moveStart(true, options.noMoveStart);\n      frame.call(this);\n      return this;\n    },\n    // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this\n    // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),\n    // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).\n    flyToBounds: function flyToBounds(bounds, options) {\n      var target = this._getBoundsCenterZoom(bounds, options);\n      return this.flyTo(target.center, target.zoom, options);\n    },\n    // @method setMaxBounds(bounds: LatLngBounds): this\n    // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).\n    setMaxBounds: function setMaxBounds(bounds) {\n      bounds = toLatLngBounds(bounds);\n      if (this.listens('moveend', this._panInsideMaxBounds)) {\n        this.off('moveend', this._panInsideMaxBounds);\n      }\n      if (!bounds.isValid()) {\n        this.options.maxBounds = null;\n        return this;\n      }\n      this.options.maxBounds = bounds;\n      if (this._loaded) {\n        this._panInsideMaxBounds();\n      }\n      return this.on('moveend', this._panInsideMaxBounds);\n    },\n    // @method setMinZoom(zoom: Number): this\n    // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).\n    setMinZoom: function setMinZoom(zoom) {\n      var oldZoom = this.options.minZoom;\n      this.options.minZoom = zoom;\n      if (this._loaded && oldZoom !== zoom) {\n        this.fire('zoomlevelschange');\n        if (this.getZoom() < this.options.minZoom) {\n          return this.setZoom(zoom);\n        }\n      }\n      return this;\n    },\n    // @method setMaxZoom(zoom: Number): this\n    // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).\n    setMaxZoom: function setMaxZoom(zoom) {\n      var oldZoom = this.options.maxZoom;\n      this.options.maxZoom = zoom;\n      if (this._loaded && oldZoom !== zoom) {\n        this.fire('zoomlevelschange');\n        if (this.getZoom() > this.options.maxZoom) {\n          return this.setZoom(zoom);\n        }\n      }\n      return this;\n    },\n    // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this\n    // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.\n    panInsideBounds: function panInsideBounds(bounds, options) {\n      this._enforcingBounds = true;\n      var center = this.getCenter(),\n        newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));\n      if (!center.equals(newCenter)) {\n        this.panTo(newCenter, options);\n      }\n      this._enforcingBounds = false;\n      return this;\n    },\n    // @method panInside(latlng: LatLng, options?: padding options): this\n    // Pans the map the minimum amount to make the `latlng` visible. Use\n    // padding options to fit the display to more restricted bounds.\n    // If `latlng` is already within the (optionally padded) display bounds,\n    // the map will not be panned.\n    panInside: function panInside(latlng, options) {\n      options = options || {};\n      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\n        paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\n        pixelCenter = this.project(this.getCenter()),\n        pixelPoint = this.project(latlng),\n        pixelBounds = this.getPixelBounds(),\n        paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]),\n        paddedSize = paddedBounds.getSize();\n      if (!paddedBounds.contains(pixelPoint)) {\n        this._enforcingBounds = true;\n        var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());\n        var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);\n        pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;\n        pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;\n        this.panTo(this.unproject(pixelCenter), options);\n        this._enforcingBounds = false;\n      }\n      return this;\n    },\n    // @method invalidateSize(options: Zoom/pan options): this\n    // Checks if the map container size changed and updates the map if so —\n    // call it after you've changed the map size dynamically, also animating\n    // pan by default. If `options.pan` is `false`, panning will not occur.\n    // If `options.debounceMoveend` is `true`, it will delay `moveend` event so\n    // that it doesn't happen often even if the method is called many\n    // times in a row.\n\n    // @alternative\n    // @method invalidateSize(animate: Boolean): this\n    // Checks if the map container size changed and updates the map if so —\n    // call it after you've changed the map size dynamically, also animating\n    // pan by default.\n    invalidateSize: function invalidateSize(options) {\n      if (!this._loaded) {\n        return this;\n      }\n      options = extend({\n        animate: false,\n        pan: true\n      }, options === true ? {\n        animate: true\n      } : options);\n      var oldSize = this.getSize();\n      this._sizeChanged = true;\n      this._lastCenter = null;\n      var newSize = this.getSize(),\n        oldCenter = oldSize.divideBy(2).round(),\n        newCenter = newSize.divideBy(2).round(),\n        offset = oldCenter.subtract(newCenter);\n      if (!offset.x && !offset.y) {\n        return this;\n      }\n      if (options.animate && options.pan) {\n        this.panBy(offset);\n      } else {\n        if (options.pan) {\n          this._rawPanBy(offset);\n        }\n        this.fire('move');\n        if (options.debounceMoveend) {\n          clearTimeout(this._sizeTimer);\n          this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);\n        } else {\n          this.fire('moveend');\n        }\n      }\n\n      // @section Map state change events\n      // @event resize: ResizeEvent\n      // Fired when the map is resized.\n      return this.fire('resize', {\n        oldSize: oldSize,\n        newSize: newSize\n      });\n    },\n    // @section Methods for modifying map state\n    // @method stop(): this\n    // Stops the currently running `panTo` or `flyTo` animation, if any.\n    stop: function stop() {\n      this.setZoom(this._limitZoom(this._zoom));\n      if (!this.options.zoomSnap) {\n        this.fire('viewreset');\n      }\n      return this._stop();\n    },\n    // @section Geolocation methods\n    // @method locate(options?: Locate options): this\n    // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)\n    // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,\n    // and optionally sets the map view to the user's location with respect to\n    // detection accuracy (or to the world view if geolocation failed).\n    // Note that, if your page doesn't use HTTPS, this method will fail in\n    // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))\n    // See `Locate options` for more details.\n    locate: function locate(options) {\n      options = this._locateOptions = extend({\n        timeout: 10000,\n        watch: false\n        // setView: false\n        // maxZoom: <Number>\n        // maximumAge: 0\n        // enableHighAccuracy: false\n      }, options);\n      if (!('geolocation' in navigator)) {\n        this._handleGeolocationError({\n          code: 0,\n          message: 'Geolocation not supported.'\n        });\n        return this;\n      }\n      var onResponse = bind(this._handleGeolocationResponse, this),\n        onError = bind(this._handleGeolocationError, this);\n      if (options.watch) {\n        this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);\n      } else {\n        navigator.geolocation.getCurrentPosition(onResponse, onError, options);\n      }\n      return this;\n    },\n    // @method stopLocate(): this\n    // Stops watching location previously initiated by `map.locate({watch: true})`\n    // and aborts resetting the map view if map.locate was called with\n    // `{setView: true}`.\n    stopLocate: function stopLocate() {\n      if (navigator.geolocation && navigator.geolocation.clearWatch) {\n        navigator.geolocation.clearWatch(this._locationWatchId);\n      }\n      if (this._locateOptions) {\n        this._locateOptions.setView = false;\n      }\n      return this;\n    },\n    _handleGeolocationError: function _handleGeolocationError(error) {\n      if (!this._container._leaflet_id) {\n        return;\n      }\n      var c = error.code,\n        message = error.message || (c === 1 ? 'permission denied' : c === 2 ? 'position unavailable' : 'timeout');\n      if (this._locateOptions.setView && !this._loaded) {\n        this.fitWorld();\n      }\n\n      // @section Location events\n      // @event locationerror: ErrorEvent\n      // Fired when geolocation (using the [`locate`](#map-locate) method) failed.\n      this.fire('locationerror', {\n        code: c,\n        message: 'Geolocation error: ' + message + '.'\n      });\n    },\n    _handleGeolocationResponse: function _handleGeolocationResponse(pos) {\n      if (!this._container._leaflet_id) {\n        return;\n      }\n      var lat = pos.coords.latitude,\n        lng = pos.coords.longitude,\n        latlng = new LatLng(lat, lng),\n        bounds = latlng.toBounds(pos.coords.accuracy * 2),\n        options = this._locateOptions;\n      if (options.setView) {\n        var zoom = this.getBoundsZoom(bounds);\n        this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);\n      }\n      var data = {\n        latlng: latlng,\n        bounds: bounds,\n        timestamp: pos.timestamp\n      };\n      for (var i in pos.coords) {\n        if (typeof pos.coords[i] === 'number') {\n          data[i] = pos.coords[i];\n        }\n      }\n\n      // @event locationfound: LocationEvent\n      // Fired when geolocation (using the [`locate`](#map-locate) method)\n      // went successfully.\n      this.fire('locationfound', data);\n    },\n    // TODO Appropriate docs section?\n    // @section Other Methods\n    // @method addHandler(name: String, HandlerClass: Function): this\n    // Adds a new `Handler` to the map, given its name and constructor function.\n    addHandler: function addHandler(name, HandlerClass) {\n      if (!HandlerClass) {\n        return this;\n      }\n      var handler = this[name] = new HandlerClass(this);\n      this._handlers.push(handler);\n      if (this.options[name]) {\n        handler.enable();\n      }\n      return this;\n    },\n    // @method remove(): this\n    // Destroys the map and clears all related event listeners.\n    remove: function remove() {\n      this._initEvents(true);\n      if (this.options.maxBounds) {\n        this.off('moveend', this._panInsideMaxBounds);\n      }\n      if (this._containerId !== this._container._leaflet_id) {\n        throw new Error('Map container is being reused by another instance');\n      }\n      try {\n        // throws error in IE6-8\n        delete this._container._leaflet_id;\n        delete this._containerId;\n      } catch (e) {\n        /*eslint-disable */\n        this._container._leaflet_id = undefined;\n        /* eslint-enable */\n        this._containerId = undefined;\n      }\n      if (this._locationWatchId !== undefined) {\n        this.stopLocate();\n      }\n      this._stop();\n      _remove(this._mapPane);\n      if (this._clearControlPos) {\n        this._clearControlPos();\n      }\n      if (this._resizeRequest) {\n        cancelAnimFrame(this._resizeRequest);\n        this._resizeRequest = null;\n      }\n      this._clearHandlers();\n      if (this._loaded) {\n        // @section Map state change events\n        // @event unload: Event\n        // Fired when the map is destroyed with [remove](#map-remove) method.\n        this.fire('unload');\n      }\n      var i;\n      for (i in this._layers) {\n        this._layers[i].remove();\n      }\n      for (i in this._panes) {\n        _remove(this._panes[i]);\n      }\n      this._layers = [];\n      this._panes = [];\n      delete this._mapPane;\n      delete this._renderer;\n      return this;\n    },\n    // @section Other Methods\n    // @method createPane(name: String, container?: HTMLElement): HTMLElement\n    // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,\n    // then returns it. The pane is created as a child of `container`, or\n    // as a child of the main map pane if not set.\n    createPane: function createPane(name, container) {\n      var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),\n        pane = create$1('div', className, container || this._mapPane);\n      if (name) {\n        this._panes[name] = pane;\n      }\n      return pane;\n    },\n    // @section Methods for Getting Map State\n\n    // @method getCenter(): LatLng\n    // Returns the geographical center of the map view\n    getCenter: function getCenter() {\n      this._checkIfLoaded();\n      if (this._lastCenter && !this._moved()) {\n        return this._lastCenter.clone();\n      }\n      return this.layerPointToLatLng(this._getCenterLayerPoint());\n    },\n    // @method getZoom(): Number\n    // Returns the current zoom level of the map view\n    getZoom: function getZoom() {\n      return this._zoom;\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the geographical bounds visible in the current map view\n    getBounds: function getBounds() {\n      var bounds = this.getPixelBounds(),\n        sw = this.unproject(bounds.getBottomLeft()),\n        ne = this.unproject(bounds.getTopRight());\n      return new LatLngBounds(sw, ne);\n    },\n    // @method getMinZoom(): Number\n    // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.\n    getMinZoom: function getMinZoom() {\n      return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;\n    },\n    // @method getMaxZoom(): Number\n    // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).\n    getMaxZoom: function getMaxZoom() {\n      return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;\n    },\n    // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number\n    // Returns the maximum zoom level on which the given bounds fit to the map\n    // view in its entirety. If `inside` (optional) is set to `true`, the method\n    // instead returns the minimum zoom level on which the map view fits into\n    // the given bounds in its entirety.\n    getBoundsZoom: function getBoundsZoom(bounds, inside, padding) {\n      // (LatLngBounds[, Boolean, Point]) -> Number\n      bounds = toLatLngBounds(bounds);\n      padding = toPoint(padding || [0, 0]);\n      var zoom = this.getZoom() || 0,\n        min = this.getMinZoom(),\n        max = this.getMaxZoom(),\n        nw = bounds.getNorthWest(),\n        se = bounds.getSouthEast(),\n        size = this.getSize().subtract(padding),\n        boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),\n        snap = Browser.any3d ? this.options.zoomSnap : 1,\n        scalex = size.x / boundsSize.x,\n        scaley = size.y / boundsSize.y,\n        scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);\n      zoom = this.getScaleZoom(scale, zoom);\n      if (snap) {\n        zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level\n        zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;\n      }\n      return Math.max(min, Math.min(max, zoom));\n    },\n    // @method getSize(): Point\n    // Returns the current size of the map container (in pixels).\n    getSize: function getSize() {\n      if (!this._size || this._sizeChanged) {\n        this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0);\n        this._sizeChanged = false;\n      }\n      return this._size.clone();\n    },\n    // @method getPixelBounds(): Bounds\n    // Returns the bounds of the current map view in projected pixel\n    // coordinates (sometimes useful in layer and overlay implementations).\n    getPixelBounds: function getPixelBounds(center, zoom) {\n      var topLeftPoint = this._getTopLeftPoint(center, zoom);\n      return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\n    },\n    // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to\n    // the map pane? \"left point of the map layer\" can be confusing, specially\n    // since there can be negative offsets.\n    // @method getPixelOrigin(): Point\n    // Returns the projected pixel coordinates of the top left point of\n    // the map layer (useful in custom layer and overlay implementations).\n    getPixelOrigin: function getPixelOrigin() {\n      this._checkIfLoaded();\n      return this._pixelOrigin;\n    },\n    // @method getPixelWorldBounds(zoom?: Number): Bounds\n    // Returns the world's bounds in pixel coordinates for zoom level `zoom`.\n    // If `zoom` is omitted, the map's current zoom level is used.\n    getPixelWorldBounds: function getPixelWorldBounds(zoom) {\n      return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);\n    },\n    // @section Other Methods\n\n    // @method getPane(pane: String|HTMLElement): HTMLElement\n    // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).\n    getPane: function getPane(pane) {\n      return typeof pane === 'string' ? this._panes[pane] : pane;\n    },\n    // @method getPanes(): Object\n    // Returns a plain object containing the names of all [panes](#map-pane) as keys and\n    // the panes as values.\n    getPanes: function getPanes() {\n      return this._panes;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTML element that contains the map.\n    getContainer: function getContainer() {\n      return this._container;\n    },\n    // @section Conversion Methods\n\n    // @method getZoomScale(toZoom: Number, fromZoom: Number): Number\n    // Returns the scale factor to be applied to a map transition from zoom level\n    // `fromZoom` to `toZoom`. Used internally to help with zoom animations.\n    getZoomScale: function getZoomScale(toZoom, fromZoom) {\n      // TODO replace with universal implementation after refactoring projections\n      var crs = this.options.crs;\n      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\n      return crs.scale(toZoom) / crs.scale(fromZoom);\n    },\n    // @method getScaleZoom(scale: Number, fromZoom: Number): Number\n    // Returns the zoom level that the map would end up at, if it is at `fromZoom`\n    // level and everything is scaled by a factor of `scale`. Inverse of\n    // [`getZoomScale`](#map-getZoomScale).\n    getScaleZoom: function getScaleZoom(scale, fromZoom) {\n      var crs = this.options.crs;\n      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\n      var zoom = crs.zoom(scale * crs.scale(fromZoom));\n      return isNaN(zoom) ? Infinity : zoom;\n    },\n    // @method project(latlng: LatLng, zoom: Number): Point\n    // Projects a geographical coordinate `LatLng` according to the projection\n    // of the map's CRS, then scales it according to `zoom` and the CRS's\n    // `Transformation`. The result is pixel coordinate relative to\n    // the CRS origin.\n    project: function project(latlng, zoom) {\n      zoom = zoom === undefined ? this._zoom : zoom;\n      return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);\n    },\n    // @method unproject(point: Point, zoom: Number): LatLng\n    // Inverse of [`project`](#map-project).\n    unproject: function unproject(point, zoom) {\n      zoom = zoom === undefined ? this._zoom : zoom;\n      return this.options.crs.pointToLatLng(toPoint(point), zoom);\n    },\n    // @method layerPointToLatLng(point: Point): LatLng\n    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n    // returns the corresponding geographical coordinate (for the current zoom level).\n    layerPointToLatLng: function layerPointToLatLng(point) {\n      var projectedPoint = toPoint(point).add(this.getPixelOrigin());\n      return this.unproject(projectedPoint);\n    },\n    // @method latLngToLayerPoint(latlng: LatLng): Point\n    // Given a geographical coordinate, returns the corresponding pixel coordinate\n    // relative to the [origin pixel](#map-getpixelorigin).\n    latLngToLayerPoint: function latLngToLayerPoint(latlng) {\n      var projectedPoint = this.project(toLatLng(latlng))._round();\n      return projectedPoint._subtract(this.getPixelOrigin());\n    },\n    // @method wrapLatLng(latlng: LatLng): LatLng\n    // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the\n    // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the\n    // CRS's bounds.\n    // By default this means longitude is wrapped around the dateline so its\n    // value is between -180 and +180 degrees.\n    wrapLatLng: function wrapLatLng(latlng) {\n      return this.options.crs.wrapLatLng(toLatLng(latlng));\n    },\n    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\n    // Returns a `LatLngBounds` with the same size as the given one, ensuring that\n    // its center is within the CRS's bounds.\n    // By default this means the center longitude is wrapped around the dateline so its\n    // value is between -180 and +180 degrees, and the majority of the bounds\n    // overlaps the CRS's bounds.\n    wrapLatLngBounds: function wrapLatLngBounds(latlng) {\n      return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));\n    },\n    // @method distance(latlng1: LatLng, latlng2: LatLng): Number\n    // Returns the distance between two geographical coordinates according to\n    // the map's CRS. By default this measures distance in meters.\n    distance: function distance(latlng1, latlng2) {\n      return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));\n    },\n    // @method containerPointToLayerPoint(point: Point): Point\n    // Given a pixel coordinate relative to the map container, returns the corresponding\n    // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).\n    containerPointToLayerPoint: function containerPointToLayerPoint(point) {\n      // (Point)\n      return toPoint(point).subtract(this._getMapPanePos());\n    },\n    // @method layerPointToContainerPoint(point: Point): Point\n    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n    // returns the corresponding pixel coordinate relative to the map container.\n    layerPointToContainerPoint: function layerPointToContainerPoint(point) {\n      // (Point)\n      return toPoint(point).add(this._getMapPanePos());\n    },\n    // @method containerPointToLatLng(point: Point): LatLng\n    // Given a pixel coordinate relative to the map container, returns\n    // the corresponding geographical coordinate (for the current zoom level).\n    containerPointToLatLng: function containerPointToLatLng(point) {\n      var layerPoint = this.containerPointToLayerPoint(toPoint(point));\n      return this.layerPointToLatLng(layerPoint);\n    },\n    // @method latLngToContainerPoint(latlng: LatLng): Point\n    // Given a geographical coordinate, returns the corresponding pixel coordinate\n    // relative to the map container.\n    latLngToContainerPoint: function latLngToContainerPoint(latlng) {\n      return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));\n    },\n    // @method mouseEventToContainerPoint(ev: MouseEvent): Point\n    // Given a MouseEvent object, returns the pixel coordinate relative to the\n    // map container where the event took place.\n    mouseEventToContainerPoint: function mouseEventToContainerPoint(e) {\n      return getMousePosition(e, this._container);\n    },\n    // @method mouseEventToLayerPoint(ev: MouseEvent): Point\n    // Given a MouseEvent object, returns the pixel coordinate relative to\n    // the [origin pixel](#map-getpixelorigin) where the event took place.\n    mouseEventToLayerPoint: function mouseEventToLayerPoint(e) {\n      return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\n    },\n    // @method mouseEventToLatLng(ev: MouseEvent): LatLng\n    // Given a MouseEvent object, returns geographical coordinate where the\n    // event took place.\n    mouseEventToLatLng: function mouseEventToLatLng(e) {\n      // (MouseEvent)\n      return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\n    },\n    // map initialization methods\n\n    _initContainer: function _initContainer(id) {\n      var container = this._container = get(id);\n      if (!container) {\n        throw new Error('Map container not found.');\n      } else if (container._leaflet_id) {\n        throw new Error('Map container is already initialized.');\n      }\n      on(container, 'scroll', this._onScroll, this);\n      this._containerId = stamp(container);\n    },\n    _initLayout: function _initLayout() {\n      var container = this._container;\n      this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;\n      addClass(container, 'leaflet-container' + (Browser.touch ? ' leaflet-touch' : '') + (Browser.retina ? ' leaflet-retina' : '') + (Browser.ielt9 ? ' leaflet-oldie' : '') + (Browser.safari ? ' leaflet-safari' : '') + (this._fadeAnimated ? ' leaflet-fade-anim' : ''));\n      var position = getStyle(container, 'position');\n      if (position !== 'absolute' && position !== 'relative' && position !== 'fixed' && position !== 'sticky') {\n        container.style.position = 'relative';\n      }\n      this._initPanes();\n      if (this._initControlPos) {\n        this._initControlPos();\n      }\n    },\n    _initPanes: function _initPanes() {\n      var panes = this._panes = {};\n      this._paneRenderers = {};\n\n      // @section\n      //\n      // Panes are DOM elements used to control the ordering of layers on the map. You\n      // can access panes with [`map.getPane`](#map-getpane) or\n      // [`map.getPanes`](#map-getpanes) methods. New panes can be created with the\n      // [`map.createPane`](#map-createpane) method.\n      //\n      // Every map has the following default panes that differ only in zIndex.\n      //\n      // @pane mapPane: HTMLElement = 'auto'\n      // Pane that contains all other map panes\n\n      this._mapPane = this.createPane('mapPane', this._container);\n      setPosition(this._mapPane, new Point(0, 0));\n\n      // @pane tilePane: HTMLElement = 200\n      // Pane for `GridLayer`s and `TileLayer`s\n      this.createPane('tilePane');\n      // @pane overlayPane: HTMLElement = 400\n      // Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s\n      this.createPane('overlayPane');\n      // @pane shadowPane: HTMLElement = 500\n      // Pane for overlay shadows (e.g. `Marker` shadows)\n      this.createPane('shadowPane');\n      // @pane markerPane: HTMLElement = 600\n      // Pane for `Icon`s of `Marker`s\n      this.createPane('markerPane');\n      // @pane tooltipPane: HTMLElement = 650\n      // Pane for `Tooltip`s.\n      this.createPane('tooltipPane');\n      // @pane popupPane: HTMLElement = 700\n      // Pane for `Popup`s.\n      this.createPane('popupPane');\n      if (!this.options.markerZoomAnimation) {\n        addClass(panes.markerPane, 'leaflet-zoom-hide');\n        addClass(panes.shadowPane, 'leaflet-zoom-hide');\n      }\n    },\n    // private methods that modify map state\n\n    // @section Map state change events\n    _resetView: function _resetView(center, zoom, noMoveStart) {\n      setPosition(this._mapPane, new Point(0, 0));\n      var loading = !this._loaded;\n      this._loaded = true;\n      zoom = this._limitZoom(zoom);\n      this.fire('viewprereset');\n      var zoomChanged = this._zoom !== zoom;\n      this._moveStart(zoomChanged, noMoveStart)._move(center, zoom)._moveEnd(zoomChanged);\n\n      // @event viewreset: Event\n      // Fired when the map needs to redraw its content (this usually happens\n      // on map zoom or load). Very useful for creating custom overlays.\n      this.fire('viewreset');\n\n      // @event load: Event\n      // Fired when the map is initialized (when its center and zoom are set\n      // for the first time).\n      if (loading) {\n        this.fire('load');\n      }\n    },\n    _moveStart: function _moveStart(zoomChanged, noMoveStart) {\n      // @event zoomstart: Event\n      // Fired when the map zoom is about to change (e.g. before zoom animation).\n      // @event movestart: Event\n      // Fired when the view of the map starts changing (e.g. user starts dragging the map).\n      if (zoomChanged) {\n        this.fire('zoomstart');\n      }\n      if (!noMoveStart) {\n        this.fire('movestart');\n      }\n      return this;\n    },\n    _move: function _move(center, zoom, data, supressEvent) {\n      if (zoom === undefined) {\n        zoom = this._zoom;\n      }\n      var zoomChanged = this._zoom !== zoom;\n      this._zoom = zoom;\n      this._lastCenter = center;\n      this._pixelOrigin = this._getNewPixelOrigin(center);\n      if (!supressEvent) {\n        // @event zoom: Event\n        // Fired repeatedly during any change in zoom level,\n        // including zoom and fly animations.\n        if (zoomChanged || data && data.pinch) {\n          // Always fire 'zoom' if pinching because #3530\n          this.fire('zoom', data);\n        }\n\n        // @event move: Event\n        // Fired repeatedly during any movement of the map,\n        // including pan and fly animations.\n        this.fire('move', data);\n      } else if (data && data.pinch) {\n        // Always fire 'zoom' if pinching because #3530\n        this.fire('zoom', data);\n      }\n      return this;\n    },\n    _moveEnd: function _moveEnd(zoomChanged) {\n      // @event zoomend: Event\n      // Fired when the map zoom changed, after any animations.\n      if (zoomChanged) {\n        this.fire('zoomend');\n      }\n\n      // @event moveend: Event\n      // Fired when the center of the map stops changing\n      // (e.g. user stopped dragging the map or after non-centered zoom).\n      return this.fire('moveend');\n    },\n    _stop: function _stop() {\n      cancelAnimFrame(this._flyToFrame);\n      if (this._panAnim) {\n        this._panAnim.stop();\n      }\n      return this;\n    },\n    _rawPanBy: function _rawPanBy(offset) {\n      setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\n    },\n    _getZoomSpan: function _getZoomSpan() {\n      return this.getMaxZoom() - this.getMinZoom();\n    },\n    _panInsideMaxBounds: function _panInsideMaxBounds() {\n      if (!this._enforcingBounds) {\n        this.panInsideBounds(this.options.maxBounds);\n      }\n    },\n    _checkIfLoaded: function _checkIfLoaded() {\n      if (!this._loaded) {\n        throw new Error('Set map center and zoom first.');\n      }\n    },\n    // DOM event handling\n\n    // @section Interaction events\n    _initEvents: function _initEvents(remove) {\n      this._targets = {};\n      this._targets[stamp(this._container)] = this;\n      var onOff = remove ? off : on;\n\n      // @event click: MouseEvent\n      // Fired when the user clicks (or taps) the map.\n      // @event dblclick: MouseEvent\n      // Fired when the user double-clicks (or double-taps) the map.\n      // @event mousedown: MouseEvent\n      // Fired when the user pushes the mouse button on the map.\n      // @event mouseup: MouseEvent\n      // Fired when the user releases the mouse button on the map.\n      // @event mouseover: MouseEvent\n      // Fired when the mouse enters the map.\n      // @event mouseout: MouseEvent\n      // Fired when the mouse leaves the map.\n      // @event mousemove: MouseEvent\n      // Fired while the mouse moves over the map.\n      // @event contextmenu: MouseEvent\n      // Fired when the user pushes the right mouse button on the map, prevents\n      // default browser context menu from showing if there are listeners on\n      // this event. Also fired on mobile when the user holds a single touch\n      // for a second (also called long press).\n      // @event keypress: KeyboardEvent\n      // Fired when the user presses a key from the keyboard that produces a character value while the map is focused.\n      // @event keydown: KeyboardEvent\n      // Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,\n      // the `keydown` event is fired for keys that produce a character value and for keys\n      // that do not produce a character value.\n      // @event keyup: KeyboardEvent\n      // Fired when the user releases a key from the keyboard while the map is focused.\n      onOff(this._container, 'click dblclick mousedown mouseup ' + 'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);\n      if (this.options.trackResize) {\n        onOff(window, 'resize', this._onResize, this);\n      }\n      if (Browser.any3d && this.options.transform3DLimit) {\n        (remove ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);\n      }\n    },\n    _onResize: function _onResize() {\n      cancelAnimFrame(this._resizeRequest);\n      this._resizeRequest = requestAnimFrame(function () {\n        this.invalidateSize({\n          debounceMoveend: true\n        });\n      }, this);\n    },\n    _onScroll: function _onScroll() {\n      this._container.scrollTop = 0;\n      this._container.scrollLeft = 0;\n    },\n    _onMoveEnd: function _onMoveEnd() {\n      var pos = this._getMapPanePos();\n      if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have\n        // a pixel offset on very high values, see: https://jsfiddle.net/dg6r5hhb/\n        this._resetView(this.getCenter(), this.getZoom());\n      }\n    },\n    _findEventTargets: function _findEventTargets(e, type) {\n      var targets = [],\n        target,\n        isHover = type === 'mouseout' || type === 'mouseover',\n        src = e.target || e.srcElement,\n        dragging = false;\n      while (src) {\n        target = this._targets[stamp(src)];\n        if (target && (type === 'click' || type === 'preclick') && this._draggableMoved(target)) {\n          // Prevent firing click after you just dragged an object.\n          dragging = true;\n          break;\n        }\n        if (target && target.listens(type, true)) {\n          if (isHover && !isExternalTarget(src, e)) {\n            break;\n          }\n          targets.push(target);\n          if (isHover) {\n            break;\n          }\n        }\n        if (src === this._container) {\n          break;\n        }\n        src = src.parentNode;\n      }\n      if (!targets.length && !dragging && !isHover && this.listens(type, true)) {\n        targets = [this];\n      }\n      return targets;\n    },\n    _isClickDisabled: function _isClickDisabled(el) {\n      while (el && el !== this._container) {\n        if (el['_leaflet_disable_click']) {\n          return true;\n        }\n        el = el.parentNode;\n      }\n    },\n    _handleDOMEvent: function _handleDOMEvent(e) {\n      var el = e.target || e.srcElement;\n      if (!this._loaded || el['_leaflet_disable_events'] || e.type === 'click' && this._isClickDisabled(el)) {\n        return;\n      }\n      var type = e.type;\n      if (type === 'mousedown') {\n        // prevents outline when clicking on keyboard-focusable element\n        preventOutline(el);\n      }\n      this._fireDOMEvent(e, type);\n    },\n    _mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],\n    _fireDOMEvent: function _fireDOMEvent(e, type, canvasTargets) {\n      if (e.type === 'click') {\n        // Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).\n        // @event preclick: MouseEvent\n        // Fired before mouse click on the map (sometimes useful when you\n        // want something to happen on click before any existing click\n        // handlers start running).\n        var synth = extend({}, e);\n        synth.type = 'preclick';\n        this._fireDOMEvent(synth, synth.type, canvasTargets);\n      }\n\n      // Find the layer the event is propagating from and its parents.\n      var targets = this._findEventTargets(e, type);\n      if (canvasTargets) {\n        var filtered = []; // pick only targets with listeners\n        for (var i = 0; i < canvasTargets.length; i++) {\n          if (canvasTargets[i].listens(type, true)) {\n            filtered.push(canvasTargets[i]);\n          }\n        }\n        targets = filtered.concat(targets);\n      }\n      if (!targets.length) {\n        return;\n      }\n      if (type === 'contextmenu') {\n        preventDefault(e);\n      }\n      var target = targets[0];\n      var data = {\n        originalEvent: e\n      };\n      if (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {\n        var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);\n        data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);\n        data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);\n        data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);\n      }\n      for (i = 0; i < targets.length; i++) {\n        targets[i].fire(type, data, true);\n        if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {\n          return;\n        }\n      }\n    },\n    _draggableMoved: function _draggableMoved(obj) {\n      obj = obj.dragging && obj.dragging.enabled() ? obj : this;\n      return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();\n    },\n    _clearHandlers: function _clearHandlers() {\n      for (var i = 0, len = this._handlers.length; i < len; i++) {\n        this._handlers[i].disable();\n      }\n    },\n    // @section Other Methods\n\n    // @method whenReady(fn: Function, context?: Object): this\n    // Runs the given function `fn` when the map gets initialized with\n    // a view (center and zoom) and at least one layer, or immediately\n    // if it's already initialized, optionally passing a function context.\n    whenReady: function whenReady(callback, context) {\n      if (this._loaded) {\n        callback.call(context || this, {\n          target: this\n        });\n      } else {\n        this.on('load', callback, context);\n      }\n      return this;\n    },\n    // private methods for getting map state\n\n    _getMapPanePos: function _getMapPanePos() {\n      return getPosition(this._mapPane) || new Point(0, 0);\n    },\n    _moved: function _moved() {\n      var pos = this._getMapPanePos();\n      return pos && !pos.equals([0, 0]);\n    },\n    _getTopLeftPoint: function _getTopLeftPoint(center, zoom) {\n      var pixelOrigin = center && zoom !== undefined ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin();\n      return pixelOrigin.subtract(this._getMapPanePos());\n    },\n    _getNewPixelOrigin: function _getNewPixelOrigin(center, zoom) {\n      var viewHalf = this.getSize()._divideBy(2);\n      return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();\n    },\n    _latLngToNewLayerPoint: function _latLngToNewLayerPoint(latlng, zoom, center) {\n      var topLeft = this._getNewPixelOrigin(center, zoom);\n      return this.project(latlng, zoom)._subtract(topLeft);\n    },\n    _latLngBoundsToNewLayerBounds: function _latLngBoundsToNewLayerBounds(latLngBounds, zoom, center) {\n      var topLeft = this._getNewPixelOrigin(center, zoom);\n      return toBounds([this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)]);\n    },\n    // layer point of the current center\n    _getCenterLayerPoint: function _getCenterLayerPoint() {\n      return this.containerPointToLayerPoint(this.getSize()._divideBy(2));\n    },\n    // offset of the specified place to the current center in pixels\n    _getCenterOffset: function _getCenterOffset(latlng) {\n      return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\n    },\n    // adjust center for view to get inside bounds\n    _limitCenter: function _limitCenter(center, zoom, bounds) {\n      if (!bounds) {\n        return center;\n      }\n      var centerPoint = this.project(center, zoom),\n        viewHalf = this.getSize().divideBy(2),\n        viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\n        offset = this._getBoundsOffset(viewBounds, bounds, zoom);\n\n      // If offset is less than a pixel, ignore.\n      // This prevents unstable projections from getting into\n      // an infinite loop of tiny offsets.\n      if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {\n        return center;\n      }\n      return this.unproject(centerPoint.add(offset), zoom);\n    },\n    // adjust offset for view to get inside bounds\n    _limitOffset: function _limitOffset(offset, bounds) {\n      if (!bounds) {\n        return offset;\n      }\n      var viewBounds = this.getPixelBounds(),\n        newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\n      return offset.add(this._getBoundsOffset(newBounds, bounds));\n    },\n    // returns offset needed for pxBounds to get inside maxBounds at a specified zoom\n    _getBoundsOffset: function _getBoundsOffset(pxBounds, maxBounds, zoom) {\n      var projectedMaxBounds = toBounds(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)),\n        minOffset = projectedMaxBounds.min.subtract(pxBounds.min),\n        maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),\n        dx = this._rebound(minOffset.x, -maxOffset.x),\n        dy = this._rebound(minOffset.y, -maxOffset.y);\n      return new Point(dx, dy);\n    },\n    _rebound: function _rebound(left, right) {\n      return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\n    },\n    _limitZoom: function _limitZoom(zoom) {\n      var min = this.getMinZoom(),\n        max = this.getMaxZoom(),\n        snap = Browser.any3d ? this.options.zoomSnap : 1;\n      if (snap) {\n        zoom = Math.round(zoom / snap) * snap;\n      }\n      return Math.max(min, Math.min(max, zoom));\n    },\n    _onPanTransitionStep: function _onPanTransitionStep() {\n      this.fire('move');\n    },\n    _onPanTransitionEnd: function _onPanTransitionEnd() {\n      removeClass(this._mapPane, 'leaflet-pan-anim');\n      this.fire('moveend');\n    },\n    _tryAnimatedPan: function _tryAnimatedPan(center, options) {\n      // difference between the new and current centers in pixels\n      var offset = this._getCenterOffset(center)._trunc();\n\n      // don't animate too far unless animate: true specified in options\n      if ((options && options.animate) !== true && !this.getSize().contains(offset)) {\n        return false;\n      }\n      this.panBy(offset, options);\n      return true;\n    },\n    _createAnimProxy: function _createAnimProxy() {\n      var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');\n      this._panes.mapPane.appendChild(proxy);\n      this.on('zoomanim', function (e) {\n        var prop = TRANSFORM,\n          transform = this._proxy.style[prop];\n        setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));\n\n        // workaround for case when transform is the same and so transitionend event is not fired\n        if (transform === this._proxy.style[prop] && this._animatingZoom) {\n          this._onZoomTransitionEnd();\n        }\n      }, this);\n      this.on('load moveend', this._animMoveEnd, this);\n      this._on('unload', this._destroyAnimProxy, this);\n    },\n    _destroyAnimProxy: function _destroyAnimProxy() {\n      _remove(this._proxy);\n      this.off('load moveend', this._animMoveEnd, this);\n      delete this._proxy;\n    },\n    _animMoveEnd: function _animMoveEnd() {\n      var c = this.getCenter(),\n        z = this.getZoom();\n      setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));\n    },\n    _catchTransitionEnd: function _catchTransitionEnd(e) {\n      if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\n        this._onZoomTransitionEnd();\n      }\n    },\n    _nothingToAnimate: function _nothingToAnimate() {\n      return !this._container.getElementsByClassName('leaflet-zoom-animated').length;\n    },\n    _tryAnimatedZoom: function _tryAnimatedZoom(center, zoom, options) {\n      if (this._animatingZoom) {\n        return true;\n      }\n      options = options || {};\n\n      // don't animate if disabled, not supported or zoom difference is too large\n      if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {\n        return false;\n      }\n\n      // offset is the pixel coords of the zoom origin relative to the current center\n      var scale = this.getZoomScale(zoom),\n        offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);\n\n      // don't animate if the zoom origin isn't within one screen from the current center, unless forced\n      if (options.animate !== true && !this.getSize().contains(offset)) {\n        return false;\n      }\n      requestAnimFrame(function () {\n        this._moveStart(true, options.noMoveStart || false)._animateZoom(center, zoom, true);\n      }, this);\n      return true;\n    },\n    _animateZoom: function _animateZoom(center, zoom, startAnim, noUpdate) {\n      if (!this._mapPane) {\n        return;\n      }\n      if (startAnim) {\n        this._animatingZoom = true;\n\n        // remember what center/zoom to set after animation\n        this._animateToCenter = center;\n        this._animateToZoom = zoom;\n        addClass(this._mapPane, 'leaflet-zoom-anim');\n      }\n\n      // @section Other Events\n      // @event zoomanim: ZoomAnimEvent\n      // Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.\n      this.fire('zoomanim', {\n        center: center,\n        zoom: zoom,\n        noUpdate: noUpdate\n      });\n      if (!this._tempFireZoomEvent) {\n        this._tempFireZoomEvent = this._zoom !== this._animateToZoom;\n      }\n      this._move(this._animateToCenter, this._animateToZoom, undefined, true);\n\n      // Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693\n      setTimeout(bind(this._onZoomTransitionEnd, this), 250);\n    },\n    _onZoomTransitionEnd: function _onZoomTransitionEnd() {\n      if (!this._animatingZoom) {\n        return;\n      }\n      if (this._mapPane) {\n        removeClass(this._mapPane, 'leaflet-zoom-anim');\n      }\n      this._animatingZoom = false;\n      this._move(this._animateToCenter, this._animateToZoom, undefined, true);\n      if (this._tempFireZoomEvent) {\n        this.fire('zoom');\n      }\n      delete this._tempFireZoomEvent;\n      this.fire('move');\n      this._moveEnd(true);\n    }\n  });\n\n  // @section\n\n  // @factory L.map(id: String, options?: Map options)\n  // Instantiates a map object given the DOM ID of a `<div>` element\n  // and optionally an object literal with `Map options`.\n  //\n  // @alternative\n  // @factory L.map(el: HTMLElement, options?: Map options)\n  // Instantiates a map object given an instance of a `<div>` HTML element\n  // and optionally an object literal with `Map options`.\n  function createMap(id, options) {\n    return new Map(id, options);\n  }\n\n  /*\r\n   * @class Control\r\n   * @aka L.Control\r\n   * @inherits Class\r\n   *\r\n   * L.Control is a base class for implementing map controls. Handles positioning.\r\n   * All other controls extend from this class.\r\n   */\n\n  var Control = Class.extend({\n    // @section\n    // @aka Control Options\n    options: {\n      // @option position: String = 'topright'\n      // The position of the control (one of the map corners). Possible values are `'topleft'`,\n      // `'topright'`, `'bottomleft'` or `'bottomright'`\n      position: 'topright'\n    },\n    initialize: function initialize(options) {\n      setOptions(this, options);\n    },\n    /* @section\r\n     * Classes extending L.Control will inherit the following methods:\r\n     *\r\n     * @method getPosition: string\r\n     * Returns the position of the control.\r\n     */\n    getPosition: function getPosition() {\n      return this.options.position;\n    },\n    // @method setPosition(position: string): this\n    // Sets the position of the control.\n    setPosition: function setPosition(position) {\n      var map = this._map;\n      if (map) {\n        map.removeControl(this);\n      }\n      this.options.position = position;\n      if (map) {\n        map.addControl(this);\n      }\n      return this;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTMLElement that contains the control.\n    getContainer: function getContainer() {\n      return this._container;\n    },\n    // @method addTo(map: Map): this\n    // Adds the control to the given map.\n    addTo: function addTo(map) {\n      this.remove();\n      this._map = map;\n      var container = this._container = this.onAdd(map),\n        pos = this.getPosition(),\n        corner = map._controlCorners[pos];\n      addClass(container, 'leaflet-control');\n      if (pos.indexOf('bottom') !== -1) {\n        corner.insertBefore(container, corner.firstChild);\n      } else {\n        corner.appendChild(container);\n      }\n      this._map.on('unload', this.remove, this);\n      return this;\n    },\n    // @method remove: this\n    // Removes the control from the map it is currently active on.\n    remove: function remove() {\n      if (!this._map) {\n        return this;\n      }\n      _remove(this._container);\n      if (this.onRemove) {\n        this.onRemove(this._map);\n      }\n      this._map.off('unload', this.remove, this);\n      this._map = null;\n      return this;\n    },\n    _refocusOnMap: function _refocusOnMap(e) {\n      // if map exists and event is not a keyboard event\n      if (this._map && e && e.screenX > 0 && e.screenY > 0) {\n        this._map.getContainer().focus();\n      }\n    }\n  });\n  var control = function control(options) {\n    return new Control(options);\n  };\n\n  /* @section Extension methods\r\n   * @uninheritable\r\n   *\r\n   * Every control should extend from `L.Control` and (re-)implement the following methods.\r\n   *\r\n   * @method onAdd(map: Map): HTMLElement\r\n   * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).\r\n   *\r\n   * @method onRemove(map: Map)\r\n   * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).\r\n   */\n\n  /* @namespace Map\r\n   * @section Methods for Layers and Controls\r\n   */\n  Map.include({\n    // @method addControl(control: Control): this\n    // Adds the given control to the map\n    addControl: function addControl(control) {\n      control.addTo(this);\n      return this;\n    },\n    // @method removeControl(control: Control): this\n    // Removes the given control from the map\n    removeControl: function removeControl(control) {\n      control.remove();\n      return this;\n    },\n    _initControlPos: function _initControlPos() {\n      var corners = this._controlCorners = {},\n        l = 'leaflet-',\n        container = this._controlContainer = create$1('div', l + 'control-container', this._container);\n      function createCorner(vSide, hSide) {\n        var className = l + vSide + ' ' + l + hSide;\n        corners[vSide + hSide] = create$1('div', className, container);\n      }\n      createCorner('top', 'left');\n      createCorner('top', 'right');\n      createCorner('bottom', 'left');\n      createCorner('bottom', 'right');\n    },\n    _clearControlPos: function _clearControlPos() {\n      for (var i in this._controlCorners) {\n        _remove(this._controlCorners[i]);\n      }\n      _remove(this._controlContainer);\n      delete this._controlCorners;\n      delete this._controlContainer;\n    }\n  });\n\n  /*\r\n   * @class Control.Layers\r\n   * @aka L.Control.Layers\r\n   * @inherits Control\r\n   *\r\n   * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](https://leafletjs.com/examples/layers-control/)). Extends `Control`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var baseLayers = {\r\n   * \t\"Mapbox\": mapbox,\r\n   * \t\"OpenStreetMap\": osm\r\n   * };\r\n   *\r\n   * var overlays = {\r\n   * \t\"Marker\": marker,\r\n   * \t\"Roads\": roadsLayer\r\n   * };\r\n   *\r\n   * L.control.layers(baseLayers, overlays).addTo(map);\r\n   * ```\r\n   *\r\n   * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:\r\n   *\r\n   * ```js\r\n   * {\r\n   *     \"<someName1>\": layer1,\r\n   *     \"<someName2>\": layer2\r\n   * }\r\n   * ```\r\n   *\r\n   * The layer names can contain HTML, which allows you to add additional styling to the items:\r\n   *\r\n   * ```js\r\n   * {\"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>\": myLayer}\r\n   * ```\r\n   */\n\n  var Layers = Control.extend({\n    // @section\n    // @aka Control.Layers options\n    options: {\n      // @option collapsed: Boolean = true\n      // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.\n      collapsed: true,\n      position: 'topright',\n      // @option autoZIndex: Boolean = true\n      // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.\n      autoZIndex: true,\n      // @option hideSingleBase: Boolean = false\n      // If `true`, the base layers in the control will be hidden when there is only one.\n      hideSingleBase: false,\n      // @option sortLayers: Boolean = false\n      // Whether to sort the layers. When `false`, layers will keep the order\n      // in which they were added to the control.\n      sortLayers: false,\n      // @option sortFunction: Function = *\n      // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\n      // that will be used for sorting the layers, when `sortLayers` is `true`.\n      // The function receives both the `L.Layer` instances and their names, as in\n      // `sortFunction(layerA, layerB, nameA, nameB)`.\n      // By default, it sorts layers alphabetically by their name.\n      sortFunction: function sortFunction(layerA, layerB, nameA, nameB) {\n        return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;\n      }\n    },\n    initialize: function initialize(baseLayers, overlays, options) {\n      setOptions(this, options);\n      this._layerControlInputs = [];\n      this._layers = [];\n      this._lastZIndex = 0;\n      this._handlingClick = false;\n      this._preventClick = false;\n      for (var i in baseLayers) {\n        this._addLayer(baseLayers[i], i);\n      }\n      for (i in overlays) {\n        this._addLayer(overlays[i], i, true);\n      }\n    },\n    onAdd: function onAdd(map) {\n      this._initLayout();\n      this._update();\n      this._map = map;\n      map.on('zoomend', this._checkDisabledLayers, this);\n      for (var i = 0; i < this._layers.length; i++) {\n        this._layers[i].layer.on('add remove', this._onLayerChange, this);\n      }\n      return this._container;\n    },\n    addTo: function addTo(map) {\n      Control.prototype.addTo.call(this, map);\n      // Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.\n      return this._expandIfNotCollapsed();\n    },\n    onRemove: function onRemove() {\n      this._map.off('zoomend', this._checkDisabledLayers, this);\n      for (var i = 0; i < this._layers.length; i++) {\n        this._layers[i].layer.off('add remove', this._onLayerChange, this);\n      }\n    },\n    // @method addBaseLayer(layer: Layer, name: String): this\n    // Adds a base layer (radio button entry) with the given name to the control.\n    addBaseLayer: function addBaseLayer(layer, name) {\n      this._addLayer(layer, name);\n      return this._map ? this._update() : this;\n    },\n    // @method addOverlay(layer: Layer, name: String): this\n    // Adds an overlay (checkbox entry) with the given name to the control.\n    addOverlay: function addOverlay(layer, name) {\n      this._addLayer(layer, name, true);\n      return this._map ? this._update() : this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Remove the given layer from the control.\n    removeLayer: function removeLayer(layer) {\n      layer.off('add remove', this._onLayerChange, this);\n      var obj = this._getLayer(stamp(layer));\n      if (obj) {\n        this._layers.splice(this._layers.indexOf(obj), 1);\n      }\n      return this._map ? this._update() : this;\n    },\n    // @method expand(): this\n    // Expand the control container if collapsed.\n    expand: function expand() {\n      addClass(this._container, 'leaflet-control-layers-expanded');\n      this._section.style.height = null;\n      var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);\n      if (acceptableHeight < this._section.clientHeight) {\n        addClass(this._section, 'leaflet-control-layers-scrollbar');\n        this._section.style.height = acceptableHeight + 'px';\n      } else {\n        removeClass(this._section, 'leaflet-control-layers-scrollbar');\n      }\n      this._checkDisabledLayers();\n      return this;\n    },\n    // @method collapse(): this\n    // Collapse the control container if expanded.\n    collapse: function collapse() {\n      removeClass(this._container, 'leaflet-control-layers-expanded');\n      return this;\n    },\n    _initLayout: function _initLayout() {\n      var className = 'leaflet-control-layers',\n        container = this._container = create$1('div', className),\n        collapsed = this.options.collapsed;\n\n      // makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released\n      container.setAttribute('aria-haspopup', true);\n      disableClickPropagation(container);\n      disableScrollPropagation(container);\n      var section = this._section = create$1('section', className + '-list');\n      if (collapsed) {\n        this._map.on('click', this.collapse, this);\n        on(container, {\n          mouseenter: this._expandSafely,\n          mouseleave: this.collapse\n        }, this);\n      }\n      var link = this._layersLink = create$1('a', className + '-toggle', container);\n      link.href = '#';\n      link.title = 'Layers';\n      link.setAttribute('role', 'button');\n      on(link, {\n        keydown: function keydown(e) {\n          if (e.keyCode === 13) {\n            this._expandSafely();\n          }\n        },\n        // Certain screen readers intercept the key event and instead send a click event\n        click: function click(e) {\n          preventDefault(e);\n          this._expandSafely();\n        }\n      }, this);\n      if (!collapsed) {\n        this.expand();\n      }\n      this._baseLayersList = create$1('div', className + '-base', section);\n      this._separator = create$1('div', className + '-separator', section);\n      this._overlaysList = create$1('div', className + '-overlays', section);\n      container.appendChild(section);\n    },\n    _getLayer: function _getLayer(id) {\n      for (var i = 0; i < this._layers.length; i++) {\n        if (this._layers[i] && stamp(this._layers[i].layer) === id) {\n          return this._layers[i];\n        }\n      }\n    },\n    _addLayer: function _addLayer(layer, name, overlay) {\n      if (this._map) {\n        layer.on('add remove', this._onLayerChange, this);\n      }\n      this._layers.push({\n        layer: layer,\n        name: name,\n        overlay: overlay\n      });\n      if (this.options.sortLayers) {\n        this._layers.sort(bind(function (a, b) {\n          return this.options.sortFunction(a.layer, b.layer, a.name, b.name);\n        }, this));\n      }\n      if (this.options.autoZIndex && layer.setZIndex) {\n        this._lastZIndex++;\n        layer.setZIndex(this._lastZIndex);\n      }\n      this._expandIfNotCollapsed();\n    },\n    _update: function _update() {\n      if (!this._container) {\n        return this;\n      }\n      empty(this._baseLayersList);\n      empty(this._overlaysList);\n      this._layerControlInputs = [];\n      var baseLayersPresent,\n        overlaysPresent,\n        i,\n        obj,\n        baseLayersCount = 0;\n      for (i = 0; i < this._layers.length; i++) {\n        obj = this._layers[i];\n        this._addItem(obj);\n        overlaysPresent = overlaysPresent || obj.overlay;\n        baseLayersPresent = baseLayersPresent || !obj.overlay;\n        baseLayersCount += !obj.overlay ? 1 : 0;\n      }\n\n      // Hide base layers section if there's only one layer.\n      if (this.options.hideSingleBase) {\n        baseLayersPresent = baseLayersPresent && baseLayersCount > 1;\n        this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';\n      }\n      this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\n      return this;\n    },\n    _onLayerChange: function _onLayerChange(e) {\n      if (!this._handlingClick) {\n        this._update();\n      }\n      var obj = this._getLayer(stamp(e.target));\n\n      // @namespace Map\n      // @section Layer events\n      // @event baselayerchange: LayersControlEvent\n      // Fired when the base layer is changed through the [layers control](#control-layers).\n      // @event overlayadd: LayersControlEvent\n      // Fired when an overlay is selected through the [layers control](#control-layers).\n      // @event overlayremove: LayersControlEvent\n      // Fired when an overlay is deselected through the [layers control](#control-layers).\n      // @namespace Control.Layers\n      var type = obj.overlay ? e.type === 'add' ? 'overlayadd' : 'overlayremove' : e.type === 'add' ? 'baselayerchange' : null;\n      if (type) {\n        this._map.fire(type, obj);\n      }\n    },\n    // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)\n    _createRadioElement: function _createRadioElement(name, checked) {\n      var radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' + name + '\"' + (checked ? ' checked=\"checked\"' : '') + '/>';\n      var radioFragment = document.createElement('div');\n      radioFragment.innerHTML = radioHtml;\n      return radioFragment.firstChild;\n    },\n    _addItem: function _addItem(obj) {\n      var label = document.createElement('label'),\n        checked = this._map.hasLayer(obj.layer),\n        input;\n      if (obj.overlay) {\n        input = document.createElement('input');\n        input.type = 'checkbox';\n        input.className = 'leaflet-control-layers-selector';\n        input.defaultChecked = checked;\n      } else {\n        input = this._createRadioElement('leaflet-base-layers_' + stamp(this), checked);\n      }\n      this._layerControlInputs.push(input);\n      input.layerId = stamp(obj.layer);\n      on(input, 'click', this._onInputClick, this);\n      var name = document.createElement('span');\n      name.innerHTML = ' ' + obj.name;\n\n      // Helps from preventing layer control flicker when checkboxes are disabled\n      // https://github.com/Leaflet/Leaflet/issues/2771\n      var holder = document.createElement('span');\n      label.appendChild(holder);\n      holder.appendChild(input);\n      holder.appendChild(name);\n      var container = obj.overlay ? this._overlaysList : this._baseLayersList;\n      container.appendChild(label);\n      this._checkDisabledLayers();\n      return label;\n    },\n    _onInputClick: function _onInputClick() {\n      // expanding the control on mobile with a click can cause adding a layer - we don't want this\n      if (this._preventClick) {\n        return;\n      }\n      var inputs = this._layerControlInputs,\n        input,\n        layer;\n      var addedLayers = [],\n        removedLayers = [];\n      this._handlingClick = true;\n      for (var i = inputs.length - 1; i >= 0; i--) {\n        input = inputs[i];\n        layer = this._getLayer(input.layerId).layer;\n        if (input.checked) {\n          addedLayers.push(layer);\n        } else if (!input.checked) {\n          removedLayers.push(layer);\n        }\n      }\n\n      // Bugfix issue 2318: Should remove all old layers before readding new ones\n      for (i = 0; i < removedLayers.length; i++) {\n        if (this._map.hasLayer(removedLayers[i])) {\n          this._map.removeLayer(removedLayers[i]);\n        }\n      }\n      for (i = 0; i < addedLayers.length; i++) {\n        if (!this._map.hasLayer(addedLayers[i])) {\n          this._map.addLayer(addedLayers[i]);\n        }\n      }\n      this._handlingClick = false;\n      this._refocusOnMap();\n    },\n    _checkDisabledLayers: function _checkDisabledLayers() {\n      var inputs = this._layerControlInputs,\n        input,\n        layer,\n        zoom = this._map.getZoom();\n      for (var i = inputs.length - 1; i >= 0; i--) {\n        input = inputs[i];\n        layer = this._getLayer(input.layerId).layer;\n        input.disabled = layer.options.minZoom !== undefined && zoom < layer.options.minZoom || layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom;\n      }\n    },\n    _expandIfNotCollapsed: function _expandIfNotCollapsed() {\n      if (this._map && !this.options.collapsed) {\n        this.expand();\n      }\n      return this;\n    },\n    _expandSafely: function _expandSafely() {\n      var section = this._section;\n      this._preventClick = true;\n      on(section, 'click', preventDefault);\n      this.expand();\n      var that = this;\n      setTimeout(function () {\n        off(section, 'click', preventDefault);\n        that._preventClick = false;\n      });\n    }\n  });\n\n  // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)\n  // Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.\n  var layers = function layers(baseLayers, overlays, options) {\n    return new Layers(baseLayers, overlays, options);\n  };\n\n  /*\r\n   * @class Control.Zoom\r\n   * @aka L.Control.Zoom\r\n   * @inherits Control\r\n   *\r\n   * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.\r\n   */\n\n  var Zoom = Control.extend({\n    // @section\n    // @aka Control.Zoom options\n    options: {\n      position: 'topleft',\n      // @option zoomInText: String = '<span aria-hidden=\"true\">+</span>'\n      // The text set on the 'zoom in' button.\n      zoomInText: '<span aria-hidden=\"true\">+</span>',\n      // @option zoomInTitle: String = 'Zoom in'\n      // The title set on the 'zoom in' button.\n      zoomInTitle: 'Zoom in',\n      // @option zoomOutText: String = '<span aria-hidden=\"true\">&#x2212;</span>'\n      // The text set on the 'zoom out' button.\n      zoomOutText: '<span aria-hidden=\"true\">&#x2212;</span>',\n      // @option zoomOutTitle: String = 'Zoom out'\n      // The title set on the 'zoom out' button.\n      zoomOutTitle: 'Zoom out'\n    },\n    onAdd: function onAdd(map) {\n      var zoomName = 'leaflet-control-zoom',\n        container = create$1('div', zoomName + ' leaflet-bar'),\n        options = this.options;\n      this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + '-in', container, this._zoomIn);\n      this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + '-out', container, this._zoomOut);\n      this._updateDisabled();\n      map.on('zoomend zoomlevelschange', this._updateDisabled, this);\n      return container;\n    },\n    onRemove: function onRemove(map) {\n      map.off('zoomend zoomlevelschange', this._updateDisabled, this);\n    },\n    disable: function disable() {\n      this._disabled = true;\n      this._updateDisabled();\n      return this;\n    },\n    enable: function enable() {\n      this._disabled = false;\n      this._updateDisabled();\n      return this;\n    },\n    _zoomIn: function _zoomIn(e) {\n      if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {\n        this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\n      }\n    },\n    _zoomOut: function _zoomOut(e) {\n      if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {\n        this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\n      }\n    },\n    _createButton: function _createButton(html, title, className, container, fn) {\n      var link = create$1('a', className, container);\n      link.innerHTML = html;\n      link.href = '#';\n      link.title = title;\n\n      /*\r\n       * Will force screen readers like VoiceOver to read this as \"Zoom in - button\"\r\n       */\n      link.setAttribute('role', 'button');\n      link.setAttribute('aria-label', title);\n      disableClickPropagation(link);\n      on(link, 'click', stop);\n      on(link, 'click', fn, this);\n      on(link, 'click', this._refocusOnMap, this);\n      return link;\n    },\n    _updateDisabled: function _updateDisabled() {\n      var map = this._map,\n        className = 'leaflet-disabled';\n      removeClass(this._zoomInButton, className);\n      removeClass(this._zoomOutButton, className);\n      this._zoomInButton.setAttribute('aria-disabled', 'false');\n      this._zoomOutButton.setAttribute('aria-disabled', 'false');\n      if (this._disabled || map._zoom === map.getMinZoom()) {\n        addClass(this._zoomOutButton, className);\n        this._zoomOutButton.setAttribute('aria-disabled', 'true');\n      }\n      if (this._disabled || map._zoom === map.getMaxZoom()) {\n        addClass(this._zoomInButton, className);\n        this._zoomInButton.setAttribute('aria-disabled', 'true');\n      }\n    }\n  });\n\n  // @namespace Map\n  // @section Control options\n  // @option zoomControl: Boolean = true\n  // Whether a [zoom control](#control-zoom) is added to the map by default.\n  Map.mergeOptions({\n    zoomControl: true\n  });\n  Map.addInitHook(function () {\n    if (this.options.zoomControl) {\n      // @section Controls\n      // @property zoomControl: Control.Zoom\n      // The default zoom control (only available if the\n      // [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).\n      this.zoomControl = new Zoom();\n      this.addControl(this.zoomControl);\n    }\n  });\n\n  // @namespace Control.Zoom\n  // @factory L.control.zoom(options: Control.Zoom options)\n  // Creates a zoom control\n  var zoom = function zoom(options) {\n    return new Zoom(options);\n  };\n\n  /*\n   * @class Control.Scale\n   * @aka L.Control.Scale\n   * @inherits Control\n   *\n   * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.\n   *\n   * @example\n   *\n   * ```js\n   * L.control.scale().addTo(map);\n   * ```\n   */\n\n  var Scale = Control.extend({\n    // @section\n    // @aka Control.Scale options\n    options: {\n      position: 'bottomleft',\n      // @option maxWidth: Number = 100\n      // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).\n      maxWidth: 100,\n      // @option metric: Boolean = True\n      // Whether to show the metric scale line (m/km).\n      metric: true,\n      // @option imperial: Boolean = True\n      // Whether to show the imperial scale line (mi/ft).\n      imperial: true\n\n      // @option updateWhenIdle: Boolean = false\n      // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).\n    },\n    onAdd: function onAdd(map) {\n      var className = 'leaflet-control-scale',\n        container = create$1('div', className),\n        options = this.options;\n      this._addScales(options, className + '-line', container);\n      map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n      map.whenReady(this._update, this);\n      return container;\n    },\n    onRemove: function onRemove(map) {\n      map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n    },\n    _addScales: function _addScales(options, className, container) {\n      if (options.metric) {\n        this._mScale = create$1('div', className, container);\n      }\n      if (options.imperial) {\n        this._iScale = create$1('div', className, container);\n      }\n    },\n    _update: function _update() {\n      var map = this._map,\n        y = map.getSize().y / 2;\n      var maxMeters = map.distance(map.containerPointToLatLng([0, y]), map.containerPointToLatLng([this.options.maxWidth, y]));\n      this._updateScales(maxMeters);\n    },\n    _updateScales: function _updateScales(maxMeters) {\n      if (this.options.metric && maxMeters) {\n        this._updateMetric(maxMeters);\n      }\n      if (this.options.imperial && maxMeters) {\n        this._updateImperial(maxMeters);\n      }\n    },\n    _updateMetric: function _updateMetric(maxMeters) {\n      var meters = this._getRoundNum(maxMeters),\n        label = meters < 1000 ? meters + ' m' : meters / 1000 + ' km';\n      this._updateScale(this._mScale, label, meters / maxMeters);\n    },\n    _updateImperial: function _updateImperial(maxMeters) {\n      var maxFeet = maxMeters * 3.2808399,\n        maxMiles,\n        miles,\n        feet;\n      if (maxFeet > 5280) {\n        maxMiles = maxFeet / 5280;\n        miles = this._getRoundNum(maxMiles);\n        this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);\n      } else {\n        feet = this._getRoundNum(maxFeet);\n        this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);\n      }\n    },\n    _updateScale: function _updateScale(scale, text, ratio) {\n      scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';\n      scale.innerHTML = text;\n    },\n    _getRoundNum: function _getRoundNum(num) {\n      var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n        d = num / pow10;\n      d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;\n      return pow10 * d;\n    }\n  });\n\n  // @factory L.control.scale(options?: Control.Scale options)\n  // Creates an scale control with the given options.\n  var scale = function scale(options) {\n    return new Scale(options);\n  };\n  var ukrainianFlag = '<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"8\" viewBox=\"0 0 12 8\" class=\"leaflet-attribution-flag\"><path fill=\"#4C7BE1\" d=\"M0 0h12v4H0z\"/><path fill=\"#FFD500\" d=\"M0 4h12v3H0z\"/><path fill=\"#E0BC00\" d=\"M0 7h12v1H0z\"/></svg>';\n\n  /*\r\n   * @class Control.Attribution\r\n   * @aka L.Control.Attribution\r\n   * @inherits Control\r\n   *\r\n   * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.\r\n   */\n\n  var Attribution = Control.extend({\n    // @section\n    // @aka Control.Attribution options\n    options: {\n      position: 'bottomright',\n      // @option prefix: String|false = 'Leaflet'\n      // The HTML text shown before the attributions. Pass `false` to disable.\n      prefix: '<a href=\"https://leafletjs.com\" title=\"A JavaScript library for interactive maps\">' + (Browser.inlineSvg ? ukrainianFlag + ' ' : '') + 'Leaflet</a>'\n    },\n    initialize: function initialize(options) {\n      setOptions(this, options);\n      this._attributions = {};\n    },\n    onAdd: function onAdd(map) {\n      map.attributionControl = this;\n      this._container = create$1('div', 'leaflet-control-attribution');\n      disableClickPropagation(this._container);\n\n      // TODO ugly, refactor\n      for (var i in map._layers) {\n        if (map._layers[i].getAttribution) {\n          this.addAttribution(map._layers[i].getAttribution());\n        }\n      }\n      this._update();\n      map.on('layeradd', this._addAttribution, this);\n      return this._container;\n    },\n    onRemove: function onRemove(map) {\n      map.off('layeradd', this._addAttribution, this);\n    },\n    _addAttribution: function _addAttribution(ev) {\n      if (ev.layer.getAttribution) {\n        this.addAttribution(ev.layer.getAttribution());\n        ev.layer.once('remove', function () {\n          this.removeAttribution(ev.layer.getAttribution());\n        }, this);\n      }\n    },\n    // @method setPrefix(prefix: String|false): this\n    // The HTML text shown before the attributions. Pass `false` to disable.\n    setPrefix: function setPrefix(prefix) {\n      this.options.prefix = prefix;\n      this._update();\n      return this;\n    },\n    // @method addAttribution(text: String): this\n    // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).\n    addAttribution: function addAttribution(text) {\n      if (!text) {\n        return this;\n      }\n      if (!this._attributions[text]) {\n        this._attributions[text] = 0;\n      }\n      this._attributions[text]++;\n      this._update();\n      return this;\n    },\n    // @method removeAttribution(text: String): this\n    // Removes an attribution text.\n    removeAttribution: function removeAttribution(text) {\n      if (!text) {\n        return this;\n      }\n      if (this._attributions[text]) {\n        this._attributions[text]--;\n        this._update();\n      }\n      return this;\n    },\n    _update: function _update() {\n      if (!this._map) {\n        return;\n      }\n      var attribs = [];\n      for (var i in this._attributions) {\n        if (this._attributions[i]) {\n          attribs.push(i);\n        }\n      }\n      var prefixAndAttribs = [];\n      if (this.options.prefix) {\n        prefixAndAttribs.push(this.options.prefix);\n      }\n      if (attribs.length) {\n        prefixAndAttribs.push(attribs.join(', '));\n      }\n      this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden=\"true\">|</span> ');\n    }\n  });\n\n  // @namespace Map\n  // @section Control options\n  // @option attributionControl: Boolean = true\n  // Whether a [attribution control](#control-attribution) is added to the map by default.\n  Map.mergeOptions({\n    attributionControl: true\n  });\n  Map.addInitHook(function () {\n    if (this.options.attributionControl) {\n      new Attribution().addTo(this);\n    }\n  });\n\n  // @namespace Control.Attribution\n  // @factory L.control.attribution(options: Control.Attribution options)\n  // Creates an attribution control.\n  var attribution = function attribution(options) {\n    return new Attribution(options);\n  };\n  Control.Layers = Layers;\n  Control.Zoom = Zoom;\n  Control.Scale = Scale;\n  Control.Attribution = Attribution;\n  control.layers = layers;\n  control.zoom = zoom;\n  control.scale = scale;\n  control.attribution = attribution;\n\n  /*\n  \tL.Handler is a base class for handler classes that are used internally to inject\n  \tinteraction features like dragging to classes like Map and Marker.\n  */\n\n  // @class Handler\n  // @aka L.Handler\n  // Abstract class for map interaction handlers\n\n  var Handler = Class.extend({\n    initialize: function initialize(map) {\n      this._map = map;\n    },\n    // @method enable(): this\n    // Enables the handler\n    enable: function enable() {\n      if (this._enabled) {\n        return this;\n      }\n      this._enabled = true;\n      this.addHooks();\n      return this;\n    },\n    // @method disable(): this\n    // Disables the handler\n    disable: function disable() {\n      if (!this._enabled) {\n        return this;\n      }\n      this._enabled = false;\n      this.removeHooks();\n      return this;\n    },\n    // @method enabled(): Boolean\n    // Returns `true` if the handler is enabled\n    enabled: function enabled() {\n      return !!this._enabled;\n    }\n\n    // @section Extension methods\n    // Classes inheriting from `Handler` must implement the two following methods:\n    // @method addHooks()\n    // Called when the handler is enabled, should add event hooks.\n    // @method removeHooks()\n    // Called when the handler is disabled, should remove the event hooks added previously.\n  });\n\n  // @section There is static function which can be called without instantiating L.Handler:\n  // @function addTo(map: Map, name: String): this\n  // Adds a new Handler to the given map with the given name.\n  Handler.addTo = function (map, name) {\n    map.addHandler(name, this);\n    return this;\n  };\n  var Mixin = {\n    Events: Events\n  };\n\n  /*\r\n   * @class Draggable\r\n   * @aka L.Draggable\r\n   * @inherits Evented\r\n   *\r\n   * A class for making DOM elements draggable (including touch support).\r\n   * Used internally for map and marker dragging. Only works for elements\r\n   * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).\r\n   *\r\n   * @example\r\n   * ```js\r\n   * var draggable = new L.Draggable(elementToDrag);\r\n   * draggable.enable();\r\n   * ```\r\n   */\n\n  var START = Browser.touch ? 'touchstart mousedown' : 'mousedown';\n  var Draggable = Evented.extend({\n    options: {\n      // @section\n      // @aka Draggable options\n      // @option clickTolerance: Number = 3\n      // The max number of pixels a user can shift the mouse pointer during a click\n      // for it to be considered a valid click (as opposed to a mouse drag).\n      clickTolerance: 3\n    },\n    // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)\n    // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).\n    initialize: function initialize(element, dragStartTarget, preventOutline, options) {\n      setOptions(this, options);\n      this._element = element;\n      this._dragStartTarget = dragStartTarget || element;\n      this._preventOutline = preventOutline;\n    },\n    // @method enable()\n    // Enables the dragging ability\n    enable: function enable() {\n      if (this._enabled) {\n        return;\n      }\n      on(this._dragStartTarget, START, this._onDown, this);\n      this._enabled = true;\n    },\n    // @method disable()\n    // Disables the dragging ability\n    disable: function disable() {\n      if (!this._enabled) {\n        return;\n      }\n\n      // If we're currently dragging this draggable,\n      // disabling it counts as first ending the drag.\n      if (Draggable._dragging === this) {\n        this.finishDrag(true);\n      }\n      off(this._dragStartTarget, START, this._onDown, this);\n      this._enabled = false;\n      this._moved = false;\n    },\n    _onDown: function _onDown(e) {\n      // Ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (!this._enabled) {\n        return;\n      }\n      this._moved = false;\n      if (hasClass(this._element, 'leaflet-zoom-anim')) {\n        return;\n      }\n      if (e.touches && e.touches.length !== 1) {\n        // Finish dragging to avoid conflict with touchZoom\n        if (Draggable._dragging === this) {\n          this.finishDrag();\n        }\n        return;\n      }\n      if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {\n        return;\n      }\n      Draggable._dragging = this; // Prevent dragging multiple objects at once.\n\n      if (this._preventOutline) {\n        preventOutline(this._element);\n      }\n      disableImageDrag();\n      disableTextSelection();\n      if (this._moving) {\n        return;\n      }\n\n      // @event down: Event\n      // Fired when a drag is about to start.\n      this.fire('down');\n      var first = e.touches ? e.touches[0] : e,\n        sizedParent = getSizedParentNode(this._element);\n      this._startPoint = new Point(first.clientX, first.clientY);\n      this._startPos = getPosition(this._element);\n\n      // Cache the scale, so that we can continuously compensate for it during drag (_onMove).\n      this._parentScale = getScale(sizedParent);\n      var mouseevent = e.type === 'mousedown';\n      on(document, mouseevent ? 'mousemove' : 'touchmove', this._onMove, this);\n      on(document, mouseevent ? 'mouseup' : 'touchend touchcancel', this._onUp, this);\n    },\n    _onMove: function _onMove(e) {\n      // Ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (!this._enabled) {\n        return;\n      }\n      if (e.touches && e.touches.length > 1) {\n        this._moved = true;\n        return;\n      }\n      var first = e.touches && e.touches.length === 1 ? e.touches[0] : e,\n        offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);\n      if (!offset.x && !offset.y) {\n        return;\n      }\n      if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {\n        return;\n      }\n\n      // We assume that the parent container's position, border and scale do not change for the duration of the drag.\n      // Therefore there is no need to account for the position and border (they are eliminated by the subtraction)\n      // and we can use the cached value for the scale.\n      offset.x /= this._parentScale.x;\n      offset.y /= this._parentScale.y;\n      preventDefault(e);\n      if (!this._moved) {\n        // @event dragstart: Event\n        // Fired when a drag starts\n        this.fire('dragstart');\n        this._moved = true;\n        addClass(document.body, 'leaflet-dragging');\n        this._lastTarget = e.target || e.srcElement;\n        // IE and Edge do not give the <use> element, so fetch it\n        // if necessary\n        if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {\n          this._lastTarget = this._lastTarget.correspondingUseElement;\n        }\n        addClass(this._lastTarget, 'leaflet-drag-target');\n      }\n      this._newPos = this._startPos.add(offset);\n      this._moving = true;\n      this._lastEvent = e;\n      this._updatePosition();\n    },\n    _updatePosition: function _updatePosition() {\n      var e = {\n        originalEvent: this._lastEvent\n      };\n\n      // @event predrag: Event\n      // Fired continuously during dragging *before* each corresponding\n      // update of the element's position.\n      this.fire('predrag', e);\n      setPosition(this._element, this._newPos);\n\n      // @event drag: Event\n      // Fired continuously during dragging.\n      this.fire('drag', e);\n    },\n    _onUp: function _onUp() {\n      // Ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (!this._enabled) {\n        return;\n      }\n      this.finishDrag();\n    },\n    finishDrag: function finishDrag(noInertia) {\n      removeClass(document.body, 'leaflet-dragging');\n      if (this._lastTarget) {\n        removeClass(this._lastTarget, 'leaflet-drag-target');\n        this._lastTarget = null;\n      }\n      off(document, 'mousemove touchmove', this._onMove, this);\n      off(document, 'mouseup touchend touchcancel', this._onUp, this);\n      enableImageDrag();\n      enableTextSelection();\n      var fireDragend = this._moved && this._moving;\n      this._moving = false;\n      Draggable._dragging = false;\n      if (fireDragend) {\n        // @event dragend: DragEndEvent\n        // Fired when the drag ends.\n        this.fire('dragend', {\n          noInertia: noInertia,\n          distance: this._newPos.distanceTo(this._startPos)\n        });\n      }\n    }\n  });\n\n  /*\r\n   * @namespace PolyUtil\r\n   * Various utility functions for polygon geometries.\r\n   */\n\n  /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]\r\n   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).\r\n   * Used by Leaflet to only show polygon points that are on the screen or near, increasing\r\n   * performance. Note that polygon points needs different algorithm for clipping\r\n   * than polyline, so there's a separate method for it.\r\n   */\n  function clipPolygon(points, bounds, round) {\n    var clippedPoints,\n      edges = [1, 4, 2, 8],\n      i,\n      j,\n      k,\n      a,\n      b,\n      len,\n      edge,\n      p;\n    for (i = 0, len = points.length; i < len; i++) {\n      points[i]._code = _getBitCode(points[i], bounds);\n    }\n\n    // for each edge (left, bottom, right, top)\n    for (k = 0; k < 4; k++) {\n      edge = edges[k];\n      clippedPoints = [];\n      for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n        a = points[i];\n        b = points[j];\n\n        // if a is inside the clip window\n        if (!(a._code & edge)) {\n          // if b is outside the clip window (a->b goes out of screen)\n          if (b._code & edge) {\n            p = _getEdgeIntersection(b, a, edge, bounds, round);\n            p._code = _getBitCode(p, bounds);\n            clippedPoints.push(p);\n          }\n          clippedPoints.push(a);\n\n          // else if b is inside the clip window (a->b enters the screen)\n        } else if (!(b._code & edge)) {\n          p = _getEdgeIntersection(b, a, edge, bounds, round);\n          p._code = _getBitCode(p, bounds);\n          clippedPoints.push(p);\n        }\n      }\n      points = clippedPoints;\n    }\n    return points;\n  }\n\n  /* @function polygonCenter(latlngs: LatLng[], crs: CRS): LatLng\r\n   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polygon.\r\n   */\n  function polygonCenter(latlngs, crs) {\n    var i, j, p1, p2, f, area, x, y, center;\n    if (!latlngs || latlngs.length === 0) {\n      throw new Error('latlngs not passed');\n    }\n    if (!isFlat(latlngs)) {\n      console.warn('latlngs are not flat! Only the first ring will be used');\n      latlngs = latlngs[0];\n    }\n    var centroidLatLng = toLatLng([0, 0]);\n    var bounds = toLatLngBounds(latlngs);\n    var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());\n    // tests showed that below 1700 rounding errors are happening\n    if (areaBounds < 1700) {\n      // getting a inexact center, to move the latlngs near to [0, 0] to prevent rounding errors\n      centroidLatLng = centroid(latlngs);\n    }\n    var len = latlngs.length;\n    var points = [];\n    for (i = 0; i < len; i++) {\n      var latlng = toLatLng(latlngs[i]);\n      points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));\n    }\n    area = x = y = 0;\n\n    // polygon centroid algorithm;\n    for (i = 0, j = len - 1; i < len; j = i++) {\n      p1 = points[i];\n      p2 = points[j];\n      f = p1.y * p2.x - p2.y * p1.x;\n      x += (p1.x + p2.x) * f;\n      y += (p1.y + p2.y) * f;\n      area += f * 3;\n    }\n    if (area === 0) {\n      // Polygon is so small that all points are on same pixel.\n      center = points[0];\n    } else {\n      center = [x / area, y / area];\n    }\n    var latlngCenter = crs.unproject(toPoint(center));\n    return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);\n  }\n\n  /* @function centroid(latlngs: LatLng[]): LatLng\r\n   * Returns the 'center of mass' of the passed LatLngs.\r\n   */\n  function centroid(coords) {\n    var latSum = 0;\n    var lngSum = 0;\n    var len = 0;\n    for (var i = 0; i < coords.length; i++) {\n      var latlng = toLatLng(coords[i]);\n      latSum += latlng.lat;\n      lngSum += latlng.lng;\n      len++;\n    }\n    return toLatLng([latSum / len, lngSum / len]);\n  }\n  var PolyUtil = {\n    __proto__: null,\n    clipPolygon: clipPolygon,\n    polygonCenter: polygonCenter,\n    centroid: centroid\n  };\n\n  /*\r\n   * @namespace LineUtil\r\n   *\r\n   * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.\r\n   */\n\n  // Simplify polyline with vertex reduction and Douglas-Peucker simplification.\n  // Improves rendering performance dramatically by lessening the number of points to draw.\n\n  // @function simplify(points: Point[], tolerance: Number): Point[]\n  // Dramatically reduces the number of points in a polyline while retaining\n  // its shape and returns a new array of simplified points, using the\n  // [Ramer-Douglas-Peucker algorithm](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm).\n  // Used for a huge performance boost when processing/displaying Leaflet polylines for\n  // each zoom level and also reducing visual noise. tolerance affects the amount of\n  // simplification (lesser value means higher quality but slower and with more points).\n  // Also released as a separated micro-library [Simplify.js](https://mourner.github.io/simplify-js/).\n  function simplify(points, tolerance) {\n    if (!tolerance || !points.length) {\n      return points.slice();\n    }\n    var sqTolerance = tolerance * tolerance;\n\n    // stage 1: vertex reduction\n    points = _reducePoints(points, sqTolerance);\n\n    // stage 2: Douglas-Peucker simplification\n    points = _simplifyDP(points, sqTolerance);\n    return points;\n  }\n\n  // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number\n  // Returns the distance between point `p` and segment `p1` to `p2`.\n  function pointToSegmentDistance(p, p1, p2) {\n    return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));\n  }\n\n  // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number\n  // Returns the closest point from a point `p` on a segment `p1` to `p2`.\n  function closestPointOnSegment(p, p1, p2) {\n    return _sqClosestPointOnSegment(p, p1, p2);\n  }\n\n  // Ramer-Douglas-Peucker simplification, see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\n  function _simplifyDP(points, sqTolerance) {\n    var len = points.length,\n      ArrayConstructor = (typeof Uint8Array === \"undefined\" ? \"undefined\" : _typeof(Uint8Array)) !== undefined + '' ? Uint8Array : Array,\n      markers = new ArrayConstructor(len);\n    markers[0] = markers[len - 1] = 1;\n    _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\n    var i,\n      newPoints = [];\n    for (i = 0; i < len; i++) {\n      if (markers[i]) {\n        newPoints.push(points[i]);\n      }\n    }\n    return newPoints;\n  }\n  function _simplifyDPStep(points, markers, sqTolerance, first, last) {\n    var maxSqDist = 0,\n      index,\n      i,\n      sqDist;\n    for (i = first + 1; i <= last - 1; i++) {\n      sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);\n      if (sqDist > maxSqDist) {\n        index = i;\n        maxSqDist = sqDist;\n      }\n    }\n    if (maxSqDist > sqTolerance) {\n      markers[index] = 1;\n      _simplifyDPStep(points, markers, sqTolerance, first, index);\n      _simplifyDPStep(points, markers, sqTolerance, index, last);\n    }\n  }\n\n  // reduce points that are too close to each other to a single point\n  function _reducePoints(points, sqTolerance) {\n    var reducedPoints = [points[0]];\n    for (var i = 1, prev = 0, len = points.length; i < len; i++) {\n      if (_sqDist(points[i], points[prev]) > sqTolerance) {\n        reducedPoints.push(points[i]);\n        prev = i;\n      }\n    }\n    if (prev < len - 1) {\n      reducedPoints.push(points[len - 1]);\n    }\n    return reducedPoints;\n  }\n  var _lastCode;\n\n  // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean\n  // Clips the segment a to b by rectangular bounds with the\n  // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)\n  // (modifying the segment points directly!). Used by Leaflet to only show polyline\n  // points that are on the screen or near, increasing performance.\n  function clipSegment(a, b, bounds, useLastCode, round) {\n    var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),\n      codeB = _getBitCode(b, bounds),\n      codeOut,\n      p,\n      newCode;\n\n    // save 2nd code to avoid calculating it on the next segment\n    _lastCode = codeB;\n    while (true) {\n      // if a,b is inside the clip window (trivial accept)\n      if (!(codeA | codeB)) {\n        return [a, b];\n      }\n\n      // if a,b is outside the clip window (trivial reject)\n      if (codeA & codeB) {\n        return false;\n      }\n\n      // other cases\n      codeOut = codeA || codeB;\n      p = _getEdgeIntersection(a, b, codeOut, bounds, round);\n      newCode = _getBitCode(p, bounds);\n      if (codeOut === codeA) {\n        a = p;\n        codeA = newCode;\n      } else {\n        b = p;\n        codeB = newCode;\n      }\n    }\n  }\n  function _getEdgeIntersection(a, b, code, bounds, round) {\n    var dx = b.x - a.x,\n      dy = b.y - a.y,\n      min = bounds.min,\n      max = bounds.max,\n      x,\n      y;\n    if (code & 8) {\n      // top\n      x = a.x + dx * (max.y - a.y) / dy;\n      y = max.y;\n    } else if (code & 4) {\n      // bottom\n      x = a.x + dx * (min.y - a.y) / dy;\n      y = min.y;\n    } else if (code & 2) {\n      // right\n      x = max.x;\n      y = a.y + dy * (max.x - a.x) / dx;\n    } else if (code & 1) {\n      // left\n      x = min.x;\n      y = a.y + dy * (min.x - a.x) / dx;\n    }\n    return new Point(x, y, round);\n  }\n  function _getBitCode(p, bounds) {\n    var code = 0;\n    if (p.x < bounds.min.x) {\n      // left\n      code |= 1;\n    } else if (p.x > bounds.max.x) {\n      // right\n      code |= 2;\n    }\n    if (p.y < bounds.min.y) {\n      // bottom\n      code |= 4;\n    } else if (p.y > bounds.max.y) {\n      // top\n      code |= 8;\n    }\n    return code;\n  }\n\n  // square distance (to avoid unnecessary Math.sqrt calls)\n  function _sqDist(p1, p2) {\n    var dx = p2.x - p1.x,\n      dy = p2.y - p1.y;\n    return dx * dx + dy * dy;\n  }\n\n  // return closest point on segment or distance to that point\n  function _sqClosestPointOnSegment(p, p1, p2, sqDist) {\n    var x = p1.x,\n      y = p1.y,\n      dx = p2.x - x,\n      dy = p2.y - y,\n      dot = dx * dx + dy * dy,\n      t;\n    if (dot > 0) {\n      t = ((p.x - x) * dx + (p.y - y) * dy) / dot;\n      if (t > 1) {\n        x = p2.x;\n        y = p2.y;\n      } else if (t > 0) {\n        x += dx * t;\n        y += dy * t;\n      }\n    }\n    dx = p.x - x;\n    dy = p.y - y;\n    return sqDist ? dx * dx + dy * dy : new Point(x, y);\n  }\n\n  // @function isFlat(latlngs: LatLng[]): Boolean\n  // Returns true if `latlngs` is a flat array, false is nested.\n  function isFlat(latlngs) {\n    return !isArray(latlngs[0]) || _typeof(latlngs[0][0]) !== 'object' && typeof latlngs[0][0] !== 'undefined';\n  }\n  function _flat(latlngs) {\n    console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');\n    return isFlat(latlngs);\n  }\n\n  /* @function polylineCenter(latlngs: LatLng[], crs: CRS): LatLng\r\n   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polyline.\r\n   */\n  function polylineCenter(latlngs, crs) {\n    var i, halfDist, segDist, dist, p1, p2, ratio, center;\n    if (!latlngs || latlngs.length === 0) {\n      throw new Error('latlngs not passed');\n    }\n    if (!isFlat(latlngs)) {\n      console.warn('latlngs are not flat! Only the first ring will be used');\n      latlngs = latlngs[0];\n    }\n    var centroidLatLng = toLatLng([0, 0]);\n    var bounds = toLatLngBounds(latlngs);\n    var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());\n    // tests showed that below 1700 rounding errors are happening\n    if (areaBounds < 1700) {\n      // getting a inexact center, to move the latlngs near to [0, 0] to prevent rounding errors\n      centroidLatLng = centroid(latlngs);\n    }\n    var len = latlngs.length;\n    var points = [];\n    for (i = 0; i < len; i++) {\n      var latlng = toLatLng(latlngs[i]);\n      points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));\n    }\n    for (i = 0, halfDist = 0; i < len - 1; i++) {\n      halfDist += points[i].distanceTo(points[i + 1]) / 2;\n    }\n\n    // The line is so small in the current view that all points are on the same pixel.\n    if (halfDist === 0) {\n      center = points[0];\n    } else {\n      for (i = 0, dist = 0; i < len - 1; i++) {\n        p1 = points[i];\n        p2 = points[i + 1];\n        segDist = p1.distanceTo(p2);\n        dist += segDist;\n        if (dist > halfDist) {\n          ratio = (dist - halfDist) / segDist;\n          center = [p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y)];\n          break;\n        }\n      }\n    }\n    var latlngCenter = crs.unproject(toPoint(center));\n    return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);\n  }\n  var LineUtil = {\n    __proto__: null,\n    simplify: simplify,\n    pointToSegmentDistance: pointToSegmentDistance,\n    closestPointOnSegment: closestPointOnSegment,\n    clipSegment: clipSegment,\n    _getEdgeIntersection: _getEdgeIntersection,\n    _getBitCode: _getBitCode,\n    _sqClosestPointOnSegment: _sqClosestPointOnSegment,\n    isFlat: isFlat,\n    _flat: _flat,\n    polylineCenter: polylineCenter\n  };\n\n  /*\r\n   * @namespace Projection\r\n   * @section\r\n   * Leaflet comes with a set of already defined Projections out of the box:\r\n   *\r\n   * @projection L.Projection.LonLat\r\n   *\r\n   * Equirectangular, or Plate Carree projection — the most simple projection,\r\n   * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as\r\n   * latitude. Also suitable for flat worlds, e.g. game maps. Used by the\r\n   * `EPSG:4326` and `Simple` CRS.\r\n   */\n\n  var LonLat = {\n    project: function project(latlng) {\n      return new Point(latlng.lng, latlng.lat);\n    },\n    unproject: function unproject(point) {\n      return new LatLng(point.y, point.x);\n    },\n    bounds: new Bounds([-180, -90], [180, 90])\n  };\n\n  /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.Mercator\r\n   *\r\n   * Elliptical Mercator projection — more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.\r\n   */\n\n  var Mercator = {\n    R: 6378137,\n    R_MINOR: 6356752.314245179,\n    bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),\n    project: function project(latlng) {\n      var d = Math.PI / 180,\n        r = this.R,\n        y = latlng.lat * d,\n        tmp = this.R_MINOR / r,\n        e = Math.sqrt(1 - tmp * tmp),\n        con = e * Math.sin(y);\n      var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);\n      y = -r * Math.log(Math.max(ts, 1E-10));\n      return new Point(latlng.lng * d * r, y);\n    },\n    unproject: function unproject(point) {\n      var d = 180 / Math.PI,\n        r = this.R,\n        tmp = this.R_MINOR / r,\n        e = Math.sqrt(1 - tmp * tmp),\n        ts = Math.exp(-point.y / r),\n        phi = Math.PI / 2 - 2 * Math.atan(ts);\n      for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {\n        con = e * Math.sin(phi);\n        con = Math.pow((1 - con) / (1 + con), e / 2);\n        dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;\n        phi += dphi;\n      }\n      return new LatLng(phi * d, point.x * d / r);\n    }\n  };\n\n  /*\n   * @class Projection\n    * An object with methods for projecting geographical coordinates of the world onto\n   * a flat surface (and back). See [Map projection](https://en.wikipedia.org/wiki/Map_projection).\n    * @property bounds: Bounds\n   * The bounds (specified in CRS units) where the projection is valid\n    * @method project(latlng: LatLng): Point\n   * Projects geographical coordinates into a 2D point.\n   * Only accepts actual `L.LatLng` instances, not arrays.\n    * @method unproject(point: Point): LatLng\n   * The inverse of `project`. Projects a 2D point into a geographical location.\n   * Only accepts actual `L.Point` instances, not arrays.\n    * Note that the projection instances do not inherit from Leaflet's `Class` object,\n   * and can't be instantiated. Also, new classes can't inherit from them,\n   * and methods can't be added to them with the `include` function.\n    */\n\n  var index = {\n    __proto__: null,\n    LonLat: LonLat,\n    Mercator: Mercator,\n    SphericalMercator: SphericalMercator\n  };\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3395\r\n   *\r\n   * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.\r\n   */\n  var EPSG3395 = extend({}, Earth, {\n    code: 'EPSG:3395',\n    projection: Mercator,\n    transformation: function () {\n      var scale = 0.5 / (Math.PI * Mercator.R);\n      return toTransformation(scale, 0.5, -scale, 0.5);\n    }()\n  });\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG4326\r\n   *\r\n   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.\r\n   *\r\n   * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),\r\n   * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`\r\n   * with this CRS, ensure that there are two 256x256 pixel tiles covering the\r\n   * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),\r\n   * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.\r\n   */\n\n  var EPSG4326 = extend({}, Earth, {\n    code: 'EPSG:4326',\n    projection: LonLat,\n    transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)\n  });\n\n  /*\n   * @namespace CRS\n   * @crs L.CRS.Simple\n   *\n   * A simple CRS that maps longitude and latitude into `x` and `y` directly.\n   * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`\n   * axis should still be inverted (going from bottom to top). `distance()` returns\n   * simple euclidean distance.\n   */\n\n  var Simple = extend({}, CRS, {\n    projection: LonLat,\n    transformation: toTransformation(1, 0, -1, 0),\n    scale: function scale(zoom) {\n      return Math.pow(2, zoom);\n    },\n    zoom: function zoom(scale) {\n      return Math.log(scale) / Math.LN2;\n    },\n    distance: function distance(latlng1, latlng2) {\n      var dx = latlng2.lng - latlng1.lng,\n        dy = latlng2.lat - latlng1.lat;\n      return Math.sqrt(dx * dx + dy * dy);\n    },\n    infinite: true\n  });\n  CRS.Earth = Earth;\n  CRS.EPSG3395 = EPSG3395;\n  CRS.EPSG3857 = EPSG3857;\n  CRS.EPSG900913 = EPSG900913;\n  CRS.EPSG4326 = EPSG4326;\n  CRS.Simple = Simple;\n\n  /*\n   * @class Layer\n   * @inherits Evented\n   * @aka L.Layer\n   * @aka ILayer\n   *\n   * A set of methods from the Layer base class that all Leaflet layers use.\n   * Inherits all methods, options and events from `L.Evented`.\n   *\n   * @example\n   *\n   * ```js\n   * var layer = L.marker(latlng).addTo(map);\n   * layer.addTo(map);\n   * layer.remove();\n   * ```\n   *\n   * @event add: Event\n   * Fired after the layer is added to a map\n   *\n   * @event remove: Event\n   * Fired after the layer is removed from a map\n   */\n\n  var Layer = Evented.extend({\n    // Classes extending `L.Layer` will inherit the following options:\n    options: {\n      // @option pane: String = 'overlayPane'\n      // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.\n      pane: 'overlayPane',\n      // @option attribution: String = null\n      // String to be shown in the attribution control, e.g. \"© OpenStreetMap contributors\". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.\n      attribution: null,\n      bubblingMouseEvents: true\n    },\n    /* @section\n     * Classes extending `L.Layer` will inherit the following methods:\n     *\n     * @method addTo(map: Map|LayerGroup): this\n     * Adds the layer to the given map or layer group.\n     */\n    addTo: function addTo(map) {\n      map.addLayer(this);\n      return this;\n    },\n    // @method remove: this\n    // Removes the layer from the map it is currently active on.\n    remove: function remove() {\n      return this.removeFrom(this._map || this._mapToAdd);\n    },\n    // @method removeFrom(map: Map): this\n    // Removes the layer from the given map\n    //\n    // @alternative\n    // @method removeFrom(group: LayerGroup): this\n    // Removes the layer from the given `LayerGroup`\n    removeFrom: function removeFrom(obj) {\n      if (obj) {\n        obj.removeLayer(this);\n      }\n      return this;\n    },\n    // @method getPane(name? : String): HTMLElement\n    // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.\n    getPane: function getPane(name) {\n      return this._map.getPane(name ? this.options[name] || name : this.options.pane);\n    },\n    addInteractiveTarget: function addInteractiveTarget(targetEl) {\n      this._map._targets[stamp(targetEl)] = this;\n      return this;\n    },\n    removeInteractiveTarget: function removeInteractiveTarget(targetEl) {\n      delete this._map._targets[stamp(targetEl)];\n      return this;\n    },\n    // @method getAttribution: String\n    // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).\n    getAttribution: function getAttribution() {\n      return this.options.attribution;\n    },\n    _layerAdd: function _layerAdd(e) {\n      var map = e.target;\n\n      // check in case layer gets added and then removed before the map is ready\n      if (!map.hasLayer(this)) {\n        return;\n      }\n      this._map = map;\n      this._zoomAnimated = map._zoomAnimated;\n      if (this.getEvents) {\n        var events = this.getEvents();\n        map.on(events, this);\n        this.once('remove', function () {\n          map.off(events, this);\n        }, this);\n      }\n      this.onAdd(map);\n      this.fire('add');\n      map.fire('layeradd', {\n        layer: this\n      });\n    }\n  });\n\n  /* @section Extension methods\n   * @uninheritable\n   *\n   * Every layer should extend from `L.Layer` and (re-)implement the following methods.\n   *\n   * @method onAdd(map: Map): this\n   * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).\n   *\n   * @method onRemove(map: Map): this\n   * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).\n   *\n   * @method getEvents(): Object\n   * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.\n   *\n   * @method getAttribution(): String\n   * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.\n   *\n   * @method beforeAdd(map: Map): this\n   * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.\n   */\n\n  /* @namespace Map\n   * @section Layer events\n   *\n   * @event layeradd: LayerEvent\n   * Fired when a new layer is added to the map.\n   *\n   * @event layerremove: LayerEvent\n   * Fired when some layer is removed from the map\n   *\n   * @section Methods for Layers and Controls\n   */\n  Map.include({\n    // @method addLayer(layer: Layer): this\n    // Adds the given layer to the map\n    addLayer: function addLayer(layer) {\n      if (!layer._layerAdd) {\n        throw new Error('The provided object is not a Layer.');\n      }\n      var id = stamp(layer);\n      if (this._layers[id]) {\n        return this;\n      }\n      this._layers[id] = layer;\n      layer._mapToAdd = this;\n      if (layer.beforeAdd) {\n        layer.beforeAdd(this);\n      }\n      this.whenReady(layer._layerAdd, layer);\n      return this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Removes the given layer from the map.\n    removeLayer: function removeLayer(layer) {\n      var id = stamp(layer);\n      if (!this._layers[id]) {\n        return this;\n      }\n      if (this._loaded) {\n        layer.onRemove(this);\n      }\n      delete this._layers[id];\n      if (this._loaded) {\n        this.fire('layerremove', {\n          layer: layer\n        });\n        layer.fire('remove');\n      }\n      layer._map = layer._mapToAdd = null;\n      return this;\n    },\n    // @method hasLayer(layer: Layer): Boolean\n    // Returns `true` if the given layer is currently added to the map\n    hasLayer: function hasLayer(layer) {\n      return stamp(layer) in this._layers;\n    },\n    /* @method eachLayer(fn: Function, context?: Object): this\n     * Iterates over the layers of the map, optionally specifying context of the iterator function.\n     * ```\n     * map.eachLayer(function(layer){\n     *     layer.bindPopup('Hello');\n     * });\n     * ```\n     */\n    eachLayer: function eachLayer(method, context) {\n      for (var i in this._layers) {\n        method.call(context, this._layers[i]);\n      }\n      return this;\n    },\n    _addLayers: function _addLayers(layers) {\n      layers = layers ? isArray(layers) ? layers : [layers] : [];\n      for (var i = 0, len = layers.length; i < len; i++) {\n        this.addLayer(layers[i]);\n      }\n    },\n    _addZoomLimit: function _addZoomLimit(layer) {\n      if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {\n        this._zoomBoundLayers[stamp(layer)] = layer;\n        this._updateZoomLevels();\n      }\n    },\n    _removeZoomLimit: function _removeZoomLimit(layer) {\n      var id = stamp(layer);\n      if (this._zoomBoundLayers[id]) {\n        delete this._zoomBoundLayers[id];\n        this._updateZoomLevels();\n      }\n    },\n    _updateZoomLevels: function _updateZoomLevels() {\n      var minZoom = Infinity,\n        maxZoom = -Infinity,\n        oldZoomSpan = this._getZoomSpan();\n      for (var i in this._zoomBoundLayers) {\n        var options = this._zoomBoundLayers[i].options;\n        minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);\n        maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);\n      }\n      this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;\n      this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;\n\n      // @section Map state change events\n      // @event zoomlevelschange: Event\n      // Fired when the number of zoomlevels on the map is changed due\n      // to adding or removing a layer.\n      if (oldZoomSpan !== this._getZoomSpan()) {\n        this.fire('zoomlevelschange');\n      }\n      if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {\n        this.setZoom(this._layersMaxZoom);\n      }\n      if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {\n        this.setZoom(this._layersMinZoom);\n      }\n    }\n  });\n\n  /*\r\n   * @class LayerGroup\r\n   * @aka L.LayerGroup\r\n   * @inherits Interactive layer\r\n   *\r\n   * Used to group several layers and handle them as one. If you add it to the map,\r\n   * any layers added or removed from the group will be added/removed on the map as\r\n   * well. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.layerGroup([marker1, marker2])\r\n   * \t.addLayer(polyline)\r\n   * \t.addTo(map);\r\n   * ```\r\n   */\n\n  var LayerGroup = Layer.extend({\n    initialize: function initialize(layers, options) {\n      setOptions(this, options);\n      this._layers = {};\n      var i, len;\n      if (layers) {\n        for (i = 0, len = layers.length; i < len; i++) {\n          this.addLayer(layers[i]);\n        }\n      }\n    },\n    // @method addLayer(layer: Layer): this\n    // Adds the given layer to the group.\n    addLayer: function addLayer(layer) {\n      var id = this.getLayerId(layer);\n      this._layers[id] = layer;\n      if (this._map) {\n        this._map.addLayer(layer);\n      }\n      return this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Removes the given layer from the group.\n    // @alternative\n    // @method removeLayer(id: Number): this\n    // Removes the layer with the given internal ID from the group.\n    removeLayer: function removeLayer(layer) {\n      var id = layer in this._layers ? layer : this.getLayerId(layer);\n      if (this._map && this._layers[id]) {\n        this._map.removeLayer(this._layers[id]);\n      }\n      delete this._layers[id];\n      return this;\n    },\n    // @method hasLayer(layer: Layer): Boolean\n    // Returns `true` if the given layer is currently added to the group.\n    // @alternative\n    // @method hasLayer(id: Number): Boolean\n    // Returns `true` if the given internal ID is currently added to the group.\n    hasLayer: function hasLayer(layer) {\n      var layerId = typeof layer === 'number' ? layer : this.getLayerId(layer);\n      return layerId in this._layers;\n    },\n    // @method clearLayers(): this\n    // Removes all the layers from the group.\n    clearLayers: function clearLayers() {\n      return this.eachLayer(this.removeLayer, this);\n    },\n    // @method invoke(methodName: String, …): this\n    // Calls `methodName` on every layer contained in this group, passing any\n    // additional parameters. Has no effect if the layers contained do not\n    // implement `methodName`.\n    invoke: function invoke(methodName) {\n      var args = Array.prototype.slice.call(arguments, 1),\n        i,\n        layer;\n      for (i in this._layers) {\n        layer = this._layers[i];\n        if (layer[methodName]) {\n          layer[methodName].apply(layer, args);\n        }\n      }\n      return this;\n    },\n    onAdd: function onAdd(map) {\n      this.eachLayer(map.addLayer, map);\n    },\n    onRemove: function onRemove(map) {\n      this.eachLayer(map.removeLayer, map);\n    },\n    // @method eachLayer(fn: Function, context?: Object): this\n    // Iterates over the layers of the group, optionally specifying context of the iterator function.\n    // ```js\n    // group.eachLayer(function (layer) {\n    // \tlayer.bindPopup('Hello');\n    // });\n    // ```\n    eachLayer: function eachLayer(method, context) {\n      for (var i in this._layers) {\n        method.call(context, this._layers[i]);\n      }\n      return this;\n    },\n    // @method getLayer(id: Number): Layer\n    // Returns the layer with the given internal ID.\n    getLayer: function getLayer(id) {\n      return this._layers[id];\n    },\n    // @method getLayers(): Layer[]\n    // Returns an array of all the layers added to the group.\n    getLayers: function getLayers() {\n      var layers = [];\n      this.eachLayer(layers.push, layers);\n      return layers;\n    },\n    // @method setZIndex(zIndex: Number): this\n    // Calls `setZIndex` on every layer contained in this group, passing the z-index.\n    setZIndex: function setZIndex(zIndex) {\n      return this.invoke('setZIndex', zIndex);\n    },\n    // @method getLayerId(layer: Layer): Number\n    // Returns the internal ID for a layer\n    getLayerId: function getLayerId(layer) {\n      return stamp(layer);\n    }\n  });\n\n  // @factory L.layerGroup(layers?: Layer[], options?: Object)\n  // Create a layer group, optionally given an initial set of layers and an `options` object.\n  var layerGroup = function layerGroup(layers, options) {\n    return new LayerGroup(layers, options);\n  };\n\n  /*\r\n   * @class FeatureGroup\r\n   * @aka L.FeatureGroup\r\n   * @inherits LayerGroup\r\n   *\r\n   * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:\r\n   *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))\r\n   *  * Events are propagated to the `FeatureGroup`, so if the group has an event\r\n   * handler, it will handle events from any of the layers. This includes mouse events\r\n   * and custom events.\r\n   *  * Has `layeradd` and `layerremove` events\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.featureGroup([marker1, marker2, polyline])\r\n   * \t.bindPopup('Hello world!')\r\n   * \t.on('click', function() { alert('Clicked on a member of the group!'); })\r\n   * \t.addTo(map);\r\n   * ```\r\n   */\n\n  var FeatureGroup = LayerGroup.extend({\n    addLayer: function addLayer(layer) {\n      if (this.hasLayer(layer)) {\n        return this;\n      }\n      layer.addEventParent(this);\n      LayerGroup.prototype.addLayer.call(this, layer);\n\n      // @event layeradd: LayerEvent\n      // Fired when a layer is added to this `FeatureGroup`\n      return this.fire('layeradd', {\n        layer: layer\n      });\n    },\n    removeLayer: function removeLayer(layer) {\n      if (!this.hasLayer(layer)) {\n        return this;\n      }\n      if (layer in this._layers) {\n        layer = this._layers[layer];\n      }\n      layer.removeEventParent(this);\n      LayerGroup.prototype.removeLayer.call(this, layer);\n\n      // @event layerremove: LayerEvent\n      // Fired when a layer is removed from this `FeatureGroup`\n      return this.fire('layerremove', {\n        layer: layer\n      });\n    },\n    // @method setStyle(style: Path options): this\n    // Sets the given path options to each layer of the group that has a `setStyle` method.\n    setStyle: function setStyle(style) {\n      return this.invoke('setStyle', style);\n    },\n    // @method bringToFront(): this\n    // Brings the layer group to the top of all other layers\n    bringToFront: function bringToFront() {\n      return this.invoke('bringToFront');\n    },\n    // @method bringToBack(): this\n    // Brings the layer group to the back of all other layers\n    bringToBack: function bringToBack() {\n      return this.invoke('bringToBack');\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).\n    getBounds: function getBounds() {\n      var bounds = new LatLngBounds();\n      for (var id in this._layers) {\n        var layer = this._layers[id];\n        bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());\n      }\n      return bounds;\n    }\n  });\n\n  // @factory L.featureGroup(layers?: Layer[], options?: Object)\n  // Create a feature group, optionally given an initial set of layers and an `options` object.\n  var featureGroup = function featureGroup(layers, options) {\n    return new FeatureGroup(layers, options);\n  };\n\n  /*\r\n   * @class Icon\r\n   * @aka L.Icon\r\n   *\r\n   * Represents an icon to provide when creating a marker.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var myIcon = L.icon({\r\n   *     iconUrl: 'my-icon.png',\r\n   *     iconRetinaUrl: 'my-icon@2x.png',\r\n   *     iconSize: [38, 95],\r\n   *     iconAnchor: [22, 94],\r\n   *     popupAnchor: [-3, -76],\r\n   *     shadowUrl: 'my-icon-shadow.png',\r\n   *     shadowRetinaUrl: 'my-icon-shadow@2x.png',\r\n   *     shadowSize: [68, 95],\r\n   *     shadowAnchor: [22, 94]\r\n   * });\r\n   *\r\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\r\n   * ```\r\n   *\r\n   * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.\r\n   *\r\n   */\n\n  var Icon = Class.extend({\n    /* @section\r\n     * @aka Icon options\r\n     *\r\n     * @option iconUrl: String = null\r\n     * **(required)** The URL to the icon image (absolute or relative to your script path).\r\n     *\r\n     * @option iconRetinaUrl: String = null\r\n     * The URL to a retina sized version of the icon image (absolute or relative to your\r\n     * script path). Used for Retina screen devices.\r\n     *\r\n     * @option iconSize: Point = null\r\n     * Size of the icon image in pixels.\r\n     *\r\n     * @option iconAnchor: Point = null\r\n     * The coordinates of the \"tip\" of the icon (relative to its top left corner). The icon\r\n     * will be aligned so that this point is at the marker's geographical location. Centered\r\n     * by default if size is specified, also can be set in CSS with negative margins.\r\n     *\r\n     * @option popupAnchor: Point = [0, 0]\r\n     * The coordinates of the point from which popups will \"open\", relative to the icon anchor.\r\n     *\r\n     * @option tooltipAnchor: Point = [0, 0]\r\n     * The coordinates of the point from which tooltips will \"open\", relative to the icon anchor.\r\n     *\r\n     * @option shadowUrl: String = null\r\n     * The URL to the icon shadow image. If not specified, no shadow image will be created.\r\n     *\r\n     * @option shadowRetinaUrl: String = null\r\n     *\r\n     * @option shadowSize: Point = null\r\n     * Size of the shadow image in pixels.\r\n     *\r\n     * @option shadowAnchor: Point = null\r\n     * The coordinates of the \"tip\" of the shadow (relative to its top left corner) (the same\r\n     * as iconAnchor if not specified).\r\n     *\r\n     * @option className: String = ''\r\n     * A custom class name to assign to both icon and shadow images. Empty by default.\r\n     */\n\n    options: {\n      popupAnchor: [0, 0],\n      tooltipAnchor: [0, 0],\n      // @option crossOrigin: Boolean|String = false\n      // Whether the crossOrigin attribute will be added to the tiles.\n      // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.\n      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n      crossOrigin: false\n    },\n    initialize: function initialize(options) {\n      setOptions(this, options);\n    },\n    // @method createIcon(oldIcon?: HTMLElement): HTMLElement\n    // Called internally when the icon has to be shown, returns a `<img>` HTML element\n    // styled according to the options.\n    createIcon: function createIcon(oldIcon) {\n      return this._createIcon('icon', oldIcon);\n    },\n    // @method createShadow(oldIcon?: HTMLElement): HTMLElement\n    // As `createIcon`, but for the shadow beneath it.\n    createShadow: function createShadow(oldIcon) {\n      return this._createIcon('shadow', oldIcon);\n    },\n    _createIcon: function _createIcon(name, oldIcon) {\n      var src = this._getIconUrl(name);\n      if (!src) {\n        if (name === 'icon') {\n          throw new Error('iconUrl not set in Icon options (see the docs).');\n        }\n        return null;\n      }\n      var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);\n      this._setIconStyles(img, name);\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n      return img;\n    },\n    _setIconStyles: function _setIconStyles(img, name) {\n      var options = this.options;\n      var sizeOption = options[name + 'Size'];\n      if (typeof sizeOption === 'number') {\n        sizeOption = [sizeOption, sizeOption];\n      }\n      var size = toPoint(sizeOption),\n        anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));\n      img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');\n      if (anchor) {\n        img.style.marginLeft = -anchor.x + 'px';\n        img.style.marginTop = -anchor.y + 'px';\n      }\n      if (size) {\n        img.style.width = size.x + 'px';\n        img.style.height = size.y + 'px';\n      }\n    },\n    _createImg: function _createImg(src, el) {\n      el = el || document.createElement('img');\n      el.src = src;\n      return el;\n    },\n    _getIconUrl: function _getIconUrl(name) {\n      return Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];\n    }\n  });\n\n  // @factory L.icon(options: Icon options)\n  // Creates an icon instance with the given options.\n  function icon(options) {\n    return new Icon(options);\n  }\n\n  /*\n   * @miniclass Icon.Default (Icon)\n   * @aka L.Icon.Default\n   * @section\n   *\n   * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when\n   * no icon is specified. Points to the blue marker image distributed with Leaflet\n   * releases.\n   *\n   * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`\n   * (which is a set of `Icon options`).\n   *\n   * If you want to _completely_ replace the default icon, override the\n   * `L.Marker.prototype.options.icon` with your own icon instead.\n   */\n\n  var IconDefault = Icon.extend({\n    options: {\n      iconUrl: 'marker-icon.png',\n      iconRetinaUrl: 'marker-icon-2x.png',\n      shadowUrl: 'marker-shadow.png',\n      iconSize: [25, 41],\n      iconAnchor: [12, 41],\n      popupAnchor: [1, -34],\n      tooltipAnchor: [16, -28],\n      shadowSize: [41, 41]\n    },\n    _getIconUrl: function _getIconUrl(name) {\n      if (typeof IconDefault.imagePath !== 'string') {\n        // Deprecated, backwards-compatibility only\n        IconDefault.imagePath = this._detectIconPath();\n      }\n\n      // @option imagePath: String\n      // `Icon.Default` will try to auto-detect the location of the\n      // blue icon images. If you are placing these images in a non-standard\n      // way, set this option to point to the right path.\n      return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);\n    },\n    _stripUrl: function _stripUrl(path) {\n      // separate function to use in tests\n      var strip = function strip(str, re, idx) {\n        var match = re.exec(str);\n        return match && match[idx];\n      };\n      path = strip(path, /^url\\((['\"])?(.+)\\1\\)$/, 2);\n      return path && strip(path, /^(.*)marker-icon\\.png$/, 1);\n    },\n    _detectIconPath: function _detectIconPath() {\n      var el = create$1('div', 'leaflet-default-icon-path', document.body);\n      var path = getStyle(el, 'background-image') || getStyle(el, 'backgroundImage'); // IE8\n\n      document.body.removeChild(el);\n      path = this._stripUrl(path);\n      if (path) {\n        return path;\n      }\n      var link = document.querySelector('link[href$=\"leaflet.css\"]');\n      if (!link) {\n        return '';\n      }\n      return link.href.substring(0, link.href.length - 'leaflet.css'.length - 1);\n    }\n  });\n\n  /*\n   * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n   */\n\n  /* @namespace Marker\n   * @section Interaction handlers\n   *\n   * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:\n   *\n   * ```js\n   * marker.dragging.disable();\n   * ```\n   *\n   * @property dragging: Handler\n   * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).\n   */\n\n  var MarkerDrag = Handler.extend({\n    initialize: function initialize(marker) {\n      this._marker = marker;\n    },\n    addHooks: function addHooks() {\n      var icon = this._marker._icon;\n      if (!this._draggable) {\n        this._draggable = new Draggable(icon, icon, true);\n      }\n      this._draggable.on({\n        dragstart: this._onDragStart,\n        predrag: this._onPreDrag,\n        drag: this._onDrag,\n        dragend: this._onDragEnd\n      }, this).enable();\n      addClass(icon, 'leaflet-marker-draggable');\n    },\n    removeHooks: function removeHooks() {\n      this._draggable.off({\n        dragstart: this._onDragStart,\n        predrag: this._onPreDrag,\n        drag: this._onDrag,\n        dragend: this._onDragEnd\n      }, this).disable();\n      if (this._marker._icon) {\n        removeClass(this._marker._icon, 'leaflet-marker-draggable');\n      }\n    },\n    moved: function moved() {\n      return this._draggable && this._draggable._moved;\n    },\n    _adjustPan: function _adjustPan(e) {\n      var marker = this._marker,\n        map = marker._map,\n        speed = this._marker.options.autoPanSpeed,\n        padding = this._marker.options.autoPanPadding,\n        iconPos = getPosition(marker._icon),\n        bounds = map.getPixelBounds(),\n        origin = map.getPixelOrigin();\n      var panBounds = toBounds(bounds.min._subtract(origin).add(padding), bounds.max._subtract(origin).subtract(padding));\n      if (!panBounds.contains(iconPos)) {\n        // Compute incremental movement\n        var movement = toPoint((Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x), (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)).multiplyBy(speed);\n        map.panBy(movement, {\n          animate: false\n        });\n        this._draggable._newPos._add(movement);\n        this._draggable._startPos._add(movement);\n        setPosition(marker._icon, this._draggable._newPos);\n        this._onDrag(e);\n        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n      }\n    },\n    _onDragStart: function _onDragStart() {\n      // @section Dragging events\n      // @event dragstart: Event\n      // Fired when the user starts dragging the marker.\n\n      // @event movestart: Event\n      // Fired when the marker starts moving (because of dragging).\n\n      this._oldLatLng = this._marker.getLatLng();\n\n      // When using ES6 imports it could not be set when `Popup` was not imported as well\n      this._marker.closePopup && this._marker.closePopup();\n      this._marker.fire('movestart').fire('dragstart');\n    },\n    _onPreDrag: function _onPreDrag(e) {\n      if (this._marker.options.autoPan) {\n        cancelAnimFrame(this._panRequest);\n        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n      }\n    },\n    _onDrag: function _onDrag(e) {\n      var marker = this._marker,\n        shadow = marker._shadow,\n        iconPos = getPosition(marker._icon),\n        latlng = marker._map.layerPointToLatLng(iconPos);\n\n      // update shadow position\n      if (shadow) {\n        setPosition(shadow, iconPos);\n      }\n      marker._latlng = latlng;\n      e.latlng = latlng;\n      e.oldLatLng = this._oldLatLng;\n\n      // @event drag: Event\n      // Fired repeatedly while the user drags the marker.\n      marker.fire('move', e).fire('drag', e);\n    },\n    _onDragEnd: function _onDragEnd(e) {\n      // @event dragend: DragEndEvent\n      // Fired when the user stops dragging the marker.\n\n      cancelAnimFrame(this._panRequest);\n\n      // @event moveend: Event\n      // Fired when the marker stops moving (because of dragging).\n      delete this._oldLatLng;\n      this._marker.fire('moveend').fire('dragend', e);\n    }\n  });\n\n  /*\r\n   * @class Marker\r\n   * @inherits Interactive layer\r\n   * @aka L.Marker\r\n   * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.marker([50.5, 30.5]).addTo(map);\r\n   * ```\r\n   */\n\n  var Marker = Layer.extend({\n    // @section\n    // @aka Marker options\n    options: {\n      // @option icon: Icon = *\n      // Icon instance to use for rendering the marker.\n      // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.\n      // If not specified, a common instance of `L.Icon.Default` is used.\n      icon: new IconDefault(),\n      // Option inherited from \"Interactive layer\" abstract class\n      interactive: true,\n      // @option keyboard: Boolean = true\n      // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.\n      keyboard: true,\n      // @option title: String = ''\n      // Text for the browser tooltip that appear on marker hover (no tooltip by default).\n      // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).\n      title: '',\n      // @option alt: String = 'Marker'\n      // Text for the `alt` attribute of the icon image.\n      // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).\n      alt: 'Marker',\n      // @option zIndexOffset: Number = 0\n      // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).\n      zIndexOffset: 0,\n      // @option opacity: Number = 1.0\n      // The opacity of the marker.\n      opacity: 1,\n      // @option riseOnHover: Boolean = false\n      // If `true`, the marker will get on top of others when you hover the mouse over it.\n      riseOnHover: false,\n      // @option riseOffset: Number = 250\n      // The z-index offset used for the `riseOnHover` feature.\n      riseOffset: 250,\n      // @option pane: String = 'markerPane'\n      // `Map pane` where the markers icon will be added.\n      pane: 'markerPane',\n      // @option shadowPane: String = 'shadowPane'\n      // `Map pane` where the markers shadow will be added.\n      shadowPane: 'shadowPane',\n      // @option bubblingMouseEvents: Boolean = false\n      // When `true`, a mouse event on this marker will trigger the same event on the map\n      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n      bubblingMouseEvents: false,\n      // @option autoPanOnFocus: Boolean = true\n      // When `true`, the map will pan whenever the marker is focused (via\n      // e.g. pressing `tab` on the keyboard) to ensure the marker is\n      // visible within the map's bounds\n      autoPanOnFocus: true,\n      // @section Draggable marker options\n      // @option draggable: Boolean = false\n      // Whether the marker is draggable with mouse/touch or not.\n      draggable: false,\n      // @option autoPan: Boolean = false\n      // Whether to pan the map when dragging this marker near its edge or not.\n      autoPan: false,\n      // @option autoPanPadding: Point = Point(50, 50)\n      // Distance (in pixels to the left/right and to the top/bottom) of the\n      // map edge to start panning the map.\n      autoPanPadding: [50, 50],\n      // @option autoPanSpeed: Number = 10\n      // Number of pixels the map should pan by.\n      autoPanSpeed: 10\n    },\n    /* @section\r\n     *\r\n     * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:\r\n     */\n\n    initialize: function initialize(latlng, options) {\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n    },\n    onAdd: function onAdd(map) {\n      this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;\n      if (this._zoomAnimated) {\n        map.on('zoomanim', this._animateZoom, this);\n      }\n      this._initIcon();\n      this.update();\n    },\n    onRemove: function onRemove(map) {\n      if (this.dragging && this.dragging.enabled()) {\n        this.options.draggable = true;\n        this.dragging.removeHooks();\n      }\n      delete this.dragging;\n      if (this._zoomAnimated) {\n        map.off('zoomanim', this._animateZoom, this);\n      }\n      this._removeIcon();\n      this._removeShadow();\n    },\n    getEvents: function getEvents() {\n      return {\n        zoom: this.update,\n        viewreset: this.update\n      };\n    },\n    // @method getLatLng: LatLng\n    // Returns the current geographical position of the marker.\n    getLatLng: function getLatLng() {\n      return this._latlng;\n    },\n    // @method setLatLng(latlng: LatLng): this\n    // Changes the marker position to the given point.\n    setLatLng: function setLatLng(latlng) {\n      var oldLatLng = this._latlng;\n      this._latlng = toLatLng(latlng);\n      this.update();\n\n      // @event move: Event\n      // Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n      return this.fire('move', {\n        oldLatLng: oldLatLng,\n        latlng: this._latlng\n      });\n    },\n    // @method setZIndexOffset(offset: Number): this\n    // Changes the [zIndex offset](#marker-zindexoffset) of the marker.\n    setZIndexOffset: function setZIndexOffset(offset) {\n      this.options.zIndexOffset = offset;\n      return this.update();\n    },\n    // @method getIcon: Icon\n    // Returns the current icon used by the marker\n    getIcon: function getIcon() {\n      return this.options.icon;\n    },\n    // @method setIcon(icon: Icon): this\n    // Changes the marker icon.\n    setIcon: function setIcon(icon) {\n      this.options.icon = icon;\n      if (this._map) {\n        this._initIcon();\n        this.update();\n      }\n      if (this._popup) {\n        this.bindPopup(this._popup, this._popup.options);\n      }\n      return this;\n    },\n    getElement: function getElement() {\n      return this._icon;\n    },\n    update: function update() {\n      if (this._icon && this._map) {\n        var pos = this._map.latLngToLayerPoint(this._latlng).round();\n        this._setPos(pos);\n      }\n      return this;\n    },\n    _initIcon: function _initIcon() {\n      var options = this.options,\n        classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\n      var icon = options.icon.createIcon(this._icon),\n        addIcon = false;\n\n      // if we're not reusing the icon, remove the old one and init new one\n      if (icon !== this._icon) {\n        if (this._icon) {\n          this._removeIcon();\n        }\n        addIcon = true;\n        if (options.title) {\n          icon.title = options.title;\n        }\n        if (icon.tagName === 'IMG') {\n          icon.alt = options.alt || '';\n        }\n      }\n      addClass(icon, classToAdd);\n      if (options.keyboard) {\n        icon.tabIndex = '0';\n        icon.setAttribute('role', 'button');\n      }\n      this._icon = icon;\n      if (options.riseOnHover) {\n        this.on({\n          mouseover: this._bringToFront,\n          mouseout: this._resetZIndex\n        });\n      }\n      if (this.options.autoPanOnFocus) {\n        on(icon, 'focus', this._panOnFocus, this);\n      }\n      var newShadow = options.icon.createShadow(this._shadow),\n        addShadow = false;\n      if (newShadow !== this._shadow) {\n        this._removeShadow();\n        addShadow = true;\n      }\n      if (newShadow) {\n        addClass(newShadow, classToAdd);\n        newShadow.alt = '';\n      }\n      this._shadow = newShadow;\n      if (options.opacity < 1) {\n        this._updateOpacity();\n      }\n      if (addIcon) {\n        this.getPane().appendChild(this._icon);\n      }\n      this._initInteraction();\n      if (newShadow && addShadow) {\n        this.getPane(options.shadowPane).appendChild(this._shadow);\n      }\n    },\n    _removeIcon: function _removeIcon() {\n      if (this.options.riseOnHover) {\n        this.off({\n          mouseover: this._bringToFront,\n          mouseout: this._resetZIndex\n        });\n      }\n      if (this.options.autoPanOnFocus) {\n        off(this._icon, 'focus', this._panOnFocus, this);\n      }\n      _remove(this._icon);\n      this.removeInteractiveTarget(this._icon);\n      this._icon = null;\n    },\n    _removeShadow: function _removeShadow() {\n      if (this._shadow) {\n        _remove(this._shadow);\n      }\n      this._shadow = null;\n    },\n    _setPos: function _setPos(pos) {\n      if (this._icon) {\n        setPosition(this._icon, pos);\n      }\n      if (this._shadow) {\n        setPosition(this._shadow, pos);\n      }\n      this._zIndex = pos.y + this.options.zIndexOffset;\n      this._resetZIndex();\n    },\n    _updateZIndex: function _updateZIndex(offset) {\n      if (this._icon) {\n        this._icon.style.zIndex = this._zIndex + offset;\n      }\n    },\n    _animateZoom: function _animateZoom(opt) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\n      this._setPos(pos);\n    },\n    _initInteraction: function _initInteraction() {\n      if (!this.options.interactive) {\n        return;\n      }\n      addClass(this._icon, 'leaflet-interactive');\n      this.addInteractiveTarget(this._icon);\n      if (MarkerDrag) {\n        var draggable = this.options.draggable;\n        if (this.dragging) {\n          draggable = this.dragging.enabled();\n          this.dragging.disable();\n        }\n        this.dragging = new MarkerDrag(this);\n        if (draggable) {\n          this.dragging.enable();\n        }\n      }\n    },\n    // @method setOpacity(opacity: Number): this\n    // Changes the opacity of the marker.\n    setOpacity: function setOpacity(opacity) {\n      this.options.opacity = opacity;\n      if (this._map) {\n        this._updateOpacity();\n      }\n      return this;\n    },\n    _updateOpacity: function _updateOpacity() {\n      var opacity = this.options.opacity;\n      if (this._icon) {\n        _setOpacity(this._icon, opacity);\n      }\n      if (this._shadow) {\n        _setOpacity(this._shadow, opacity);\n      }\n    },\n    _bringToFront: function _bringToFront() {\n      this._updateZIndex(this.options.riseOffset);\n    },\n    _resetZIndex: function _resetZIndex() {\n      this._updateZIndex(0);\n    },\n    _panOnFocus: function _panOnFocus() {\n      var map = this._map;\n      if (!map) {\n        return;\n      }\n      var iconOpts = this.options.icon.options;\n      var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);\n      var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);\n      map.panInside(this._latlng, {\n        paddingTopLeft: anchor,\n        paddingBottomRight: size.subtract(anchor)\n      });\n    },\n    _getPopupAnchor: function _getPopupAnchor() {\n      return this.options.icon.options.popupAnchor;\n    },\n    _getTooltipAnchor: function _getTooltipAnchor() {\n      return this.options.icon.options.tooltipAnchor;\n    }\n  });\n\n  // factory L.marker(latlng: LatLng, options? : Marker options)\n\n  // @factory L.marker(latlng: LatLng, options? : Marker options)\n  // Instantiates a Marker object given a geographical point and optionally an options object.\n  function marker(latlng, options) {\n    return new Marker(latlng, options);\n  }\n\n  /*\n   * @class Path\n   * @aka L.Path\n   * @inherits Interactive layer\n   *\n   * An abstract class that contains options and constants shared between vector\n   * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.\n   */\n\n  var Path = Layer.extend({\n    // @section\n    // @aka Path options\n    options: {\n      // @option stroke: Boolean = true\n      // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.\n      stroke: true,\n      // @option color: String = '#3388ff'\n      // Stroke color\n      color: '#3388ff',\n      // @option weight: Number = 3\n      // Stroke width in pixels\n      weight: 3,\n      // @option opacity: Number = 1.0\n      // Stroke opacity\n      opacity: 1,\n      // @option lineCap: String= 'round'\n      // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.\n      lineCap: 'round',\n      // @option lineJoin: String = 'round'\n      // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.\n      lineJoin: 'round',\n      // @option dashArray: String = null\n      // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n      dashArray: null,\n      // @option dashOffset: String = null\n      // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n      dashOffset: null,\n      // @option fill: Boolean = depends\n      // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.\n      fill: false,\n      // @option fillColor: String = *\n      // Fill color. Defaults to the value of the [`color`](#path-color) option\n      fillColor: null,\n      // @option fillOpacity: Number = 0.2\n      // Fill opacity.\n      fillOpacity: 0.2,\n      // @option fillRule: String = 'evenodd'\n      // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.\n      fillRule: 'evenodd',\n      // className: '',\n\n      // Option inherited from \"Interactive layer\" abstract class\n      interactive: true,\n      // @option bubblingMouseEvents: Boolean = true\n      // When `true`, a mouse event on this path will trigger the same event on the map\n      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n      bubblingMouseEvents: true\n    },\n    beforeAdd: function beforeAdd(map) {\n      // Renderer is set here because we need to call renderer.getEvents\n      // before this.getEvents.\n      this._renderer = map.getRenderer(this);\n    },\n    onAdd: function onAdd() {\n      this._renderer._initPath(this);\n      this._reset();\n      this._renderer._addPath(this);\n    },\n    onRemove: function onRemove() {\n      this._renderer._removePath(this);\n    },\n    // @method redraw(): this\n    // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.\n    redraw: function redraw() {\n      if (this._map) {\n        this._renderer._updatePath(this);\n      }\n      return this;\n    },\n    // @method setStyle(style: Path options): this\n    // Changes the appearance of a Path based on the options in the `Path options` object.\n    setStyle: function setStyle(style) {\n      setOptions(this, style);\n      if (this._renderer) {\n        this._renderer._updateStyle(this);\n        if (this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, 'weight')) {\n          this._updateBounds();\n        }\n      }\n      return this;\n    },\n    // @method bringToFront(): this\n    // Brings the layer to the top of all path layers.\n    bringToFront: function bringToFront() {\n      if (this._renderer) {\n        this._renderer._bringToFront(this);\n      }\n      return this;\n    },\n    // @method bringToBack(): this\n    // Brings the layer to the bottom of all path layers.\n    bringToBack: function bringToBack() {\n      if (this._renderer) {\n        this._renderer._bringToBack(this);\n      }\n      return this;\n    },\n    getElement: function getElement() {\n      return this._path;\n    },\n    _reset: function _reset() {\n      // defined in child classes\n      this._project();\n      this._update();\n    },\n    _clickTolerance: function _clickTolerance() {\n      // used when doing hit detection for Canvas layers\n      return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);\n    }\n  });\n\n  /*\n   * @class CircleMarker\n   * @aka L.CircleMarker\n   * @inherits Path\n   *\n   * A circle of a fixed size with radius specified in pixels. Extends `Path`.\n   */\n\n  var CircleMarker = Path.extend({\n    // @section\n    // @aka CircleMarker options\n    options: {\n      fill: true,\n      // @option radius: Number = 10\n      // Radius of the circle marker, in pixels\n      radius: 10\n    },\n    initialize: function initialize(latlng, options) {\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n      this._radius = this.options.radius;\n    },\n    // @method setLatLng(latLng: LatLng): this\n    // Sets the position of a circle marker to a new location.\n    setLatLng: function setLatLng(latlng) {\n      var oldLatLng = this._latlng;\n      this._latlng = toLatLng(latlng);\n      this.redraw();\n\n      // @event move: Event\n      // Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n      return this.fire('move', {\n        oldLatLng: oldLatLng,\n        latlng: this._latlng\n      });\n    },\n    // @method getLatLng(): LatLng\n    // Returns the current geographical position of the circle marker\n    getLatLng: function getLatLng() {\n      return this._latlng;\n    },\n    // @method setRadius(radius: Number): this\n    // Sets the radius of a circle marker. Units are in pixels.\n    setRadius: function setRadius(radius) {\n      this.options.radius = this._radius = radius;\n      return this.redraw();\n    },\n    // @method getRadius(): Number\n    // Returns the current radius of the circle\n    getRadius: function getRadius() {\n      return this._radius;\n    },\n    setStyle: function setStyle(options) {\n      var radius = options && options.radius || this._radius;\n      Path.prototype.setStyle.call(this, options);\n      this.setRadius(radius);\n      return this;\n    },\n    _project: function _project() {\n      this._point = this._map.latLngToLayerPoint(this._latlng);\n      this._updateBounds();\n    },\n    _updateBounds: function _updateBounds() {\n      var r = this._radius,\n        r2 = this._radiusY || r,\n        w = this._clickTolerance(),\n        p = [r + w, r2 + w];\n      this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));\n    },\n    _update: function _update() {\n      if (this._map) {\n        this._updatePath();\n      }\n    },\n    _updatePath: function _updatePath() {\n      this._renderer._updateCircle(this);\n    },\n    _empty: function _empty() {\n      return this._radius && !this._renderer._bounds.intersects(this._pxBounds);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function _containsPoint(p) {\n      return p.distanceTo(this._point) <= this._radius + this._clickTolerance();\n    }\n  });\n\n  // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)\n  // Instantiates a circle marker object given a geographical point, and an optional options object.\n  function circleMarker(latlng, options) {\n    return new CircleMarker(latlng, options);\n  }\n\n  /*\n   * @class Circle\n   * @aka L.Circle\n   * @inherits CircleMarker\n   *\n   * A class for drawing circle overlays on a map. Extends `CircleMarker`.\n   *\n   * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).\n   *\n   * @example\n   *\n   * ```js\n   * L.circle([50.5, 30.5], {radius: 200}).addTo(map);\n   * ```\n   */\n\n  var Circle = CircleMarker.extend({\n    initialize: function initialize(latlng, options, legacyOptions) {\n      if (typeof options === 'number') {\n        // Backwards compatibility with 0.7.x factory (latlng, radius, options?)\n        options = extend({}, legacyOptions, {\n          radius: options\n        });\n      }\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n      if (isNaN(this.options.radius)) {\n        throw new Error('Circle radius cannot be NaN');\n      }\n\n      // @section\n      // @aka Circle options\n      // @option radius: Number; Radius of the circle, in meters.\n      this._mRadius = this.options.radius;\n    },\n    // @method setRadius(radius: Number): this\n    // Sets the radius of a circle. Units are in meters.\n    setRadius: function setRadius(radius) {\n      this._mRadius = radius;\n      return this.redraw();\n    },\n    // @method getRadius(): Number\n    // Returns the current radius of a circle. Units are in meters.\n    getRadius: function getRadius() {\n      return this._mRadius;\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the `LatLngBounds` of the path.\n    getBounds: function getBounds() {\n      var half = [this._radius, this._radiusY || this._radius];\n      return new LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));\n    },\n    setStyle: Path.prototype.setStyle,\n    _project: function _project() {\n      var lng = this._latlng.lng,\n        lat = this._latlng.lat,\n        map = this._map,\n        crs = map.options.crs;\n      if (crs.distance === Earth.distance) {\n        var d = Math.PI / 180,\n          latR = this._mRadius / Earth.R / d,\n          top = map.project([lat + latR, lng]),\n          bottom = map.project([lat - latR, lng]),\n          p = top.add(bottom).divideBy(2),\n          lat2 = map.unproject(p).lat,\n          lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;\n        if (isNaN(lngR) || lngR === 0) {\n          lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425\n        }\n        this._point = p.subtract(map.getPixelOrigin());\n        this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;\n        this._radiusY = p.y - top.y;\n      } else {\n        var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));\n        this._point = map.latLngToLayerPoint(this._latlng);\n        this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;\n      }\n      this._updateBounds();\n    }\n  });\n\n  // @factory L.circle(latlng: LatLng, options?: Circle options)\n  // Instantiates a circle object given a geographical point, and an options object\n  // which contains the circle radius.\n  // @alternative\n  // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)\n  // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.\n  // Do not use in new applications or plugins.\n  function circle(latlng, options, legacyOptions) {\n    return new Circle(latlng, options, legacyOptions);\n  }\n\n  /*\n   * @class Polyline\n   * @aka L.Polyline\n   * @inherits Path\n   *\n   * A class for drawing polyline overlays on a map. Extends `Path`.\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polyline from an array of LatLng points\n   * var latlngs = [\n   * \t[45.51, -122.68],\n   * \t[37.77, -122.43],\n   * \t[34.04, -118.2]\n   * ];\n   *\n   * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polyline\n   * map.fitBounds(polyline.getBounds());\n   * ```\n   *\n   * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:\n   *\n   * ```js\n   * // create a red polyline from an array of arrays of LatLng points\n   * var latlngs = [\n   * \t[[45.51, -122.68],\n   * \t [37.77, -122.43],\n   * \t [34.04, -118.2]],\n   * \t[[40.78, -73.91],\n   * \t [41.83, -87.62],\n   * \t [32.76, -96.72]]\n   * ];\n   * ```\n   */\n\n  var Polyline = Path.extend({\n    // @section\n    // @aka Polyline options\n    options: {\n      // @option smoothFactor: Number = 1.0\n      // How much to simplify the polyline on each zoom level. More means\n      // better performance and smoother look, and less means more accurate representation.\n      smoothFactor: 1.0,\n      // @option noClip: Boolean = false\n      // Disable polyline clipping.\n      noClip: false\n    },\n    initialize: function initialize(latlngs, options) {\n      setOptions(this, options);\n      this._setLatLngs(latlngs);\n    },\n    // @method getLatLngs(): LatLng[]\n    // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.\n    getLatLngs: function getLatLngs() {\n      return this._latlngs;\n    },\n    // @method setLatLngs(latlngs: LatLng[]): this\n    // Replaces all the points in the polyline with the given array of geographical points.\n    setLatLngs: function setLatLngs(latlngs) {\n      this._setLatLngs(latlngs);\n      return this.redraw();\n    },\n    // @method isEmpty(): Boolean\n    // Returns `true` if the Polyline has no LatLngs.\n    isEmpty: function isEmpty() {\n      return !this._latlngs.length;\n    },\n    // @method closestLayerPoint(p: Point): Point\n    // Returns the point closest to `p` on the Polyline.\n    closestLayerPoint: function closestLayerPoint(p) {\n      var minDistance = Infinity,\n        minPoint = null,\n        closest = _sqClosestPointOnSegment,\n        p1,\n        p2;\n      for (var j = 0, jLen = this._parts.length; j < jLen; j++) {\n        var points = this._parts[j];\n        for (var i = 1, len = points.length; i < len; i++) {\n          p1 = points[i - 1];\n          p2 = points[i];\n          var sqDist = closest(p, p1, p2, true);\n          if (sqDist < minDistance) {\n            minDistance = sqDist;\n            minPoint = closest(p, p1, p2);\n          }\n        }\n      }\n      if (minPoint) {\n        minPoint.distance = Math.sqrt(minDistance);\n      }\n      return minPoint;\n    },\n    // @method getCenter(): LatLng\n    // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.\n    getCenter: function getCenter() {\n      // throws error when not yet added to map as this center calculation requires projected coordinates\n      if (!this._map) {\n        throw new Error('Must add layer to map before using getCenter()');\n      }\n      return polylineCenter(this._defaultShape(), this._map.options.crs);\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the `LatLngBounds` of the path.\n    getBounds: function getBounds() {\n      return this._bounds;\n    },\n    // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this\n    // Adds a given point to the polyline. By default, adds to the first ring of\n    // the polyline in case of a multi-polyline, but can be overridden by passing\n    // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).\n    addLatLng: function addLatLng(latlng, latlngs) {\n      latlngs = latlngs || this._defaultShape();\n      latlng = toLatLng(latlng);\n      latlngs.push(latlng);\n      this._bounds.extend(latlng);\n      return this.redraw();\n    },\n    _setLatLngs: function _setLatLngs(latlngs) {\n      this._bounds = new LatLngBounds();\n      this._latlngs = this._convertLatLngs(latlngs);\n    },\n    _defaultShape: function _defaultShape() {\n      return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];\n    },\n    // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way\n    _convertLatLngs: function _convertLatLngs(latlngs) {\n      var result = [],\n        flat = isFlat(latlngs);\n      for (var i = 0, len = latlngs.length; i < len; i++) {\n        if (flat) {\n          result[i] = toLatLng(latlngs[i]);\n          this._bounds.extend(result[i]);\n        } else {\n          result[i] = this._convertLatLngs(latlngs[i]);\n        }\n      }\n      return result;\n    },\n    _project: function _project() {\n      var pxBounds = new Bounds();\n      this._rings = [];\n      this._projectLatlngs(this._latlngs, this._rings, pxBounds);\n      if (this._bounds.isValid() && pxBounds.isValid()) {\n        this._rawPxBounds = pxBounds;\n        this._updateBounds();\n      }\n    },\n    _updateBounds: function _updateBounds() {\n      var w = this._clickTolerance(),\n        p = new Point(w, w);\n      if (!this._rawPxBounds) {\n        return;\n      }\n      this._pxBounds = new Bounds([this._rawPxBounds.min.subtract(p), this._rawPxBounds.max.add(p)]);\n    },\n    // recursively turns latlngs into a set of rings with projected coordinates\n    _projectLatlngs: function _projectLatlngs(latlngs, result, projectedBounds) {\n      var flat = latlngs[0] instanceof LatLng,\n        len = latlngs.length,\n        i,\n        ring;\n      if (flat) {\n        ring = [];\n        for (i = 0; i < len; i++) {\n          ring[i] = this._map.latLngToLayerPoint(latlngs[i]);\n          projectedBounds.extend(ring[i]);\n        }\n        result.push(ring);\n      } else {\n        for (i = 0; i < len; i++) {\n          this._projectLatlngs(latlngs[i], result, projectedBounds);\n        }\n      }\n    },\n    // clip polyline by renderer bounds so that we have less to render for performance\n    _clipPoints: function _clipPoints() {\n      var bounds = this._renderer._bounds;\n      this._parts = [];\n      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n        return;\n      }\n      if (this.options.noClip) {\n        this._parts = this._rings;\n        return;\n      }\n      var parts = this._parts,\n        i,\n        j,\n        k,\n        len,\n        len2,\n        segment,\n        points;\n      for (i = 0, k = 0, len = this._rings.length; i < len; i++) {\n        points = this._rings[i];\n        for (j = 0, len2 = points.length; j < len2 - 1; j++) {\n          segment = clipSegment(points[j], points[j + 1], bounds, j, true);\n          if (!segment) {\n            continue;\n          }\n          parts[k] = parts[k] || [];\n          parts[k].push(segment[0]);\n\n          // if segment goes out of screen, or it's the last one, it's the end of the line part\n          if (segment[1] !== points[j + 1] || j === len2 - 2) {\n            parts[k].push(segment[1]);\n            k++;\n          }\n        }\n      }\n    },\n    // simplify each clipped part of the polyline for performance\n    _simplifyPoints: function _simplifyPoints() {\n      var parts = this._parts,\n        tolerance = this.options.smoothFactor;\n      for (var i = 0, len = parts.length; i < len; i++) {\n        parts[i] = simplify(parts[i], tolerance);\n      }\n    },\n    _update: function _update() {\n      if (!this._map) {\n        return;\n      }\n      this._clipPoints();\n      this._simplifyPoints();\n      this._updatePath();\n    },\n    _updatePath: function _updatePath() {\n      this._renderer._updatePoly(this);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function _containsPoint(p, closed) {\n      var i,\n        j,\n        k,\n        len,\n        len2,\n        part,\n        w = this._clickTolerance();\n      if (!this._pxBounds || !this._pxBounds.contains(p)) {\n        return false;\n      }\n\n      // hit detection for polylines\n      for (i = 0, len = this._parts.length; i < len; i++) {\n        part = this._parts[i];\n        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n          if (!closed && j === 0) {\n            continue;\n          }\n          if (pointToSegmentDistance(p, part[k], part[j]) <= w) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n  });\n\n  // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)\n  // Instantiates a polyline object given an array of geographical points and\n  // optionally an options object. You can create a `Polyline` object with\n  // multiple separate lines (`MultiPolyline`) by passing an array of arrays\n  // of geographic points.\n  function polyline(latlngs, options) {\n    return new Polyline(latlngs, options);\n  }\n\n  // Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.\n  Polyline._flat = _flat;\n\n  /*\n   * @class Polygon\n   * @aka L.Polygon\n   * @inherits Polyline\n   *\n   * A class for drawing polygon overlays on a map. Extends `Polyline`.\n   *\n   * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.\n   *\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polygon from an array of LatLng points\n   * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];\n   *\n   * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polygon\n   * map.fitBounds(polygon.getBounds());\n   * ```\n   *\n   * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:\n   *\n   * ```js\n   * var latlngs = [\n   *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   * ];\n   * ```\n   *\n   * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.\n   *\n   * ```js\n   * var latlngs = [\n   *   [ // first polygon\n   *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   *   ],\n   *   [ // second polygon\n   *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]\n   *   ]\n   * ];\n   * ```\n   */\n\n  var Polygon = Polyline.extend({\n    options: {\n      fill: true\n    },\n    isEmpty: function isEmpty() {\n      return !this._latlngs.length || !this._latlngs[0].length;\n    },\n    // @method getCenter(): LatLng\n    // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.\n    getCenter: function getCenter() {\n      // throws error when not yet added to map as this center calculation requires projected coordinates\n      if (!this._map) {\n        throw new Error('Must add layer to map before using getCenter()');\n      }\n      return polygonCenter(this._defaultShape(), this._map.options.crs);\n    },\n    _convertLatLngs: function _convertLatLngs(latlngs) {\n      var result = Polyline.prototype._convertLatLngs.call(this, latlngs),\n        len = result.length;\n\n      // remove last point if it equals first one\n      if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {\n        result.pop();\n      }\n      return result;\n    },\n    _setLatLngs: function _setLatLngs(latlngs) {\n      Polyline.prototype._setLatLngs.call(this, latlngs);\n      if (isFlat(this._latlngs)) {\n        this._latlngs = [this._latlngs];\n      }\n    },\n    _defaultShape: function _defaultShape() {\n      return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];\n    },\n    _clipPoints: function _clipPoints() {\n      // polygons need a different clipping algorithm so we redefine that\n\n      var bounds = this._renderer._bounds,\n        w = this.options.weight,\n        p = new Point(w, w);\n\n      // increase clip padding by stroke width to avoid stroke on clip edges\n      bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));\n      this._parts = [];\n      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n        return;\n      }\n      if (this.options.noClip) {\n        this._parts = this._rings;\n        return;\n      }\n      for (var i = 0, len = this._rings.length, clipped; i < len; i++) {\n        clipped = clipPolygon(this._rings[i], bounds, true);\n        if (clipped.length) {\n          this._parts.push(clipped);\n        }\n      }\n    },\n    _updatePath: function _updatePath() {\n      this._renderer._updatePoly(this, true);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function _containsPoint(p) {\n      var inside = false,\n        part,\n        p1,\n        p2,\n        i,\n        j,\n        k,\n        len,\n        len2;\n      if (!this._pxBounds || !this._pxBounds.contains(p)) {\n        return false;\n      }\n\n      // ray casting algorithm for detecting if point is in polygon\n      for (i = 0, len = this._parts.length; i < len; i++) {\n        part = this._parts[i];\n        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n          p1 = part[j];\n          p2 = part[k];\n          if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {\n            inside = !inside;\n          }\n        }\n      }\n\n      // also check if it's on polygon stroke\n      return inside || Polyline.prototype._containsPoint.call(this, p, true);\n    }\n  });\n\n  // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)\n  function polygon(latlngs, options) {\n    return new Polygon(latlngs, options);\n  }\n\n  /*\r\n   * @class GeoJSON\r\n   * @aka L.GeoJSON\r\n   * @inherits FeatureGroup\r\n   *\r\n   * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse\r\n   * GeoJSON data and display it on the map. Extends `FeatureGroup`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.geoJSON(data, {\r\n   * \tstyle: function (feature) {\r\n   * \t\treturn {color: feature.properties.color};\r\n   * \t}\r\n   * }).bindPopup(function (layer) {\r\n   * \treturn layer.feature.properties.description;\r\n   * }).addTo(map);\r\n   * ```\r\n   */\n\n  var GeoJSON = FeatureGroup.extend({\n    /* @section\r\n     * @aka GeoJSON options\r\n     *\r\n     * @option pointToLayer: Function = *\r\n     * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally\r\n     * called when data is added, passing the GeoJSON point feature and its `LatLng`.\r\n     * The default is to spawn a default `Marker`:\r\n     * ```js\r\n     * function(geoJsonPoint, latlng) {\r\n     * \treturn L.marker(latlng);\r\n     * }\r\n     * ```\r\n     *\r\n     * @option style: Function = *\r\n     * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,\r\n     * called internally when data is added.\r\n     * The default value is to not override any defaults:\r\n     * ```js\r\n     * function (geoJsonFeature) {\r\n     * \treturn {}\r\n     * }\r\n     * ```\r\n     *\r\n     * @option onEachFeature: Function = *\r\n     * A `Function` that will be called once for each created `Feature`, after it has\r\n     * been created and styled. Useful for attaching events and popups to features.\r\n     * The default is to do nothing with the newly created layers:\r\n     * ```js\r\n     * function (feature, layer) {}\r\n     * ```\r\n     *\r\n     * @option filter: Function = *\r\n     * A `Function` that will be used to decide whether to include a feature or not.\r\n     * The default is to include all features:\r\n     * ```js\r\n     * function (geoJsonFeature) {\r\n     * \treturn true;\r\n     * }\r\n     * ```\r\n     * Note: dynamically changing the `filter` option will have effect only on newly\r\n     * added data. It will _not_ re-evaluate already included features.\r\n     *\r\n     * @option coordsToLatLng: Function = *\r\n     * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.\r\n     * The default is the `coordsToLatLng` static method.\r\n     *\r\n     * @option markersInheritOptions: Boolean = false\r\n     * Whether default Markers for \"Point\" type Features inherit from group options.\r\n     */\n\n    initialize: function initialize(geojson, options) {\n      setOptions(this, options);\n      this._layers = {};\n      if (geojson) {\n        this.addData(geojson);\n      }\n    },\n    // @method addData( <GeoJSON> data ): this\n    // Adds a GeoJSON object to the layer.\n    addData: function addData(geojson) {\n      var features = isArray(geojson) ? geojson : geojson.features,\n        i,\n        len,\n        feature;\n      if (features) {\n        for (i = 0, len = features.length; i < len; i++) {\n          // only add this if geometry or geometries are set and not null\n          feature = features[i];\n          if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\n            this.addData(feature);\n          }\n        }\n        return this;\n      }\n      var options = this.options;\n      if (options.filter && !options.filter(geojson)) {\n        return this;\n      }\n      var layer = geometryToLayer(geojson, options);\n      if (!layer) {\n        return this;\n      }\n      layer.feature = asFeature(geojson);\n      layer.defaultOptions = layer.options;\n      this.resetStyle(layer);\n      if (options.onEachFeature) {\n        options.onEachFeature(geojson, layer);\n      }\n      return this.addLayer(layer);\n    },\n    // @method resetStyle( <Path> layer? ): this\n    // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.\n    // If `layer` is omitted, the style of all features in the current layer is reset.\n    resetStyle: function resetStyle(layer) {\n      if (layer === undefined) {\n        return this.eachLayer(this.resetStyle, this);\n      }\n      // reset any custom styles\n      layer.options = extend({}, layer.defaultOptions);\n      this._setLayerStyle(layer, this.options.style);\n      return this;\n    },\n    // @method setStyle( <Function> style ): this\n    // Changes styles of GeoJSON vector layers with the given style function.\n    setStyle: function setStyle(style) {\n      return this.eachLayer(function (layer) {\n        this._setLayerStyle(layer, style);\n      }, this);\n    },\n    _setLayerStyle: function _setLayerStyle(layer, style) {\n      if (layer.setStyle) {\n        if (typeof style === 'function') {\n          style = style(layer.feature);\n        }\n        layer.setStyle(style);\n      }\n    }\n  });\n\n  // @section\n  // There are several static functions which can be called without instantiating L.GeoJSON:\n\n  // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer\n  // Creates a `Layer` from a given GeoJSON feature. Can use a custom\n  // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)\n  // functions if provided as options.\n  function geometryToLayer(geojson, options) {\n    var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\n      coords = geometry ? geometry.coordinates : null,\n      layers = [],\n      pointToLayer = options && options.pointToLayer,\n      _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,\n      latlng,\n      latlngs,\n      i,\n      len;\n    if (!coords && !geometry) {\n      return null;\n    }\n    switch (geometry.type) {\n      case 'Point':\n        latlng = _coordsToLatLng(coords);\n        return _pointToLayer(pointToLayer, geojson, latlng, options);\n      case 'MultiPoint':\n        for (i = 0, len = coords.length; i < len; i++) {\n          latlng = _coordsToLatLng(coords[i]);\n          layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));\n        }\n        return new FeatureGroup(layers);\n      case 'LineString':\n      case 'MultiLineString':\n        latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);\n        return new Polyline(latlngs, options);\n      case 'Polygon':\n      case 'MultiPolygon':\n        latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);\n        return new Polygon(latlngs, options);\n      case 'GeometryCollection':\n        for (i = 0, len = geometry.geometries.length; i < len; i++) {\n          var geoLayer = geometryToLayer({\n            geometry: geometry.geometries[i],\n            type: 'Feature',\n            properties: geojson.properties\n          }, options);\n          if (geoLayer) {\n            layers.push(geoLayer);\n          }\n        }\n        return new FeatureGroup(layers);\n      case 'FeatureCollection':\n        for (i = 0, len = geometry.features.length; i < len; i++) {\n          var featureLayer = geometryToLayer(geometry.features[i], options);\n          if (featureLayer) {\n            layers.push(featureLayer);\n          }\n        }\n        return new FeatureGroup(layers);\n      default:\n        throw new Error('Invalid GeoJSON object.');\n    }\n  }\n  function _pointToLayer(pointToLayerFn, geojson, latlng, options) {\n    return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);\n  }\n\n  // @function coordsToLatLng(coords: Array): LatLng\n  // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)\n  // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.\n  function coordsToLatLng(coords) {\n    return new LatLng(coords[1], coords[0], coords[2]);\n  }\n\n  // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array\n  // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.\n  // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).\n  // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.\n  function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {\n    var latlngs = [];\n    for (var i = 0, len = coords.length, latlng; i < len; i++) {\n      latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);\n      latlngs.push(latlng);\n    }\n    return latlngs;\n  }\n\n  // @function latLngToCoords(latlng: LatLng, precision?: Number|false): Array\n  // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.\n  function latLngToCoords(latlng, precision) {\n    latlng = toLatLng(latlng);\n    return latlng.alt !== undefined ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];\n  }\n\n  // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean, precision?: Number|false): Array\n  // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)\n  // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.\n  function latLngsToCoords(latlngs, levelsDeep, closed, precision) {\n    var coords = [];\n    for (var i = 0, len = latlngs.length; i < len; i++) {\n      // Check for flat arrays required to ensure unbalanced arrays are correctly converted in recursion\n      coords.push(levelsDeep ? latLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));\n    }\n    if (!levelsDeep && closed && coords.length > 0) {\n      coords.push(coords[0].slice());\n    }\n    return coords;\n  }\n  function getFeature(layer, newGeometry) {\n    return layer.feature ? extend({}, layer.feature, {\n      geometry: newGeometry\n    }) : asFeature(newGeometry);\n  }\n\n  // @function asFeature(geojson: Object): Object\n  // Normalize GeoJSON geometries/features into GeoJSON features.\n  function asFeature(geojson) {\n    if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {\n      return geojson;\n    }\n    return {\n      type: 'Feature',\n      properties: {},\n      geometry: geojson\n    };\n  }\n  var PointToGeoJSON = {\n    toGeoJSON: function toGeoJSON(precision) {\n      return getFeature(this, {\n        type: 'Point',\n        coordinates: latLngToCoords(this.getLatLng(), precision)\n      });\n    }\n  };\n\n  // @namespace Marker\n  // @section Other methods\n  // @method toGeoJSON(precision?: Number|false): Object\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).\n  Marker.include(PointToGeoJSON);\n\n  // @namespace CircleMarker\n  // @method toGeoJSON(precision?: Number|false): Object\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).\n  Circle.include(PointToGeoJSON);\n  CircleMarker.include(PointToGeoJSON);\n\n  // @namespace Polyline\n  // @method toGeoJSON(precision?: Number|false): Object\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).\n  Polyline.include({\n    toGeoJSON: function toGeoJSON(precision) {\n      var multi = !isFlat(this._latlngs);\n      var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);\n      return getFeature(this, {\n        type: (multi ? 'Multi' : '') + 'LineString',\n        coordinates: coords\n      });\n    }\n  });\n\n  // @namespace Polygon\n  // @method toGeoJSON(precision?: Number|false): Object\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).\n  Polygon.include({\n    toGeoJSON: function toGeoJSON(precision) {\n      var holes = !isFlat(this._latlngs),\n        multi = holes && !isFlat(this._latlngs[0]);\n      var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);\n      if (!holes) {\n        coords = [coords];\n      }\n      return getFeature(this, {\n        type: (multi ? 'Multi' : '') + 'Polygon',\n        coordinates: coords\n      });\n    }\n  });\n\n  // @namespace LayerGroup\n  LayerGroup.include({\n    toMultiPoint: function toMultiPoint(precision) {\n      var coords = [];\n      this.eachLayer(function (layer) {\n        coords.push(layer.toGeoJSON(precision).geometry.coordinates);\n      });\n      return getFeature(this, {\n        type: 'MultiPoint',\n        coordinates: coords\n      });\n    },\n    // @method toGeoJSON(precision?: Number|false): Object\n    // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n    // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).\n    toGeoJSON: function toGeoJSON(precision) {\n      var type = this.feature && this.feature.geometry && this.feature.geometry.type;\n      if (type === 'MultiPoint') {\n        return this.toMultiPoint(precision);\n      }\n      var isGeometryCollection = type === 'GeometryCollection',\n        jsons = [];\n      this.eachLayer(function (layer) {\n        if (layer.toGeoJSON) {\n          var json = layer.toGeoJSON(precision);\n          if (isGeometryCollection) {\n            jsons.push(json.geometry);\n          } else {\n            var feature = asFeature(json);\n            // Squash nested feature collections\n            if (feature.type === 'FeatureCollection') {\n              jsons.push.apply(jsons, feature.features);\n            } else {\n              jsons.push(feature);\n            }\n          }\n        }\n      });\n      if (isGeometryCollection) {\n        return getFeature(this, {\n          geometries: jsons,\n          type: 'GeometryCollection'\n        });\n      }\n      return {\n        type: 'FeatureCollection',\n        features: jsons\n      };\n    }\n  });\n\n  // @namespace GeoJSON\n  // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)\n  // Creates a GeoJSON layer. Optionally accepts an object in\n  // [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map\n  // (you can alternatively add it later with `addData` method) and an `options` object.\n  function geoJSON(geojson, options) {\n    return new GeoJSON(geojson, options);\n  }\n\n  // Backward compatibility.\n  var geoJson = geoJSON;\n\n  /*\r\n   * @class ImageOverlay\r\n   * @aka L.ImageOverlay\r\n   * @inherits Interactive layer\r\n   *\r\n   * Used to load and display a single image over specific bounds of the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var imageUrl = 'https://maps.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',\r\n   * \timageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];\r\n   * L.imageOverlay(imageUrl, imageBounds).addTo(map);\r\n   * ```\r\n   */\n\n  var ImageOverlay = Layer.extend({\n    // @section\n    // @aka ImageOverlay options\n    options: {\n      // @option opacity: Number = 1.0\n      // The opacity of the image overlay.\n      opacity: 1,\n      // @option alt: String = ''\n      // Text for the `alt` attribute of the image (useful for accessibility).\n      alt: '',\n      // @option interactive: Boolean = false\n      // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.\n      interactive: false,\n      // @option crossOrigin: Boolean|String = false\n      // Whether the crossOrigin attribute will be added to the image.\n      // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.\n      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n      crossOrigin: false,\n      // @option errorOverlayUrl: String = ''\n      // URL to the overlay image to show in place of the overlay that failed to load.\n      errorOverlayUrl: '',\n      // @option zIndex: Number = 1\n      // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.\n      zIndex: 1,\n      // @option className: String = ''\n      // A custom class name to assign to the image. Empty by default.\n      className: ''\n    },\n    initialize: function initialize(url, bounds, options) {\n      // (String, LatLngBounds, Object)\n      this._url = url;\n      this._bounds = toLatLngBounds(bounds);\n      setOptions(this, options);\n    },\n    onAdd: function onAdd() {\n      if (!this._image) {\n        this._initImage();\n        if (this.options.opacity < 1) {\n          this._updateOpacity();\n        }\n      }\n      if (this.options.interactive) {\n        addClass(this._image, 'leaflet-interactive');\n        this.addInteractiveTarget(this._image);\n      }\n      this.getPane().appendChild(this._image);\n      this._reset();\n    },\n    onRemove: function onRemove() {\n      _remove(this._image);\n      if (this.options.interactive) {\n        this.removeInteractiveTarget(this._image);\n      }\n    },\n    // @method setOpacity(opacity: Number): this\n    // Sets the opacity of the overlay.\n    setOpacity: function setOpacity(opacity) {\n      this.options.opacity = opacity;\n      if (this._image) {\n        this._updateOpacity();\n      }\n      return this;\n    },\n    setStyle: function setStyle(styleOpts) {\n      if (styleOpts.opacity) {\n        this.setOpacity(styleOpts.opacity);\n      }\n      return this;\n    },\n    // @method bringToFront(): this\n    // Brings the layer to the top of all overlays.\n    bringToFront: function bringToFront() {\n      if (this._map) {\n        toFront(this._image);\n      }\n      return this;\n    },\n    // @method bringToBack(): this\n    // Brings the layer to the bottom of all overlays.\n    bringToBack: function bringToBack() {\n      if (this._map) {\n        toBack(this._image);\n      }\n      return this;\n    },\n    // @method setUrl(url: String): this\n    // Changes the URL of the image.\n    setUrl: function setUrl(url) {\n      this._url = url;\n      if (this._image) {\n        this._image.src = url;\n      }\n      return this;\n    },\n    // @method setBounds(bounds: LatLngBounds): this\n    // Update the bounds that this ImageOverlay covers\n    setBounds: function setBounds(bounds) {\n      this._bounds = toLatLngBounds(bounds);\n      if (this._map) {\n        this._reset();\n      }\n      return this;\n    },\n    getEvents: function getEvents() {\n      var events = {\n        zoom: this._reset,\n        viewreset: this._reset\n      };\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n      return events;\n    },\n    // @method setZIndex(value: Number): this\n    // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.\n    setZIndex: function setZIndex(value) {\n      this.options.zIndex = value;\n      this._updateZIndex();\n      return this;\n    },\n    // @method getBounds(): LatLngBounds\n    // Get the bounds that this ImageOverlay covers\n    getBounds: function getBounds() {\n      return this._bounds;\n    },\n    // @method getElement(): HTMLElement\n    // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)\n    // used by this overlay.\n    getElement: function getElement() {\n      return this._image;\n    },\n    _initImage: function _initImage() {\n      var wasElementSupplied = this._url.tagName === 'IMG';\n      var img = this._image = wasElementSupplied ? this._url : create$1('img');\n      addClass(img, 'leaflet-image-layer');\n      if (this._zoomAnimated) {\n        addClass(img, 'leaflet-zoom-animated');\n      }\n      if (this.options.className) {\n        addClass(img, this.options.className);\n      }\n      img.onselectstart = falseFn;\n      img.onmousemove = falseFn;\n\n      // @event load: Event\n      // Fired when the ImageOverlay layer has loaded its image\n      img.onload = bind(this.fire, this, 'load');\n      img.onerror = bind(this._overlayOnError, this, 'error');\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n      if (this.options.zIndex) {\n        this._updateZIndex();\n      }\n      if (wasElementSupplied) {\n        this._url = img.src;\n        return;\n      }\n      img.src = this._url;\n      img.alt = this.options.alt;\n    },\n    _animateZoom: function _animateZoom(e) {\n      var scale = this._map.getZoomScale(e.zoom),\n        offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;\n      setTransform(this._image, offset, scale);\n    },\n    _reset: function _reset() {\n      var image = this._image,\n        bounds = new Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())),\n        size = bounds.getSize();\n      setPosition(image, bounds.min);\n      image.style.width = size.x + 'px';\n      image.style.height = size.y + 'px';\n    },\n    _updateOpacity: function _updateOpacity() {\n      _setOpacity(this._image, this.options.opacity);\n    },\n    _updateZIndex: function _updateZIndex() {\n      if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n        this._image.style.zIndex = this.options.zIndex;\n      }\n    },\n    _overlayOnError: function _overlayOnError() {\n      // @event error: Event\n      // Fired when the ImageOverlay layer fails to load its image\n      this.fire('error');\n      var errorUrl = this.options.errorOverlayUrl;\n      if (errorUrl && this._url !== errorUrl) {\n        this._url = errorUrl;\n        this._image.src = errorUrl;\n      }\n    },\n    // @method getCenter(): LatLng\n    // Returns the center of the ImageOverlay.\n    getCenter: function getCenter() {\n      return this._bounds.getCenter();\n    }\n  });\n\n  // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)\n  // Instantiates an image overlay object given the URL of the image and the\n  // geographical bounds it is tied to.\n  var imageOverlay = function imageOverlay(url, bounds, options) {\n    return new ImageOverlay(url, bounds, options);\n  };\n\n  /*\r\n   * @class VideoOverlay\r\n   * @aka L.VideoOverlay\r\n   * @inherits ImageOverlay\r\n   *\r\n   * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.\r\n   *\r\n   * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)\r\n   * HTML5 element.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',\r\n   * \tvideoBounds = [[ 32, -130], [ 13, -100]];\r\n   * L.videoOverlay(videoUrl, videoBounds ).addTo(map);\r\n   * ```\r\n   */\n\n  var VideoOverlay = ImageOverlay.extend({\n    // @section\n    // @aka VideoOverlay options\n    options: {\n      // @option autoplay: Boolean = true\n      // Whether the video starts playing automatically when loaded.\n      // On some browsers autoplay will only work with `muted: true`\n      autoplay: true,\n      // @option loop: Boolean = true\n      // Whether the video will loop back to the beginning when played.\n      loop: true,\n      // @option keepAspectRatio: Boolean = true\n      // Whether the video will save aspect ratio after the projection.\n      // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)\n      keepAspectRatio: true,\n      // @option muted: Boolean = false\n      // Whether the video starts on mute when loaded.\n      muted: false,\n      // @option playsInline: Boolean = true\n      // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.\n      playsInline: true\n    },\n    _initImage: function _initImage() {\n      var wasElementSupplied = this._url.tagName === 'VIDEO';\n      var vid = this._image = wasElementSupplied ? this._url : create$1('video');\n      addClass(vid, 'leaflet-image-layer');\n      if (this._zoomAnimated) {\n        addClass(vid, 'leaflet-zoom-animated');\n      }\n      if (this.options.className) {\n        addClass(vid, this.options.className);\n      }\n      vid.onselectstart = falseFn;\n      vid.onmousemove = falseFn;\n\n      // @event load: Event\n      // Fired when the video has finished loading the first frame\n      vid.onloadeddata = bind(this.fire, this, 'load');\n      if (wasElementSupplied) {\n        var sourceElements = vid.getElementsByTagName('source');\n        var sources = [];\n        for (var j = 0; j < sourceElements.length; j++) {\n          sources.push(sourceElements[j].src);\n        }\n        this._url = sourceElements.length > 0 ? sources : [vid.src];\n        return;\n      }\n      if (!isArray(this._url)) {\n        this._url = [this._url];\n      }\n      if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, 'objectFit')) {\n        vid.style['objectFit'] = 'fill';\n      }\n      vid.autoplay = !!this.options.autoplay;\n      vid.loop = !!this.options.loop;\n      vid.muted = !!this.options.muted;\n      vid.playsInline = !!this.options.playsInline;\n      for (var i = 0; i < this._url.length; i++) {\n        var source = create$1('source');\n        source.src = this._url[i];\n        vid.appendChild(source);\n      }\n    }\n\n    // @method getElement(): HTMLVideoElement\n    // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)\n    // used by this overlay.\n  });\n\n  // @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)\n  // Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the\n  // geographical bounds it is tied to.\n\n  function videoOverlay(video, bounds, options) {\n    return new VideoOverlay(video, bounds, options);\n  }\n\n  /*\n   * @class SVGOverlay\n   * @aka L.SVGOverlay\n   * @inherits ImageOverlay\n   *\n   * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.\n   *\n   * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.\n   *\n   * @example\n   *\n   * ```js\n   * var svgElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n   * svgElement.setAttribute('xmlns', \"http://www.w3.org/2000/svg\");\n   * svgElement.setAttribute('viewBox', \"0 0 200 200\");\n   * svgElement.innerHTML = '<rect width=\"200\" height=\"200\"/><rect x=\"75\" y=\"23\" width=\"50\" height=\"50\" style=\"fill:red\"/><rect x=\"75\" y=\"123\" width=\"50\" height=\"50\" style=\"fill:#0013ff\"/>';\n   * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];\n   * L.svgOverlay(svgElement, svgElementBounds).addTo(map);\n   * ```\n   */\n\n  var SVGOverlay = ImageOverlay.extend({\n    _initImage: function _initImage() {\n      var el = this._image = this._url;\n      addClass(el, 'leaflet-image-layer');\n      if (this._zoomAnimated) {\n        addClass(el, 'leaflet-zoom-animated');\n      }\n      if (this.options.className) {\n        addClass(el, this.options.className);\n      }\n      el.onselectstart = falseFn;\n      el.onmousemove = falseFn;\n    }\n\n    // @method getElement(): SVGElement\n    // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)\n    // used by this overlay.\n  });\n\n  // @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)\n  // Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.\n  // A viewBox attribute is required on the SVG element to zoom in and out properly.\n\n  function svgOverlay(el, bounds, options) {\n    return new SVGOverlay(el, bounds, options);\n  }\n\n  /*\r\n   * @class DivOverlay\r\n   * @inherits Interactive layer\r\n   * @aka L.DivOverlay\r\n   * Base model for L.Popup and L.Tooltip. Inherit from it for custom overlays like plugins.\r\n   */\n\n  // @namespace DivOverlay\n  var DivOverlay = Layer.extend({\n    // @section\n    // @aka DivOverlay options\n    options: {\n      // @option interactive: Boolean = false\n      // If true, the popup/tooltip will listen to the mouse events.\n      interactive: false,\n      // @option offset: Point = Point(0, 0)\n      // The offset of the overlay position.\n      offset: [0, 0],\n      // @option className: String = ''\n      // A custom CSS class name to assign to the overlay.\n      className: '',\n      // @option pane: String = undefined\n      // `Map pane` where the overlay will be added.\n      pane: undefined,\n      // @option content: String|HTMLElement|Function = ''\n      // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be\n      // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.\n      content: ''\n    },\n    initialize: function initialize(options, source) {\n      if (options && (options instanceof LatLng || isArray(options))) {\n        this._latlng = toLatLng(options);\n        setOptions(this, source);\n      } else {\n        setOptions(this, options);\n        this._source = source;\n      }\n      if (this.options.content) {\n        this._content = this.options.content;\n      }\n    },\n    // @method openOn(map: Map): this\n    // Adds the overlay to the map.\n    // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.\n    openOn: function openOn(map) {\n      map = arguments.length ? map : this._source._map; // experimental, not the part of public api\n      if (!map.hasLayer(this)) {\n        map.addLayer(this);\n      }\n      return this;\n    },\n    // @method close(): this\n    // Closes the overlay.\n    // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`\n    // and `layer.closePopup()`/`.closeTooltip()`.\n    close: function close() {\n      if (this._map) {\n        this._map.removeLayer(this);\n      }\n      return this;\n    },\n    // @method toggle(layer?: Layer): this\n    // Opens or closes the overlay bound to layer depending on its current state.\n    // Argument may be omitted only for overlay bound to layer.\n    // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.\n    toggle: function toggle(layer) {\n      if (this._map) {\n        this.close();\n      } else {\n        if (arguments.length) {\n          this._source = layer;\n        } else {\n          layer = this._source;\n        }\n        this._prepareOpen();\n\n        // open the overlay on the map\n        this.openOn(layer._map);\n      }\n      return this;\n    },\n    onAdd: function onAdd(map) {\n      this._zoomAnimated = map._zoomAnimated;\n      if (!this._container) {\n        this._initLayout();\n      }\n      if (map._fadeAnimated) {\n        _setOpacity(this._container, 0);\n      }\n      clearTimeout(this._removeTimeout);\n      this.getPane().appendChild(this._container);\n      this.update();\n      if (map._fadeAnimated) {\n        _setOpacity(this._container, 1);\n      }\n      this.bringToFront();\n      if (this.options.interactive) {\n        addClass(this._container, 'leaflet-interactive');\n        this.addInteractiveTarget(this._container);\n      }\n    },\n    onRemove: function onRemove(map) {\n      if (map._fadeAnimated) {\n        _setOpacity(this._container, 0);\n        this._removeTimeout = setTimeout(bind(_remove, undefined, this._container), 200);\n      } else {\n        _remove(this._container);\n      }\n      if (this.options.interactive) {\n        removeClass(this._container, 'leaflet-interactive');\n        this.removeInteractiveTarget(this._container);\n      }\n    },\n    // @namespace DivOverlay\n    // @method getLatLng: LatLng\n    // Returns the geographical point of the overlay.\n    getLatLng: function getLatLng() {\n      return this._latlng;\n    },\n    // @method setLatLng(latlng: LatLng): this\n    // Sets the geographical point where the overlay will open.\n    setLatLng: function setLatLng(latlng) {\n      this._latlng = toLatLng(latlng);\n      if (this._map) {\n        this._updatePosition();\n        this._adjustPan();\n      }\n      return this;\n    },\n    // @method getContent: String|HTMLElement\n    // Returns the content of the overlay.\n    getContent: function getContent() {\n      return this._content;\n    },\n    // @method setContent(htmlContent: String|HTMLElement|Function): this\n    // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.\n    // The function should return a `String` or `HTMLElement` to be used in the overlay.\n    setContent: function setContent(content) {\n      this._content = content;\n      this.update();\n      return this;\n    },\n    // @method getElement: String|HTMLElement\n    // Returns the HTML container of the overlay.\n    getElement: function getElement() {\n      return this._container;\n    },\n    // @method update: null\n    // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.\n    update: function update() {\n      if (!this._map) {\n        return;\n      }\n      this._container.style.visibility = 'hidden';\n      this._updateContent();\n      this._updateLayout();\n      this._updatePosition();\n      this._container.style.visibility = '';\n      this._adjustPan();\n    },\n    getEvents: function getEvents() {\n      var events = {\n        zoom: this._updatePosition,\n        viewreset: this._updatePosition\n      };\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n      return events;\n    },\n    // @method isOpen: Boolean\n    // Returns `true` when the overlay is visible on the map.\n    isOpen: function isOpen() {\n      return !!this._map && this._map.hasLayer(this);\n    },\n    // @method bringToFront: this\n    // Brings this overlay in front of other overlays (in the same map pane).\n    bringToFront: function bringToFront() {\n      if (this._map) {\n        toFront(this._container);\n      }\n      return this;\n    },\n    // @method bringToBack: this\n    // Brings this overlay to the back of other overlays (in the same map pane).\n    bringToBack: function bringToBack() {\n      if (this._map) {\n        toBack(this._container);\n      }\n      return this;\n    },\n    // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)\n    _prepareOpen: function _prepareOpen(latlng) {\n      var source = this._source;\n      if (!source._map) {\n        return false;\n      }\n      if (source instanceof FeatureGroup) {\n        source = null;\n        var layers = this._source._layers;\n        for (var id in layers) {\n          if (layers[id]._map) {\n            source = layers[id];\n            break;\n          }\n        }\n        if (!source) {\n          return false;\n        } // Unable to get source layer.\n\n        // set overlay source to this layer\n        this._source = source;\n      }\n      if (!latlng) {\n        if (source.getCenter) {\n          latlng = source.getCenter();\n        } else if (source.getLatLng) {\n          latlng = source.getLatLng();\n        } else if (source.getBounds) {\n          latlng = source.getBounds().getCenter();\n        } else {\n          throw new Error('Unable to get source layer LatLng.');\n        }\n      }\n      this.setLatLng(latlng);\n      if (this._map) {\n        // update the overlay (content, layout, etc...)\n        this.update();\n      }\n      return true;\n    },\n    _updateContent: function _updateContent() {\n      if (!this._content) {\n        return;\n      }\n      var node = this._contentNode;\n      var content = typeof this._content === 'function' ? this._content(this._source || this) : this._content;\n      if (typeof content === 'string') {\n        node.innerHTML = content;\n      } else {\n        while (node.hasChildNodes()) {\n          node.removeChild(node.firstChild);\n        }\n        node.appendChild(content);\n      }\n\n      // @namespace DivOverlay\n      // @section DivOverlay events\n      // @event contentupdate: Event\n      // Fired when the content of the overlay is updated\n      this.fire('contentupdate');\n    },\n    _updatePosition: function _updatePosition() {\n      if (!this._map) {\n        return;\n      }\n      var pos = this._map.latLngToLayerPoint(this._latlng),\n        offset = toPoint(this.options.offset),\n        anchor = this._getAnchor();\n      if (this._zoomAnimated) {\n        setPosition(this._container, pos.add(anchor));\n      } else {\n        offset = offset.add(pos).add(anchor);\n      }\n      var bottom = this._containerBottom = -offset.y,\n        left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;\n\n      // bottom position the overlay in case the height of the overlay changes (images loading etc)\n      this._container.style.bottom = bottom + 'px';\n      this._container.style.left = left + 'px';\n    },\n    _getAnchor: function _getAnchor() {\n      return [0, 0];\n    }\n  });\n  Map.include({\n    _initOverlay: function _initOverlay(OverlayClass, content, latlng, options) {\n      var overlay = content;\n      if (!(overlay instanceof OverlayClass)) {\n        overlay = new OverlayClass(options).setContent(content);\n      }\n      if (latlng) {\n        overlay.setLatLng(latlng);\n      }\n      return overlay;\n    }\n  });\n  Layer.include({\n    _initOverlay: function _initOverlay(OverlayClass, old, content, options) {\n      var overlay = content;\n      if (overlay instanceof OverlayClass) {\n        setOptions(overlay, options);\n        overlay._source = this;\n      } else {\n        overlay = old && !options ? old : new OverlayClass(options, this);\n        overlay.setContent(content);\n      }\n      return overlay;\n    }\n  });\n\n  /*\r\n   * @class Popup\r\n   * @inherits DivOverlay\r\n   * @aka L.Popup\r\n   * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to\r\n   * open popups while making sure that only one popup is open at one time\r\n   * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.\r\n   *\r\n   * @example\r\n   *\r\n   * If you want to just bind a popup to marker click and then open it, it's really easy:\r\n   *\r\n   * ```js\r\n   * marker.bindPopup(popupContent).openPopup();\r\n   * ```\r\n   * Path overlays like polylines also have a `bindPopup` method.\r\n   *\r\n   * A popup can be also standalone:\r\n   *\r\n   * ```js\r\n   * var popup = L.popup()\r\n   * \t.setLatLng(latlng)\r\n   * \t.setContent('<p>Hello world!<br />This is a nice popup.</p>')\r\n   * \t.openOn(map);\r\n   * ```\r\n   * or\r\n   * ```js\r\n   * var popup = L.popup(latlng, {content: '<p>Hello world!<br />This is a nice popup.</p>')\r\n   * \t.openOn(map);\r\n   * ```\r\n   */\n\n  // @namespace Popup\n  var Popup = DivOverlay.extend({\n    // @section\n    // @aka Popup options\n    options: {\n      // @option pane: String = 'popupPane'\n      // `Map pane` where the popup will be added.\n      pane: 'popupPane',\n      // @option offset: Point = Point(0, 7)\n      // The offset of the popup position.\n      offset: [0, 7],\n      // @option maxWidth: Number = 300\n      // Max width of the popup, in pixels.\n      maxWidth: 300,\n      // @option minWidth: Number = 50\n      // Min width of the popup, in pixels.\n      minWidth: 50,\n      // @option maxHeight: Number = null\n      // If set, creates a scrollable container of the given height\n      // inside a popup if its content exceeds it.\n      // The scrollable container can be styled using the\n      // `leaflet-popup-scrolled` CSS class selector.\n      maxHeight: null,\n      // @option autoPan: Boolean = true\n      // Set it to `false` if you don't want the map to do panning animation\n      // to fit the opened popup.\n      autoPan: true,\n      // @option autoPanPaddingTopLeft: Point = null\n      // The margin between the popup and the top left corner of the map\n      // view after autopanning was performed.\n      autoPanPaddingTopLeft: null,\n      // @option autoPanPaddingBottomRight: Point = null\n      // The margin between the popup and the bottom right corner of the map\n      // view after autopanning was performed.\n      autoPanPaddingBottomRight: null,\n      // @option autoPanPadding: Point = Point(5, 5)\n      // Equivalent of setting both top left and bottom right autopan padding to the same value.\n      autoPanPadding: [5, 5],\n      // @option keepInView: Boolean = false\n      // Set it to `true` if you want to prevent users from panning the popup\n      // off of the screen while it is open.\n      keepInView: false,\n      // @option closeButton: Boolean = true\n      // Controls the presence of a close button in the popup.\n      closeButton: true,\n      // @option autoClose: Boolean = true\n      // Set it to `false` if you want to override the default behavior of\n      // the popup closing when another popup is opened.\n      autoClose: true,\n      // @option closeOnEscapeKey: Boolean = true\n      // Set it to `false` if you want to override the default behavior of\n      // the ESC key for closing of the popup.\n      closeOnEscapeKey: true,\n      // @option closeOnClick: Boolean = *\n      // Set it if you want to override the default behavior of the popup closing when user clicks\n      // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.\n\n      // @option className: String = ''\n      // A custom CSS class name to assign to the popup.\n      className: ''\n    },\n    // @namespace Popup\n    // @method openOn(map: Map): this\n    // Alternative to `map.openPopup(popup)`.\n    // Adds the popup to the map and closes the previous one.\n    openOn: function openOn(map) {\n      map = arguments.length ? map : this._source._map; // experimental, not the part of public api\n\n      if (!map.hasLayer(this) && map._popup && map._popup.options.autoClose) {\n        map.removeLayer(map._popup);\n      }\n      map._popup = this;\n      return DivOverlay.prototype.openOn.call(this, map);\n    },\n    onAdd: function onAdd(map) {\n      DivOverlay.prototype.onAdd.call(this, map);\n\n      // @namespace Map\n      // @section Popup events\n      // @event popupopen: PopupEvent\n      // Fired when a popup is opened in the map\n      map.fire('popupopen', {\n        popup: this\n      });\n      if (this._source) {\n        // @namespace Layer\n        // @section Popup events\n        // @event popupopen: PopupEvent\n        // Fired when a popup bound to this layer is opened\n        this._source.fire('popupopen', {\n          popup: this\n        }, true);\n        // For non-path layers, we toggle the popup when clicking\n        // again the layer, so prevent the map to reopen it.\n        if (!(this._source instanceof Path)) {\n          this._source.on('preclick', stopPropagation);\n        }\n      }\n    },\n    onRemove: function onRemove(map) {\n      DivOverlay.prototype.onRemove.call(this, map);\n\n      // @namespace Map\n      // @section Popup events\n      // @event popupclose: PopupEvent\n      // Fired when a popup in the map is closed\n      map.fire('popupclose', {\n        popup: this\n      });\n      if (this._source) {\n        // @namespace Layer\n        // @section Popup events\n        // @event popupclose: PopupEvent\n        // Fired when a popup bound to this layer is closed\n        this._source.fire('popupclose', {\n          popup: this\n        }, true);\n        if (!(this._source instanceof Path)) {\n          this._source.off('preclick', stopPropagation);\n        }\n      }\n    },\n    getEvents: function getEvents() {\n      var events = DivOverlay.prototype.getEvents.call(this);\n      if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\n        events.preclick = this.close;\n      }\n      if (this.options.keepInView) {\n        events.moveend = this._adjustPan;\n      }\n      return events;\n    },\n    _initLayout: function _initLayout() {\n      var prefix = 'leaflet-popup',\n        container = this._container = create$1('div', prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-animated');\n      var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);\n      this._contentNode = create$1('div', prefix + '-content', wrapper);\n      disableClickPropagation(container);\n      disableScrollPropagation(this._contentNode);\n      on(container, 'contextmenu', stopPropagation);\n      this._tipContainer = create$1('div', prefix + '-tip-container', container);\n      this._tip = create$1('div', prefix + '-tip', this._tipContainer);\n      if (this.options.closeButton) {\n        var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);\n        closeButton.setAttribute('role', 'button'); // overrides the implicit role=link of <a> elements #7399\n        closeButton.setAttribute('aria-label', 'Close popup');\n        closeButton.href = '#close';\n        closeButton.innerHTML = '<span aria-hidden=\"true\">&#215;</span>';\n        on(closeButton, 'click', function (ev) {\n          preventDefault(ev);\n          this.close();\n        }, this);\n      }\n    },\n    _updateLayout: function _updateLayout() {\n      var container = this._contentNode,\n        style = container.style;\n      style.width = '';\n      style.whiteSpace = 'nowrap';\n      var width = container.offsetWidth;\n      width = Math.min(width, this.options.maxWidth);\n      width = Math.max(width, this.options.minWidth);\n      style.width = width + 1 + 'px';\n      style.whiteSpace = '';\n      style.height = '';\n      var height = container.offsetHeight,\n        maxHeight = this.options.maxHeight,\n        scrolledClass = 'leaflet-popup-scrolled';\n      if (maxHeight && height > maxHeight) {\n        style.height = maxHeight + 'px';\n        addClass(container, scrolledClass);\n      } else {\n        removeClass(container, scrolledClass);\n      }\n      this._containerWidth = this._container.offsetWidth;\n    },\n    _animateZoom: function _animateZoom(e) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),\n        anchor = this._getAnchor();\n      setPosition(this._container, pos.add(anchor));\n    },\n    _adjustPan: function _adjustPan() {\n      if (!this.options.autoPan) {\n        return;\n      }\n      if (this._map._panAnim) {\n        this._map._panAnim.stop();\n      }\n\n      // We can endlessly recurse if keepInView is set and the view resets.\n      // Let's guard against that by exiting early if we're responding to our own autopan.\n      if (this._autopanning) {\n        this._autopanning = false;\n        return;\n      }\n      var map = this._map,\n        marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,\n        containerHeight = this._container.offsetHeight + marginBottom,\n        containerWidth = this._containerWidth,\n        layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);\n      layerPos._add(getPosition(this._container));\n      var containerPos = map.layerPointToContainerPoint(layerPos),\n        padding = toPoint(this.options.autoPanPadding),\n        paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),\n        paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),\n        size = map.getSize(),\n        dx = 0,\n        dy = 0;\n      if (containerPos.x + containerWidth + paddingBR.x > size.x) {\n        // right\n        dx = containerPos.x + containerWidth - size.x + paddingBR.x;\n      }\n      if (containerPos.x - dx - paddingTL.x < 0) {\n        // left\n        dx = containerPos.x - paddingTL.x;\n      }\n      if (containerPos.y + containerHeight + paddingBR.y > size.y) {\n        // bottom\n        dy = containerPos.y + containerHeight - size.y + paddingBR.y;\n      }\n      if (containerPos.y - dy - paddingTL.y < 0) {\n        // top\n        dy = containerPos.y - paddingTL.y;\n      }\n\n      // @namespace Map\n      // @section Popup events\n      // @event autopanstart: Event\n      // Fired when the map starts autopanning when opening a popup.\n      if (dx || dy) {\n        // Track that we're autopanning, as this function will be re-ran on moveend\n        if (this.options.keepInView) {\n          this._autopanning = true;\n        }\n        map.fire('autopanstart').panBy([dx, dy]);\n      }\n    },\n    _getAnchor: function _getAnchor() {\n      // Where should we anchor the popup on the source layer?\n      return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);\n    }\n  });\n\n  // @namespace Popup\n  // @factory L.popup(options?: Popup options, source?: Layer)\n  // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.\n  // @alternative\n  // @factory L.popup(latlng: LatLng, options?: Popup options)\n  // Instantiates a `Popup` object given `latlng` where the popup will open and an optional `options` object that describes its appearance and location.\n  var popup = function popup(options, source) {\n    return new Popup(options, source);\n  };\n\n  /* @namespace Map\r\n   * @section Interaction Options\r\n   * @option closePopupOnClick: Boolean = true\r\n   * Set it to `false` if you don't want popups to close when user clicks the map.\r\n   */\n  Map.mergeOptions({\n    closePopupOnClick: true\n  });\n\n  // @namespace Map\n  // @section Methods for Layers and Controls\n  Map.include({\n    // @method openPopup(popup: Popup): this\n    // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).\n    // @alternative\n    // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this\n    // Creates a popup with the specified content and options and opens it in the given point on a map.\n    openPopup: function openPopup(popup, latlng, options) {\n      this._initOverlay(Popup, popup, latlng, options).openOn(this);\n      return this;\n    },\n    // @method closePopup(popup?: Popup): this\n    // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).\n    closePopup: function closePopup(popup) {\n      popup = arguments.length ? popup : this._popup;\n      if (popup) {\n        popup.close();\n      }\n      return this;\n    }\n  });\n\n  /*\r\n   * @namespace Layer\r\n   * @section Popup methods example\r\n   *\r\n   * All layers share a set of methods convenient for binding popups to it.\r\n   *\r\n   * ```js\r\n   * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);\r\n   * layer.openPopup();\r\n   * layer.closePopup();\r\n   * ```\r\n   *\r\n   * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.\r\n   */\n\n  // @section Popup methods\n  Layer.include({\n    // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this\n    // Binds a popup to the layer with the passed `content` and sets up the\n    // necessary event listeners. If a `Function` is passed it will receive\n    // the layer as the first argument and should return a `String` or `HTMLElement`.\n    bindPopup: function bindPopup(content, options) {\n      this._popup = this._initOverlay(Popup, this._popup, content, options);\n      if (!this._popupHandlersAdded) {\n        this.on({\n          click: this._openPopup,\n          keypress: this._onKeyPress,\n          remove: this.closePopup,\n          move: this._movePopup\n        });\n        this._popupHandlersAdded = true;\n      }\n      return this;\n    },\n    // @method unbindPopup(): this\n    // Removes the popup previously bound with `bindPopup`.\n    unbindPopup: function unbindPopup() {\n      if (this._popup) {\n        this.off({\n          click: this._openPopup,\n          keypress: this._onKeyPress,\n          remove: this.closePopup,\n          move: this._movePopup\n        });\n        this._popupHandlersAdded = false;\n        this._popup = null;\n      }\n      return this;\n    },\n    // @method openPopup(latlng?: LatLng): this\n    // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.\n    openPopup: function openPopup(latlng) {\n      if (this._popup) {\n        if (!(this instanceof FeatureGroup)) {\n          this._popup._source = this;\n        }\n        if (this._popup._prepareOpen(latlng || this._latlng)) {\n          // open the popup on the map\n          this._popup.openOn(this._map);\n        }\n      }\n      return this;\n    },\n    // @method closePopup(): this\n    // Closes the popup bound to this layer if it is open.\n    closePopup: function closePopup() {\n      if (this._popup) {\n        this._popup.close();\n      }\n      return this;\n    },\n    // @method togglePopup(): this\n    // Opens or closes the popup bound to this layer depending on its current state.\n    togglePopup: function togglePopup() {\n      if (this._popup) {\n        this._popup.toggle(this);\n      }\n      return this;\n    },\n    // @method isPopupOpen(): boolean\n    // Returns `true` if the popup bound to this layer is currently open.\n    isPopupOpen: function isPopupOpen() {\n      return this._popup ? this._popup.isOpen() : false;\n    },\n    // @method setPopupContent(content: String|HTMLElement|Popup): this\n    // Sets the content of the popup bound to this layer.\n    setPopupContent: function setPopupContent(content) {\n      if (this._popup) {\n        this._popup.setContent(content);\n      }\n      return this;\n    },\n    // @method getPopup(): Popup\n    // Returns the popup bound to this layer.\n    getPopup: function getPopup() {\n      return this._popup;\n    },\n    _openPopup: function _openPopup(e) {\n      if (!this._popup || !this._map) {\n        return;\n      }\n      // prevent map click\n      stop(e);\n      var target = e.layer || e.target;\n      if (this._popup._source === target && !(target instanceof Path)) {\n        // treat it like a marker and figure out\n        // if we should toggle it open/closed\n        if (this._map.hasLayer(this._popup)) {\n          this.closePopup();\n        } else {\n          this.openPopup(e.latlng);\n        }\n        return;\n      }\n      this._popup._source = target;\n      this.openPopup(e.latlng);\n    },\n    _movePopup: function _movePopup(e) {\n      this._popup.setLatLng(e.latlng);\n    },\n    _onKeyPress: function _onKeyPress(e) {\n      if (e.originalEvent.keyCode === 13) {\n        this._openPopup(e);\n      }\n    }\n  });\n\n  /*\n   * @class Tooltip\n   * @inherits DivOverlay\n   * @aka L.Tooltip\n   * Used to display small texts on top of map layers.\n   *\n   * @example\n   * If you want to just bind a tooltip to marker:\n   *\n   * ```js\n   * marker.bindTooltip(\"my tooltip text\").openTooltip();\n   * ```\n   * Path overlays like polylines also have a `bindTooltip` method.\n   *\n   * A tooltip can be also standalone:\n   *\n   * ```js\n   * var tooltip = L.tooltip()\n   * \t.setLatLng(latlng)\n   * \t.setContent('Hello world!<br />This is a nice tooltip.')\n   * \t.addTo(map);\n   * ```\n   * or\n   * ```js\n   * var tooltip = L.tooltip(latlng, {content: 'Hello world!<br />This is a nice tooltip.'})\n   * \t.addTo(map);\n   * ```\n   *\n   *\n   * Note about tooltip offset. Leaflet takes two options in consideration\n   * for computing tooltip offsetting:\n   * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.\n   *   Add a positive x offset to move the tooltip to the right, and a positive y offset to\n   *   move it to the bottom. Negatives will move to the left and top.\n   * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You\n   *   should adapt this value if you use a custom icon.\n   */\n\n  // @namespace Tooltip\n  var Tooltip = DivOverlay.extend({\n    // @section\n    // @aka Tooltip options\n    options: {\n      // @option pane: String = 'tooltipPane'\n      // `Map pane` where the tooltip will be added.\n      pane: 'tooltipPane',\n      // @option offset: Point = Point(0, 0)\n      // Optional offset of the tooltip position.\n      offset: [0, 0],\n      // @option direction: String = 'auto'\n      // Direction where to open the tooltip. Possible values are: `right`, `left`,\n      // `top`, `bottom`, `center`, `auto`.\n      // `auto` will dynamically switch between `right` and `left` according to the tooltip\n      // position on the map.\n      direction: 'auto',\n      // @option permanent: Boolean = false\n      // Whether to open the tooltip permanently or only on mouseover.\n      permanent: false,\n      // @option sticky: Boolean = false\n      // If true, the tooltip will follow the mouse instead of being fixed at the feature center.\n      sticky: false,\n      // @option opacity: Number = 0.9\n      // Tooltip container opacity.\n      opacity: 0.9\n    },\n    onAdd: function onAdd(map) {\n      DivOverlay.prototype.onAdd.call(this, map);\n      this.setOpacity(this.options.opacity);\n\n      // @namespace Map\n      // @section Tooltip events\n      // @event tooltipopen: TooltipEvent\n      // Fired when a tooltip is opened in the map.\n      map.fire('tooltipopen', {\n        tooltip: this\n      });\n      if (this._source) {\n        this.addEventParent(this._source);\n\n        // @namespace Layer\n        // @section Tooltip events\n        // @event tooltipopen: TooltipEvent\n        // Fired when a tooltip bound to this layer is opened.\n        this._source.fire('tooltipopen', {\n          tooltip: this\n        }, true);\n      }\n    },\n    onRemove: function onRemove(map) {\n      DivOverlay.prototype.onRemove.call(this, map);\n\n      // @namespace Map\n      // @section Tooltip events\n      // @event tooltipclose: TooltipEvent\n      // Fired when a tooltip in the map is closed.\n      map.fire('tooltipclose', {\n        tooltip: this\n      });\n      if (this._source) {\n        this.removeEventParent(this._source);\n\n        // @namespace Layer\n        // @section Tooltip events\n        // @event tooltipclose: TooltipEvent\n        // Fired when a tooltip bound to this layer is closed.\n        this._source.fire('tooltipclose', {\n          tooltip: this\n        }, true);\n      }\n    },\n    getEvents: function getEvents() {\n      var events = DivOverlay.prototype.getEvents.call(this);\n      if (!this.options.permanent) {\n        events.preclick = this.close;\n      }\n      return events;\n    },\n    _initLayout: function _initLayout() {\n      var prefix = 'leaflet-tooltip',\n        className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\n      this._contentNode = this._container = create$1('div', className);\n      this._container.setAttribute('role', 'tooltip');\n      this._container.setAttribute('id', 'leaflet-tooltip-' + stamp(this));\n    },\n    _updateLayout: function _updateLayout() {},\n    _adjustPan: function _adjustPan() {},\n    _setPosition: function _setPosition(pos) {\n      var subX,\n        subY,\n        map = this._map,\n        container = this._container,\n        centerPoint = map.latLngToContainerPoint(map.getCenter()),\n        tooltipPoint = map.layerPointToContainerPoint(pos),\n        direction = this.options.direction,\n        tooltipWidth = container.offsetWidth,\n        tooltipHeight = container.offsetHeight,\n        offset = toPoint(this.options.offset),\n        anchor = this._getAnchor();\n      if (direction === 'top') {\n        subX = tooltipWidth / 2;\n        subY = tooltipHeight;\n      } else if (direction === 'bottom') {\n        subX = tooltipWidth / 2;\n        subY = 0;\n      } else if (direction === 'center') {\n        subX = tooltipWidth / 2;\n        subY = tooltipHeight / 2;\n      } else if (direction === 'right') {\n        subX = 0;\n        subY = tooltipHeight / 2;\n      } else if (direction === 'left') {\n        subX = tooltipWidth;\n        subY = tooltipHeight / 2;\n      } else if (tooltipPoint.x < centerPoint.x) {\n        direction = 'right';\n        subX = 0;\n        subY = tooltipHeight / 2;\n      } else {\n        direction = 'left';\n        subX = tooltipWidth + (offset.x + anchor.x) * 2;\n        subY = tooltipHeight / 2;\n      }\n      pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);\n      removeClass(container, 'leaflet-tooltip-right');\n      removeClass(container, 'leaflet-tooltip-left');\n      removeClass(container, 'leaflet-tooltip-top');\n      removeClass(container, 'leaflet-tooltip-bottom');\n      addClass(container, 'leaflet-tooltip-' + direction);\n      setPosition(container, pos);\n    },\n    _updatePosition: function _updatePosition() {\n      var pos = this._map.latLngToLayerPoint(this._latlng);\n      this._setPosition(pos);\n    },\n    setOpacity: function setOpacity(opacity) {\n      this.options.opacity = opacity;\n      if (this._container) {\n        _setOpacity(this._container, opacity);\n      }\n    },\n    _animateZoom: function _animateZoom(e) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);\n      this._setPosition(pos);\n    },\n    _getAnchor: function _getAnchor() {\n      // Where should we anchor the tooltip on the source layer?\n      return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);\n    }\n  });\n\n  // @namespace Tooltip\n  // @factory L.tooltip(options?: Tooltip options, source?: Layer)\n  // Instantiates a `Tooltip` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.\n  // @alternative\n  // @factory L.tooltip(latlng: LatLng, options?: Tooltip options)\n  // Instantiates a `Tooltip` object given `latlng` where the tooltip will open and an optional `options` object that describes its appearance and location.\n  var tooltip = function tooltip(options, source) {\n    return new Tooltip(options, source);\n  };\n\n  // @namespace Map\n  // @section Methods for Layers and Controls\n  Map.include({\n    // @method openTooltip(tooltip: Tooltip): this\n    // Opens the specified tooltip.\n    // @alternative\n    // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this\n    // Creates a tooltip with the specified content and options and open it.\n    openTooltip: function openTooltip(tooltip, latlng, options) {\n      this._initOverlay(Tooltip, tooltip, latlng, options).openOn(this);\n      return this;\n    },\n    // @method closeTooltip(tooltip: Tooltip): this\n    // Closes the tooltip given as parameter.\n    closeTooltip: function closeTooltip(tooltip) {\n      tooltip.close();\n      return this;\n    }\n  });\n\n  /*\n   * @namespace Layer\n   * @section Tooltip methods example\n   *\n   * All layers share a set of methods convenient for binding tooltips to it.\n   *\n   * ```js\n   * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);\n   * layer.openTooltip();\n   * layer.closeTooltip();\n   * ```\n   */\n\n  // @section Tooltip methods\n  Layer.include({\n    // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this\n    // Binds a tooltip to the layer with the passed `content` and sets up the\n    // necessary event listeners. If a `Function` is passed it will receive\n    // the layer as the first argument and should return a `String` or `HTMLElement`.\n    bindTooltip: function bindTooltip(content, options) {\n      if (this._tooltip && this.isTooltipOpen()) {\n        this.unbindTooltip();\n      }\n      this._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);\n      this._initTooltipInteractions();\n      if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {\n        this.openTooltip();\n      }\n      return this;\n    },\n    // @method unbindTooltip(): this\n    // Removes the tooltip previously bound with `bindTooltip`.\n    unbindTooltip: function unbindTooltip() {\n      if (this._tooltip) {\n        this._initTooltipInteractions(true);\n        this.closeTooltip();\n        this._tooltip = null;\n      }\n      return this;\n    },\n    _initTooltipInteractions: function _initTooltipInteractions(remove) {\n      if (!remove && this._tooltipHandlersAdded) {\n        return;\n      }\n      var onOff = remove ? 'off' : 'on',\n        events = {\n          remove: this.closeTooltip,\n          move: this._moveTooltip\n        };\n      if (!this._tooltip.options.permanent) {\n        events.mouseover = this._openTooltip;\n        events.mouseout = this.closeTooltip;\n        events.click = this._openTooltip;\n        if (this._map) {\n          this._addFocusListeners();\n        } else {\n          events.add = this._addFocusListeners;\n        }\n      } else {\n        events.add = this._openTooltip;\n      }\n      if (this._tooltip.options.sticky) {\n        events.mousemove = this._moveTooltip;\n      }\n      this[onOff](events);\n      this._tooltipHandlersAdded = !remove;\n    },\n    // @method openTooltip(latlng?: LatLng): this\n    // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.\n    openTooltip: function openTooltip(latlng) {\n      if (this._tooltip) {\n        if (!(this instanceof FeatureGroup)) {\n          this._tooltip._source = this;\n        }\n        if (this._tooltip._prepareOpen(latlng)) {\n          // open the tooltip on the map\n          this._tooltip.openOn(this._map);\n          if (this.getElement) {\n            this._setAriaDescribedByOnLayer(this);\n          } else if (this.eachLayer) {\n            this.eachLayer(this._setAriaDescribedByOnLayer, this);\n          }\n        }\n      }\n      return this;\n    },\n    // @method closeTooltip(): this\n    // Closes the tooltip bound to this layer if it is open.\n    closeTooltip: function closeTooltip() {\n      if (this._tooltip) {\n        return this._tooltip.close();\n      }\n    },\n    // @method toggleTooltip(): this\n    // Opens or closes the tooltip bound to this layer depending on its current state.\n    toggleTooltip: function toggleTooltip() {\n      if (this._tooltip) {\n        this._tooltip.toggle(this);\n      }\n      return this;\n    },\n    // @method isTooltipOpen(): boolean\n    // Returns `true` if the tooltip bound to this layer is currently open.\n    isTooltipOpen: function isTooltipOpen() {\n      return this._tooltip.isOpen();\n    },\n    // @method setTooltipContent(content: String|HTMLElement|Tooltip): this\n    // Sets the content of the tooltip bound to this layer.\n    setTooltipContent: function setTooltipContent(content) {\n      if (this._tooltip) {\n        this._tooltip.setContent(content);\n      }\n      return this;\n    },\n    // @method getTooltip(): Tooltip\n    // Returns the tooltip bound to this layer.\n    getTooltip: function getTooltip() {\n      return this._tooltip;\n    },\n    _addFocusListeners: function _addFocusListeners() {\n      if (this.getElement) {\n        this._addFocusListenersOnLayer(this);\n      } else if (this.eachLayer) {\n        this.eachLayer(this._addFocusListenersOnLayer, this);\n      }\n    },\n    _addFocusListenersOnLayer: function _addFocusListenersOnLayer(layer) {\n      var el = typeof layer.getElement === 'function' && layer.getElement();\n      if (el) {\n        on(el, 'focus', function () {\n          this._tooltip._source = layer;\n          this.openTooltip();\n        }, this);\n        on(el, 'blur', this.closeTooltip, this);\n      }\n    },\n    _setAriaDescribedByOnLayer: function _setAriaDescribedByOnLayer(layer) {\n      var el = typeof layer.getElement === 'function' && layer.getElement();\n      if (el) {\n        el.setAttribute('aria-describedby', this._tooltip._container.id);\n      }\n    },\n    _openTooltip: function _openTooltip(e) {\n      if (!this._tooltip || !this._map) {\n        return;\n      }\n\n      // If the map is moving, we will show the tooltip after it's done.\n      if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {\n        this._openOnceFlag = true;\n        var that = this;\n        this._map.once('moveend', function () {\n          that._openOnceFlag = false;\n          that._openTooltip(e);\n        });\n        return;\n      }\n      this._tooltip._source = e.layer || e.target;\n      this.openTooltip(this._tooltip.options.sticky ? e.latlng : undefined);\n    },\n    _moveTooltip: function _moveTooltip(e) {\n      var latlng = e.latlng,\n        containerPoint,\n        layerPoint;\n      if (this._tooltip.options.sticky && e.originalEvent) {\n        containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);\n        layerPoint = this._map.containerPointToLayerPoint(containerPoint);\n        latlng = this._map.layerPointToLatLng(layerPoint);\n      }\n      this._tooltip.setLatLng(latlng);\n    }\n  });\n\n  /*\n   * @class DivIcon\n   * @aka L.DivIcon\n   * @inherits Icon\n   *\n   * Represents a lightweight icon for markers that uses a simple `<div>`\n   * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.\n   *\n   * @example\n   * ```js\n   * var myIcon = L.divIcon({className: 'my-div-icon'});\n   * // you can set .my-div-icon styles in CSS\n   *\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\n   * ```\n   *\n   * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.\n   */\n\n  var DivIcon = Icon.extend({\n    options: {\n      // @section\n      // @aka DivIcon options\n      iconSize: [12, 12],\n      // also can be set through CSS\n\n      // iconAnchor: (Point),\n      // popupAnchor: (Point),\n\n      // @option html: String|HTMLElement = ''\n      // Custom HTML code to put inside the div element, empty by default. Alternatively,\n      // an instance of `HTMLElement`.\n      html: false,\n      // @option bgPos: Point = [0, 0]\n      // Optional relative position of the background, in pixels\n      bgPos: null,\n      className: 'leaflet-div-icon'\n    },\n    createIcon: function createIcon(oldIcon) {\n      var div = oldIcon && oldIcon.tagName === 'DIV' ? oldIcon : document.createElement('div'),\n        options = this.options;\n      if (options.html instanceof Element) {\n        empty(div);\n        div.appendChild(options.html);\n      } else {\n        div.innerHTML = options.html !== false ? options.html : '';\n      }\n      if (options.bgPos) {\n        var bgPos = toPoint(options.bgPos);\n        div.style.backgroundPosition = -bgPos.x + 'px ' + -bgPos.y + 'px';\n      }\n      this._setIconStyles(div, 'icon');\n      return div;\n    },\n    createShadow: function createShadow() {\n      return null;\n    }\n  });\n\n  // @factory L.divIcon(options: DivIcon options)\n  // Creates a `DivIcon` instance with the given options.\n  function divIcon(options) {\n    return new DivIcon(options);\n  }\n  Icon.Default = IconDefault;\n\n  /*\n   * @class GridLayer\n   * @inherits Layer\n   * @aka L.GridLayer\n   *\n   * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.\n   * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.\n   *\n   *\n   * @section Synchronous usage\n   * @example\n   *\n   * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords){\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z\n   *         var ctx = tile.getContext('2d');\n   *\n   *         // return the tile so it can be rendered on screen\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section Asynchronous usage\n   * @example\n   *\n   * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords, done){\n   *         var error;\n   *\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // draw something asynchronously and pass the tile to the done() callback\n   *         setTimeout(function() {\n   *             done(error, tile);\n   *         }, 1000);\n   *\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section\n   */\n\n  var GridLayer = Layer.extend({\n    // @section\n    // @aka GridLayer options\n    options: {\n      // @option tileSize: Number|Point = 256\n      // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.\n      tileSize: 256,\n      // @option opacity: Number = 1.0\n      // Opacity of the tiles. Can be used in the `createTile()` function.\n      opacity: 1,\n      // @option updateWhenIdle: Boolean = (depends)\n      // Load new tiles only when panning ends.\n      // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.\n      // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the\n      // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.\n      updateWhenIdle: Browser.mobile,\n      // @option updateWhenZooming: Boolean = true\n      // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.\n      updateWhenZooming: true,\n      // @option updateInterval: Number = 200\n      // Tiles will not update more than once every `updateInterval` milliseconds when panning.\n      updateInterval: 200,\n      // @option zIndex: Number = 1\n      // The explicit zIndex of the tile layer.\n      zIndex: 1,\n      // @option bounds: LatLngBounds = undefined\n      // If set, tiles will only be loaded inside the set `LatLngBounds`.\n      bounds: null,\n      // @option minZoom: Number = 0\n      // The minimum zoom level down to which this layer will be displayed (inclusive).\n      minZoom: 0,\n      // @option maxZoom: Number = undefined\n      // The maximum zoom level up to which this layer will be displayed (inclusive).\n      maxZoom: undefined,\n      // @option maxNativeZoom: Number = undefined\n      // Maximum zoom number the tile source has available. If it is specified,\n      // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded\n      // from `maxNativeZoom` level and auto-scaled.\n      maxNativeZoom: undefined,\n      // @option minNativeZoom: Number = undefined\n      // Minimum zoom number the tile source has available. If it is specified,\n      // the tiles on all zoom levels lower than `minNativeZoom` will be loaded\n      // from `minNativeZoom` level and auto-scaled.\n      minNativeZoom: undefined,\n      // @option noWrap: Boolean = false\n      // Whether the layer is wrapped around the antimeridian. If `true`, the\n      // GridLayer will only be displayed once at low zoom levels. Has no\n      // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used\n      // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting\n      // tiles outside the CRS limits.\n      noWrap: false,\n      // @option pane: String = 'tilePane'\n      // `Map pane` where the grid layer will be added.\n      pane: 'tilePane',\n      // @option className: String = ''\n      // A custom class name to assign to the tile layer. Empty by default.\n      className: '',\n      // @option keepBuffer: Number = 2\n      // When panning the map, keep this many rows and columns of tiles before unloading them.\n      keepBuffer: 2\n    },\n    initialize: function initialize(options) {\n      setOptions(this, options);\n    },\n    onAdd: function onAdd() {\n      this._initContainer();\n      this._levels = {};\n      this._tiles = {};\n      this._resetView(); // implicit _update() call\n    },\n    beforeAdd: function beforeAdd(map) {\n      map._addZoomLimit(this);\n    },\n    onRemove: function onRemove(map) {\n      this._removeAllTiles();\n      _remove(this._container);\n      map._removeZoomLimit(this);\n      this._container = null;\n      this._tileZoom = undefined;\n    },\n    // @method bringToFront: this\n    // Brings the tile layer to the top of all tile layers.\n    bringToFront: function bringToFront() {\n      if (this._map) {\n        toFront(this._container);\n        this._setAutoZIndex(Math.max);\n      }\n      return this;\n    },\n    // @method bringToBack: this\n    // Brings the tile layer to the bottom of all tile layers.\n    bringToBack: function bringToBack() {\n      if (this._map) {\n        toBack(this._container);\n        this._setAutoZIndex(Math.min);\n      }\n      return this;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTML element that contains the tiles for this layer.\n    getContainer: function getContainer() {\n      return this._container;\n    },\n    // @method setOpacity(opacity: Number): this\n    // Changes the [opacity](#gridlayer-opacity) of the grid layer.\n    setOpacity: function setOpacity(opacity) {\n      this.options.opacity = opacity;\n      this._updateOpacity();\n      return this;\n    },\n    // @method setZIndex(zIndex: Number): this\n    // Changes the [zIndex](#gridlayer-zindex) of the grid layer.\n    setZIndex: function setZIndex(zIndex) {\n      this.options.zIndex = zIndex;\n      this._updateZIndex();\n      return this;\n    },\n    // @method isLoading: Boolean\n    // Returns `true` if any tile in the grid layer has not finished loading.\n    isLoading: function isLoading() {\n      return this._loading;\n    },\n    // @method redraw: this\n    // Causes the layer to clear all the tiles and request them again.\n    redraw: function redraw() {\n      if (this._map) {\n        this._removeAllTiles();\n        var tileZoom = this._clampZoom(this._map.getZoom());\n        if (tileZoom !== this._tileZoom) {\n          this._tileZoom = tileZoom;\n          this._updateLevels();\n        }\n        this._update();\n      }\n      return this;\n    },\n    getEvents: function getEvents() {\n      var events = {\n        viewprereset: this._invalidateAll,\n        viewreset: this._resetView,\n        zoom: this._resetView,\n        moveend: this._onMoveEnd\n      };\n      if (!this.options.updateWhenIdle) {\n        // update tiles on move, but not more often than once per given interval\n        if (!this._onMove) {\n          this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);\n        }\n        events.move = this._onMove;\n      }\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n      return events;\n    },\n    // @section Extension methods\n    // Layers extending `GridLayer` shall reimplement the following method.\n    // @method createTile(coords: Object, done?: Function): HTMLElement\n    // Called only internally, must be overridden by classes extending `GridLayer`.\n    // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback\n    // is specified, it must be called when the tile has finished loading and drawing.\n    createTile: function createTile() {\n      return document.createElement('div');\n    },\n    // @section\n    // @method getTileSize: Point\n    // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.\n    getTileSize: function getTileSize() {\n      var s = this.options.tileSize;\n      return s instanceof Point ? s : new Point(s, s);\n    },\n    _updateZIndex: function _updateZIndex() {\n      if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n        this._container.style.zIndex = this.options.zIndex;\n      }\n    },\n    _setAutoZIndex: function _setAutoZIndex(compare) {\n      // go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)\n\n      var layers = this.getPane().children,\n        edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min\n\n      for (var i = 0, len = layers.length, zIndex; i < len; i++) {\n        zIndex = layers[i].style.zIndex;\n        if (layers[i] !== this._container && zIndex) {\n          edgeZIndex = compare(edgeZIndex, +zIndex);\n        }\n      }\n      if (isFinite(edgeZIndex)) {\n        this.options.zIndex = edgeZIndex + compare(-1, 1);\n        this._updateZIndex();\n      }\n    },\n    _updateOpacity: function _updateOpacity() {\n      if (!this._map) {\n        return;\n      }\n\n      // IE doesn't inherit filter opacity properly, so we're forced to set it on tiles\n      if (Browser.ielt9) {\n        return;\n      }\n      _setOpacity(this._container, this.options.opacity);\n      var now = +new Date(),\n        nextFrame = false,\n        willPrune = false;\n      for (var key in this._tiles) {\n        var tile = this._tiles[key];\n        if (!tile.current || !tile.loaded) {\n          continue;\n        }\n        var fade = Math.min(1, (now - tile.loaded) / 200);\n        _setOpacity(tile.el, fade);\n        if (fade < 1) {\n          nextFrame = true;\n        } else {\n          if (tile.active) {\n            willPrune = true;\n          } else {\n            this._onOpaqueTile(tile);\n          }\n          tile.active = true;\n        }\n      }\n      if (willPrune && !this._noPrune) {\n        this._pruneTiles();\n      }\n      if (nextFrame) {\n        cancelAnimFrame(this._fadeFrame);\n        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n      }\n    },\n    _onOpaqueTile: falseFn,\n    _initContainer: function _initContainer() {\n      if (this._container) {\n        return;\n      }\n      this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));\n      this._updateZIndex();\n      if (this.options.opacity < 1) {\n        this._updateOpacity();\n      }\n      this.getPane().appendChild(this._container);\n    },\n    _updateLevels: function _updateLevels() {\n      var zoom = this._tileZoom,\n        maxZoom = this.options.maxZoom;\n      if (zoom === undefined) {\n        return undefined;\n      }\n      for (var z in this._levels) {\n        z = Number(z);\n        if (this._levels[z].el.children.length || z === zoom) {\n          this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);\n          this._onUpdateLevel(z);\n        } else {\n          _remove(this._levels[z].el);\n          this._removeTilesAtZoom(z);\n          this._onRemoveLevel(z);\n          delete this._levels[z];\n        }\n      }\n      var level = this._levels[zoom],\n        map = this._map;\n      if (!level) {\n        level = this._levels[zoom] = {};\n        level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);\n        level.el.style.zIndex = maxZoom;\n        level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();\n        level.zoom = zoom;\n        this._setZoomTransform(level, map.getCenter(), map.getZoom());\n\n        // force the browser to consider the newly added element for transition\n        falseFn(level.el.offsetWidth);\n        this._onCreateLevel(level);\n      }\n      this._level = level;\n      return level;\n    },\n    _onUpdateLevel: falseFn,\n    _onRemoveLevel: falseFn,\n    _onCreateLevel: falseFn,\n    _pruneTiles: function _pruneTiles() {\n      if (!this._map) {\n        return;\n      }\n      var key, tile;\n      var zoom = this._map.getZoom();\n      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n        this._removeAllTiles();\n        return;\n      }\n      for (key in this._tiles) {\n        tile = this._tiles[key];\n        tile.retain = tile.current;\n      }\n      for (key in this._tiles) {\n        tile = this._tiles[key];\n        if (tile.current && !tile.active) {\n          var coords = tile.coords;\n          if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\n            this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\n          }\n        }\n      }\n      for (key in this._tiles) {\n        if (!this._tiles[key].retain) {\n          this._removeTile(key);\n        }\n      }\n    },\n    _removeTilesAtZoom: function _removeTilesAtZoom(zoom) {\n      for (var key in this._tiles) {\n        if (this._tiles[key].coords.z !== zoom) {\n          continue;\n        }\n        this._removeTile(key);\n      }\n    },\n    _removeAllTiles: function _removeAllTiles() {\n      for (var key in this._tiles) {\n        this._removeTile(key);\n      }\n    },\n    _invalidateAll: function _invalidateAll() {\n      for (var z in this._levels) {\n        _remove(this._levels[z].el);\n        this._onRemoveLevel(Number(z));\n        delete this._levels[z];\n      }\n      this._removeAllTiles();\n      this._tileZoom = undefined;\n    },\n    _retainParent: function _retainParent(x, y, z, minZoom) {\n      var x2 = Math.floor(x / 2),\n        y2 = Math.floor(y / 2),\n        z2 = z - 1,\n        coords2 = new Point(+x2, +y2);\n      coords2.z = +z2;\n      var key = this._tileCoordsToKey(coords2),\n        tile = this._tiles[key];\n      if (tile && tile.active) {\n        tile.retain = true;\n        return true;\n      } else if (tile && tile.loaded) {\n        tile.retain = true;\n      }\n      if (z2 > minZoom) {\n        return this._retainParent(x2, y2, z2, minZoom);\n      }\n      return false;\n    },\n    _retainChildren: function _retainChildren(x, y, z, maxZoom) {\n      for (var i = 2 * x; i < 2 * x + 2; i++) {\n        for (var j = 2 * y; j < 2 * y + 2; j++) {\n          var coords = new Point(i, j);\n          coords.z = z + 1;\n          var key = this._tileCoordsToKey(coords),\n            tile = this._tiles[key];\n          if (tile && tile.active) {\n            tile.retain = true;\n            continue;\n          } else if (tile && tile.loaded) {\n            tile.retain = true;\n          }\n          if (z + 1 < maxZoom) {\n            this._retainChildren(i, j, z + 1, maxZoom);\n          }\n        }\n      }\n    },\n    _resetView: function _resetView(e) {\n      var animating = e && (e.pinch || e.flyTo);\n      this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);\n    },\n    _animateZoom: function _animateZoom(e) {\n      this._setView(e.center, e.zoom, true, e.noUpdate);\n    },\n    _clampZoom: function _clampZoom(zoom) {\n      var options = this.options;\n      if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {\n        return options.minNativeZoom;\n      }\n      if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {\n        return options.maxNativeZoom;\n      }\n      return zoom;\n    },\n    _setView: function _setView(center, zoom, noPrune, noUpdate) {\n      var tileZoom = Math.round(zoom);\n      if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) {\n        tileZoom = undefined;\n      } else {\n        tileZoom = this._clampZoom(tileZoom);\n      }\n      var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;\n      if (!noUpdate || tileZoomChanged) {\n        this._tileZoom = tileZoom;\n        if (this._abortLoading) {\n          this._abortLoading();\n        }\n        this._updateLevels();\n        this._resetGrid();\n        if (tileZoom !== undefined) {\n          this._update(center);\n        }\n        if (!noPrune) {\n          this._pruneTiles();\n        }\n\n        // Flag to prevent _updateOpacity from pruning tiles during\n        // a zoom anim or a pinch gesture\n        this._noPrune = !!noPrune;\n      }\n      this._setZoomTransforms(center, zoom);\n    },\n    _setZoomTransforms: function _setZoomTransforms(center, zoom) {\n      for (var i in this._levels) {\n        this._setZoomTransform(this._levels[i], center, zoom);\n      }\n    },\n    _setZoomTransform: function _setZoomTransform(level, center, zoom) {\n      var scale = this._map.getZoomScale(zoom, level.zoom),\n        translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();\n      if (Browser.any3d) {\n        setTransform(level.el, translate, scale);\n      } else {\n        setPosition(level.el, translate);\n      }\n    },\n    _resetGrid: function _resetGrid() {\n      var map = this._map,\n        crs = map.options.crs,\n        tileSize = this._tileSize = this.getTileSize(),\n        tileZoom = this._tileZoom;\n      var bounds = this._map.getPixelWorldBounds(this._tileZoom);\n      if (bounds) {\n        this._globalTileRange = this._pxBoundsToTileRange(bounds);\n      }\n      this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)];\n      this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)];\n    },\n    _onMoveEnd: function _onMoveEnd() {\n      if (!this._map || this._map._animatingZoom) {\n        return;\n      }\n      this._update();\n    },\n    _getTiledPixelBounds: function _getTiledPixelBounds(center) {\n      var map = this._map,\n        mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),\n        scale = map.getZoomScale(mapZoom, this._tileZoom),\n        pixelCenter = map.project(center, this._tileZoom).floor(),\n        halfSize = map.getSize().divideBy(scale * 2);\n      return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n    },\n    // Private method to load tiles in the grid's active zoom level according to map bounds\n    _update: function _update(center) {\n      var map = this._map;\n      if (!map) {\n        return;\n      }\n      var zoom = this._clampZoom(map.getZoom());\n      if (center === undefined) {\n        center = map.getCenter();\n      }\n      if (this._tileZoom === undefined) {\n        return;\n      } // if out of minzoom/maxzoom\n\n      var pixelBounds = this._getTiledPixelBounds(center),\n        tileRange = this._pxBoundsToTileRange(pixelBounds),\n        tileCenter = tileRange.getCenter(),\n        queue = [],\n        margin = this.options.keepBuffer,\n        noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin]));\n\n      // Sanity check: panic if the tile range contains Infinity somewhere.\n      if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {\n        throw new Error('Attempted to load an infinite number of tiles');\n      }\n      for (var key in this._tiles) {\n        var c = this._tiles[key].coords;\n        if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {\n          this._tiles[key].current = false;\n        }\n      }\n\n      // _update just loads more tiles. If the tile zoom level differs too much\n      // from the map's, let _setView reset levels and prune old tiles.\n      if (Math.abs(zoom - this._tileZoom) > 1) {\n        this._setView(center, zoom);\n        return;\n      }\n\n      // create a queue of coordinates to load tiles from\n      for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {\n        for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {\n          var coords = new Point(i, j);\n          coords.z = this._tileZoom;\n          if (!this._isValidTile(coords)) {\n            continue;\n          }\n          var tile = this._tiles[this._tileCoordsToKey(coords)];\n          if (tile) {\n            tile.current = true;\n          } else {\n            queue.push(coords);\n          }\n        }\n      }\n\n      // sort tile queue to load tiles in order of their distance to center\n      queue.sort(function (a, b) {\n        return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);\n      });\n      if (queue.length !== 0) {\n        // if it's the first batch of tiles to load\n        if (!this._loading) {\n          this._loading = true;\n          // @event loading: Event\n          // Fired when the grid layer starts loading tiles.\n          this.fire('loading');\n        }\n\n        // create DOM fragment to append tiles in one batch\n        var fragment = document.createDocumentFragment();\n        for (i = 0; i < queue.length; i++) {\n          this._addTile(queue[i], fragment);\n        }\n        this._level.el.appendChild(fragment);\n      }\n    },\n    _isValidTile: function _isValidTile(coords) {\n      var crs = this._map.options.crs;\n      if (!crs.infinite) {\n        // don't load tile if it's out of bounds and not wrapped\n        var bounds = this._globalTileRange;\n        if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {\n          return false;\n        }\n      }\n      if (!this.options.bounds) {\n        return true;\n      }\n\n      // don't load tile if it doesn't intersect the bounds in options\n      var tileBounds = this._tileCoordsToBounds(coords);\n      return toLatLngBounds(this.options.bounds).overlaps(tileBounds);\n    },\n    _keyToBounds: function _keyToBounds(key) {\n      return this._tileCoordsToBounds(this._keyToTileCoords(key));\n    },\n    _tileCoordsToNwSe: function _tileCoordsToNwSe(coords) {\n      var map = this._map,\n        tileSize = this.getTileSize(),\n        nwPoint = coords.scaleBy(tileSize),\n        sePoint = nwPoint.add(tileSize),\n        nw = map.unproject(nwPoint, coords.z),\n        se = map.unproject(sePoint, coords.z);\n      return [nw, se];\n    },\n    // converts tile coordinates to its geographical bounds\n    _tileCoordsToBounds: function _tileCoordsToBounds(coords) {\n      var bp = this._tileCoordsToNwSe(coords),\n        bounds = new LatLngBounds(bp[0], bp[1]);\n      if (!this.options.noWrap) {\n        bounds = this._map.wrapLatLngBounds(bounds);\n      }\n      return bounds;\n    },\n    // converts tile coordinates to key for the tile cache\n    _tileCoordsToKey: function _tileCoordsToKey(coords) {\n      return coords.x + ':' + coords.y + ':' + coords.z;\n    },\n    // converts tile cache key to coordinates\n    _keyToTileCoords: function _keyToTileCoords(key) {\n      var k = key.split(':'),\n        coords = new Point(+k[0], +k[1]);\n      coords.z = +k[2];\n      return coords;\n    },\n    _removeTile: function _removeTile(key) {\n      var tile = this._tiles[key];\n      if (!tile) {\n        return;\n      }\n      _remove(tile.el);\n      delete this._tiles[key];\n\n      // @event tileunload: TileEvent\n      // Fired when a tile is removed (e.g. when a tile goes off the screen).\n      this.fire('tileunload', {\n        tile: tile.el,\n        coords: this._keyToTileCoords(key)\n      });\n    },\n    _initTile: function _initTile(tile) {\n      addClass(tile, 'leaflet-tile');\n      var tileSize = this.getTileSize();\n      tile.style.width = tileSize.x + 'px';\n      tile.style.height = tileSize.y + 'px';\n      tile.onselectstart = falseFn;\n      tile.onmousemove = falseFn;\n\n      // update opacity on tiles in IE7-8 because of filter inheritance problems\n      if (Browser.ielt9 && this.options.opacity < 1) {\n        _setOpacity(tile, this.options.opacity);\n      }\n    },\n    _addTile: function _addTile(coords, container) {\n      var tilePos = this._getTilePos(coords),\n        key = this._tileCoordsToKey(coords);\n      var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));\n      this._initTile(tile);\n\n      // if createTile is defined with a second argument (\"done\" callback),\n      // we know that tile is async and will be ready later; otherwise\n      if (this.createTile.length < 2) {\n        // mark tile as ready, but delay one frame for opacity animation to happen\n        requestAnimFrame(bind(this._tileReady, this, coords, null, tile));\n      }\n      setPosition(tile, tilePos);\n\n      // save tile in cache\n      this._tiles[key] = {\n        el: tile,\n        coords: coords,\n        current: true\n      };\n      container.appendChild(tile);\n      // @event tileloadstart: TileEvent\n      // Fired when a tile is requested and starts loading.\n      this.fire('tileloadstart', {\n        tile: tile,\n        coords: coords\n      });\n    },\n    _tileReady: function _tileReady(coords, err, tile) {\n      if (err) {\n        // @event tileerror: TileErrorEvent\n        // Fired when there is an error loading a tile.\n        this.fire('tileerror', {\n          error: err,\n          tile: tile,\n          coords: coords\n        });\n      }\n      var key = this._tileCoordsToKey(coords);\n      tile = this._tiles[key];\n      if (!tile) {\n        return;\n      }\n      tile.loaded = +new Date();\n      if (this._map._fadeAnimated) {\n        _setOpacity(tile.el, 0);\n        cancelAnimFrame(this._fadeFrame);\n        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n      } else {\n        tile.active = true;\n        this._pruneTiles();\n      }\n      if (!err) {\n        addClass(tile.el, 'leaflet-tile-loaded');\n\n        // @event tileload: TileEvent\n        // Fired when a tile loads.\n        this.fire('tileload', {\n          tile: tile.el,\n          coords: coords\n        });\n      }\n      if (this._noTilesToLoad()) {\n        this._loading = false;\n        // @event load: Event\n        // Fired when the grid layer loaded all visible tiles.\n        this.fire('load');\n        if (Browser.ielt9 || !this._map._fadeAnimated) {\n          requestAnimFrame(this._pruneTiles, this);\n        } else {\n          // Wait a bit more than 0.2 secs (the duration of the tile fade-in)\n          // to trigger a pruning.\n          setTimeout(bind(this._pruneTiles, this), 250);\n        }\n      }\n    },\n    _getTilePos: function _getTilePos(coords) {\n      return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);\n    },\n    _wrapCoords: function _wrapCoords(coords) {\n      var newCoords = new Point(this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);\n      newCoords.z = coords.z;\n      return newCoords;\n    },\n    _pxBoundsToTileRange: function _pxBoundsToTileRange(bounds) {\n      var tileSize = this.getTileSize();\n      return new Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));\n    },\n    _noTilesToLoad: function _noTilesToLoad() {\n      for (var key in this._tiles) {\n        if (!this._tiles[key].loaded) {\n          return false;\n        }\n      }\n      return true;\n    }\n  });\n\n  // @factory L.gridLayer(options?: GridLayer options)\n  // Creates a new instance of GridLayer with the supplied options.\n  function gridLayer(options) {\n    return new GridLayer(options);\n  }\n\n  /*\r\n   * @class TileLayer\r\n   * @inherits GridLayer\r\n   * @aka L.TileLayer\r\n   * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'}).addTo(map);\n   * ```\r\n   *\r\n   * @section URL template\r\n   * @example\r\n   *\r\n   * A string of the following form:\r\n   *\r\n   * ```\r\n   * 'https://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'\r\n   * ```\r\n   *\r\n   * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add \"&commat;2x\" to the URL to load retina tiles.\r\n   *\r\n   * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:\r\n   *\r\n   * ```\r\n   * L.tileLayer('https://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});\r\n   * ```\r\n   */\n\n  var TileLayer = GridLayer.extend({\n    // @section\n    // @aka TileLayer options\n    options: {\n      // @option minZoom: Number = 0\n      // The minimum zoom level down to which this layer will be displayed (inclusive).\n      minZoom: 0,\n      // @option maxZoom: Number = 18\n      // The maximum zoom level up to which this layer will be displayed (inclusive).\n      maxZoom: 18,\n      // @option subdomains: String|String[] = 'abc'\n      // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.\n      subdomains: 'abc',\n      // @option errorTileUrl: String = ''\n      // URL to the tile image to show in place of the tile that failed to load.\n      errorTileUrl: '',\n      // @option zoomOffset: Number = 0\n      // The zoom number used in tile URLs will be offset with this value.\n      zoomOffset: 0,\n      // @option tms: Boolean = false\n      // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).\n      tms: false,\n      // @option zoomReverse: Boolean = false\n      // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)\n      zoomReverse: false,\n      // @option detectRetina: Boolean = false\n      // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.\n      detectRetina: false,\n      // @option crossOrigin: Boolean|String = false\n      // Whether the crossOrigin attribute will be added to the tiles.\n      // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.\n      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n      crossOrigin: false,\n      // @option referrerPolicy: Boolean|String = false\n      // Whether the referrerPolicy attribute will be added to the tiles.\n      // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.\n      // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer\n      // (e.g. to validate an API token).\n      // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.\n      referrerPolicy: false\n    },\n    initialize: function initialize(url, options) {\n      this._url = url;\n      options = setOptions(this, options);\n\n      // detecting retina displays, adjusting tileSize and zoom levels\n      if (options.detectRetina && Browser.retina && options.maxZoom > 0) {\n        options.tileSize = Math.floor(options.tileSize / 2);\n        if (!options.zoomReverse) {\n          options.zoomOffset++;\n          options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);\n        } else {\n          options.zoomOffset--;\n          options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);\n        }\n        options.minZoom = Math.max(0, options.minZoom);\n      } else if (!options.zoomReverse) {\n        // make sure maxZoom is gte minZoom\n        options.maxZoom = Math.max(options.minZoom, options.maxZoom);\n      } else {\n        // make sure minZoom is lte maxZoom\n        options.minZoom = Math.min(options.maxZoom, options.minZoom);\n      }\n      if (typeof options.subdomains === 'string') {\n        options.subdomains = options.subdomains.split('');\n      }\n      this.on('tileunload', this._onTileRemove);\n    },\n    // @method setUrl(url: String, noRedraw?: Boolean): this\n    // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).\n    // If the URL does not change, the layer will not be redrawn unless\n    // the noRedraw parameter is set to false.\n    setUrl: function setUrl(url, noRedraw) {\n      if (this._url === url && noRedraw === undefined) {\n        noRedraw = true;\n      }\n      this._url = url;\n      if (!noRedraw) {\n        this.redraw();\n      }\n      return this;\n    },\n    // @method createTile(coords: Object, done?: Function): HTMLElement\n    // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)\n    // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`\n    // callback is called when the tile has been loaded.\n    createTile: function createTile(coords, done) {\n      var tile = document.createElement('img');\n      on(tile, 'load', bind(this._tileOnLoad, this, done, tile));\n      on(tile, 'error', bind(this._tileOnError, this, done, tile));\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n\n      // for this new option we follow the documented behavior\n      // more closely by only setting the property when string\n      if (typeof this.options.referrerPolicy === 'string') {\n        tile.referrerPolicy = this.options.referrerPolicy;\n      }\n\n      // The alt attribute is set to the empty string,\n      // allowing screen readers to ignore the decorative image tiles.\n      // https://www.w3.org/WAI/tutorials/images/decorative/\n      // https://www.w3.org/TR/html-aria/#el-img-empty-alt\n      tile.alt = '';\n      tile.src = this.getTileUrl(coords);\n      return tile;\n    },\n    // @section Extension methods\n    // @uninheritable\n    // Layers extending `TileLayer` might reimplement the following method.\n    // @method getTileUrl(coords: Object): String\n    // Called only internally, returns the URL for a tile given its coordinates.\n    // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.\n    getTileUrl: function getTileUrl(coords) {\n      var data = {\n        r: Browser.retina ? '@2x' : '',\n        s: this._getSubdomain(coords),\n        x: coords.x,\n        y: coords.y,\n        z: this._getZoomForUrl()\n      };\n      if (this._map && !this._map.options.crs.infinite) {\n        var invertedY = this._globalTileRange.max.y - coords.y;\n        if (this.options.tms) {\n          data['y'] = invertedY;\n        }\n        data['-y'] = invertedY;\n      }\n      return template(this._url, extend(data, this.options));\n    },\n    _tileOnLoad: function _tileOnLoad(done, tile) {\n      // For https://github.com/Leaflet/Leaflet/issues/3332\n      if (Browser.ielt9) {\n        setTimeout(bind(done, this, null, tile), 0);\n      } else {\n        done(null, tile);\n      }\n    },\n    _tileOnError: function _tileOnError(done, tile, e) {\n      var errorUrl = this.options.errorTileUrl;\n      if (errorUrl && tile.getAttribute('src') !== errorUrl) {\n        tile.src = errorUrl;\n      }\n      done(e, tile);\n    },\n    _onTileRemove: function _onTileRemove(e) {\n      e.tile.onload = null;\n    },\n    _getZoomForUrl: function _getZoomForUrl() {\n      var zoom = this._tileZoom,\n        maxZoom = this.options.maxZoom,\n        zoomReverse = this.options.zoomReverse,\n        zoomOffset = this.options.zoomOffset;\n      if (zoomReverse) {\n        zoom = maxZoom - zoom;\n      }\n      return zoom + zoomOffset;\n    },\n    _getSubdomain: function _getSubdomain(tilePoint) {\n      var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\n      return this.options.subdomains[index];\n    },\n    // stops loading all tiles in the background layer\n    _abortLoading: function _abortLoading() {\n      var i, tile;\n      for (i in this._tiles) {\n        if (this._tiles[i].coords.z !== this._tileZoom) {\n          tile = this._tiles[i].el;\n          tile.onload = falseFn;\n          tile.onerror = falseFn;\n          if (!tile.complete) {\n            tile.src = emptyImageUrl;\n            var coords = this._tiles[i].coords;\n            _remove(tile);\n            delete this._tiles[i];\n            // @event tileabort: TileEvent\n            // Fired when a tile was loading but is now not wanted.\n            this.fire('tileabort', {\n              tile: tile,\n              coords: coords\n            });\n          }\n        }\n      }\n    },\n    _removeTile: function _removeTile(key) {\n      var tile = this._tiles[key];\n      if (!tile) {\n        return;\n      }\n\n      // Cancels any pending http requests associated with the tile\n      tile.el.setAttribute('src', emptyImageUrl);\n      return GridLayer.prototype._removeTile.call(this, key);\n    },\n    _tileReady: function _tileReady(coords, err, tile) {\n      if (!this._map || tile && tile.getAttribute('src') === emptyImageUrl) {\n        return;\n      }\n      return GridLayer.prototype._tileReady.call(this, coords, err, tile);\n    }\n  });\n\n  // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)\n  // Instantiates a tile layer object given a `URL template` and optionally an options object.\n\n  function tileLayer(url, options) {\n    return new TileLayer(url, options);\n  }\n\n  /*\r\n   * @class TileLayer.WMS\r\n   * @inherits TileLayer\r\n   * @aka L.TileLayer.WMS\r\n   * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var nexrad = L.tileLayer.wms(\"http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\", {\r\n   * \tlayers: 'nexrad-n0r-900913',\r\n   * \tformat: 'image/png',\r\n   * \ttransparent: true,\r\n   * \tattribution: \"Weather data © 2012 IEM Nexrad\"\r\n   * });\r\n   * ```\r\n   */\n\n  var TileLayerWMS = TileLayer.extend({\n    // @section\n    // @aka TileLayer.WMS options\n    // If any custom options not documented here are used, they will be sent to the\n    // WMS server as extra parameters in each request URL. This can be useful for\n    // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).\n    defaultWmsParams: {\n      service: 'WMS',\n      request: 'GetMap',\n      // @option layers: String = ''\n      // **(required)** Comma-separated list of WMS layers to show.\n      layers: '',\n      // @option styles: String = ''\n      // Comma-separated list of WMS styles.\n      styles: '',\n      // @option format: String = 'image/jpeg'\n      // WMS image format (use `'image/png'` for layers with transparency).\n      format: 'image/jpeg',\n      // @option transparent: Boolean = false\n      // If `true`, the WMS service will return images with transparency.\n      transparent: false,\n      // @option version: String = '1.1.1'\n      // Version of the WMS service to use\n      version: '1.1.1'\n    },\n    options: {\n      // @option crs: CRS = null\n      // Coordinate Reference System to use for the WMS requests, defaults to\n      // map CRS. Don't change this if you're not sure what it means.\n      crs: null,\n      // @option uppercase: Boolean = false\n      // If `true`, WMS request parameter keys will be uppercase.\n      uppercase: false\n    },\n    initialize: function initialize(url, options) {\n      this._url = url;\n      var wmsParams = extend({}, this.defaultWmsParams);\n\n      // all keys that are not TileLayer options go to WMS params\n      for (var i in options) {\n        if (!(i in this.options)) {\n          wmsParams[i] = options[i];\n        }\n      }\n      options = setOptions(this, options);\n      var realRetina = options.detectRetina && Browser.retina ? 2 : 1;\n      var tileSize = this.getTileSize();\n      wmsParams.width = tileSize.x * realRetina;\n      wmsParams.height = tileSize.y * realRetina;\n      this.wmsParams = wmsParams;\n    },\n    onAdd: function onAdd(map) {\n      this._crs = this.options.crs || map.options.crs;\n      this._wmsVersion = parseFloat(this.wmsParams.version);\n      var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\n      this.wmsParams[projectionKey] = this._crs.code;\n      TileLayer.prototype.onAdd.call(this, map);\n    },\n    getTileUrl: function getTileUrl(coords) {\n      var tileBounds = this._tileCoordsToNwSe(coords),\n        crs = this._crs,\n        bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),\n        min = bounds.min,\n        max = bounds.max,\n        bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(','),\n        url = TileLayer.prototype.getTileUrl.call(this, coords);\n      return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;\n    },\n    // @method setParams(params: Object, noRedraw?: Boolean): this\n    // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).\n    setParams: function setParams(params, noRedraw) {\n      extend(this.wmsParams, params);\n      if (!noRedraw) {\n        this.redraw();\n      }\n      return this;\n    }\n  });\n\n  // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)\n  // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.\n  function tileLayerWMS(url, options) {\n    return new TileLayerWMS(url, options);\n  }\n  TileLayer.WMS = TileLayerWMS;\n  tileLayer.wms = tileLayerWMS;\n\n  /*\n   * @class Renderer\n   * @inherits Layer\n   * @aka L.Renderer\n   *\n   * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the\n   * DOM container of the renderer, its bounds, and its zoom animation.\n   *\n   * A `Renderer` works as an implicit layer group for all `Path`s - the renderer\n   * itself can be added or removed to the map. All paths use a renderer, which can\n   * be implicit (the map will decide the type of renderer and use it automatically)\n   * or explicit (using the [`renderer`](#path-renderer) option of the path).\n   *\n   * Do not use this class directly, use `SVG` and `Canvas` instead.\n   *\n   * @event update: Event\n   * Fired when the renderer updates its bounds, center and zoom, for example when\n   * its map has moved\n   */\n\n  var Renderer = Layer.extend({\n    // @section\n    // @aka Renderer options\n    options: {\n      // @option padding: Number = 0.1\n      // How much to extend the clip area around the map view (relative to its size)\n      // e.g. 0.1 would be 10% of map view in each direction\n      padding: 0.1\n    },\n    initialize: function initialize(options) {\n      setOptions(this, options);\n      stamp(this);\n      this._layers = this._layers || {};\n    },\n    onAdd: function onAdd() {\n      if (!this._container) {\n        this._initContainer(); // defined by renderer implementations\n\n        // always keep transform-origin as 0 0\n        addClass(this._container, 'leaflet-zoom-animated');\n      }\n      this.getPane().appendChild(this._container);\n      this._update();\n      this.on('update', this._updatePaths, this);\n    },\n    onRemove: function onRemove() {\n      this.off('update', this._updatePaths, this);\n      this._destroyContainer();\n    },\n    getEvents: function getEvents() {\n      var events = {\n        viewreset: this._reset,\n        zoom: this._onZoom,\n        moveend: this._update,\n        zoomend: this._onZoomEnd\n      };\n      if (this._zoomAnimated) {\n        events.zoomanim = this._onAnimZoom;\n      }\n      return events;\n    },\n    _onAnimZoom: function _onAnimZoom(ev) {\n      this._updateTransform(ev.center, ev.zoom);\n    },\n    _onZoom: function _onZoom() {\n      this._updateTransform(this._map.getCenter(), this._map.getZoom());\n    },\n    _updateTransform: function _updateTransform(center, zoom) {\n      var scale = this._map.getZoomScale(zoom, this._zoom),\n        viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),\n        currentCenterPoint = this._map.project(this._center, zoom),\n        topLeftOffset = viewHalf.multiplyBy(-scale).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom));\n      if (Browser.any3d) {\n        setTransform(this._container, topLeftOffset, scale);\n      } else {\n        setPosition(this._container, topLeftOffset);\n      }\n    },\n    _reset: function _reset() {\n      this._update();\n      this._updateTransform(this._center, this._zoom);\n      for (var id in this._layers) {\n        this._layers[id]._reset();\n      }\n    },\n    _onZoomEnd: function _onZoomEnd() {\n      for (var id in this._layers) {\n        this._layers[id]._project();\n      }\n    },\n    _updatePaths: function _updatePaths() {\n      for (var id in this._layers) {\n        this._layers[id]._update();\n      }\n    },\n    _update: function _update() {\n      // Update pixel bounds of renderer container (for positioning/sizing/clipping later)\n      // Subclasses are responsible of firing the 'update' event.\n      var p = this.options.padding,\n        size = this._map.getSize(),\n        min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();\n      this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());\n      this._center = this._map.getCenter();\n      this._zoom = this._map.getZoom();\n    }\n  });\n\n  /*\n   * @class Canvas\n   * @inherits Renderer\n   * @aka L.Canvas\n   *\n   * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](https://caniuse.com/canvas), Canvas is not\n   * available in all web browsers, notably IE8, and overlapping geometries might\n   * not display properly in some edge cases.\n   *\n   * @example\n   *\n   * Use Canvas by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.canvas()\n   * });\n   * ```\n   *\n   * Use a Canvas renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.canvas({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */\n\n  var Canvas = Renderer.extend({\n    // @section\n    // @aka Canvas options\n    options: {\n      // @option tolerance: Number = 0\n      // How much to extend the click tolerance around a path/object on the map.\n      tolerance: 0\n    },\n    getEvents: function getEvents() {\n      var events = Renderer.prototype.getEvents.call(this);\n      events.viewprereset = this._onViewPreReset;\n      return events;\n    },\n    _onViewPreReset: function _onViewPreReset() {\n      // Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once\n      this._postponeUpdatePaths = true;\n    },\n    onAdd: function onAdd() {\n      Renderer.prototype.onAdd.call(this);\n\n      // Redraw vectors since canvas is cleared upon removal,\n      // in case of removing the renderer itself from the map.\n      this._draw();\n    },\n    _initContainer: function _initContainer() {\n      var container = this._container = document.createElement('canvas');\n      on(container, 'mousemove', this._onMouseMove, this);\n      on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);\n      on(container, 'mouseout', this._handleMouseOut, this);\n      container['_leaflet_disable_events'] = true;\n      this._ctx = container.getContext('2d');\n    },\n    _destroyContainer: function _destroyContainer() {\n      cancelAnimFrame(this._redrawRequest);\n      delete this._ctx;\n      _remove(this._container);\n      off(this._container);\n      delete this._container;\n    },\n    _updatePaths: function _updatePaths() {\n      if (this._postponeUpdatePaths) {\n        return;\n      }\n      var layer;\n      this._redrawBounds = null;\n      for (var id in this._layers) {\n        layer = this._layers[id];\n        layer._update();\n      }\n      this._redraw();\n    },\n    _update: function _update() {\n      if (this._map._animatingZoom && this._bounds) {\n        return;\n      }\n      Renderer.prototype._update.call(this);\n      var b = this._bounds,\n        container = this._container,\n        size = b.getSize(),\n        m = Browser.retina ? 2 : 1;\n      setPosition(container, b.min);\n\n      // set canvas size (also clearing it); use double size on retina\n      container.width = m * size.x;\n      container.height = m * size.y;\n      container.style.width = size.x + 'px';\n      container.style.height = size.y + 'px';\n      if (Browser.retina) {\n        this._ctx.scale(2, 2);\n      }\n\n      // translate so we use the same path coordinates after canvas element moves\n      this._ctx.translate(-b.min.x, -b.min.y);\n\n      // Tell paths to redraw themselves\n      this.fire('update');\n    },\n    _reset: function _reset() {\n      Renderer.prototype._reset.call(this);\n      if (this._postponeUpdatePaths) {\n        this._postponeUpdatePaths = false;\n        this._updatePaths();\n      }\n    },\n    _initPath: function _initPath(layer) {\n      this._updateDashArray(layer);\n      this._layers[stamp(layer)] = layer;\n      var order = layer._order = {\n        layer: layer,\n        prev: this._drawLast,\n        next: null\n      };\n      if (this._drawLast) {\n        this._drawLast.next = order;\n      }\n      this._drawLast = order;\n      this._drawFirst = this._drawFirst || this._drawLast;\n    },\n    _addPath: function _addPath(layer) {\n      this._requestRedraw(layer);\n    },\n    _removePath: function _removePath(layer) {\n      var order = layer._order;\n      var next = order.next;\n      var prev = order.prev;\n      if (next) {\n        next.prev = prev;\n      } else {\n        this._drawLast = prev;\n      }\n      if (prev) {\n        prev.next = next;\n      } else {\n        this._drawFirst = next;\n      }\n      delete layer._order;\n      delete this._layers[stamp(layer)];\n      this._requestRedraw(layer);\n    },\n    _updatePath: function _updatePath(layer) {\n      // Redraw the union of the layer's old pixel\n      // bounds and the new pixel bounds.\n      this._extendRedrawBounds(layer);\n      layer._project();\n      layer._update();\n      // The redraw will extend the redraw bounds\n      // with the new pixel bounds.\n      this._requestRedraw(layer);\n    },\n    _updateStyle: function _updateStyle(layer) {\n      this._updateDashArray(layer);\n      this._requestRedraw(layer);\n    },\n    _updateDashArray: function _updateDashArray(layer) {\n      if (typeof layer.options.dashArray === 'string') {\n        var parts = layer.options.dashArray.split(/[, ]+/),\n          dashArray = [],\n          dashValue,\n          i;\n        for (i = 0; i < parts.length; i++) {\n          dashValue = Number(parts[i]);\n          // Ignore dash array containing invalid lengths\n          if (isNaN(dashValue)) {\n            return;\n          }\n          dashArray.push(dashValue);\n        }\n        layer.options._dashArray = dashArray;\n      } else {\n        layer.options._dashArray = layer.options.dashArray;\n      }\n    },\n    _requestRedraw: function _requestRedraw(layer) {\n      if (!this._map) {\n        return;\n      }\n      this._extendRedrawBounds(layer);\n      this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);\n    },\n    _extendRedrawBounds: function _extendRedrawBounds(layer) {\n      if (layer._pxBounds) {\n        var padding = (layer.options.weight || 0) + 1;\n        this._redrawBounds = this._redrawBounds || new Bounds();\n        this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));\n        this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));\n      }\n    },\n    _redraw: function _redraw() {\n      this._redrawRequest = null;\n      if (this._redrawBounds) {\n        this._redrawBounds.min._floor();\n        this._redrawBounds.max._ceil();\n      }\n      this._clear(); // clear layers in redraw bounds\n      this._draw(); // draw layers\n\n      this._redrawBounds = null;\n    },\n    _clear: function _clear() {\n      var bounds = this._redrawBounds;\n      if (bounds) {\n        var size = bounds.getSize();\n        this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);\n      } else {\n        this._ctx.save();\n        this._ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this._ctx.clearRect(0, 0, this._container.width, this._container.height);\n        this._ctx.restore();\n      }\n    },\n    _draw: function _draw() {\n      var layer,\n        bounds = this._redrawBounds;\n      this._ctx.save();\n      if (bounds) {\n        var size = bounds.getSize();\n        this._ctx.beginPath();\n        this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);\n        this._ctx.clip();\n      }\n      this._drawing = true;\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n        if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {\n          layer._updatePath();\n        }\n      }\n      this._drawing = false;\n      this._ctx.restore(); // Restore state before clipping.\n    },\n    _updatePoly: function _updatePoly(layer, closed) {\n      if (!this._drawing) {\n        return;\n      }\n      var i,\n        j,\n        len2,\n        p,\n        parts = layer._parts,\n        len = parts.length,\n        ctx = this._ctx;\n      if (!len) {\n        return;\n      }\n      ctx.beginPath();\n      for (i = 0; i < len; i++) {\n        for (j = 0, len2 = parts[i].length; j < len2; j++) {\n          p = parts[i][j];\n          ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);\n        }\n        if (closed) {\n          ctx.closePath();\n        }\n      }\n      this._fillStroke(ctx, layer);\n\n      // TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\n    },\n    _updateCircle: function _updateCircle(layer) {\n      if (!this._drawing || layer._empty()) {\n        return;\n      }\n      var p = layer._point,\n        ctx = this._ctx,\n        r = Math.max(Math.round(layer._radius), 1),\n        s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;\n      if (s !== 1) {\n        ctx.save();\n        ctx.scale(1, s);\n      }\n      ctx.beginPath();\n      ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);\n      if (s !== 1) {\n        ctx.restore();\n      }\n      this._fillStroke(ctx, layer);\n    },\n    _fillStroke: function _fillStroke(ctx, layer) {\n      var options = layer.options;\n      if (options.fill) {\n        ctx.globalAlpha = options.fillOpacity;\n        ctx.fillStyle = options.fillColor || options.color;\n        ctx.fill(options.fillRule || 'evenodd');\n      }\n      if (options.stroke && options.weight !== 0) {\n        if (ctx.setLineDash) {\n          ctx.setLineDash(layer.options && layer.options._dashArray || []);\n        }\n        ctx.globalAlpha = options.opacity;\n        ctx.lineWidth = options.weight;\n        ctx.strokeStyle = options.color;\n        ctx.lineCap = options.lineCap;\n        ctx.lineJoin = options.lineJoin;\n        ctx.stroke();\n      }\n    },\n    // Canvas obviously doesn't have mouse events for individual drawn objects,\n    // so we emulate that by calculating what's under the mouse on mousemove/click manually\n\n    _onClick: function _onClick(e) {\n      var point = this._map.mouseEventToLayerPoint(e),\n        layer,\n        clickedLayer;\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n        if (layer.options.interactive && layer._containsPoint(point)) {\n          if (!(e.type === 'click' || e.type === 'preclick') || !this._map._draggableMoved(layer)) {\n            clickedLayer = layer;\n          }\n        }\n      }\n      this._fireEvent(clickedLayer ? [clickedLayer] : false, e);\n    },\n    _onMouseMove: function _onMouseMove(e) {\n      if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {\n        return;\n      }\n      var point = this._map.mouseEventToLayerPoint(e);\n      this._handleMouseHover(e, point);\n    },\n    _handleMouseOut: function _handleMouseOut(e) {\n      var layer = this._hoveredLayer;\n      if (layer) {\n        // if we're leaving the layer, fire mouseout\n        removeClass(this._container, 'leaflet-interactive');\n        this._fireEvent([layer], e, 'mouseout');\n        this._hoveredLayer = null;\n        this._mouseHoverThrottled = false;\n      }\n    },\n    _handleMouseHover: function _handleMouseHover(e, point) {\n      if (this._mouseHoverThrottled) {\n        return;\n      }\n      var layer, candidateHoveredLayer;\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n        if (layer.options.interactive && layer._containsPoint(point)) {\n          candidateHoveredLayer = layer;\n        }\n      }\n      if (candidateHoveredLayer !== this._hoveredLayer) {\n        this._handleMouseOut(e);\n        if (candidateHoveredLayer) {\n          addClass(this._container, 'leaflet-interactive'); // change cursor\n          this._fireEvent([candidateHoveredLayer], e, 'mouseover');\n          this._hoveredLayer = candidateHoveredLayer;\n        }\n      }\n      this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e);\n      this._mouseHoverThrottled = true;\n      setTimeout(bind(function () {\n        this._mouseHoverThrottled = false;\n      }, this), 32);\n    },\n    _fireEvent: function _fireEvent(layers, e, type) {\n      this._map._fireDOMEvent(e, type || e.type, layers);\n    },\n    _bringToFront: function _bringToFront(layer) {\n      var order = layer._order;\n      if (!order) {\n        return;\n      }\n      var next = order.next;\n      var prev = order.prev;\n      if (next) {\n        next.prev = prev;\n      } else {\n        // Already last\n        return;\n      }\n      if (prev) {\n        prev.next = next;\n      } else if (next) {\n        // Update first entry unless this is the\n        // single entry\n        this._drawFirst = next;\n      }\n      order.prev = this._drawLast;\n      this._drawLast.next = order;\n      order.next = null;\n      this._drawLast = order;\n      this._requestRedraw(layer);\n    },\n    _bringToBack: function _bringToBack(layer) {\n      var order = layer._order;\n      if (!order) {\n        return;\n      }\n      var next = order.next;\n      var prev = order.prev;\n      if (prev) {\n        prev.next = next;\n      } else {\n        // Already first\n        return;\n      }\n      if (next) {\n        next.prev = prev;\n      } else if (prev) {\n        // Update last entry unless this is the\n        // single entry\n        this._drawLast = prev;\n      }\n      order.prev = null;\n      order.next = this._drawFirst;\n      this._drawFirst.prev = order;\n      this._drawFirst = order;\n      this._requestRedraw(layer);\n    }\n  });\n\n  // @factory L.canvas(options?: Renderer options)\n  // Creates a Canvas renderer with the given options.\n  function canvas(options) {\n    return Browser.canvas ? new Canvas(options) : null;\n  }\n\n  /*\n   * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\n   */\n\n  var vmlCreate = function () {\n    try {\n      document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\n      return function (name) {\n        return document.createElement('<lvml:' + name + ' class=\"lvml\">');\n      };\n    } catch (e) {\n      // Do not return fn from catch block so `e` can be garbage collected\n      // See https://github.com/Leaflet/Leaflet/pull/7279\n    }\n    return function (name) {\n      return document.createElement('<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\n    };\n  }();\n\n  /*\n   * @class SVG\n   *\n   *\n   * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility\n   * with old versions of Internet Explorer.\n   */\n\n  // mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences\n  var vmlMixin = {\n    _initContainer: function _initContainer() {\n      this._container = create$1('div', 'leaflet-vml-container');\n    },\n    _update: function _update() {\n      if (this._map._animatingZoom) {\n        return;\n      }\n      Renderer.prototype._update.call(this);\n      this.fire('update');\n    },\n    _initPath: function _initPath(layer) {\n      var container = layer._container = vmlCreate('shape');\n      addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));\n      container.coordsize = '1 1';\n      layer._path = vmlCreate('path');\n      container.appendChild(layer._path);\n      this._updateStyle(layer);\n      this._layers[stamp(layer)] = layer;\n    },\n    _addPath: function _addPath(layer) {\n      var container = layer._container;\n      this._container.appendChild(container);\n      if (layer.options.interactive) {\n        layer.addInteractiveTarget(container);\n      }\n    },\n    _removePath: function _removePath(layer) {\n      var container = layer._container;\n      _remove(container);\n      layer.removeInteractiveTarget(container);\n      delete this._layers[stamp(layer)];\n    },\n    _updateStyle: function _updateStyle(layer) {\n      var stroke = layer._stroke,\n        fill = layer._fill,\n        options = layer.options,\n        container = layer._container;\n      container.stroked = !!options.stroke;\n      container.filled = !!options.fill;\n      if (options.stroke) {\n        if (!stroke) {\n          stroke = layer._stroke = vmlCreate('stroke');\n        }\n        container.appendChild(stroke);\n        stroke.weight = options.weight + 'px';\n        stroke.color = options.color;\n        stroke.opacity = options.opacity;\n        if (options.dashArray) {\n          stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(' ') : options.dashArray.replace(/( *, *)/g, ' ');\n        } else {\n          stroke.dashStyle = '';\n        }\n        stroke.endcap = options.lineCap.replace('butt', 'flat');\n        stroke.joinstyle = options.lineJoin;\n      } else if (stroke) {\n        container.removeChild(stroke);\n        layer._stroke = null;\n      }\n      if (options.fill) {\n        if (!fill) {\n          fill = layer._fill = vmlCreate('fill');\n        }\n        container.appendChild(fill);\n        fill.color = options.fillColor || options.color;\n        fill.opacity = options.fillOpacity;\n      } else if (fill) {\n        container.removeChild(fill);\n        layer._fill = null;\n      }\n    },\n    _updateCircle: function _updateCircle(layer) {\n      var p = layer._point.round(),\n        r = Math.round(layer._radius),\n        r2 = Math.round(layer._radiusY || r);\n      this._setPath(layer, layer._empty() ? 'M0 0' : 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + 65535 * 360);\n    },\n    _setPath: function _setPath(layer, path) {\n      layer._path.v = path;\n    },\n    _bringToFront: function _bringToFront(layer) {\n      toFront(layer._container);\n    },\n    _bringToBack: function _bringToBack(layer) {\n      toBack(layer._container);\n    }\n  };\n  var create = Browser.vml ? vmlCreate : svgCreate;\n\n  /*\n   * @class SVG\n   * @inherits Renderer\n   * @aka L.SVG\n   *\n   * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](https://caniuse.com/svg), SVG is not\n   * available in all web browsers, notably Android 2.x and 3.x.\n   *\n   * Although SVG is not available on IE7 and IE8, these browsers support\n   * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)\n   * (a now deprecated technology), and the SVG renderer will fall back to VML in\n   * this case.\n   *\n   * @example\n   *\n   * Use SVG by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.svg()\n   * });\n   * ```\n   *\n   * Use a SVG renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.svg({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */\n\n  var SVG = Renderer.extend({\n    _initContainer: function _initContainer() {\n      this._container = create('svg');\n\n      // makes it possible to click through svg root; we'll reset it back in individual paths\n      this._container.setAttribute('pointer-events', 'none');\n      this._rootGroup = create('g');\n      this._container.appendChild(this._rootGroup);\n    },\n    _destroyContainer: function _destroyContainer() {\n      _remove(this._container);\n      off(this._container);\n      delete this._container;\n      delete this._rootGroup;\n      delete this._svgSize;\n    },\n    _update: function _update() {\n      if (this._map._animatingZoom && this._bounds) {\n        return;\n      }\n      Renderer.prototype._update.call(this);\n      var b = this._bounds,\n        size = b.getSize(),\n        container = this._container;\n\n      // set size of svg-container if changed\n      if (!this._svgSize || !this._svgSize.equals(size)) {\n        this._svgSize = size;\n        container.setAttribute('width', size.x);\n        container.setAttribute('height', size.y);\n      }\n\n      // movement: update container viewBox so that we don't have to change coordinates of individual layers\n      setPosition(container, b.min);\n      container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));\n      this.fire('update');\n    },\n    // methods below are called by vector layers implementations\n\n    _initPath: function _initPath(layer) {\n      var path = layer._path = create('path');\n\n      // @namespace Path\n      // @option className: String = null\n      // Custom class name set on an element. Only for SVG renderer.\n      if (layer.options.className) {\n        addClass(path, layer.options.className);\n      }\n      if (layer.options.interactive) {\n        addClass(path, 'leaflet-interactive');\n      }\n      this._updateStyle(layer);\n      this._layers[stamp(layer)] = layer;\n    },\n    _addPath: function _addPath(layer) {\n      if (!this._rootGroup) {\n        this._initContainer();\n      }\n      this._rootGroup.appendChild(layer._path);\n      layer.addInteractiveTarget(layer._path);\n    },\n    _removePath: function _removePath(layer) {\n      _remove(layer._path);\n      layer.removeInteractiveTarget(layer._path);\n      delete this._layers[stamp(layer)];\n    },\n    _updatePath: function _updatePath(layer) {\n      layer._project();\n      layer._update();\n    },\n    _updateStyle: function _updateStyle(layer) {\n      var path = layer._path,\n        options = layer.options;\n      if (!path) {\n        return;\n      }\n      if (options.stroke) {\n        path.setAttribute('stroke', options.color);\n        path.setAttribute('stroke-opacity', options.opacity);\n        path.setAttribute('stroke-width', options.weight);\n        path.setAttribute('stroke-linecap', options.lineCap);\n        path.setAttribute('stroke-linejoin', options.lineJoin);\n        if (options.dashArray) {\n          path.setAttribute('stroke-dasharray', options.dashArray);\n        } else {\n          path.removeAttribute('stroke-dasharray');\n        }\n        if (options.dashOffset) {\n          path.setAttribute('stroke-dashoffset', options.dashOffset);\n        } else {\n          path.removeAttribute('stroke-dashoffset');\n        }\n      } else {\n        path.setAttribute('stroke', 'none');\n      }\n      if (options.fill) {\n        path.setAttribute('fill', options.fillColor || options.color);\n        path.setAttribute('fill-opacity', options.fillOpacity);\n        path.setAttribute('fill-rule', options.fillRule || 'evenodd');\n      } else {\n        path.setAttribute('fill', 'none');\n      }\n    },\n    _updatePoly: function _updatePoly(layer, closed) {\n      this._setPath(layer, pointsToPath(layer._parts, closed));\n    },\n    _updateCircle: function _updateCircle(layer) {\n      var p = layer._point,\n        r = Math.max(Math.round(layer._radius), 1),\n        r2 = Math.max(Math.round(layer._radiusY), 1) || r,\n        arc = 'a' + r + ',' + r2 + ' 0 1,0 ';\n\n      // drawing a circle with two half-arcs\n      var d = layer._empty() ? 'M0 0' : 'M' + (p.x - r) + ',' + p.y + arc + r * 2 + ',0 ' + arc + -r * 2 + ',0 ';\n      this._setPath(layer, d);\n    },\n    _setPath: function _setPath(layer, path) {\n      layer._path.setAttribute('d', path);\n    },\n    // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements\n    _bringToFront: function _bringToFront(layer) {\n      toFront(layer._path);\n    },\n    _bringToBack: function _bringToBack(layer) {\n      toBack(layer._path);\n    }\n  });\n  if (Browser.vml) {\n    SVG.include(vmlMixin);\n  }\n\n  // @namespace SVG\n  // @factory L.svg(options?: Renderer options)\n  // Creates a SVG renderer with the given options.\n  function svg(options) {\n    return Browser.svg || Browser.vml ? new SVG(options) : null;\n  }\n  Map.include({\n    // @namespace Map; @method getRenderer(layer: Path): Renderer\n    // Returns the instance of `Renderer` that should be used to render the given\n    // `Path`. It will ensure that the `renderer` options of the map and paths\n    // are respected, and that the renderers do exist on the map.\n    getRenderer: function getRenderer(layer) {\n      // @namespace Path; @option renderer: Renderer\n      // Use this specific instance of `Renderer` for this path. Takes\n      // precedence over the map's [default renderer](#map-renderer).\n      var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;\n      if (!renderer) {\n        renderer = this._renderer = this._createRenderer();\n      }\n      if (!this.hasLayer(renderer)) {\n        this.addLayer(renderer);\n      }\n      return renderer;\n    },\n    _getPaneRenderer: function _getPaneRenderer(name) {\n      if (name === 'overlayPane' || name === undefined) {\n        return false;\n      }\n      var renderer = this._paneRenderers[name];\n      if (renderer === undefined) {\n        renderer = this._createRenderer({\n          pane: name\n        });\n        this._paneRenderers[name] = renderer;\n      }\n      return renderer;\n    },\n    _createRenderer: function _createRenderer(options) {\n      // @namespace Map; @option preferCanvas: Boolean = false\n      // Whether `Path`s should be rendered on a `Canvas` renderer.\n      // By default, all `Path`s are rendered in a `SVG` renderer.\n      return this.options.preferCanvas && canvas(options) || svg(options);\n    }\n  });\n\n  /*\n   * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\n   */\n\n  /*\n   * @class Rectangle\n   * @aka L.Rectangle\n   * @inherits Polygon\n   *\n   * A class for drawing rectangle overlays on a map. Extends `Polygon`.\n   *\n   * @example\n   *\n   * ```js\n   * // define rectangle geographical bounds\n   * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];\n   *\n   * // create an orange rectangle\n   * L.rectangle(bounds, {color: \"#ff7800\", weight: 1}).addTo(map);\n   *\n   * // zoom the map to the rectangle bounds\n   * map.fitBounds(bounds);\n   * ```\n   *\n   */\n\n  var Rectangle = Polygon.extend({\n    initialize: function initialize(latLngBounds, options) {\n      Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\n    },\n    // @method setBounds(latLngBounds: LatLngBounds): this\n    // Redraws the rectangle with the passed bounds.\n    setBounds: function setBounds(latLngBounds) {\n      return this.setLatLngs(this._boundsToLatLngs(latLngBounds));\n    },\n    _boundsToLatLngs: function _boundsToLatLngs(latLngBounds) {\n      latLngBounds = toLatLngBounds(latLngBounds);\n      return [latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast()];\n    }\n  });\n\n  // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)\n  function rectangle(latLngBounds, options) {\n    return new Rectangle(latLngBounds, options);\n  }\n  SVG.create = create;\n  SVG.pointsToPath = pointsToPath;\n  GeoJSON.geometryToLayer = geometryToLayer;\n  GeoJSON.coordsToLatLng = coordsToLatLng;\n  GeoJSON.coordsToLatLngs = coordsToLatLngs;\n  GeoJSON.latLngToCoords = latLngToCoords;\n  GeoJSON.latLngsToCoords = latLngsToCoords;\n  GeoJSON.getFeature = getFeature;\n  GeoJSON.asFeature = asFeature;\n\n  /*\n   * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map\n   * (zoom to a selected bounding box), enabled by default.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n    // @option boxZoom: Boolean = true\n    // Whether the map can be zoomed to a rectangular area specified by\n    // dragging the mouse while pressing the shift key.\n    boxZoom: true\n  });\n  var BoxZoom = Handler.extend({\n    initialize: function initialize(map) {\n      this._map = map;\n      this._container = map._container;\n      this._pane = map._panes.overlayPane;\n      this._resetStateTimeout = 0;\n      map.on('unload', this._destroy, this);\n    },\n    addHooks: function addHooks() {\n      on(this._container, 'mousedown', this._onMouseDown, this);\n    },\n    removeHooks: function removeHooks() {\n      off(this._container, 'mousedown', this._onMouseDown, this);\n    },\n    moved: function moved() {\n      return this._moved;\n    },\n    _destroy: function _destroy() {\n      _remove(this._pane);\n      delete this._pane;\n    },\n    _resetState: function _resetState() {\n      this._resetStateTimeout = 0;\n      this._moved = false;\n    },\n    _clearDeferredResetState: function _clearDeferredResetState() {\n      if (this._resetStateTimeout !== 0) {\n        clearTimeout(this._resetStateTimeout);\n        this._resetStateTimeout = 0;\n      }\n    },\n    _onMouseDown: function _onMouseDown(e) {\n      if (!e.shiftKey || e.which !== 1 && e.button !== 1) {\n        return false;\n      }\n\n      // Clear the deferred resetState if it hasn't executed yet, otherwise it\n      // will interrupt the interaction and orphan a box element in the container.\n      this._clearDeferredResetState();\n      this._resetState();\n      disableTextSelection();\n      disableImageDrag();\n      this._startPoint = this._map.mouseEventToContainerPoint(e);\n      on(document, {\n        contextmenu: stop,\n        mousemove: this._onMouseMove,\n        mouseup: this._onMouseUp,\n        keydown: this._onKeyDown\n      }, this);\n    },\n    _onMouseMove: function _onMouseMove(e) {\n      if (!this._moved) {\n        this._moved = true;\n        this._box = create$1('div', 'leaflet-zoom-box', this._container);\n        addClass(this._container, 'leaflet-crosshair');\n        this._map.fire('boxzoomstart');\n      }\n      this._point = this._map.mouseEventToContainerPoint(e);\n      var bounds = new Bounds(this._point, this._startPoint),\n        size = bounds.getSize();\n      setPosition(this._box, bounds.min);\n      this._box.style.width = size.x + 'px';\n      this._box.style.height = size.y + 'px';\n    },\n    _finish: function _finish() {\n      if (this._moved) {\n        _remove(this._box);\n        removeClass(this._container, 'leaflet-crosshair');\n      }\n      enableTextSelection();\n      enableImageDrag();\n      off(document, {\n        contextmenu: stop,\n        mousemove: this._onMouseMove,\n        mouseup: this._onMouseUp,\n        keydown: this._onKeyDown\n      }, this);\n    },\n    _onMouseUp: function _onMouseUp(e) {\n      if (e.which !== 1 && e.button !== 1) {\n        return;\n      }\n      this._finish();\n      if (!this._moved) {\n        return;\n      }\n      // Postpone to next JS tick so internal click event handling\n      // still see it as \"moved\".\n      this._clearDeferredResetState();\n      this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);\n      var bounds = new LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));\n      this._map.fitBounds(bounds).fire('boxzoomend', {\n        boxZoomBounds: bounds\n      });\n    },\n    _onKeyDown: function _onKeyDown(e) {\n      if (e.keyCode === 27) {\n        this._finish();\n        this._clearDeferredResetState();\n        this._resetState();\n      }\n    }\n  });\n\n  // @section Handlers\n  // @property boxZoom: Handler\n  // Box (shift-drag with mouse) zoom handler.\n  Map.addInitHook('addHandler', 'boxZoom', BoxZoom);\n\n  /*\n   * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @option doubleClickZoom: Boolean|String = true\n    // Whether the map can be zoomed in by double clicking on it and\n    // zoomed out by double clicking while holding shift. If passed\n    // `'center'`, double-click zoom will zoom to the center of the\n    //  view regardless of where the mouse was.\n    doubleClickZoom: true\n  });\n  var DoubleClickZoom = Handler.extend({\n    addHooks: function addHooks() {\n      this._map.on('dblclick', this._onDoubleClick, this);\n    },\n    removeHooks: function removeHooks() {\n      this._map.off('dblclick', this._onDoubleClick, this);\n    },\n    _onDoubleClick: function _onDoubleClick(e) {\n      var map = this._map,\n        oldZoom = map.getZoom(),\n        delta = map.options.zoomDelta,\n        zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;\n      if (map.options.doubleClickZoom === 'center') {\n        map.setZoom(zoom);\n      } else {\n        map.setZoomAround(e.containerPoint, zoom);\n      }\n    }\n  });\n\n  // @section Handlers\n  //\n  // Map properties include interaction handlers that allow you to control\n  // interaction behavior in runtime, enabling or disabling certain features such\n  // as dragging or touch zoom (see `Handler` methods). For example:\n  //\n  // ```js\n  // map.doubleClickZoom.disable();\n  // ```\n  //\n  // @property doubleClickZoom: Handler\n  // Double click zoom handler.\n  Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);\n\n  /*\n   * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n    // @option dragging: Boolean = true\n    // Whether the map is draggable with mouse/touch or not.\n    dragging: true,\n    // @section Panning Inertia Options\n    // @option inertia: Boolean = *\n    // If enabled, panning of the map will have an inertia effect where\n    // the map builds momentum while dragging and continues moving in\n    // the same direction for some time. Feels especially nice on touch\n    // devices. Enabled by default.\n    inertia: true,\n    // @option inertiaDeceleration: Number = 3000\n    // The rate with which the inertial movement slows down, in pixels/second².\n    inertiaDeceleration: 3400,\n    // px/s^2\n\n    // @option inertiaMaxSpeed: Number = Infinity\n    // Max speed of the inertial movement, in pixels/second.\n    inertiaMaxSpeed: Infinity,\n    // px/s\n\n    // @option easeLinearity: Number = 0.2\n    easeLinearity: 0.2,\n    // TODO refactor, move to CRS\n    // @option worldCopyJump: Boolean = false\n    // With this option enabled, the map tracks when you pan to another \"copy\"\n    // of the world and seamlessly jumps to the original one so that all overlays\n    // like markers and vector layers are still visible.\n    worldCopyJump: false,\n    // @option maxBoundsViscosity: Number = 0.0\n    // If `maxBounds` is set, this option will control how solid the bounds\n    // are when dragging the map around. The default value of `0.0` allows the\n    // user to drag outside the bounds at normal speed, higher values will\n    // slow down map dragging outside bounds, and `1.0` makes the bounds fully\n    // solid, preventing the user from dragging outside the bounds.\n    maxBoundsViscosity: 0.0\n  });\n  var Drag = Handler.extend({\n    addHooks: function addHooks() {\n      if (!this._draggable) {\n        var map = this._map;\n        this._draggable = new Draggable(map._mapPane, map._container);\n        this._draggable.on({\n          dragstart: this._onDragStart,\n          drag: this._onDrag,\n          dragend: this._onDragEnd\n        }, this);\n        this._draggable.on('predrag', this._onPreDragLimit, this);\n        if (map.options.worldCopyJump) {\n          this._draggable.on('predrag', this._onPreDragWrap, this);\n          map.on('zoomend', this._onZoomEnd, this);\n          map.whenReady(this._onZoomEnd, this);\n        }\n      }\n      addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');\n      this._draggable.enable();\n      this._positions = [];\n      this._times = [];\n    },\n    removeHooks: function removeHooks() {\n      removeClass(this._map._container, 'leaflet-grab');\n      removeClass(this._map._container, 'leaflet-touch-drag');\n      this._draggable.disable();\n    },\n    moved: function moved() {\n      return this._draggable && this._draggable._moved;\n    },\n    moving: function moving() {\n      return this._draggable && this._draggable._moving;\n    },\n    _onDragStart: function _onDragStart() {\n      var map = this._map;\n      map._stop();\n      if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {\n        var bounds = toLatLngBounds(this._map.options.maxBounds);\n        this._offsetLimit = toBounds(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));\n        this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));\n      } else {\n        this._offsetLimit = null;\n      }\n      map.fire('movestart').fire('dragstart');\n      if (map.options.inertia) {\n        this._positions = [];\n        this._times = [];\n      }\n    },\n    _onDrag: function _onDrag(e) {\n      if (this._map.options.inertia) {\n        var time = this._lastTime = +new Date(),\n          pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;\n        this._positions.push(pos);\n        this._times.push(time);\n        this._prunePositions(time);\n      }\n      this._map.fire('move', e).fire('drag', e);\n    },\n    _prunePositions: function _prunePositions(time) {\n      while (this._positions.length > 1 && time - this._times[0] > 50) {\n        this._positions.shift();\n        this._times.shift();\n      }\n    },\n    _onZoomEnd: function _onZoomEnd() {\n      var pxCenter = this._map.getSize().divideBy(2),\n        pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n      this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n      this._worldWidth = this._map.getPixelWorldBounds().getSize().x;\n    },\n    _viscousLimit: function _viscousLimit(value, threshold) {\n      return value - (value - threshold) * this._viscosity;\n    },\n    _onPreDragLimit: function _onPreDragLimit() {\n      if (!this._viscosity || !this._offsetLimit) {\n        return;\n      }\n      var offset = this._draggable._newPos.subtract(this._draggable._startPos);\n      var limit = this._offsetLimit;\n      if (offset.x < limit.min.x) {\n        offset.x = this._viscousLimit(offset.x, limit.min.x);\n      }\n      if (offset.y < limit.min.y) {\n        offset.y = this._viscousLimit(offset.y, limit.min.y);\n      }\n      if (offset.x > limit.max.x) {\n        offset.x = this._viscousLimit(offset.x, limit.max.x);\n      }\n      if (offset.y > limit.max.y) {\n        offset.y = this._viscousLimit(offset.y, limit.max.y);\n      }\n      this._draggable._newPos = this._draggable._startPos.add(offset);\n    },\n    _onPreDragWrap: function _onPreDragWrap() {\n      // TODO refactor to be able to adjust map pane position after zoom\n      var worldWidth = this._worldWidth,\n        halfWidth = Math.round(worldWidth / 2),\n        dx = this._initialWorldOffset,\n        x = this._draggable._newPos.x,\n        newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n        newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n        newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n      this._draggable._absPos = this._draggable._newPos.clone();\n      this._draggable._newPos.x = newX;\n    },\n    _onDragEnd: function _onDragEnd(e) {\n      var map = this._map,\n        options = map.options,\n        noInertia = !options.inertia || e.noInertia || this._times.length < 2;\n      map.fire('dragend', e);\n      if (noInertia) {\n        map.fire('moveend');\n      } else {\n        this._prunePositions(+new Date());\n        var direction = this._lastPos.subtract(this._positions[0]),\n          duration = (this._lastTime - this._times[0]) / 1000,\n          ease = options.easeLinearity,\n          speedVector = direction.multiplyBy(ease / duration),\n          speed = speedVector.distanceTo([0, 0]),\n          limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n          limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n          decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n          offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n        if (!offset.x && !offset.y) {\n          map.fire('moveend');\n        } else {\n          offset = map._limitOffset(offset, map.options.maxBounds);\n          requestAnimFrame(function () {\n            map.panBy(offset, {\n              duration: decelerationDuration,\n              easeLinearity: ease,\n              noMoveStart: true,\n              animate: true\n            });\n          });\n        }\n      }\n    }\n  });\n\n  // @section Handlers\n  // @property dragging: Handler\n  // Map dragging handler (by both mouse and touch).\n  Map.addInitHook('addHandler', 'dragging', Drag);\n\n  /*\n   * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n   */\n\n  // @namespace Map\n  // @section Keyboard Navigation Options\n  Map.mergeOptions({\n    // @option keyboard: Boolean = true\n    // Makes the map focusable and allows users to navigate the map with keyboard\n    // arrows and `+`/`-` keys.\n    keyboard: true,\n    // @option keyboardPanDelta: Number = 80\n    // Amount of pixels to pan when pressing an arrow key.\n    keyboardPanDelta: 80\n  });\n  var Keyboard = Handler.extend({\n    keyCodes: {\n      left: [37],\n      right: [39],\n      down: [40],\n      up: [38],\n      zoomIn: [187, 107, 61, 171],\n      zoomOut: [189, 109, 54, 173]\n    },\n    initialize: function initialize(map) {\n      this._map = map;\n      this._setPanDelta(map.options.keyboardPanDelta);\n      this._setZoomDelta(map.options.zoomDelta);\n    },\n    addHooks: function addHooks() {\n      var container = this._map._container;\n\n      // make the container focusable by tabbing\n      if (container.tabIndex <= 0) {\n        container.tabIndex = '0';\n      }\n      on(container, {\n        focus: this._onFocus,\n        blur: this._onBlur,\n        mousedown: this._onMouseDown\n      }, this);\n      this._map.on({\n        focus: this._addHooks,\n        blur: this._removeHooks\n      }, this);\n    },\n    removeHooks: function removeHooks() {\n      this._removeHooks();\n      off(this._map._container, {\n        focus: this._onFocus,\n        blur: this._onBlur,\n        mousedown: this._onMouseDown\n      }, this);\n      this._map.off({\n        focus: this._addHooks,\n        blur: this._removeHooks\n      }, this);\n    },\n    _onMouseDown: function _onMouseDown() {\n      if (this._focused) {\n        return;\n      }\n      var body = document.body,\n        docEl = document.documentElement,\n        top = body.scrollTop || docEl.scrollTop,\n        left = body.scrollLeft || docEl.scrollLeft;\n      this._map._container.focus();\n      window.scrollTo(left, top);\n    },\n    _onFocus: function _onFocus() {\n      this._focused = true;\n      this._map.fire('focus');\n    },\n    _onBlur: function _onBlur() {\n      this._focused = false;\n      this._map.fire('blur');\n    },\n    _setPanDelta: function _setPanDelta(panDelta) {\n      var keys = this._panKeys = {},\n        codes = this.keyCodes,\n        i,\n        len;\n      for (i = 0, len = codes.left.length; i < len; i++) {\n        keys[codes.left[i]] = [-1 * panDelta, 0];\n      }\n      for (i = 0, len = codes.right.length; i < len; i++) {\n        keys[codes.right[i]] = [panDelta, 0];\n      }\n      for (i = 0, len = codes.down.length; i < len; i++) {\n        keys[codes.down[i]] = [0, panDelta];\n      }\n      for (i = 0, len = codes.up.length; i < len; i++) {\n        keys[codes.up[i]] = [0, -1 * panDelta];\n      }\n    },\n    _setZoomDelta: function _setZoomDelta(zoomDelta) {\n      var keys = this._zoomKeys = {},\n        codes = this.keyCodes,\n        i,\n        len;\n      for (i = 0, len = codes.zoomIn.length; i < len; i++) {\n        keys[codes.zoomIn[i]] = zoomDelta;\n      }\n      for (i = 0, len = codes.zoomOut.length; i < len; i++) {\n        keys[codes.zoomOut[i]] = -zoomDelta;\n      }\n    },\n    _addHooks: function _addHooks() {\n      on(document, 'keydown', this._onKeyDown, this);\n    },\n    _removeHooks: function _removeHooks() {\n      off(document, 'keydown', this._onKeyDown, this);\n    },\n    _onKeyDown: function _onKeyDown(e) {\n      if (e.altKey || e.ctrlKey || e.metaKey) {\n        return;\n      }\n      var key = e.keyCode,\n        map = this._map,\n        offset;\n      if (key in this._panKeys) {\n        if (!map._panAnim || !map._panAnim._inProgress) {\n          offset = this._panKeys[key];\n          if (e.shiftKey) {\n            offset = toPoint(offset).multiplyBy(3);\n          }\n          if (map.options.maxBounds) {\n            offset = map._limitOffset(toPoint(offset), map.options.maxBounds);\n          }\n          if (map.options.worldCopyJump) {\n            var newLatLng = map.wrapLatLng(map.unproject(map.project(map.getCenter()).add(offset)));\n            map.panTo(newLatLng);\n          } else {\n            map.panBy(offset);\n          }\n        }\n      } else if (key in this._zoomKeys) {\n        map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);\n      } else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {\n        map.closePopup();\n      } else {\n        return;\n      }\n      stop(e);\n    }\n  });\n\n  // @section Handlers\n  // @section Handlers\n  // @property keyboard: Handler\n  // Keyboard navigation handler.\n  Map.addInitHook('addHandler', 'keyboard', Keyboard);\n\n  /*\n   * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n    // @section Mouse wheel options\n    // @option scrollWheelZoom: Boolean|String = true\n    // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,\n    // it will zoom to the center of the view regardless of where the mouse was.\n    scrollWheelZoom: true,\n    // @option wheelDebounceTime: Number = 40\n    // Limits the rate at which a wheel can fire (in milliseconds). By default\n    // user can't zoom via wheel more often than once per 40 ms.\n    wheelDebounceTime: 40,\n    // @option wheelPxPerZoomLevel: Number = 60\n    // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))\n    // mean a change of one full zoom level. Smaller values will make wheel-zooming\n    // faster (and vice versa).\n    wheelPxPerZoomLevel: 60\n  });\n  var ScrollWheelZoom = Handler.extend({\n    addHooks: function addHooks() {\n      on(this._map._container, 'wheel', this._onWheelScroll, this);\n      this._delta = 0;\n    },\n    removeHooks: function removeHooks() {\n      off(this._map._container, 'wheel', this._onWheelScroll, this);\n    },\n    _onWheelScroll: function _onWheelScroll(e) {\n      var delta = getWheelDelta(e);\n      var debounce = this._map.options.wheelDebounceTime;\n      this._delta += delta;\n      this._lastMousePos = this._map.mouseEventToContainerPoint(e);\n      if (!this._startTime) {\n        this._startTime = +new Date();\n      }\n      var left = Math.max(debounce - (+new Date() - this._startTime), 0);\n      clearTimeout(this._timer);\n      this._timer = setTimeout(bind(this._performZoom, this), left);\n      stop(e);\n    },\n    _performZoom: function _performZoom() {\n      var map = this._map,\n        zoom = map.getZoom(),\n        snap = this._map.options.zoomSnap || 0;\n      map._stop(); // stop panning and fly animations if any\n\n      // map the delta with a sigmoid function to -4..4 range leaning on -1..1\n      var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),\n        d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,\n        d4 = snap ? Math.ceil(d3 / snap) * snap : d3,\n        delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;\n      this._delta = 0;\n      this._startTime = null;\n      if (!delta) {\n        return;\n      }\n      if (map.options.scrollWheelZoom === 'center') {\n        map.setZoom(zoom + delta);\n      } else {\n        map.setZoomAround(this._lastMousePos, zoom + delta);\n      }\n    }\n  });\n\n  // @section Handlers\n  // @property scrollWheelZoom: Handler\n  // Scroll wheel zoom handler.\n  Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);\n\n  /*\n   * L.Map.TapHold is used to simulate `contextmenu` event on long hold,\n   * which otherwise is not fired by mobile Safari.\n   */\n\n  var tapHoldDelay = 600;\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n    // @section Touch interaction options\n    // @option tapHold: Boolean\n    // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.\n    tapHold: Browser.touchNative && Browser.safari && Browser.mobile,\n    // @option tapTolerance: Number = 15\n    // The max number of pixels a user can shift his finger during touch\n    // for it to be considered a valid tap.\n    tapTolerance: 15\n  });\n  var TapHold = Handler.extend({\n    addHooks: function addHooks() {\n      on(this._map._container, 'touchstart', this._onDown, this);\n    },\n    removeHooks: function removeHooks() {\n      off(this._map._container, 'touchstart', this._onDown, this);\n    },\n    _onDown: function _onDown(e) {\n      clearTimeout(this._holdTimeout);\n      if (e.touches.length !== 1) {\n        return;\n      }\n      var first = e.touches[0];\n      this._startPos = this._newPos = new Point(first.clientX, first.clientY);\n      this._holdTimeout = setTimeout(bind(function () {\n        this._cancel();\n        if (!this._isTapValid()) {\n          return;\n        }\n\n        // prevent simulated mouse events https://w3c.github.io/touch-events/#mouse-events\n        on(document, 'touchend', preventDefault);\n        on(document, 'touchend touchcancel', this._cancelClickPrevent);\n        this._simulateEvent('contextmenu', first);\n      }, this), tapHoldDelay);\n      on(document, 'touchend touchcancel contextmenu', this._cancel, this);\n      on(document, 'touchmove', this._onMove, this);\n    },\n    _cancelClickPrevent: function cancelClickPrevent() {\n      off(document, 'touchend', preventDefault);\n      off(document, 'touchend touchcancel', cancelClickPrevent);\n    },\n    _cancel: function _cancel() {\n      clearTimeout(this._holdTimeout);\n      off(document, 'touchend touchcancel contextmenu', this._cancel, this);\n      off(document, 'touchmove', this._onMove, this);\n    },\n    _onMove: function _onMove(e) {\n      var first = e.touches[0];\n      this._newPos = new Point(first.clientX, first.clientY);\n    },\n    _isTapValid: function _isTapValid() {\n      return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n    },\n    _simulateEvent: function _simulateEvent(type, e) {\n      var simulatedEvent = new MouseEvent(type, {\n        bubbles: true,\n        cancelable: true,\n        view: window,\n        // detail: 1,\n        screenX: e.screenX,\n        screenY: e.screenY,\n        clientX: e.clientX,\n        clientY: e.clientY\n        // button: 2,\n        // buttons: 2\n      });\n      simulatedEvent._simulated = true;\n      e.target.dispatchEvent(simulatedEvent);\n    }\n  });\n\n  // @section Handlers\n  // @property tapHold: Handler\n  // Long tap handler to simulate `contextmenu` event (useful in mobile Safari).\n  Map.addInitHook('addHandler', 'tapHold', TapHold);\n\n  /*\n   * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n    // @section Touch interaction options\n    // @option touchZoom: Boolean|String = *\n    // Whether the map can be zoomed by touch-dragging with two fingers. If\n    // passed `'center'`, it will zoom to the center of the view regardless of\n    // where the touch events (fingers) were. Enabled for touch-capable web\n    // browsers.\n    touchZoom: Browser.touch,\n    // @option bounceAtZoomLimits: Boolean = true\n    // Set it to false if you don't want the map to zoom beyond min/max zoom\n    // and then bounce back when pinch-zooming.\n    bounceAtZoomLimits: true\n  });\n  var TouchZoom = Handler.extend({\n    addHooks: function addHooks() {\n      addClass(this._map._container, 'leaflet-touch-zoom');\n      on(this._map._container, 'touchstart', this._onTouchStart, this);\n    },\n    removeHooks: function removeHooks() {\n      removeClass(this._map._container, 'leaflet-touch-zoom');\n      off(this._map._container, 'touchstart', this._onTouchStart, this);\n    },\n    _onTouchStart: function _onTouchStart(e) {\n      var map = this._map;\n      if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {\n        return;\n      }\n      var p1 = map.mouseEventToContainerPoint(e.touches[0]),\n        p2 = map.mouseEventToContainerPoint(e.touches[1]);\n      this._centerPoint = map.getSize()._divideBy(2);\n      this._startLatLng = map.containerPointToLatLng(this._centerPoint);\n      if (map.options.touchZoom !== 'center') {\n        this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));\n      }\n      this._startDist = p1.distanceTo(p2);\n      this._startZoom = map.getZoom();\n      this._moved = false;\n      this._zooming = true;\n      map._stop();\n      on(document, 'touchmove', this._onTouchMove, this);\n      on(document, 'touchend touchcancel', this._onTouchEnd, this);\n      preventDefault(e);\n    },\n    _onTouchMove: function _onTouchMove(e) {\n      if (!e.touches || e.touches.length !== 2 || !this._zooming) {\n        return;\n      }\n      var map = this._map,\n        p1 = map.mouseEventToContainerPoint(e.touches[0]),\n        p2 = map.mouseEventToContainerPoint(e.touches[1]),\n        scale = p1.distanceTo(p2) / this._startDist;\n      this._zoom = map.getScaleZoom(scale, this._startZoom);\n      if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1)) {\n        this._zoom = map._limitZoom(this._zoom);\n      }\n      if (map.options.touchZoom === 'center') {\n        this._center = this._startLatLng;\n        if (scale === 1) {\n          return;\n        }\n      } else {\n        // Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng\n        var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);\n        if (scale === 1 && delta.x === 0 && delta.y === 0) {\n          return;\n        }\n        this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);\n      }\n      if (!this._moved) {\n        map._moveStart(true, false);\n        this._moved = true;\n      }\n      cancelAnimFrame(this._animRequest);\n      var moveFn = bind(map._move, map, this._center, this._zoom, {\n        pinch: true,\n        round: false\n      }, undefined);\n      this._animRequest = requestAnimFrame(moveFn, this, true);\n      preventDefault(e);\n    },\n    _onTouchEnd: function _onTouchEnd() {\n      if (!this._moved || !this._zooming) {\n        this._zooming = false;\n        return;\n      }\n      this._zooming = false;\n      cancelAnimFrame(this._animRequest);\n      off(document, 'touchmove', this._onTouchMove, this);\n      off(document, 'touchend touchcancel', this._onTouchEnd, this);\n\n      // Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.\n      if (this._map.options.zoomAnimation) {\n        this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);\n      } else {\n        this._map._resetView(this._center, this._map._limitZoom(this._zoom));\n      }\n    }\n  });\n\n  // @section Handlers\n  // @property touchZoom: Handler\n  // Touch zoom handler.\n  Map.addInitHook('addHandler', 'touchZoom', TouchZoom);\n  Map.BoxZoom = BoxZoom;\n  Map.DoubleClickZoom = DoubleClickZoom;\n  Map.Drag = Drag;\n  Map.Keyboard = Keyboard;\n  Map.ScrollWheelZoom = ScrollWheelZoom;\n  Map.TapHold = TapHold;\n  Map.TouchZoom = TouchZoom;\n  exports.Bounds = Bounds;\n  exports.Browser = Browser;\n  exports.CRS = CRS;\n  exports.Canvas = Canvas;\n  exports.Circle = Circle;\n  exports.CircleMarker = CircleMarker;\n  exports.Class = Class;\n  exports.Control = Control;\n  exports.DivIcon = DivIcon;\n  exports.DivOverlay = DivOverlay;\n  exports.DomEvent = DomEvent;\n  exports.DomUtil = DomUtil;\n  exports.Draggable = Draggable;\n  exports.Evented = Evented;\n  exports.FeatureGroup = FeatureGroup;\n  exports.GeoJSON = GeoJSON;\n  exports.GridLayer = GridLayer;\n  exports.Handler = Handler;\n  exports.Icon = Icon;\n  exports.ImageOverlay = ImageOverlay;\n  exports.LatLng = LatLng;\n  exports.LatLngBounds = LatLngBounds;\n  exports.Layer = Layer;\n  exports.LayerGroup = LayerGroup;\n  exports.LineUtil = LineUtil;\n  exports.Map = Map;\n  exports.Marker = Marker;\n  exports.Mixin = Mixin;\n  exports.Path = Path;\n  exports.Point = Point;\n  exports.PolyUtil = PolyUtil;\n  exports.Polygon = Polygon;\n  exports.Polyline = Polyline;\n  exports.Popup = Popup;\n  exports.PosAnimation = PosAnimation;\n  exports.Projection = index;\n  exports.Rectangle = Rectangle;\n  exports.Renderer = Renderer;\n  exports.SVG = SVG;\n  exports.SVGOverlay = SVGOverlay;\n  exports.TileLayer = TileLayer;\n  exports.Tooltip = Tooltip;\n  exports.Transformation = Transformation;\n  exports.Util = Util;\n  exports.VideoOverlay = VideoOverlay;\n  exports.bind = bind;\n  exports.bounds = toBounds;\n  exports.canvas = canvas;\n  exports.circle = circle;\n  exports.circleMarker = circleMarker;\n  exports.control = control;\n  exports.divIcon = divIcon;\n  exports.extend = extend;\n  exports.featureGroup = featureGroup;\n  exports.geoJSON = geoJSON;\n  exports.geoJson = geoJson;\n  exports.gridLayer = gridLayer;\n  exports.icon = icon;\n  exports.imageOverlay = imageOverlay;\n  exports.latLng = toLatLng;\n  exports.latLngBounds = toLatLngBounds;\n  exports.layerGroup = layerGroup;\n  exports.map = createMap;\n  exports.marker = marker;\n  exports.point = toPoint;\n  exports.polygon = polygon;\n  exports.polyline = polyline;\n  exports.popup = popup;\n  exports.rectangle = rectangle;\n  exports.setOptions = setOptions;\n  exports.stamp = stamp;\n  exports.svg = svg;\n  exports.svgOverlay = svgOverlay;\n  exports.tileLayer = tileLayer;\n  exports.tooltip = tooltip;\n  exports.transformation = toTransformation;\n  exports.version = version;\n  exports.videoOverlay = videoOverlay;\n  var oldL = window.L;\n  exports.noConflict = function () {\n    window.L = oldL;\n    return this;\n  };\n  // Always export us to window global (see #2364)\n  window.L = exports;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQtc3JjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7RUFBQTs7Ozs7O0VBTUE7RUFDQTtFQUNPLFNBQVNBLE1BQU1BLENBQUNDLElBQUksRUFBRTtJQUM1QixJQUFJQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsR0FBRyxFQUFFQyxHQUFHO0lBRWxCLEtBQUtGLENBQUMsR0FBRyxDQUFDLEVBQUVDLEdBQUcsR0FBR0UsU0FBUyxDQUFDQyxNQUFNLEVBQUVKLENBQUMsR0FBR0MsR0FBRyxFQUFFRCxDQUFDLEVBQUUsRUFBRTtNQUNqREUsR0FBRyxHQUFHQyxTQUFTLENBQUNILENBQUMsQ0FBQztNQUNsQixLQUFLRCxDQUFDLElBQUlHLEdBQUcsRUFBRTtRQUNkSixJQUFJLENBQUNDLENBQUMsQ0FBQyxHQUFHRyxHQUFHLENBQUNILENBQUMsQ0FBQztNQUNuQjtJQUNBO0lBQ0MsT0FBT0QsSUFBSTtFQUNaOztFQUVBO0VBQ0E7RUFDTyxJQUFJTyxRQUFNLEdBQUdDLE1BQU0sQ0FBQ0MsTUFBTSxJQUFLLFlBQVk7SUFDakQsU0FBU0MsQ0FBQ0EsQ0FBQSxFQUFHO0lBQ2IsT0FBTyxVQUFVQyxLQUFLLEVBQUU7TUFDdkJELENBQUMsQ0FBQ0UsU0FBUyxHQUFHRCxLQUFLO01BQ25CLE9BQU8sSUFBSUQsQ0FBQyxFQUFFO0lBQ2hCLENBQUU7RUFDRixDQUFDLEVBQUc7O0VBRUo7RUFDQTtFQUNBO0VBQ08sU0FBU0csSUFBSUEsQ0FBQ0MsRUFBRSxFQUFFQyxHQUFHLEVBQUU7SUFDN0IsSUFBSUMsS0FBSyxHQUFHQyxLQUFLLENBQUNMLFNBQVMsQ0FBQ0ksS0FBSztJQUVqQyxJQUFJRixFQUFFLENBQUNELElBQUksRUFBRTtNQUNaLE9BQU9DLEVBQUUsQ0FBQ0QsSUFBSSxDQUFDSyxLQUFLLENBQUNKLEVBQUUsRUFBRUUsS0FBSyxDQUFDRyxJQUFJLENBQUNkLFNBQVMsRUFBRSxDQUFDLENB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QUN1K0IsT0FBTyxFQUFFLElBQUksQ0FBQ3p2QixJQUFJLENBQUMvUCxVQUFVLENBQUMsSUFBSSxDQUFDRCxLQUFLLENBQUMsQ0FBQztNQUN2RTtJQUNBO0VBQ0EsQ0FBQyxDQUFDOztFQUVGO0VBQ0E7RUFDQTtFQUNBeEIsR0FBRyxDQUFDbmQsV0FBVyxDQUFDLFlBQVksRUFBRSxXQUFXLEVBQUVtcEQsU0FBUyxDQUFDO0VDL0hyRGhzQyxHQUFHLENBQUNvbEMsT0FBTyxHQUFHQSxPQUFPO0VBRXJCcGxDLEdBQUcsQ0FBQ29tQyxlQUFlLEdBQUdBLGVBQWU7RUFFckNwbUMsR0FBRyxDQUFDMm1DLElBQUksR0FBR0EsSUFBSTtFQUVmM21DLEdBQUcsQ0FBQ3lvQyxRQUFRLEdBQUdBLFFBQVE7RUFFdkJ6b0MsR0FBRyxDQUFDb3FDLGVBQWUsR0FBR0EsZUFBZTtFQUVyQ3BxQyxHQUFHLENBQUNpckMsT0FBTyxHQUFHQSxPQUFPO0VBRXJCanJDLEdBQUcsQ0FBQ2dzQyxTQUFTLEdBQUdBLFNBQVMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9jb3JlL1V0aWwuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvY29yZS9DbGFzcy5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9jb3JlL0V2ZW50cy5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9nZW9tZXRyeS9Qb2ludC5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9nZW9tZXRyeS9Cb3VuZHMuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvZ2VvL0xhdExuZ0JvdW5kcy5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9nZW8vTGF0TG5nLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2dlby9jcnMvQ1JTLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2dlby9jcnMvQ1JTLkVhcnRoLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2dlby9wcm9qZWN0aW9uL1Byb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3IuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24uanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvZ2VvL2Nycy9DUlMuRVBTRzM4NTcuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvbGF5ZXIvdmVjdG9yL1NWRy5VdGlsLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2NvcmUvQnJvd3Nlci5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9kb20vRG9tRXZlbnQuUG9pbnRlci5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9kb20vRG9tRXZlbnQuRG91YmxlVGFwLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2RvbS9Eb21VdGlsLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2RvbS9Eb21FdmVudC5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9kb20vUG9zQW5pbWF0aW9uLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL21hcC9NYXAuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvY29udHJvbC9Db250cm9sLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2NvbnRyb2wvQ29udHJvbC5MYXllcnMuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvY29udHJvbC9Db250cm9sLlpvb20uanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvY29udHJvbC9Db250cm9sLlNjYWxlLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2NvbnRyb2wvQ29udHJvbC5BdHRyaWJ1dGlvbi5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9jb250cm9sL2luZGV4LmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2NvcmUvSGFuZGxlci5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9jb3JlL2luZGV4LmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2RvbS9EcmFnZ2FibGUuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvZ2VvbWV0cnkvUG9seVV0aWwuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvZ2VvbWV0cnkvTGluZVV0aWwuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5Mb25MYXQuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5NZXJjYXRvci5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9nZW8vcHJvamVjdGlvbi9pbmRleC5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9nZW8vY3JzL0NSUy5FUFNHMzM5NS5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9nZW8vY3JzL0NSUy5FUFNHNDMyNi5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9nZW8vY3JzL0NSUy5TaW1wbGUuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvZ2VvL2Nycy9pbmRleC5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci9MYXllci5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci9MYXllckdyb3VwLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL0ZlYXR1cmVHcm91cC5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci9tYXJrZXIvSWNvbi5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci9tYXJrZXIvSWNvbi5EZWZhdWx0LmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL21hcmtlci9NYXJrZXIuRHJhZy5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci9tYXJrZXIvTWFya2VyLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL3ZlY3Rvci9QYXRoLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL3ZlY3Rvci9DaXJjbGVNYXJrZXIuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvbGF5ZXIvdmVjdG9yL0NpcmNsZS5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci92ZWN0b3IvUG9seWxpbmUuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvbGF5ZXIvdmVjdG9yL1BvbHlnb24uanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvbGF5ZXIvR2VvSlNPTi5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci9JbWFnZU92ZXJsYXkuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvbGF5ZXIvVmlkZW9PdmVybGF5LmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL1NWR092ZXJsYXkuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvbGF5ZXIvRGl2T3ZlcmxheS5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci9Qb3B1cC5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci9Ub29sdGlwLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL21hcmtlci9EaXZJY29uLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL21hcmtlci9pbmRleC5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci90aWxlL0dyaWRMYXllci5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci90aWxlL1RpbGVMYXllci5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci90aWxlL1RpbGVMYXllci5XTVMuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvbGF5ZXIvdGlsZS9pbmRleC5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci92ZWN0b3IvUmVuZGVyZXIuanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvbGF5ZXIvdmVjdG9yL0NhbnZhcy5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci92ZWN0b3IvU1ZHLlZNTC5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci92ZWN0b3IvU1ZHLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL3ZlY3Rvci9SZW5kZXJlci5nZXRSZW5kZXJlci5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci92ZWN0b3IvUmVjdGFuZ2xlLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL2xheWVyL3ZlY3Rvci9pbmRleC5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9sYXllci9pbmRleC5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9tYXAvaGFuZGxlci9NYXAuQm94Wm9vbS5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9tYXAvaGFuZGxlci9NYXAuRG91YmxlQ2xpY2tab29tLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL21hcC9oYW5kbGVyL01hcC5EcmFnLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL21hcC9oYW5kbGVyL01hcC5LZXlib2FyZC5qcyIsIi9Vc2Vycy9zYXJ0aGFrMjE1cy9Eb2N1bWVudHMvR2l0SHViL3NyYy9tYXAvaGFuZGxlci9NYXAuU2Nyb2xsV2hlZWxab29tLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL21hcC9oYW5kbGVyL01hcC5UYXBIb2xkLmpzIiwiL1VzZXJzL3NhcnRoYWsyMTVzL0RvY3VtZW50cy9HaXRIdWIvc3JjL21hcC9oYW5kbGVyL01hcC5Ub3VjaFpvb20uanMiLCIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9zcmMvbWFwL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIEBuYW1lc3BhY2UgVXRpbFxyXG4gKlxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICovXHJcblxyXG4vLyBAZnVuY3Rpb24gZXh0ZW5kKGRlc3Q6IE9iamVjdCwgc3JjPzogT2JqZWN0KTogT2JqZWN0XHJcbi8vIE1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgYHNyY2Agb2JqZWN0IChvciBtdWx0aXBsZSBvYmplY3RzKSBpbnRvIGBkZXN0YCBvYmplY3QgYW5kIHJldHVybnMgdGhlIGxhdHRlci4gSGFzIGFuIGBMLmV4dGVuZGAgc2hvcnRjdXQuXHJcbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQoZGVzdCkge1xyXG5cdHZhciBpLCBqLCBsZW4sIHNyYztcclxuXHJcblx0Zm9yIChqID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XHJcblx0XHRzcmMgPSBhcmd1bWVudHNbal07XHJcblx0XHRmb3IgKGkgaW4gc3JjKSB7XHJcblx0XHRcdGRlc3RbaV0gPSBzcmNbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBkZXN0O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY3JlYXRlKHByb3RvOiBPYmplY3QsIHByb3BlcnRpZXM/OiBPYmplY3QpOiBPYmplY3RcclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW09iamVjdC5jcmVhdGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9jcmVhdGUpXHJcbmV4cG9ydCB2YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24gKCkge1xyXG5cdGZ1bmN0aW9uIEYoKSB7fVxyXG5cdHJldHVybiBmdW5jdGlvbiAocHJvdG8pIHtcclxuXHRcdEYucHJvdG90eXBlID0gcHJvdG87XHJcblx0XHRyZXR1cm4gbmV3IEYoKTtcclxuXHR9O1xyXG59KSgpO1xyXG5cclxuLy8gQGZ1bmN0aW9uIGJpbmQoZm46IEZ1bmN0aW9uLCDigKYpOiBGdW5jdGlvblxyXG4vLyBSZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBhcmd1bWVudHMgcGFzc2VkLCBsaWtlIFtGdW5jdGlvbi5wcm90b3R5cGUuYmluZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZCkuXHJcbi8vIEhhcyBhIGBMLmJpbmQoKWAgc2hvcnRjdXQuXHJcbmV4cG9ydCBmdW5jdGlvbiBiaW5kKGZuLCBvYmopIHtcclxuXHR2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XHJcblxyXG5cdGlmIChmbi5iaW5kKSB7XHJcblx0XHRyZXR1cm4gZm4uYmluZC5hcHBseShmbiwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcclxuXHR9XHJcblxyXG5cdHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5sZW5ndGggPyBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpIDogYXJndW1lbnRzKTtcclxuXHR9O1xyXG59XHJcblxyXG4vLyBAcHJvcGVydHkgbGFzdElkOiBOdW1iZXJcclxuLy8gTGFzdCB1bmlxdWUgSUQgdXNlZCBieSBbYHN0YW1wKClgXSgjdXRpbC1zdGFtcClcclxuZXhwb3J0IHZhciBsYXN0SWQgPSAwO1xyXG5cclxuLy8gQGZ1bmN0aW9uIHN0YW1wKG9iajogT2JqZWN0KTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIHVuaXF1ZSBJRCBvZiBhbiBvYmplY3QsIGFzc2lnbmluZyBpdCBvbmUgaWYgaXQgZG9lc24ndCBoYXZlIGl0LlxyXG5leHBvcnQgZnVuY3Rpb24gc3RhbXAob2JqKSB7XHJcblx0aWYgKCEoJ19sZWFmbGV0X2lkJyBpbiBvYmopKSB7XHJcblx0XHRvYmpbJ19sZWFmbGV0X2lkJ10gPSArK2xhc3RJZDtcclxuXHR9XHJcblx0cmV0dXJuIG9iai5fbGVhZmxldF9pZDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRocm90dGxlKGZuOiBGdW5jdGlvbiwgdGltZTogTnVtYmVyLCBjb250ZXh0OiBPYmplY3QpOiBGdW5jdGlvblxyXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZXhlY3V0ZXMgZnVuY3Rpb24gYGZuYCB3aXRoIHRoZSBnaXZlbiBzY29wZSBgY29udGV4dGBcclxuLy8gKHNvIHRoYXQgdGhlIGB0aGlzYCBrZXl3b3JkIHJlZmVycyB0byBgY29udGV4dGAgaW5zaWRlIGBmbmAncyBjb2RlKS4gVGhlIGZ1bmN0aW9uXHJcbi8vIGBmbmAgd2lsbCBiZSBjYWxsZWQgbm8gbW9yZSB0aGFuIG9uZSB0aW1lIHBlciBnaXZlbiBhbW91bnQgb2YgYHRpbWVgLiBUaGUgYXJndW1lbnRzXHJcbi8vIHJlY2VpdmVkIGJ5IHRoZSBib3VuZCBmdW5jdGlvbiB3aWxsIGJlIGFueSBhcmd1bWVudHMgcGFzc2VkIHdoZW4gYmluZGluZyB0aGVcclxuLy8gZnVuY3Rpb24sIGZvbGxvd2VkIGJ5IGFueSBhcmd1bWVudHMgcGFzc2VkIHdoZW4gaW52b2tpbmcgdGhlIGJvdW5kIGZ1bmN0aW9uLlxyXG4vLyBIYXMgYW4gYEwudGhyb3R0bGVgIHNob3J0Y3V0LlxyXG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGUoZm4sIHRpbWUsIGNvbnRleHQpIHtcclxuXHR2YXIgbG9jaywgYXJncywgd3JhcHBlckZuLCBsYXRlcjtcclxuXHJcblx0bGF0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyByZXNldCBsb2NrIGFuZCBjYWxsIGlmIHF1ZXVlZFxyXG5cdFx0bG9jayA9IGZhbHNlO1xyXG5cdFx0aWYgKGFyZ3MpIHtcclxuXHRcdFx0d3JhcHBlckZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG5cdFx0XHRhcmdzID0gZmFsc2U7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0d3JhcHBlckZuID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKGxvY2spIHtcclxuXHRcdFx0Ly8gY2FsbGVkIHRvbyBzb29uLCBxdWV1ZSB0byBjYWxsIGxhdGVyXHJcblx0XHRcdGFyZ3MgPSBhcmd1bWVudHM7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gY2FsbCBhbmQgbG9jayB1bnRpbCBsYXRlclxyXG5cdFx0XHRmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xyXG5cdFx0XHRzZXRUaW1lb3V0KGxhdGVyLCB0aW1lKTtcclxuXHRcdFx0bG9jayA9IHRydWU7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIHdyYXBwZXJGbjtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHdyYXBOdW0obnVtOiBOdW1iZXIsIHJhbmdlOiBOdW1iZXJbXSwgaW5jbHVkZU1heD86IEJvb2xlYW4pOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIGBudW1gIG1vZHVsbyBgcmFuZ2VgIGluIHN1Y2ggYSB3YXkgc28gaXQgbGllcyB3aXRoaW5cclxuLy8gYHJhbmdlWzBdYCBhbmQgYHJhbmdlWzFdYC4gVGhlIHJldHVybmVkIHZhbHVlIHdpbGwgYmUgYWx3YXlzIHNtYWxsZXIgdGhhblxyXG4vLyBgcmFuZ2VbMV1gIHVubGVzcyBgaW5jbHVkZU1heGAgaXMgc2V0IHRvIGB0cnVlYC5cclxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBOdW0oeCwgcmFuZ2UsIGluY2x1ZGVNYXgpIHtcclxuXHR2YXIgbWF4ID0gcmFuZ2VbMV0sXHJcblx0ICAgIG1pbiA9IHJhbmdlWzBdLFxyXG5cdCAgICBkID0gbWF4IC0gbWluO1xyXG5cdHJldHVybiB4ID09PSBtYXggJiYgaW5jbHVkZU1heCA/IHggOiAoKHggLSBtaW4pICUgZCArIGQpICUgZCArIG1pbjtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGZhbHNlRm4oKTogRnVuY3Rpb25cclxuLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGFsd2F5cyByZXR1cm5zIGBmYWxzZWAuXHJcbmV4cG9ydCBmdW5jdGlvbiBmYWxzZUZuKCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbi8vIEBmdW5jdGlvbiBmb3JtYXROdW0obnVtOiBOdW1iZXIsIHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgYG51bWAgcm91bmRlZCB3aXRoIHNwZWNpZmllZCBgcHJlY2lzaW9uYC5cclxuLy8gVGhlIGRlZmF1bHQgYHByZWNpc2lvbmAgdmFsdWUgaXMgNiBkZWNpbWFsIHBsYWNlcy5cclxuLy8gYGZhbHNlYCBjYW4gYmUgcGFzc2VkIHRvIHNraXAgYW55IHByb2Nlc3NpbmcgKGNhbiBiZSB1c2VmdWwgdG8gYXZvaWQgcm91bmQtb2ZmIGVycm9ycykuXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXROdW0obnVtLCBwcmVjaXNpb24pIHtcclxuXHRpZiAocHJlY2lzaW9uID09PSBmYWxzZSkgeyByZXR1cm4gbnVtOyB9XHJcblx0dmFyIHBvdyA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/IDYgOiBwcmVjaXNpb24pO1xyXG5cdHJldHVybiBNYXRoLnJvdW5kKG51bSAqIHBvdykgLyBwb3c7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0cmltKHN0cjogU3RyaW5nKTogU3RyaW5nXHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtTdHJpbmcucHJvdG90eXBlLnRyaW1dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9UcmltKVxyXG5leHBvcnQgZnVuY3Rpb24gdHJpbShzdHIpIHtcclxuXHRyZXR1cm4gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNwbGl0V29yZHMoc3RyOiBTdHJpbmcpOiBTdHJpbmdbXVxyXG4vLyBUcmltcyBhbmQgc3BsaXRzIHRoZSBzdHJpbmcgb24gd2hpdGVzcGFjZSBhbmQgcmV0dXJucyB0aGUgYXJyYXkgb2YgcGFydHMuXHJcbmV4cG9ydCBmdW5jdGlvbiBzcGxpdFdvcmRzKHN0cikge1xyXG5cdHJldHVybiB0cmltKHN0cikuc3BsaXQoL1xccysvKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldE9wdGlvbnMob2JqOiBPYmplY3QsIG9wdGlvbnM6IE9iamVjdCk6IE9iamVjdFxyXG4vLyBNZXJnZXMgdGhlIGdpdmVuIHByb3BlcnRpZXMgdG8gdGhlIGBvcHRpb25zYCBvZiB0aGUgYG9iamAgb2JqZWN0LCByZXR1cm5pbmcgdGhlIHJlc3VsdGluZyBvcHRpb25zLiBTZWUgYENsYXNzIG9wdGlvbnNgLiBIYXMgYW4gYEwuc2V0T3B0aW9uc2Agc2hvcnRjdXQuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRPcHRpb25zKG9iaiwgb3B0aW9ucykge1xyXG5cdGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgJ29wdGlvbnMnKSkge1xyXG5cdFx0b2JqLm9wdGlvbnMgPSBvYmoub3B0aW9ucyA/IGNyZWF0ZShvYmoub3B0aW9ucykgOiB7fTtcclxuXHR9XHJcblx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcblx0XHRvYmoub3B0aW9uc1tpXSA9IG9wdGlvbnNbaV07XHJcblx0fVxyXG5cdHJldHVybiBvYmoub3B0aW9ucztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFBhcmFtU3RyaW5nKG9iajogT2JqZWN0LCBleGlzdGluZ1VybD86IFN0cmluZywgdXBwZXJjYXNlPzogQm9vbGVhbik6IFN0cmluZ1xyXG4vLyBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIHBhcmFtZXRlciBVUkwgc3RyaW5nLCBlLmcuIGB7YTogXCJmb29cIiwgYjogXCJiYXJcIn1gXHJcbi8vIHRyYW5zbGF0ZXMgdG8gYCc/YT1mb28mYj1iYXInYC4gSWYgYGV4aXN0aW5nVXJsYCBpcyBzZXQsIHRoZSBwYXJhbWV0ZXJzIHdpbGxcclxuLy8gYmUgYXBwZW5kZWQgYXQgdGhlIGVuZC4gSWYgYHVwcGVyY2FzZWAgaXMgYHRydWVgLCB0aGUgcGFyYW1ldGVyIG5hbWVzIHdpbGxcclxuLy8gYmUgdXBwZXJjYXNlZCAoZS5nLiBgJz9BPWZvbyZCPWJhcidgKVxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyYW1TdHJpbmcob2JqLCBleGlzdGluZ1VybCwgdXBwZXJjYXNlKSB7XHJcblx0dmFyIHBhcmFtcyA9IFtdO1xyXG5cdGZvciAodmFyIGkgaW4gb2JqKSB7XHJcblx0XHRwYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQodXBwZXJjYXNlID8gaS50b1VwcGVyQ2FzZSgpIDogaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKSk7XHJcblx0fVxyXG5cdHJldHVybiAoKCFleGlzdGluZ1VybCB8fCBleGlzdGluZ1VybC5pbmRleE9mKCc/JykgPT09IC0xKSA/ICc/JyA6ICcmJykgKyBwYXJhbXMuam9pbignJicpO1xyXG59XHJcblxyXG52YXIgdGVtcGxhdGVSZSA9IC9cXHsgKihbXFx3XyAtXSspICpcXH0vZztcclxuXHJcbi8vIEBmdW5jdGlvbiB0ZW1wbGF0ZShzdHI6IFN0cmluZywgZGF0YTogT2JqZWN0KTogU3RyaW5nXHJcbi8vIFNpbXBsZSB0ZW1wbGF0aW5nIGZhY2lsaXR5LCBhY2NlcHRzIGEgdGVtcGxhdGUgc3RyaW5nIG9mIHRoZSBmb3JtIGAnSGVsbG8ge2F9LCB7Yn0nYFxyXG4vLyBhbmQgYSBkYXRhIG9iamVjdCBsaWtlIGB7YTogJ2ZvbycsIGI6ICdiYXInfWAsIHJldHVybnMgZXZhbHVhdGVkIHN0cmluZ1xyXG4vLyBgKCdIZWxsbyBmb28sIGJhcicpYC4gWW91IGNhbiBhbHNvIHNwZWNpZnkgZnVuY3Rpb25zIGluc3RlYWQgb2Ygc3RyaW5ncyBmb3JcclxuLy8gZGF0YSB2YWx1ZXMg4oCUIHRoZXkgd2lsbCBiZSBldmFsdWF0ZWQgcGFzc2luZyBgZGF0YWAgYXMgYW4gYXJndW1lbnQuXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZShzdHIsIGRhdGEpIHtcclxuXHRyZXR1cm4gc3RyLnJlcGxhY2UodGVtcGxhdGVSZSwgZnVuY3Rpb24gKHN0ciwga2V5KSB7XHJcblx0XHR2YXIgdmFsdWUgPSBkYXRhW2tleV07XHJcblxyXG5cdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdObyB2YWx1ZSBwcm92aWRlZCBmb3IgdmFyaWFibGUgJyArIHN0cik7XHJcblxyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0dmFsdWUgPSB2YWx1ZShkYXRhKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB2YWx1ZTtcclxuXHR9KTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGlzQXJyYXkob2JqKTogQm9vbGVhblxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbQXJyYXkuaXNBcnJheV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheSlcclxuZXhwb3J0IHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAob2JqKSB7XHJcblx0cmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJyk7XHJcbn07XHJcblxyXG4vLyBAZnVuY3Rpb24gaW5kZXhPZihhcnJheTogQXJyYXksIGVsOiBPYmplY3QpOiBOdW1iZXJcclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW0FycmF5LnByb3RvdHlwZS5pbmRleE9mXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mKVxyXG5leHBvcnQgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgZWwpIHtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAoYXJyYXlbaV0gPT09IGVsKSB7IHJldHVybiBpOyB9XHJcblx0fVxyXG5cdHJldHVybiAtMTtcclxufVxyXG5cclxuLy8gQHByb3BlcnR5IGVtcHR5SW1hZ2VVcmw6IFN0cmluZ1xyXG4vLyBEYXRhIFVSSSBzdHJpbmcgY29udGFpbmluZyBhIGJhc2U2NC1lbmNvZGVkIGVtcHR5IEdJRiBpbWFnZS5cclxuLy8gVXNlZCBhcyBhIGhhY2sgdG8gZnJlZSBtZW1vcnkgZnJvbSB1bnVzZWQgaW1hZ2VzIG9uIFdlYktpdC1wb3dlcmVkXHJcbi8vIG1vYmlsZSBkZXZpY2VzIChieSBzZXR0aW5nIGltYWdlIGBzcmNgIHRvIHRoaXMgc3RyaW5nKS5cclxuZXhwb3J0IHZhciBlbXB0eUltYWdlVXJsID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUQvQUN3QUFBQUFBUUFCQUFBQ0FEcz0nO1xyXG5cclxuLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXHJcblxyXG5mdW5jdGlvbiBnZXRQcmVmaXhlZChuYW1lKSB7XHJcblx0cmV0dXJuIHdpbmRvd1snd2Via2l0JyArIG5hbWVdIHx8IHdpbmRvd1snbW96JyArIG5hbWVdIHx8IHdpbmRvd1snbXMnICsgbmFtZV07XHJcbn1cclxuXHJcbnZhciBsYXN0VGltZSA9IDA7XHJcblxyXG4vLyBmYWxsYmFjayBmb3IgSUUgNy04XHJcbmZ1bmN0aW9uIHRpbWVvdXREZWZlcihmbikge1xyXG5cdHZhciB0aW1lID0gK25ldyBEYXRlKCksXHJcblx0ICAgIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtICh0aW1lIC0gbGFzdFRpbWUpKTtcclxuXHJcblx0bGFzdFRpbWUgPSB0aW1lICsgdGltZVRvQ2FsbDtcclxuXHRyZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZm4sIHRpbWVUb0NhbGwpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIHJlcXVlc3RGbiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZ2V0UHJlZml4ZWQoJ1JlcXVlc3RBbmltYXRpb25GcmFtZScpIHx8IHRpbWVvdXREZWZlcjtcclxuZXhwb3J0IHZhciBjYW5jZWxGbiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCBnZXRQcmVmaXhlZCgnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnKSB8fFxyXG5cdFx0Z2V0UHJlZml4ZWQoJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZScpIHx8IGZ1bmN0aW9uIChpZCkgeyB3aW5kb3cuY2xlYXJUaW1lb3V0KGlkKTsgfTtcclxuXHJcbi8vIEBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCwgaW1tZWRpYXRlPzogQm9vbGVhbik6IE51bWJlclxyXG4vLyBTY2hlZHVsZXMgYGZuYCB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBicm93c2VyIHJlcGFpbnRzLiBgZm5gIGlzIGJvdW5kIHRvXHJcbi8vIGBjb250ZXh0YCBpZiBnaXZlbi4gV2hlbiBgaW1tZWRpYXRlYCBpcyBzZXQsIGBmbmAgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGlmXHJcbi8vIHRoZSBicm93c2VyIGRvZXNuJ3QgaGF2ZSBuYXRpdmUgc3VwcG9ydCBmb3JcclxuLy8gW2B3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL3dpbmRvdy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpLFxyXG4vLyBvdGhlcndpc2UgaXQncyBkZWxheWVkLiBSZXR1cm5zIGEgcmVxdWVzdCBJRCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoZm4sIGNvbnRleHQsIGltbWVkaWF0ZSkge1xyXG5cdGlmIChpbW1lZGlhdGUgJiYgcmVxdWVzdEZuID09PSB0aW1lb3V0RGVmZXIpIHtcclxuXHRcdGZuLmNhbGwoY29udGV4dCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiByZXF1ZXN0Rm4uY2FsbCh3aW5kb3csIGJpbmQoZm4sIGNvbnRleHQpKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoaWQ6IE51bWJlcik6IHVuZGVmaW5lZFxyXG4vLyBDYW5jZWxzIGEgcHJldmlvdXMgYHJlcXVlc3RBbmltRnJhbWVgLiBTZWUgYWxzbyBbd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L2NhbmNlbEFuaW1hdGlvbkZyYW1lKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbmNlbEFuaW1GcmFtZShpZCkge1xyXG5cdGlmIChpZCkge1xyXG5cdFx0Y2FuY2VsRm4uY2FsbCh3aW5kb3csIGlkKTtcclxuXHR9XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuL1V0aWwnO1xyXG5cclxuLy8gQGNsYXNzIENsYXNzXHJcbi8vIEBha2EgTC5DbGFzc1xyXG5cclxuLy8gQHNlY3Rpb25cclxuLy8gQHVuaW5oZXJpdGFibGVcclxuXHJcbi8vIFRoYW5rcyB0byBKb2huIFJlc2lnIGFuZCBEZWFuIEVkd2FyZHMgZm9yIGluc3BpcmF0aW9uIVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENsYXNzKCkge31cclxuXHJcbkNsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cclxuXHQvLyBAZnVuY3Rpb24gZXh0ZW5kKHByb3BzOiBPYmplY3QpOiBGdW5jdGlvblxyXG5cdC8vIFtFeHRlbmRzIHRoZSBjdXJyZW50IGNsYXNzXSgjY2xhc3MtaW5oZXJpdGFuY2UpIGdpdmVuIHRoZSBwcm9wZXJ0aWVzIHRvIGJlIGluY2x1ZGVkLlxyXG5cdC8vIFJldHVybnMgYSBKYXZhc2NyaXB0IGZ1bmN0aW9uIHRoYXQgaXMgYSBjbGFzcyBjb25zdHJ1Y3RvciAodG8gYmUgY2FsbGVkIHdpdGggYG5ld2ApLlxyXG5cdHZhciBOZXdDbGFzcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcyk7XHJcblxyXG5cdFx0Ly8gY2FsbCB0aGUgY29uc3RydWN0b3JcclxuXHRcdGlmICh0aGlzLmluaXRpYWxpemUpIHtcclxuXHRcdFx0dGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2FsbCBhbGwgY29uc3RydWN0b3IgaG9va3NcclxuXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cdH07XHJcblxyXG5cdHZhciBwYXJlbnRQcm90byA9IE5ld0NsYXNzLl9fc3VwZXJfXyA9IHRoaXMucHJvdG90eXBlO1xyXG5cclxuXHR2YXIgcHJvdG8gPSBVdGlsLmNyZWF0ZShwYXJlbnRQcm90byk7XHJcblx0cHJvdG8uY29uc3RydWN0b3IgPSBOZXdDbGFzcztcclxuXHJcblx0TmV3Q2xhc3MucHJvdG90eXBlID0gcHJvdG87XHJcblxyXG5cdC8vIGluaGVyaXQgcGFyZW50J3Mgc3RhdGljc1xyXG5cdGZvciAodmFyIGkgaW4gdGhpcykge1xyXG5cdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBpKSAmJiBpICE9PSAncHJvdG90eXBlJyAmJiBpICE9PSAnX19zdXBlcl9fJykge1xyXG5cdFx0XHROZXdDbGFzc1tpXSA9IHRoaXNbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBtaXggc3RhdGljIHByb3BlcnRpZXMgaW50byB0aGUgY2xhc3NcclxuXHRpZiAocHJvcHMuc3RhdGljcykge1xyXG5cdFx0VXRpbC5leHRlbmQoTmV3Q2xhc3MsIHByb3BzLnN0YXRpY3MpO1xyXG5cdH1cclxuXHJcblx0Ly8gbWl4IGluY2x1ZGVzIGludG8gdGhlIHByb3RvdHlwZVxyXG5cdGlmIChwcm9wcy5pbmNsdWRlcykge1xyXG5cdFx0Y2hlY2tEZXByZWNhdGVkTWl4aW5FdmVudHMocHJvcHMuaW5jbHVkZXMpO1xyXG5cdFx0VXRpbC5leHRlbmQuYXBwbHkobnVsbCwgW3Byb3RvXS5jb25jYXQocHJvcHMuaW5jbHVkZXMpKTtcclxuXHR9XHJcblxyXG5cdC8vIG1peCBnaXZlbiBwcm9wZXJ0aWVzIGludG8gdGhlIHByb3RvdHlwZVxyXG5cdFV0aWwuZXh0ZW5kKHByb3RvLCBwcm9wcyk7XHJcblx0ZGVsZXRlIHByb3RvLnN0YXRpY3M7XHJcblx0ZGVsZXRlIHByb3RvLmluY2x1ZGVzO1xyXG5cclxuXHQvLyBtZXJnZSBvcHRpb25zXHJcblx0aWYgKHByb3RvLm9wdGlvbnMpIHtcclxuXHRcdHByb3RvLm9wdGlvbnMgPSBwYXJlbnRQcm90by5vcHRpb25zID8gVXRpbC5jcmVhdGUocGFyZW50UHJvdG8ub3B0aW9ucykgOiB7fTtcclxuXHRcdFV0aWwuZXh0ZW5kKHByb3RvLm9wdGlvbnMsIHByb3BzLm9wdGlvbnMpO1xyXG5cdH1cclxuXHJcblx0cHJvdG8uX2luaXRIb29rcyA9IFtdO1xyXG5cclxuXHQvLyBhZGQgbWV0aG9kIGZvciBjYWxsaW5nIGFsbCBob29rc1xyXG5cdHByb3RvLmNhbGxJbml0SG9va3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2luaXRIb29rc0NhbGxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAocGFyZW50UHJvdG8uY2FsbEluaXRIb29rcykge1xyXG5cdFx0XHRwYXJlbnRQcm90by5jYWxsSW5pdEhvb2tzLmNhbGwodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdEhvb2tzQ2FsbGVkID0gdHJ1ZTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcHJvdG8uX2luaXRIb29rcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRwcm90by5faW5pdEhvb2tzW2ldLmNhbGwodGhpcyk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIE5ld0NsYXNzO1xyXG59O1xyXG5cclxuXHJcbi8vIEBmdW5jdGlvbiBpbmNsdWRlKHByb3BlcnRpZXM6IE9iamVjdCk6IHRoaXNcclxuLy8gW0luY2x1ZGVzIGEgbWl4aW5dKCNjbGFzcy1pbmNsdWRlcykgaW50byB0aGUgY3VycmVudCBjbGFzcy5cclxuQ2xhc3MuaW5jbHVkZSA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cdHZhciBwYXJlbnRPcHRpb25zID0gdGhpcy5wcm90b3R5cGUub3B0aW9ucztcclxuXHRVdGlsLmV4dGVuZCh0aGlzLnByb3RvdHlwZSwgcHJvcHMpO1xyXG5cdGlmIChwcm9wcy5vcHRpb25zKSB7XHJcblx0XHR0aGlzLnByb3RvdHlwZS5vcHRpb25zID0gcGFyZW50T3B0aW9ucztcclxuXHRcdHRoaXMubWVyZ2VPcHRpb25zKHByb3BzLm9wdGlvbnMpO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8vIEBmdW5jdGlvbiBtZXJnZU9wdGlvbnMob3B0aW9uczogT2JqZWN0KTogdGhpc1xyXG4vLyBbTWVyZ2VzIGBvcHRpb25zYF0oI2NsYXNzLW9wdGlvbnMpIGludG8gdGhlIGRlZmF1bHRzIG9mIHRoZSBjbGFzcy5cclxuQ2xhc3MubWVyZ2VPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRVdGlsLmV4dGVuZCh0aGlzLnByb3RvdHlwZS5vcHRpb25zLCBvcHRpb25zKTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8vIEBmdW5jdGlvbiBhZGRJbml0SG9vayhmbjogRnVuY3Rpb24pOiB0aGlzXHJcbi8vIEFkZHMgYSBbY29uc3RydWN0b3IgaG9va10oI2NsYXNzLWNvbnN0cnVjdG9yLWhvb2tzKSB0byB0aGUgY2xhc3MuXHJcbkNsYXNzLmFkZEluaXRIb29rID0gZnVuY3Rpb24gKGZuKSB7IC8vIChGdW5jdGlvbikgfHwgKFN0cmluZywgYXJncy4uLilcclxuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblxyXG5cdHZhciBpbml0ID0gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nID8gZm4gOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzW2ZuXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuXHR9O1xyXG5cclxuXHR0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzID0gdGhpcy5wcm90b3R5cGUuX2luaXRIb29rcyB8fCBbXTtcclxuXHR0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzLnB1c2goaW5pdCk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBjaGVja0RlcHJlY2F0ZWRNaXhpbkV2ZW50cyhpbmNsdWRlcykge1xyXG5cdC8qIGdsb2JhbCBMOiB0cnVlICovXHJcblx0aWYgKHR5cGVvZiBMID09PSAndW5kZWZpbmVkJyB8fCAhTCB8fCAhTC5NaXhpbikgeyByZXR1cm47IH1cclxuXHJcblx0aW5jbHVkZXMgPSBVdGlsLmlzQXJyYXkoaW5jbHVkZXMpID8gaW5jbHVkZXMgOiBbaW5jbHVkZXNdO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGluY2x1ZGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAoaW5jbHVkZXNbaV0gPT09IEwuTWl4aW4uRXZlbnRzKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybignRGVwcmVjYXRlZCBpbmNsdWRlIG9mIEwuTWl4aW4uRXZlbnRzOiAnICtcclxuXHRcdFx0XHQndGhpcyBwcm9wZXJ0eSB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHJlbGVhc2VzLCAnICtcclxuXHRcdFx0XHQncGxlYXNlIGluaGVyaXQgZnJvbSBMLkV2ZW50ZWQgaW5zdGVhZC4nLCBuZXcgRXJyb3IoKS5zdGFjayk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbiIsImltcG9ydCB7Q2xhc3N9IGZyb20gJy4vQ2xhc3MnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4vVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRXZlbnRlZFxyXG4gKiBAYWthIEwuRXZlbnRlZFxyXG4gKiBAaW5oZXJpdHMgQ2xhc3NcclxuICpcclxuICogQSBzZXQgb2YgbWV0aG9kcyBzaGFyZWQgYmV0d2VlbiBldmVudC1wb3dlcmVkIGNsYXNzZXMgKGxpa2UgYE1hcGAgYW5kIGBNYXJrZXJgKS4gR2VuZXJhbGx5LCBldmVudHMgYWxsb3cgeW91IHRvIGV4ZWN1dGUgc29tZSBmdW5jdGlvbiB3aGVuIHNvbWV0aGluZyBoYXBwZW5zIHdpdGggYW4gb2JqZWN0IChlLmcuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgbWFwLCBjYXVzaW5nIHRoZSBtYXAgdG8gZmlyZSBgJ2NsaWNrJ2AgZXZlbnQpLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xyXG4gKiBcdGFsZXJ0KGUubGF0bG5nKTtcclxuICogfSApO1xyXG4gKiBgYGBcclxuICpcclxuICogTGVhZmxldCBkZWFscyB3aXRoIGV2ZW50IGxpc3RlbmVycyBieSByZWZlcmVuY2UsIHNvIGlmIHlvdSB3YW50IHRvIGFkZCBhIGxpc3RlbmVyIGFuZCB0aGVuIHJlbW92ZSBpdCwgZGVmaW5lIGl0IGFzIGEgZnVuY3Rpb246XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGZ1bmN0aW9uIG9uQ2xpY2soZSkgeyAuLi4gfVxyXG4gKlxyXG4gKiBtYXAub24oJ2NsaWNrJywgb25DbGljayk7XHJcbiAqIG1hcC5vZmYoJ2NsaWNrJywgb25DbGljayk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRXZlbnRzID0ge1xyXG5cdC8qIEBtZXRob2Qgb24odHlwZTogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0ICogQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBvZiB0aGUgb2JqZWN0LiBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgY29udGV4dCBvZiB0aGUgbGlzdGVuZXIgKG9iamVjdCB0aGUgdGhpcyBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvbihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG5cdCAqIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuXHQgKi9cclxuXHRvbjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdC8vIHR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xyXG5cdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdC8vIHdlIGRvbid0IHByb2Nlc3Mgc3BhY2Utc2VwYXJhdGVkIGV2ZW50cyBoZXJlIGZvciBwZXJmb3JtYW5jZTtcclxuXHRcdFx0XHQvLyBpdCdzIGEgaG90IHBhdGggc2luY2UgTGF5ZXIgdXNlcyB0aGUgb24ob2JqKSBzeW50YXhcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCB3b3Jkc1xyXG5cdFx0XHR0eXBlcyA9IFV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0LyogQG1ldGhvZCBvZmYodHlwZTogU3RyaW5nLCBmbj86IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLiBJZiBubyBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIGl0IHdpbGwgcmVtb3ZlIGFsbCB0aGUgbGlzdGVuZXJzIG9mIHRoYXQgcGFydGljdWxhciBldmVudCBmcm9tIHRoZSBvYmplY3QuIE5vdGUgdGhhdCBpZiB5b3UgcGFzc2VkIGEgY3VzdG9tIGNvbnRleHQgdG8gYG9uYCwgeW91IG11c3QgcGFzcyB0aGUgc2FtZSBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9mZihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycy5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb2ZmOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIHRvIGFsbCBldmVudHMgb24gdGhlIG9iamVjdC4gVGhpcyBpbmNsdWRlcyBpbXBsaWNpdGx5IGF0dGFjaGVkIGV2ZW50cy5cclxuXHQgKi9cclxuXHRvZmY6IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBpZiBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHNcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50cztcclxuXHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdHRoaXMuX29mZih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dHlwZXMgPSBVdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdFx0dmFyIHJlbW92ZUFsbCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDE7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdGlmIChyZW1vdmVBbGwpIHtcclxuXHRcdFx0XHRcdHRoaXMuX29mZih0eXBlc1tpXSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRoaXMuX29mZih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIGF0dGFjaCBsaXN0ZW5lciAod2l0aG91dCBzeW50YWN0aWMgc3VnYXIgbm93KVxyXG5cdF9vbjogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0LCBfb25jZSkge1xyXG5cdFx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oJ3dyb25nIGxpc3RlbmVyIHR5cGU6ICcgKyB0eXBlb2YgZm4pO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2hlY2sgaWYgZm4gYWxyZWFkeSB0aGVyZVxyXG5cdFx0aWYgKHRoaXMuX2xpc3RlbnModHlwZSwgZm4sIGNvbnRleHQpICE9PSBmYWxzZSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbnRleHQgPT09IHRoaXMpIHtcclxuXHRcdFx0Ly8gTGVzcyBtZW1vcnkgZm9vdHByaW50LlxyXG5cdFx0XHRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBuZXdMaXN0ZW5lciA9IHtmbjogZm4sIGN0eDogY29udGV4dH07XHJcblx0XHRpZiAoX29uY2UpIHtcclxuXHRcdFx0bmV3TGlzdGVuZXIub25jZSA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xyXG5cdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gdGhpcy5fZXZlbnRzW3R5cGVdIHx8IFtdO1xyXG5cdFx0dGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobmV3TGlzdGVuZXIpO1xyXG5cdH0sXHJcblxyXG5cdF9vZmY6IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdFx0dmFyIGxpc3RlbmVycyxcclxuXHRcdCAgICBpLFxyXG5cdFx0ICAgIGxlbjtcclxuXHJcblx0XHRpZiAoIXRoaXMuX2V2ZW50cykge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0bGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0aWYgKCFsaXN0ZW5lcnMpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7IC8vIHJlbW92ZSBhbGxcclxuXHRcdFx0aWYgKHRoaXMuX2ZpcmluZ0NvdW50KSB7XHJcblx0XHRcdFx0Ly8gU2V0IGFsbCByZW1vdmVkIGxpc3RlbmVycyB0byBub29wXHJcblx0XHRcdFx0Ly8gc28gdGhleSBhcmUgbm90IGNhbGxlZCBpZiByZW1vdmUgaGFwcGVucyBpbiBmaXJlXHJcblx0XHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0XHRsaXN0ZW5lcnNbaV0uZm4gPSBVdGlsLmZhbHNlRm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdC8vIGNsZWFyIGFsbCBsaXN0ZW5lcnMgZm9yIGEgdHlwZSBpZiBmdW5jdGlvbiBpc24ndCBzcGVjaWZpZWRcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCd3cm9uZyBsaXN0ZW5lciB0eXBlOiAnICsgdHlwZW9mIGZuKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZpbmQgZm4gYW5kIHJlbW92ZSBpdFxyXG5cdFx0dmFyIGluZGV4ID0gdGhpcy5fbGlzdGVucyh0eXBlLCBmbiwgY29udGV4dCk7XHJcblx0XHRpZiAoaW5kZXggIT09IGZhbHNlKSB7XHJcblx0XHRcdHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpbmRleF07XHJcblx0XHRcdGlmICh0aGlzLl9maXJpbmdDb3VudCkge1xyXG5cdFx0XHRcdC8vIHNldCB0aGUgcmVtb3ZlZCBsaXN0ZW5lciB0byBub29wIHNvIHRoYXQncyBub3QgY2FsbGVkIGlmIHJlbW92ZSBoYXBwZW5zIGluIGZpcmVcclxuXHRcdFx0XHRsaXN0ZW5lci5mbiA9IFV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHRcdFx0LyogY29weSBhcnJheSBpbiBjYXNlIGV2ZW50cyBhcmUgYmVpbmcgZmlyZWQgKi9cclxuXHRcdFx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpcmUodHlwZTogU3RyaW5nLCBkYXRhPzogT2JqZWN0LCBwcm9wYWdhdGU/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIEZpcmVzIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZS4gWW91IGNhbiBvcHRpb25hbGx5IHByb3ZpZGUgYSBkYXRhXHJcblx0Ly8gb2JqZWN0IOKAlCB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHdpbGwgY29udGFpbiBpdHNcclxuXHQvLyBwcm9wZXJ0aWVzLiBUaGUgZXZlbnQgY2FuIG9wdGlvbmFsbHkgYmUgcHJvcGFnYXRlZCB0byBldmVudCBwYXJlbnRzLlxyXG5cdGZpcmU6IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBwcm9wYWdhdGUpIHtcclxuXHRcdGlmICghdGhpcy5saXN0ZW5zKHR5cGUsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgZXZlbnQgPSBVdGlsLmV4dGVuZCh7fSwgZGF0YSwge1xyXG5cdFx0XHR0eXBlOiB0eXBlLFxyXG5cdFx0XHR0YXJnZXQ6IHRoaXMsXHJcblx0XHRcdHNvdXJjZVRhcmdldDogZGF0YSAmJiBkYXRhLnNvdXJjZVRhcmdldCB8fCB0aGlzXHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fZXZlbnRzKSB7XHJcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRcdGlmIChsaXN0ZW5lcnMpIHtcclxuXHRcdFx0XHR0aGlzLl9maXJpbmdDb3VudCA9ICh0aGlzLl9maXJpbmdDb3VudCArIDEpIHx8IDE7XHJcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdFx0dmFyIGwgPSBsaXN0ZW5lcnNbaV07XHJcblx0XHRcdFx0XHQvLyBvZmYgb3ZlcndyaXRlcyBsLmZuLCBzbyB3ZSBuZWVkIHRvIGNvcHkgZm4gdG8gYSB2YXJcclxuXHRcdFx0XHRcdHZhciBmbiA9IGwuZm47XHJcblx0XHRcdFx0XHRpZiAobC5vbmNlKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMub2ZmKHR5cGUsIGZuLCBsLmN0eCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRmbi5jYWxsKGwuY3R4IHx8IHRoaXMsIGV2ZW50KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuX2ZpcmluZ0NvdW50LS07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAocHJvcGFnYXRlKSB7XHJcblx0XHRcdC8vIHByb3BhZ2F0ZSB0aGUgZXZlbnQgdG8gcGFyZW50cyAoc2V0IHdpdGggYWRkRXZlbnRQYXJlbnQpXHJcblx0XHRcdHRoaXMuX3Byb3BhZ2F0ZUV2ZW50KGV2ZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxpc3RlbnModHlwZTogU3RyaW5nLCBwcm9wYWdhdGU/OiBCb29sZWFuKTogQm9vbGVhblxyXG5cdC8vIEBtZXRob2QgbGlzdGVucyh0eXBlOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCwgcHJvcGFnYXRlPzogQm9vbGVhbik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBoYXMgYW55IGxpc3RlbmVycyBhdHRhY2hlZCB0byBpdC5cclxuXHQvLyBUaGUgdmVyaWZpY2F0aW9uIGNhbiBvcHRpb25hbGx5IGJlIHByb3BhZ2F0ZWQsIGl0IHdpbGwgcmV0dXJuIGB0cnVlYCBpZiBwYXJlbnRzIGhhdmUgdGhlIGxpc3RlbmVyIGF0dGFjaGVkIHRvIGl0LlxyXG5cdGxpc3RlbnM6IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCwgcHJvcGFnYXRlKSB7XHJcblx0XHRpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybignXCJzdHJpbmdcIiB0eXBlIGFyZ3VtZW50IGV4cGVjdGVkJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gd2UgZG9uJ3Qgb3ZlcndyaXRlIHRoZSBpbnB1dCBgZm5gIHZhbHVlLCBiZWNhdXNlIHdlIG5lZWQgdG8gdXNlIGl0IGZvciBwcm9wYWdhdGlvblxyXG5cdFx0dmFyIF9mbiA9IGZuO1xyXG5cdFx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRwcm9wYWdhdGUgPSAhIWZuO1xyXG5cdFx0XHRfZm4gPSB1bmRlZmluZWQ7XHJcblx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRpZiAobGlzdGVuZXJzICYmIGxpc3RlbmVycy5sZW5ndGgpIHtcclxuXHRcdFx0aWYgKHRoaXMuX2xpc3RlbnModHlwZSwgX2ZuLCBjb250ZXh0KSAhPT0gZmFsc2UpIHtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuXHRcdFx0Ly8gYWxzbyBjaGVjayBwYXJlbnRzIGZvciBsaXN0ZW5lcnMgaWYgZXZlbnQgcHJvcGFnYXRlc1xyXG5cdFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5saXN0ZW5zKHR5cGUsIGZuLCBjb250ZXh0LCBwcm9wYWdhdGUpKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHQvLyByZXR1cm5zIHRoZSBpbmRleCAobnVtYmVyKSBvciBmYWxzZVxyXG5cdF9saXN0ZW5zOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHRcdGlmICghdGhpcy5fZXZlbnRzKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdIHx8IFtdO1xyXG5cdFx0aWYgKCFmbikge1xyXG5cdFx0XHRyZXR1cm4gISFsaXN0ZW5lcnMubGVuZ3RoO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb250ZXh0ID09PSB0aGlzKSB7XHJcblx0XHRcdC8vIExlc3MgbWVtb3J5IGZvb3RwcmludC5cclxuXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGlmIChsaXN0ZW5lcnNbaV0uZm4gPT09IGZuICYmIGxpc3RlbmVyc1tpXS5jdHggPT09IGNvbnRleHQpIHtcclxuXHRcdFx0XHRyZXR1cm4gaTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG9uY2Uo4oCmKTogdGhpc1xyXG5cdC8vIEJlaGF2ZXMgYXMgW2BvbijigKYpYF0oI2V2ZW50ZWQtb24pLCBleGNlcHQgdGhlIGxpc3RlbmVyIHdpbGwgb25seSBnZXQgZmlyZWQgb25jZSBhbmQgdGhlbiByZW1vdmVkLlxyXG5cdG9uY2U6IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHQvLyB0eXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcclxuXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHQvLyB3ZSBkb24ndCBwcm9jZXNzIHNwYWNlLXNlcGFyYXRlZCBldmVudHMgaGVyZSBmb3IgcGVyZm9ybWFuY2U7XHJcblx0XHRcdFx0Ly8gaXQncyBhIGhvdCBwYXRoIHNpbmNlIExheWVyIHVzZXMgdGhlIG9uKG9iaikgc3ludGF4XHJcblx0XHRcdFx0dGhpcy5fb24odHlwZSwgdHlwZXNbdHlwZV0sIGZuLCB0cnVlKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIHR5cGVzIGNhbiBiZSBhIHN0cmluZyBvZiBzcGFjZS1zZXBhcmF0ZWQgd29yZHNcclxuXHRcdFx0dHlwZXMgPSBVdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5fb24odHlwZXNbaV0sIGZuLCBjb250ZXh0LCB0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkRXZlbnRQYXJlbnQob2JqOiBFdmVudGVkKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gZXZlbnQgcGFyZW50IC0gYW4gYEV2ZW50ZWRgIHRoYXQgd2lsbCByZWNlaXZlIHByb3BhZ2F0ZWQgZXZlbnRzXHJcblx0YWRkRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHRoaXMuX2V2ZW50UGFyZW50cyA9IHRoaXMuX2V2ZW50UGFyZW50cyB8fCB7fTtcclxuXHRcdHRoaXMuX2V2ZW50UGFyZW50c1tVdGlsLnN0YW1wKG9iaildID0gb2JqO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVFdmVudFBhcmVudChvYmo6IEV2ZW50ZWQpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbiBldmVudCBwYXJlbnQsIHNvIGl0IHdpbGwgc3RvcCByZWNlaXZpbmcgcHJvcGFnYXRlZCBldmVudHNcclxuXHRyZW1vdmVFdmVudFBhcmVudDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0aWYgKHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRQYXJlbnRzW1V0aWwuc3RhbXAob2JqKV07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcHJvcGFnYXRlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0dGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5maXJlKGUudHlwZSwgVXRpbC5leHRlbmQoe1xyXG5cdFx0XHRcdGxheWVyOiBlLnRhcmdldCxcclxuXHRcdFx0XHRwcm9wYWdhdGVkRnJvbTogZS50YXJnZXRcclxuXHRcdFx0fSwgZSksIHRydWUpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbi8vIGFsaWFzZXM7IHdlIHNob3VsZCBkaXRjaCB0aG9zZSBldmVudHVhbGx5XHJcblxyXG4vLyBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9uKOKApilgXSgjZXZlbnRlZC1vbilcclxuRXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBFdmVudHMub247XHJcblxyXG4vLyBAbWV0aG9kIHJlbW92ZUV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9mZijigKYpYF0oI2V2ZW50ZWQtb2ZmKVxyXG5cclxuLy8gQG1ldGhvZCBjbGVhckFsbEV2ZW50TGlzdGVuZXJzKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvZmYoKWBdKCNldmVudGVkLW9mZilcclxuRXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBFdmVudHMuY2xlYXJBbGxFdmVudExpc3RlbmVycyA9IEV2ZW50cy5vZmY7XHJcblxyXG4vLyBAbWV0aG9kIGFkZE9uZVRpbWVFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvbmNlKOKApilgXSgjZXZlbnRlZC1vbmNlKVxyXG5FdmVudHMuYWRkT25lVGltZUV2ZW50TGlzdGVuZXIgPSBFdmVudHMub25jZTtcclxuXHJcbi8vIEBtZXRob2QgZmlyZUV2ZW50KOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BmaXJlKOKApilgXSgjZXZlbnRlZC1maXJlKVxyXG5FdmVudHMuZmlyZUV2ZW50ID0gRXZlbnRzLmZpcmU7XHJcblxyXG4vLyBAbWV0aG9kIGhhc0V2ZW50TGlzdGVuZXJzKOKApik6IEJvb2xlYW5cclxuLy8gQWxpYXMgdG8gW2BsaXN0ZW5zKOKApilgXSgjZXZlbnRlZC1saXN0ZW5zKVxyXG5FdmVudHMuaGFzRXZlbnRMaXN0ZW5lcnMgPSBFdmVudHMubGlzdGVucztcclxuXHJcbmV4cG9ydCB2YXIgRXZlbnRlZCA9IENsYXNzLmV4dGVuZChFdmVudHMpO1xyXG4iLCJpbXBvcnQge2lzQXJyYXksIGZvcm1hdE51bX0gZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBQb2ludFxyXG4gKiBAYWthIEwuUG9pbnRcclxuICpcclxuICogUmVwcmVzZW50cyBhIHBvaW50IHdpdGggYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgaW4gcGl4ZWxzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcG9pbnQgPSBMLnBvaW50KDIwMCwgMzAwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgYW5kIG9wdGlvbnMgdGhhdCBhY2NlcHQgYFBvaW50YCBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZXNlIGxpbmVzIGFyZSBlcXVpdmFsZW50OlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAucGFuQnkoWzIwMCwgMzAwXSk7XHJcbiAqIG1hcC5wYW5CeShMLnBvaW50KDIwMCwgMzAwKSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYFBvaW50YCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIFBvaW50KHgsIHksIHJvdW5kKSB7XHJcblx0Ly8gQHByb3BlcnR5IHg6IE51bWJlcjsgVGhlIGB4YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxyXG5cdHRoaXMueCA9IChyb3VuZCA/IE1hdGgucm91bmQoeCkgOiB4KTtcclxuXHQvLyBAcHJvcGVydHkgeTogTnVtYmVyOyBUaGUgYHlgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XHJcblx0dGhpcy55ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh5KSA6IHkpO1xyXG59XHJcblxyXG52YXIgdHJ1bmMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uICh2KSB7XHJcblx0cmV0dXJuIHYgPiAwID8gTWF0aC5mbG9vcih2KSA6IE1hdGguY2VpbCh2KTtcclxufTtcclxuXHJcblBvaW50LnByb3RvdHlwZSA9IHtcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9uZSgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50LlxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZChvdGhlclBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGFkZGl0aW9uIG9mIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG5cdGFkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHQvLyBub24tZGVzdHJ1Y3RpdmUsIHJldHVybnMgYSBuZXcgcG9pbnRcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2FkZCh0b1BvaW50KHBvaW50KSk7XHJcblx0fSxcclxuXHJcblx0X2FkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHQvLyBkZXN0cnVjdGl2ZSwgdXNlZCBkaXJlY3RseSBmb3IgcGVyZm9ybWFuY2UgaW4gc2l0dWF0aW9ucyB3aGVyZSBpdCdzIHNhZmUgdG8gbW9kaWZ5IGV4aXN0aW5nIHBvaW50XHJcblx0XHR0aGlzLnggKz0gcG9pbnQueDtcclxuXHRcdHRoaXMueSArPSBwb2ludC55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzdWJ0cmFjdChvdGhlclBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHN1YnRyYWN0aW9uIG9mIHRoZSBnaXZlbiBwb2ludCBmcm9tIHRoZSBjdXJyZW50LlxyXG5cdHN1YnRyYWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3N1YnRyYWN0KHRvUG9pbnQocG9pbnQpKTtcclxuXHR9LFxyXG5cclxuXHRfc3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dGhpcy54IC09IHBvaW50Lng7XHJcblx0XHR0aGlzLnkgLT0gcG9pbnQueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGl2aWRlQnkobnVtOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbiBvZiB0aGUgY3VycmVudCBwb2ludCBieSB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG5cdGRpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXZpZGVCeShudW0pO1xyXG5cdH0sXHJcblxyXG5cdF9kaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0dGhpcy54IC89IG51bTtcclxuXHRcdHRoaXMueSAvPSBudW07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG11bHRpcGx5QnkobnVtOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBtdWx0aXBsaWNhdGlvbiBvZiB0aGUgY3VycmVudCBwb2ludCBieSB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG5cdG11bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX211bHRpcGx5QnkobnVtKTtcclxuXHR9LFxyXG5cclxuXHRfbXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0dGhpcy54ICo9IG51bTtcclxuXHRcdHRoaXMueSAqPSBudW07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcclxuXHQvLyBNdWx0aXBseSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgZWFjaCBjb29yZGluYXRlIG9mXHJcblx0Ly8gYHNjYWxlYC4gSW4gbGluZWFyIGFsZ2VicmEgdGVybXMsIG11bHRpcGx5IHRoZSBwb2ludCBieSB0aGVcclxuXHQvLyBbc2NhbGluZyBtYXRyaXhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NjYWxpbmdfJTI4Z2VvbWV0cnklMjkjTWF0cml4X3JlcHJlc2VudGF0aW9uKVxyXG5cdC8vIGRlZmluZWQgYnkgYHNjYWxlYC5cclxuXHRzY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54ICogcG9pbnQueCwgdGhpcy55ICogcG9pbnQueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcclxuXHQvLyBJbnZlcnNlIG9mIGBzY2FsZUJ5YC4gRGl2aWRlIGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgY3VycmVudCBwb2ludCBieVxyXG5cdC8vIGVhY2ggY29vcmRpbmF0ZSBvZiBgc2NhbGVgLlxyXG5cdHVuc2NhbGVCeTogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAvIHBvaW50LngsIHRoaXMueSAvIHBvaW50LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgcm91bmQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIHJvdW5kZWQgY29vcmRpbmF0ZXMuXHJcblx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3JvdW5kKCk7XHJcblx0fSxcclxuXHJcblx0X3JvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZsb29yKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCBmbG9vcmVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIGRvd24pLlxyXG5cdGZsb29yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9mbG9vcigpO1xyXG5cdH0sXHJcblxyXG5cdF9mbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vcih0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vcih0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjZWlsKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCBjZWlsZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgdXApLlxyXG5cdGNlaWw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2NlaWwoKTtcclxuXHR9LFxyXG5cclxuXHRfY2VpbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdHJ1bmMoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIHRydW5jYXRlZCBjb29yZGluYXRlcyAocm91bmRlZCB0b3dhcmRzIHplcm8pLlxyXG5cdHRydW5jOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl90cnVuYygpO1xyXG5cdH0sXHJcblxyXG5cdF90cnVuYzogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gdHJ1bmModGhpcy54KTtcclxuXHRcdHRoaXMueSA9IHRydW5jKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlVG8ob3RoZXJQb2ludDogUG9pbnQpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBjYXJ0ZXNpYW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIGdpdmVuIHBvaW50cy5cclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG5cdFx0dmFyIHggPSBwb2ludC54IC0gdGhpcy54LFxyXG5cdFx0ICAgIHkgPSBwb2ludC55IC0gdGhpcy55O1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJQb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHBvaW50IGhhcyB0aGUgc2FtZSBjb29yZGluYXRlcy5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnQueCA9PT0gdGhpcy54ICYmXHJcblx0XHQgICAgICAgcG9pbnQueSA9PT0gdGhpcy55O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJQb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBjb29yZGluYXRlcyBvZiB0aGUgZ2l2ZW4gcG9pbnQgYXJlIGxlc3MgdGhhbiB0aGUgY29ycmVzcG9uZGluZyBjdXJyZW50IHBvaW50IGNvb3JkaW5hdGVzIChpbiBhYnNvbHV0ZSB2YWx1ZXMpLlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWJzKHBvaW50LngpIDw9IE1hdGguYWJzKHRoaXMueCkgJiZcclxuXHRcdCAgICAgICBNYXRoLmFicyhwb2ludC55KSA8PSBNYXRoLmFicyh0aGlzLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cclxuXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICdQb2ludCgnICtcclxuXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMueCkgKyAnLCAnICtcclxuXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMueSkgKyAnKSc7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gQGZhY3RvcnkgTC5wb2ludCh4OiBOdW1iZXIsIHk6IE51bWJlciwgcm91bmQ/OiBCb29sZWFuKVxyXG4vLyBDcmVhdGVzIGEgUG9pbnQgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzLiBJZiBvcHRpb25hbCBgcm91bmRgIGlzIHNldCB0byB0cnVlLCByb3VuZHMgdGhlIGB4YCBhbmQgYHlgIHZhbHVlcy5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KGNvb3JkczogTnVtYmVyW10pXHJcbi8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFt4LCB5XWAgaW5zdGVhZC5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KGNvb3JkczogT2JqZWN0KVxyXG4vLyBFeHBlY3RzIGEgcGxhaW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7eDogTnVtYmVyLCB5OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9Qb2ludCh4LCB5LCByb3VuZCkge1xyXG5cdGlmICh4IGluc3RhbmNlb2YgUG9pbnQpIHtcclxuXHRcdHJldHVybiB4O1xyXG5cdH1cclxuXHRpZiAoaXNBcnJheSh4KSkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh4WzBdLCB4WzFdKTtcclxuXHR9XHJcblx0aWYgKHggPT09IHVuZGVmaW5lZCB8fCB4ID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4geDtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiAneCcgaW4geCAmJiAneScgaW4geCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh4LngsIHgueSk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgUG9pbnQoeCwgeSwgcm91bmQpO1xyXG59XHJcbiIsImltcG9ydCB7UG9pbnQsIHRvUG9pbnR9IGZyb20gJy4vUG9pbnQnO1xyXG5cclxuLypcclxuICogQGNsYXNzIEJvdW5kc1xyXG4gKiBAYWthIEwuQm91bmRzXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBhcmVhIGluIHBpeGVsIGNvb3JkaW5hdGVzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcDEgPSBMLnBvaW50KDEwLCAxMCksXHJcbiAqIHAyID0gTC5wb2ludCg0MCwgNjApLFxyXG4gKiBib3VuZHMgPSBMLmJvdW5kcyhwMSwgcDIpO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBgQm91bmRzYCBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICpcclxuICogYGBganNcclxuICogb3RoZXJCb3VuZHMuaW50ZXJzZWN0cyhbWzEwLCAxMF0sIFs0MCwgNjBdXSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYEJvdW5kc2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBCb3VuZHMoYSwgYikge1xyXG5cdGlmICghYSkgeyByZXR1cm47IH1cclxuXHJcblx0dmFyIHBvaW50cyA9IGIgPyBbYSwgYl0gOiBhO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHR0aGlzLmV4dGVuZChwb2ludHNbaV0pO1xyXG5cdH1cclxufVxyXG5cclxuQm91bmRzLnByb3RvdHlwZSA9IHtcclxuXHQvLyBAbWV0aG9kIGV4dGVuZChwb2ludDogUG9pbnQpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kcyB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIHBvaW50LlxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGV4dGVuZChvdGhlckJvdW5kczogQm91bmRzKTogdGhpc1xyXG5cdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIGJvdW5kc1xyXG5cdGV4dGVuZDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIG1pbjIsIG1heDI7XHJcblx0XHRpZiAoIW9iaikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBQb2ludCB8fCB0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCAneCcgaW4gb2JqKSB7XHJcblx0XHRcdG1pbjIgPSBtYXgyID0gdG9Qb2ludChvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gdG9Cb3VuZHMob2JqKTtcclxuXHRcdFx0bWluMiA9IG9iai5taW47XHJcblx0XHRcdG1heDIgPSBvYmoubWF4O1xyXG5cclxuXHRcdFx0aWYgKCFtaW4yIHx8ICFtYXgyKSB7IHJldHVybiB0aGlzOyB9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IG1pbjogUG9pbnRcclxuXHRcdC8vIFRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cclxuXHRcdC8vIEBwcm9wZXJ0eSBtYXg6IFBvaW50XHJcblx0XHQvLyBUaGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cdFx0aWYgKCF0aGlzLm1pbiAmJiAhdGhpcy5tYXgpIHtcclxuXHRcdFx0dGhpcy5taW4gPSBtaW4yLmNsb25lKCk7XHJcblx0XHRcdHRoaXMubWF4ID0gbWF4Mi5jbG9uZSgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5taW4ueCA9IE1hdGgubWluKG1pbjIueCwgdGhpcy5taW4ueCk7XHJcblx0XHRcdHRoaXMubWF4LnggPSBNYXRoLm1heChtYXgyLngsIHRoaXMubWF4LngpO1xyXG5cdFx0XHR0aGlzLm1pbi55ID0gTWF0aC5taW4obWluMi55LCB0aGlzLm1pbi55KTtcclxuXHRcdFx0dGhpcy5tYXgueSA9IE1hdGgubWF4KG1heDIueSwgdGhpcy5tYXgueSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENlbnRlcihyb3VuZD86IEJvb2xlYW4pOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKHJvdW5kKSB7XHJcblx0XHRyZXR1cm4gdG9Qb2ludChcclxuXHRcdCAgICAgICAgKHRoaXMubWluLnggKyB0aGlzLm1heC54KSAvIDIsXHJcblx0XHQgICAgICAgICh0aGlzLm1pbi55ICsgdGhpcy5tYXgueSkgLyAyLCByb3VuZCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3R0b21MZWZ0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgYm90dG9tLWxlZnQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRCb3R0b21MZWZ0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdG9Qb2ludCh0aGlzLm1pbi54LCB0aGlzLm1heC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFRvcFJpZ2h0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgdG9wLXJpZ2h0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0VG9wUmlnaHQ6IGZ1bmN0aW9uICgpIHsgLy8gLT4gUG9pbnRcclxuXHRcdHJldHVybiB0b1BvaW50KHRoaXMubWF4LngsIHRoaXMubWluLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0VG9wTGVmdCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHRvcC1sZWZ0IHBvaW50IG9mIHRoZSBib3VuZHMgKGkuZS4gW2B0aGlzLm1pbmBdKCNib3VuZHMtbWluKSkuXHJcblx0Z2V0VG9wTGVmdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWluOyAvLyBsZWZ0LCB0b3BcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdHRvbVJpZ2h0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgYm90dG9tLXJpZ2h0IHBvaW50IG9mIHRoZSBib3VuZHMgKGkuZS4gW2B0aGlzLm1heGBdKCNib3VuZHMtbWF4KSkuXHJcblx0Z2V0Qm90dG9tUmlnaHQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm1heDsgLy8gcmlnaHQsIGJvdHRvbVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U2l6ZSgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIGdpdmVuIGJvdW5kc1xyXG5cdGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm1heC5zdWJ0cmFjdCh0aGlzLm1pbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIG9uZS5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKHBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cclxuXHRjb250YWluczogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIG1pbiwgbWF4O1xyXG5cclxuXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBQb2ludCkge1xyXG5cdFx0XHRvYmogPSB0b1BvaW50KG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSB0b0JvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBCb3VuZHMpIHtcclxuXHRcdFx0bWluID0gb2JqLm1pbjtcclxuXHRcdFx0bWF4ID0gb2JqLm1heDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1pbiA9IG1heCA9IG9iajtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKG1pbi54ID49IHRoaXMubWluLngpICYmXHJcblx0XHQgICAgICAgKG1heC54IDw9IHRoaXMubWF4LngpICYmXHJcblx0XHQgICAgICAgKG1pbi55ID49IHRoaXMubWluLnkpICYmXHJcblx0XHQgICAgICAgKG1heC55IDw9IHRoaXMubWF4LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW50ZXJzZWN0cyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzXHJcblx0Ly8gaW50ZXJzZWN0IGlmIHRoZXkgaGF2ZSBhdCBsZWFzdCBvbmUgcG9pbnQgaW4gY29tbW9uLlxyXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKEJvdW5kcykgLT4gQm9vbGVhblxyXG5cdFx0Ym91bmRzID0gdG9Cb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcblx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXHJcblx0XHQgICAgbWluMiA9IGJvdW5kcy5taW4sXHJcblx0XHQgICAgbWF4MiA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgeEludGVyc2VjdHMgPSAobWF4Mi54ID49IG1pbi54KSAmJiAobWluMi54IDw9IG1heC54KSxcclxuXHRcdCAgICB5SW50ZXJzZWN0cyA9IChtYXgyLnkgPj0gbWluLnkpICYmIChtaW4yLnkgPD0gbWF4LnkpO1xyXG5cclxuXHRcdHJldHVybiB4SW50ZXJzZWN0cyAmJiB5SW50ZXJzZWN0cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG92ZXJsYXBzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBvdmVybGFwcyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzXHJcblx0Ly8gb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcblx0XHRib3VuZHMgPSB0b0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuXHRcdCAgICB4T3ZlcmxhcHMgPSAobWF4Mi54ID4gbWluLngpICYmIChtaW4yLnggPCBtYXgueCksXHJcblx0XHQgICAgeU92ZXJsYXBzID0gKG1heDIueSA+IG1pbi55KSAmJiAobWluMi55IDwgbWF4LnkpO1xyXG5cclxuXHRcdHJldHVybiB4T3ZlcmxhcHMgJiYgeU92ZXJsYXBzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNWYWxpZCgpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGJvdW5kcyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWQuXHJcblx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhKHRoaXMubWluICYmIHRoaXMubWF4KTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gQG1ldGhvZCBwYWQoYnVmZmVyUmF0aW86IE51bWJlcik6IEJvdW5kc1xyXG5cdC8vIFJldHVybnMgYm91bmRzIGNyZWF0ZWQgYnkgZXh0ZW5kaW5nIG9yIHJldHJhY3RpbmcgdGhlIGN1cnJlbnQgYm91bmRzIGJ5IGEgZ2l2ZW4gcmF0aW8gaW4gZWFjaCBkaXJlY3Rpb24uXHJcblx0Ly8gRm9yIGV4YW1wbGUsIGEgcmF0aW8gb2YgMC41IGV4dGVuZHMgdGhlIGJvdW5kcyBieSA1MCUgaW4gZWFjaCBkaXJlY3Rpb24uXHJcblx0Ly8gTmVnYXRpdmUgdmFsdWVzIHdpbGwgcmV0cmFjdCB0aGUgYm91bmRzLlxyXG5cdHBhZDogZnVuY3Rpb24gKGJ1ZmZlclJhdGlvKSB7XHJcblx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcblx0XHRtYXggPSB0aGlzLm1heCxcclxuXHRcdGhlaWdodEJ1ZmZlciA9IE1hdGguYWJzKG1pbi54IC0gbWF4LngpICogYnVmZmVyUmF0aW8sXHJcblx0XHR3aWR0aEJ1ZmZlciA9IE1hdGguYWJzKG1pbi55IC0gbWF4LnkpICogYnVmZmVyUmF0aW87XHJcblxyXG5cclxuXHRcdHJldHVybiB0b0JvdW5kcyhcclxuXHRcdFx0dG9Qb2ludChtaW4ueCAtIGhlaWdodEJ1ZmZlciwgbWluLnkgLSB3aWR0aEJ1ZmZlciksXHJcblx0XHRcdHRvUG9pbnQobWF4LnggKyBoZWlnaHRCdWZmZXIsIG1heC55ICsgd2lkdGhCdWZmZXIpKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGdpdmVuIGJvdW5kcy5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdGJvdW5kcyA9IHRvQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubWluLmVxdWFscyhib3VuZHMuZ2V0VG9wTGVmdCgpKSAmJlxyXG5cdFx0XHR0aGlzLm1heC5lcXVhbHMoYm91bmRzLmdldEJvdHRvbVJpZ2h0KCkpO1xyXG5cdH0sXHJcbn07XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5ib3VuZHMoY29ybmVyMTogUG9pbnQsIGNvcm5lcjI6IFBvaW50KVxyXG4vLyBDcmVhdGVzIGEgQm91bmRzIG9iamVjdCBmcm9tIHR3byBjb3JuZXJzIGNvb3JkaW5hdGUgcGFpcnMuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmJvdW5kcyhwb2ludHM6IFBvaW50W10pXHJcbi8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdGhlIGdpdmVuIGFycmF5IG9mIHBvaW50cy5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvQm91bmRzKGEsIGIpIHtcclxuXHRpZiAoIWEgfHwgYSBpbnN0YW5jZW9mIEJvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgQm91bmRzKGEsIGIpO1xyXG59XHJcbiIsImltcG9ydCB7TGF0TG5nLCB0b0xhdExuZ30gZnJvbSAnLi9MYXRMbmcnO1xyXG5cclxuLypcclxuICogQGNsYXNzIExhdExuZ0JvdW5kc1xyXG4gKiBAYWthIEwuTGF0TG5nQm91bmRzXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBnZW9ncmFwaGljYWwgYXJlYSBvbiBhIG1hcC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGNvcm5lcjEgPSBMLmxhdExuZyg0MC43MTIsIC03NC4yMjcpLFxyXG4gKiBjb3JuZXIyID0gTC5sYXRMbmcoNDAuNzc0LCAtNzQuMTI1KSxcclxuICogYm91bmRzID0gTC5sYXRMbmdCb3VuZHMoY29ybmVyMSwgY29ybmVyMik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZ0JvdW5kcyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICpcclxuICogYGBganNcclxuICogbWFwLmZpdEJvdW5kcyhbXHJcbiAqIFx0WzQwLjcxMiwgLTc0LjIyN10sXHJcbiAqIFx0WzQwLjc3NCwgLTc0LjEyNV1cclxuICogXSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBDYXV0aW9uOiBpZiB0aGUgYXJlYSBjcm9zc2VzIHRoZSBhbnRpbWVyaWRpYW4gKG9mdGVuIGNvbmZ1c2VkIHdpdGggdGhlIEludGVybmF0aW9uYWwgRGF0ZSBMaW5lKSwgeW91IG11c3Qgc3BlY2lmeSBjb3JuZXJzIF9vdXRzaWRlXyB0aGUgWy0xODAsIDE4MF0gZGVncmVlcyBsb25naXR1ZGUgcmFuZ2UuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgTGF0TG5nQm91bmRzYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIExhdExuZ0JvdW5kcyhjb3JuZXIxLCBjb3JuZXIyKSB7IC8vIChMYXRMbmcsIExhdExuZykgb3IgKExhdExuZ1tdKVxyXG5cdGlmICghY29ybmVyMSkgeyByZXR1cm47IH1cclxuXHJcblx0dmFyIGxhdGxuZ3MgPSBjb3JuZXIyID8gW2Nvcm5lcjEsIGNvcm5lcjJdIDogY29ybmVyMTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHRoaXMuZXh0ZW5kKGxhdGxuZ3NbaV0pO1xyXG5cdH1cclxufVxyXG5cclxuTGF0TG5nQm91bmRzLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Ly8gQG1ldGhvZCBleHRlbmQobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnRcclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBleHRlbmQob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBib3VuZHNcclxuXHRleHRlbmQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nKSB7XHJcblx0XHRcdHN3MiA9IG9iajtcclxuXHRcdFx0bmUyID0gb2JqO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHN3MiA9IG9iai5fc291dGhXZXN0O1xyXG5cdFx0XHRuZTIgPSBvYmouX25vcnRoRWFzdDtcclxuXHJcblx0XHRcdGlmICghc3cyIHx8ICFuZTIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gb2JqID8gdGhpcy5leHRlbmQodG9MYXRMbmcob2JqKSB8fCB0b0xhdExuZ0JvdW5kcyhvYmopKSA6IHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFzdyAmJiAhbmUpIHtcclxuXHRcdFx0dGhpcy5fc291dGhXZXN0ID0gbmV3IExhdExuZyhzdzIubGF0LCBzdzIubG5nKTtcclxuXHRcdFx0dGhpcy5fbm9ydGhFYXN0ID0gbmV3IExhdExuZyhuZTIubGF0LCBuZTIubG5nKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN3LmxhdCA9IE1hdGgubWluKHN3Mi5sYXQsIHN3LmxhdCk7XHJcblx0XHRcdHN3LmxuZyA9IE1hdGgubWluKHN3Mi5sbmcsIHN3LmxuZyk7XHJcblx0XHRcdG5lLmxhdCA9IE1hdGgubWF4KG5lMi5sYXQsIG5lLmxhdCk7XHJcblx0XHRcdG5lLmxuZyA9IE1hdGgubWF4KG5lMi5sbmcsIG5lLmxuZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYWQoYnVmZmVyUmF0aW86IE51bWJlcik6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgYm91bmRzIGNyZWF0ZWQgYnkgZXh0ZW5kaW5nIG9yIHJldHJhY3RpbmcgdGhlIGN1cnJlbnQgYm91bmRzIGJ5IGEgZ2l2ZW4gcmF0aW8gaW4gZWFjaCBkaXJlY3Rpb24uXHJcblx0Ly8gRm9yIGV4YW1wbGUsIGEgcmF0aW8gb2YgMC41IGV4dGVuZHMgdGhlIGJvdW5kcyBieSA1MCUgaW4gZWFjaCBkaXJlY3Rpb24uXHJcblx0Ly8gTmVnYXRpdmUgdmFsdWVzIHdpbGwgcmV0cmFjdCB0aGUgYm91bmRzLlxyXG5cdHBhZDogZnVuY3Rpb24gKGJ1ZmZlclJhdGlvKSB7XHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgaGVpZ2h0QnVmZmVyID0gTWF0aC5hYnMoc3cubGF0IC0gbmUubGF0KSAqIGJ1ZmZlclJhdGlvLFxyXG5cdFx0ICAgIHdpZHRoQnVmZmVyID0gTWF0aC5hYnMoc3cubG5nIC0gbmUubG5nKSAqIGJ1ZmZlclJhdGlvO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKFxyXG5cdFx0ICAgICAgICBuZXcgTGF0TG5nKHN3LmxhdCAtIGhlaWdodEJ1ZmZlciwgc3cubG5nIC0gd2lkdGhCdWZmZXIpLFxyXG5cdFx0ICAgICAgICBuZXcgTGF0TG5nKG5lLmxhdCArIGhlaWdodEJ1ZmZlciwgbmUubG5nICsgd2lkdGhCdWZmZXIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKFxyXG5cdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxhdCArIHRoaXMuX25vcnRoRWFzdC5sYXQpIC8gMixcclxuXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sbmcgKyB0aGlzLl9ub3J0aEVhc3QubG5nKSAvIDIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U291dGhXZXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRTb3V0aFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3Q7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aEVhc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgbm9ydGgtZWFzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldE5vcnRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoV2VzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aC13ZXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Tm9ydGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmdldE5vcnRoKCksIHRoaXMuZ2V0V2VzdCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoRWFzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0U291dGhFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFdlc3QoKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgd2VzdCBsb25naXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG5cdGdldFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U291dGgoKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc291dGggbGF0aXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG5cdGdldFNvdXRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxhdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEVhc3QoKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZWFzdCBsb25naXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG5cdGdldEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGgoKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbm9ydGggbGF0aXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG5cdGdldE5vcnRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxhdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gb25lLlxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zIChsYXRsbmc6IExhdExuZyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cclxuXHRjb250YWluczogZnVuY3Rpb24gKG9iaikgeyAvLyAoTGF0TG5nQm91bmRzKSBvciAoTGF0TG5nKSAtPiBCb29sZWFuXHJcblx0XHRpZiAodHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgTGF0TG5nIHx8ICdsYXQnIGluIG9iaikge1xyXG5cdFx0XHRvYmogPSB0b0xhdExuZyhvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gdG9MYXRMbmdCb3VuZHMob2JqKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyLCBuZTI7XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG5cdFx0XHRzdzIgPSBvYmouZ2V0U291dGhXZXN0KCk7XHJcblx0XHRcdG5lMiA9IG9iai5nZXROb3J0aEVhc3QoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN3MiA9IG5lMiA9IG9iajtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKHN3Mi5sYXQgPj0gc3cubGF0KSAmJiAobmUyLmxhdCA8PSBuZS5sYXQpICYmXHJcblx0XHQgICAgICAgKHN3Mi5sbmcgPj0gc3cubG5nKSAmJiAobmUyLmxuZyA8PSBuZS5sbmcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW50ZXJzZWN0cyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzIGludGVyc2VjdCBpZiB0aGV5IGhhdmUgYXQgbGVhc3Qgb25lIHBvaW50IGluIGNvbW1vbi5cclxuXHRpbnRlcnNlY3RzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcblx0XHQgICAgbmUyID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cclxuXHRcdCAgICBsYXRJbnRlcnNlY3RzID0gKG5lMi5sYXQgPj0gc3cubGF0KSAmJiAoc3cyLmxhdCA8PSBuZS5sYXQpLFxyXG5cdFx0ICAgIGxuZ0ludGVyc2VjdHMgPSAobmUyLmxuZyA+PSBzdy5sbmcpICYmIChzdzIubG5nIDw9IG5lLmxuZyk7XHJcblxyXG5cdFx0cmV0dXJuIGxhdEludGVyc2VjdHMgJiYgbG5nSW50ZXJzZWN0cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG92ZXJsYXBzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBvdmVybGFwcyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzIG92ZXJsYXAgaWYgdGhlaXIgaW50ZXJzZWN0aW9uIGlzIGFuIGFyZWEuXHJcblx0b3ZlcmxhcHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZTIgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblxyXG5cdFx0ICAgIGxhdE92ZXJsYXBzID0gKG5lMi5sYXQgPiBzdy5sYXQpICYmIChzdzIubGF0IDwgbmUubGF0KSxcclxuXHRcdCAgICBsbmdPdmVybGFwcyA9IChuZTIubG5nID4gc3cubG5nKSAmJiAoc3cyLmxuZyA8IG5lLmxuZyk7XHJcblxyXG5cdFx0cmV0dXJuIGxhdE92ZXJsYXBzICYmIGxuZ092ZXJsYXBzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9CQm94U3RyaW5nKCk6IFN0cmluZ1xyXG5cdC8vIFJldHVybnMgYSBzdHJpbmcgd2l0aCBib3VuZGluZyBib3ggY29vcmRpbmF0ZXMgaW4gYSAnc291dGh3ZXN0X2xuZyxzb3V0aHdlc3RfbGF0LG5vcnRoZWFzdF9sbmcsbm9ydGhlYXN0X2xhdCcgZm9ybWF0LiBVc2VmdWwgZm9yIHNlbmRpbmcgcmVxdWVzdHMgdG8gd2ViIHNlcnZpY2VzIHRoYXQgcmV0dXJuIGdlbyBkYXRhLlxyXG5cdHRvQkJveFN0cmluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIFt0aGlzLmdldFdlc3QoKSwgdGhpcy5nZXRTb3V0aCgpLCB0aGlzLmdldEVhc3QoKSwgdGhpcy5nZXROb3J0aCgpXS5qb2luKCcsJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcywgbWF4TWFyZ2luPzogTnVtYmVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaXMgZXF1aXZhbGVudCAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKSB0byB0aGUgZ2l2ZW4gYm91bmRzLiBUaGUgbWFyZ2luIG9mIGVycm9yIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgYG1heE1hcmdpbmAgdG8gYSBzbWFsbCBudW1iZXIuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoYm91bmRzLCBtYXhNYXJnaW4pIHtcclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5lcXVhbHMoYm91bmRzLmdldFNvdXRoV2VzdCgpLCBtYXhNYXJnaW4pICYmXHJcblx0XHQgICAgICAgdGhpcy5fbm9ydGhFYXN0LmVxdWFscyhib3VuZHMuZ2V0Tm9ydGhFYXN0KCksIG1heE1hcmdpbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpc1ZhbGlkKCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYm91bmRzIGFyZSBwcm9wZXJseSBpbml0aWFsaXplZC5cclxuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISEodGhpcy5fc291dGhXZXN0ICYmIHRoaXMuX25vcnRoRWFzdCk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gVE9ETyBJbnRlcm5hdGlvbmFsIGRhdGUgbGluZT9cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nQm91bmRzKGNvcm5lcjE6IExhdExuZywgY29ybmVyMjogTGF0TG5nKVxyXG4vLyBDcmVhdGVzIGEgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGJ5IGRlZmluaW5nIHR3byBkaWFnb25hbGx5IG9wcG9zaXRlIGNvcm5lcnMgb2YgdGhlIHJlY3RhbmdsZS5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZ0JvdW5kcyhsYXRsbmdzOiBMYXRMbmdbXSlcclxuLy8gQ3JlYXRlcyBhIGBMYXRMbmdCb3VuZHNgIG9iamVjdCBkZWZpbmVkIGJ5IHRoZSBnZW9ncmFwaGljYWwgcG9pbnRzIGl0IGNvbnRhaW5zLiBWZXJ5IHVzZWZ1bCBmb3Igem9vbWluZyB0aGUgbWFwIHRvIGZpdCBhIHBhcnRpY3VsYXIgc2V0IG9mIGxvY2F0aW9ucyB3aXRoIFtgZml0Qm91bmRzYF0oI21hcC1maXRib3VuZHMpLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9MYXRMbmdCb3VuZHMoYSwgYikge1xyXG5cdGlmIChhIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoYSwgYik7XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge0VhcnRofSBmcm9tICcuL2Nycy9DUlMuRWFydGgnO1xyXG5pbXBvcnQge3RvTGF0TG5nQm91bmRzfSBmcm9tICcuL0xhdExuZ0JvdW5kcyc7XHJcblxyXG4vKiBAY2xhc3MgTGF0TG5nXHJcbiAqIEBha2EgTC5MYXRMbmdcclxuICpcclxuICogUmVwcmVzZW50cyBhIGdlb2dyYXBoaWNhbCBwb2ludCB3aXRoIGEgY2VydGFpbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogdmFyIGxhdGxuZyA9IEwubGF0TG5nKDUwLjUsIDMwLjUpO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBMYXRMbmcgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gYW5kIHNpbXBsZSBvYmplY3QgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZXNlIGxpbmVzIGFyZSBlcXVpdmFsZW50OlxyXG4gKlxyXG4gKiBgYGBcclxuICogbWFwLnBhblRvKFs1MCwgMzBdKTtcclxuICogbWFwLnBhblRvKHtsb246IDMwLCBsYXQ6IDUwfSk7XHJcbiAqIG1hcC5wYW5Ubyh7bGF0OiA1MCwgbG5nOiAzMH0pO1xyXG4gKiBtYXAucGFuVG8oTC5sYXRMbmcoNTAsIDMwKSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYExhdExuZ2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBMYXRMbmcobGF0LCBsbmcsIGFsdCkge1xyXG5cdGlmIChpc05hTihsYXQpIHx8IGlzTmFOKGxuZykpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMYXRMbmcgb2JqZWN0OiAoJyArIGxhdCArICcsICcgKyBsbmcgKyAnKScpO1xyXG5cdH1cclxuXHJcblx0Ly8gQHByb3BlcnR5IGxhdDogTnVtYmVyXHJcblx0Ly8gTGF0aXR1ZGUgaW4gZGVncmVlc1xyXG5cdHRoaXMubGF0ID0gK2xhdDtcclxuXHJcblx0Ly8gQHByb3BlcnR5IGxuZzogTnVtYmVyXHJcblx0Ly8gTG9uZ2l0dWRlIGluIGRlZ3JlZXNcclxuXHR0aGlzLmxuZyA9ICtsbmc7XHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBhbHQ6IE51bWJlclxyXG5cdC8vIEFsdGl0dWRlIGluIG1ldGVycyAob3B0aW9uYWwpXHJcblx0aWYgKGFsdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHR0aGlzLmFsdCA9ICthbHQ7XHJcblx0fVxyXG59XHJcblxyXG5MYXRMbmcucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyTGF0TG5nOiBMYXRMbmcsIG1heE1hcmdpbj86IE51bWJlcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gYExhdExuZ2AgcG9pbnQgaXMgYXQgdGhlIHNhbWUgcG9zaXRpb24gKHdpdGhpbiBhIHNtYWxsIG1hcmdpbiBvZiBlcnJvcikuIFRoZSBtYXJnaW4gb2YgZXJyb3IgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyBgbWF4TWFyZ2luYCB0byBhIHNtYWxsIG51bWJlci5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChvYmosIG1heE1hcmdpbikge1xyXG5cdFx0aWYgKCFvYmopIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0b2JqID0gdG9MYXRMbmcob2JqKTtcclxuXHJcblx0XHR2YXIgbWFyZ2luID0gTWF0aC5tYXgoXHJcblx0XHQgICAgICAgIE1hdGguYWJzKHRoaXMubGF0IC0gb2JqLmxhdCksXHJcblx0XHQgICAgICAgIE1hdGguYWJzKHRoaXMubG5nIC0gb2JqLmxuZykpO1xyXG5cclxuXHRcdHJldHVybiBtYXJnaW4gPD0gKG1heE1hcmdpbiA9PT0gdW5kZWZpbmVkID8gMS4wRS05IDogbWF4TWFyZ2luKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvU3RyaW5nKCk6IFN0cmluZ1xyXG5cdC8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvaW50IChmb3IgZGVidWdnaW5nIHB1cnBvc2VzKS5cclxuXHR0b1N0cmluZzogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0cmV0dXJuICdMYXRMbmcoJyArXHJcblx0XHQgICAgICAgIFV0aWwuZm9ybWF0TnVtKHRoaXMubGF0LCBwcmVjaXNpb24pICsgJywgJyArXHJcblx0XHQgICAgICAgIFV0aWwuZm9ybWF0TnVtKHRoaXMubG5nLCBwcmVjaXNpb24pICsgJyknO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2VUbyhvdGhlckxhdExuZzogTGF0TG5nKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgKGluIG1ldGVycykgdG8gdGhlIGdpdmVuIGBMYXRMbmdgIGNhbGN1bGF0ZWQgdXNpbmcgdGhlIFtTcGhlcmljYWwgTGF3IG9mIENvc2luZXNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NwaGVyaWNhbF9sYXdfb2ZfY29zaW5lcykuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKG90aGVyKSB7XHJcblx0XHRyZXR1cm4gRWFydGguZGlzdGFuY2UodGhpcywgdG9MYXRMbmcob3RoZXIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXAoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyBhIG5ldyBgTGF0TG5nYCBvYmplY3Qgd2l0aCB0aGUgbG9uZ2l0dWRlIHdyYXBwZWQgc28gaXQncyBhbHdheXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMuXHJcblx0d3JhcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIEVhcnRoLndyYXBMYXRMbmcodGhpcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0JvdW5kcyhzaXplSW5NZXRlcnM6IE51bWJlcik6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgYSBuZXcgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGluIHdoaWNoIGVhY2ggYm91bmRhcnkgaXMgYHNpemVJbk1ldGVycy8yYCBtZXRlcnMgYXBhcnQgZnJvbSB0aGUgYExhdExuZ2AuXHJcblx0dG9Cb3VuZHM6IGZ1bmN0aW9uIChzaXplSW5NZXRlcnMpIHtcclxuXHRcdHZhciBsYXRBY2N1cmFjeSA9IDE4MCAqIHNpemVJbk1ldGVycyAvIDQwMDc1MDE3LFxyXG5cdFx0ICAgIGxuZ0FjY3VyYWN5ID0gbGF0QWNjdXJhY3kgLyBNYXRoLmNvcygoTWF0aC5QSSAvIDE4MCkgKiB0aGlzLmxhdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRvTGF0TG5nQm91bmRzKFxyXG5cdFx0ICAgICAgICBbdGhpcy5sYXQgLSBsYXRBY2N1cmFjeSwgdGhpcy5sbmcgLSBsbmdBY2N1cmFjeV0sXHJcblx0XHQgICAgICAgIFt0aGlzLmxhdCArIGxhdEFjY3VyYWN5LCB0aGlzLmxuZyArIGxuZ0FjY3VyYWN5XSk7XHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMubGF0LCB0aGlzLmxuZywgdGhpcy5hbHQpO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5sYXRMbmcobGF0aXR1ZGU6IE51bWJlciwgbG9uZ2l0dWRlOiBOdW1iZXIsIGFsdGl0dWRlPzogTnVtYmVyKTogTGF0TG5nXHJcbi8vIENyZWF0ZXMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyBhIGdlb2dyYXBoaWNhbCBwb2ludCB3aXRoIHRoZSBnaXZlbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlIChhbmQgb3B0aW9uYWxseSBhbHRpdHVkZSkuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmcoY29vcmRzOiBBcnJheSk6IExhdExuZ1xyXG4vLyBFeHBlY3RzIGFuIGFycmF5IG9mIHRoZSBmb3JtIGBbTnVtYmVyLCBOdW1iZXJdYCBvciBgW051bWJlciwgTnVtYmVyLCBOdW1iZXJdYCBpbnN0ZWFkLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGNvb3JkczogT2JqZWN0KTogTGF0TG5nXHJcbi8vIEV4cGVjdHMgYW4gcGxhaW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7bGF0OiBOdW1iZXIsIGxuZzogTnVtYmVyfWAgb3IgYHtsYXQ6IE51bWJlciwgbG5nOiBOdW1iZXIsIGFsdDogTnVtYmVyfWAgaW5zdGVhZC5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0xhdExuZyhhLCBiLCBjKSB7XHJcblx0aWYgKGEgaW5zdGFuY2VvZiBMYXRMbmcpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRpZiAoVXRpbC5pc0FycmF5KGEpICYmIHR5cGVvZiBhWzBdICE9PSAnb2JqZWN0Jykge1xyXG5cdFx0aWYgKGEubGVuZ3RoID09PSAzKSB7XHJcblx0XHRcdHJldHVybiBuZXcgTGF0TG5nKGFbMF0sIGFbMV0sIGFbMl0pO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGEubGVuZ3RoID09PSAyKSB7XHJcblx0XHRcdHJldHVybiBuZXcgTGF0TG5nKGFbMF0sIGFbMV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cdGlmIChhID09PSB1bmRlZmluZWQgfHwgYSA9PT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgJ2xhdCcgaW4gYSkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcoYS5sYXQsICdsbmcnIGluIGEgPyBhLmxuZyA6IGEubG9uLCBhLmFsdCk7XHJcblx0fVxyXG5cdGlmIChiID09PSB1bmRlZmluZWQpIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IExhdExuZyhhLCBiLCBjKTtcclxufVxyXG4iLCJcclxuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vTGF0TG5nQm91bmRzJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5CYXNlXHJcbiAqIE9iamVjdCB0aGF0IGRlZmluZXMgY29vcmRpbmF0ZSByZWZlcmVuY2Ugc3lzdGVtcyBmb3IgcHJvamVjdGluZ1xyXG4gKiBnZW9ncmFwaGljYWwgcG9pbnRzIGludG8gcGl4ZWwgKHNjcmVlbikgY29vcmRpbmF0ZXMgYW5kIGJhY2sgKGFuZCB0b1xyXG4gKiBjb29yZGluYXRlcyBpbiBvdGhlciB1bml0cyBmb3IgW1dNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2ViX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcykuIFNlZVxyXG4gKiBbc3BhdGlhbCByZWZlcmVuY2Ugc3lzdGVtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TcGF0aWFsX3JlZmVyZW5jZV9zeXN0ZW0pLlxyXG4gKlxyXG4gKiBMZWFmbGV0IGRlZmluZXMgdGhlIG1vc3QgdXN1YWwgQ1JTcyBieSBkZWZhdWx0LiBJZiB5b3Ugd2FudCB0byB1c2UgYVxyXG4gKiBDUlMgbm90IGRlZmluZWQgYnkgZGVmYXVsdCwgdGFrZSBhIGxvb2sgYXQgdGhlXHJcbiAqIFtQcm9qNExlYWZsZXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9rYXJ0ZW5hL1Byb2o0TGVhZmxldCkgcGx1Z2luLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgdGhlIENSUyBpbnN0YW5jZXMgZG8gbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxyXG4gKiBhbmQgbWV0aG9kcyBjYW4ndCBiZSBhZGRlZCB0byB0aGVtIHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIENSUyA9IHtcclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvUG9pbnQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgZ2l2ZW4gem9vbS5cclxuXHRsYXRMbmdUb1BvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpLFxyXG5cdFx0ICAgIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvbi5fdHJhbnNmb3JtKHByb2plY3RlZFBvaW50LCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcblx0Ly8gVGhlIGludmVyc2Ugb2YgYGxhdExuZ1RvUG9pbnRgLiBQcm9qZWN0cyBwaXhlbCBjb29yZGluYXRlcyBvbiBhIGdpdmVuXHJcblx0Ly8gem9vbSBpbnRvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuXHRwb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuc2NhbGUoem9vbSksXHJcblx0XHQgICAgdW50cmFuc2Zvcm1lZFBvaW50ID0gdGhpcy50cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwb2ludCwgc2NhbGUpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHVudHJhbnNmb3JtZWRQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBjb29yZGluYXRlcyBpbiB1bml0cyBhY2NlcHRlZCBmb3JcclxuXHQvLyB0aGlzIENSUyAoZS5nLiBtZXRlcnMgZm9yIEVQU0c6Mzg1NywgZm9yIHBhc3NpbmcgaXQgdG8gV01TIHNlcnZpY2VzKS5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHByb2plY3RlZCBjb29yZGluYXRlIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgTGF0TG5nLlxyXG5cdC8vIFRoZSBpbnZlcnNlIG9mIGBwcm9qZWN0YC5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QocG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2NhbGUoem9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgdXNlZCB3aGVuIHRyYW5zZm9ybWluZyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXMgaW50b1xyXG5cdC8vIHBpeGVsIGNvb3JkaW5hdGVzIGZvciBhIHBhcnRpY3VsYXIgem9vbS4gRm9yIGV4YW1wbGUsIGl0IHJldHVybnNcclxuXHQvLyBgMjU2ICogMl56b29tYCBmb3IgTWVyY2F0b3ItYmFzZWQgQ1JTLlxyXG5cdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0cmV0dXJuIDI1NiAqIE1hdGgucG93KDIsIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgem9vbShzY2FsZTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gSW52ZXJzZSBvZiBgc2NhbGUoKWAsIHJldHVybnMgdGhlIHpvb20gbGV2ZWwgY29ycmVzcG9uZGluZyB0byBhIHNjYWxlXHJcblx0Ly8gZmFjdG9yIG9mIGBzY2FsZWAuXHJcblx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5sb2coc2NhbGUgLyAyNTYpIC8gTWF0aC5MTjI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQcm9qZWN0ZWRCb3VuZHMoem9vbTogTnVtYmVyKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGlvbidzIGJvdW5kcyBzY2FsZWQgYW5kIHRyYW5zZm9ybWVkIGZvciB0aGUgcHJvdmlkZWQgYHpvb21gLlxyXG5cdGdldFByb2plY3RlZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdGlmICh0aGlzLmluZmluaXRlKSB7IHJldHVybiBudWxsOyB9XHJcblxyXG5cdFx0dmFyIGIgPSB0aGlzLnByb2plY3Rpb24uYm91bmRzLFxyXG5cdFx0ICAgIHMgPSB0aGlzLnNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIG1pbiA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWluLCBzKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShiLm1heCwgcyk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMobWluLCBtYXgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2UobGF0bG5nMTogTGF0TG5nLCBsYXRsbmcyOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBjb2RlOiBTdHJpbmdcclxuXHQvLyBTdGFuZGFyZCBjb2RlIG5hbWUgb2YgdGhlIENSUyBwYXNzZWQgaW50byBXTVMgc2VydmljZXMgKGUuZy4gYCdFUFNHOjM4NTcnYClcclxuXHQvL1xyXG5cdC8vIEBwcm9wZXJ0eSB3cmFwTG5nOiBOdW1iZXJbXVxyXG5cdC8vIEFuIGFycmF5IG9mIHR3byBudW1iZXJzIGRlZmluaW5nIHdoZXRoZXIgdGhlIGxvbmdpdHVkZSAoaG9yaXpvbnRhbCkgY29vcmRpbmF0ZVxyXG5cdC8vIGF4aXMgd3JhcHMgYXJvdW5kIGEgZ2l2ZW4gcmFuZ2UgYW5kIGhvdy4gRGVmYXVsdHMgdG8gYFstMTgwLCAxODBdYCBpbiBtb3N0XHJcblx0Ly8gZ2VvZ3JhcGhpY2FsIENSU3MuIElmIGB1bmRlZmluZWRgLCB0aGUgbG9uZ2l0dWRlIGF4aXMgZG9lcyBub3Qgd3JhcCBhcm91bmQuXHJcblx0Ly9cclxuXHQvLyBAcHJvcGVydHkgd3JhcExhdDogTnVtYmVyW11cclxuXHQvLyBMaWtlIGB3cmFwTG5nYCwgYnV0IGZvciB0aGUgbGF0aXR1ZGUgKHZlcnRpY2FsKSBheGlzLlxyXG5cclxuXHQvLyB3cmFwTG5nOiBbbWluLCBtYXhdLFxyXG5cdC8vIHdyYXBMYXQ6IFttaW4sIG1heF0sXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBpbmZpbml0ZTogQm9vbGVhblxyXG5cdC8vIElmIHRydWUsIHRoZSBjb29yZGluYXRlIHNwYWNlIHdpbGwgYmUgdW5ib3VuZGVkIChpbmZpbml0ZSBpbiBib3RoIGF4ZXMpXHJcblx0aW5maW5pdGU6IGZhbHNlLFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ2Agd2hlcmUgbGF0IGFuZCBsbmcgaGFzIGJlZW4gd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlXHJcblx0Ly8gQ1JTJ3MgYHdyYXBMYXRgIGFuZCBgd3JhcExuZ2AgcHJvcGVydGllcywgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBsbmcgPSB0aGlzLndyYXBMbmcgPyBVdGlsLndyYXBOdW0obGF0bG5nLmxuZywgdGhpcy53cmFwTG5nLCB0cnVlKSA6IGxhdGxuZy5sbmcsXHJcblx0XHQgICAgbGF0ID0gdGhpcy53cmFwTGF0ID8gVXRpbC53cmFwTnVtKGxhdGxuZy5sYXQsIHRoaXMud3JhcExhdCwgdHJ1ZSkgOiBsYXRsbmcubGF0LFxyXG5cdFx0ICAgIGFsdCA9IGxhdGxuZy5hbHQ7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcobGF0LCBsbmcsIGFsdCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdCb3VuZHNgIHdpdGggdGhlIHNhbWUgc2l6ZSBhcyB0aGUgZ2l2ZW4gb25lLCBlbnN1cmluZ1xyXG5cdC8vIHRoYXQgaXRzIGNlbnRlciBpcyB3aXRoaW4gdGhlIENSUydzIGJvdW5kcy5cclxuXHQvLyBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLkxhdExuZ0JvdW5kc2AgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG5cdHdyYXBMYXRMbmdCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdHZhciBjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy53cmFwTGF0TG5nKGNlbnRlciksXHJcblx0XHQgICAgbGF0U2hpZnQgPSBjZW50ZXIubGF0IC0gbmV3Q2VudGVyLmxhdCxcclxuXHRcdCAgICBsbmdTaGlmdCA9IGNlbnRlci5sbmcgLSBuZXdDZW50ZXIubG5nO1xyXG5cclxuXHRcdGlmIChsYXRTaGlmdCA9PT0gMCAmJiBsbmdTaGlmdCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzdyA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZSA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHRcdCAgICBuZXdTdyA9IG5ldyBMYXRMbmcoc3cubGF0IC0gbGF0U2hpZnQsIHN3LmxuZyAtIGxuZ1NoaWZ0KSxcclxuXHRcdCAgICBuZXdOZSA9IG5ldyBMYXRMbmcobmUubGF0IC0gbGF0U2hpZnQsIG5lLmxuZyAtIGxuZ1NoaWZ0KTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhuZXdTdywgbmV3TmUpO1xyXG5cdH1cclxufTtcclxuIiwiaW1wb3J0IHtDUlN9IGZyb20gJy4vQ1JTJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBuYW1lc3BhY2UgQ1JTXG4gKiBAY3JzIEwuQ1JTLkVhcnRoXG4gKlxuICogU2VydmVzIGFzIHRoZSBiYXNlIGZvciBDUlMgdGhhdCBhcmUgZ2xvYmFsIHN1Y2ggdGhhdCB0aGV5IGNvdmVyIHRoZSBlYXJ0aC5cbiAqIENhbiBvbmx5IGJlIHVzZWQgYXMgdGhlIGJhc2UgZm9yIG90aGVyIENSUyBhbmQgY2Fubm90IGJlIHVzZWQgZGlyZWN0bHksXG4gKiBzaW5jZSBpdCBkb2VzIG5vdCBoYXZlIGEgYGNvZGVgLCBgcHJvamVjdGlvbmAgb3IgYHRyYW5zZm9ybWF0aW9uYC4gYGRpc3RhbmNlKClgIHJldHVybnNcbiAqIG1ldGVycy5cbiAqL1xuXG5leHBvcnQgdmFyIEVhcnRoID0gVXRpbC5leHRlbmQoe30sIENSUywge1xuXHR3cmFwTG5nOiBbLTE4MCwgMTgwXSxcblxuXHQvLyBNZWFuIEVhcnRoIFJhZGl1cywgYXMgcmVjb21tZW5kZWQgZm9yIHVzZSBieVxuXHQvLyB0aGUgSW50ZXJuYXRpb25hbCBVbmlvbiBvZiBHZW9kZXN5IGFuZCBHZW9waHlzaWNzLFxuXHQvLyBzZWUgaHR0cHM6Ly9yb3NldHRhY29kZS5vcmcvd2lraS9IYXZlcnNpbmVfZm9ybXVsYVxuXHRSOiA2MzcxMDAwLFxuXG5cdC8vIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBwb2ludHMgdXNpbmcgc3BoZXJpY2FsIGxhdyBvZiBjb3NpbmVzIGFwcHJveGltYXRpb25cblx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XG5cdFx0dmFyIHJhZCA9IE1hdGguUEkgLyAxODAsXG5cdFx0ICAgIGxhdDEgPSBsYXRsbmcxLmxhdCAqIHJhZCxcblx0XHQgICAgbGF0MiA9IGxhdGxuZzIubGF0ICogcmFkLFxuXHRcdCAgICBzaW5ETGF0ID0gTWF0aC5zaW4oKGxhdGxuZzIubGF0IC0gbGF0bG5nMS5sYXQpICogcmFkIC8gMiksXG5cdFx0ICAgIHNpbkRMb24gPSBNYXRoLnNpbigobGF0bG5nMi5sbmcgLSBsYXRsbmcxLmxuZykgKiByYWQgLyAyKSxcblx0XHQgICAgYSA9IHNpbkRMYXQgKiBzaW5ETGF0ICsgTWF0aC5jb3MobGF0MSkgKiBNYXRoLmNvcyhsYXQyKSAqIHNpbkRMb24gKiBzaW5ETG9uLFxuXHRcdCAgICBjID0gMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKTtcblx0XHRyZXR1cm4gdGhpcy5SICogYztcblx0fVxufSk7XG4iLCJpbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vTGF0TG5nJztcclxuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3JcclxuICpcclxuICogU3BoZXJpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24g4oCUIHRoZSBtb3N0IGNvbW1vbiBwcm9qZWN0aW9uIGZvciBvbmxpbmUgbWFwcyxcclxuICogdXNlZCBieSBhbG1vc3QgYWxsIGZyZWUgYW5kIGNvbW1lcmNpYWwgdGlsZSBwcm92aWRlcnMuIEFzc3VtZXMgdGhhdCBFYXJ0aCBpc1xyXG4gKiBhIHNwaGVyZS4gVXNlZCBieSB0aGUgYEVQU0c6Mzg1N2AgQ1JTLlxyXG4gKi9cclxuXHJcbnZhciBlYXJ0aFJhZGl1cyA9IDYzNzgxMzc7XHJcblxyXG5leHBvcnQgdmFyIFNwaGVyaWNhbE1lcmNhdG9yID0ge1xyXG5cclxuXHRSOiBlYXJ0aFJhZGl1cyxcclxuXHRNQVhfTEFUSVRVREU6IDg1LjA1MTEyODc3OTgsXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcclxuXHRcdCAgICBtYXggPSB0aGlzLk1BWF9MQVRJVFVERSxcclxuXHRcdCAgICBsYXQgPSBNYXRoLm1heChNYXRoLm1pbihtYXgsIGxhdGxuZy5sYXQpLCAtbWF4KSxcclxuXHRcdCAgICBzaW4gPSBNYXRoLnNpbihsYXQgKiBkKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KFxyXG5cdFx0XHR0aGlzLlIgKiBsYXRsbmcubG5nICogZCxcclxuXHRcdFx0dGhpcy5SICogTWF0aC5sb2coKDEgKyBzaW4pIC8gKDEgLSBzaW4pKSAvIDIpO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgZCA9IDE4MCAvIE1hdGguUEk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcoXHJcblx0XHRcdCgyICogTWF0aC5hdGFuKE1hdGguZXhwKHBvaW50LnkgLyB0aGlzLlIpKSAtIChNYXRoLlBJIC8gMikpICogZCxcclxuXHRcdFx0cG9pbnQueCAqIGQgLyB0aGlzLlIpO1xyXG5cdH0sXHJcblxyXG5cdGJvdW5kczogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBkID0gZWFydGhSYWRpdXMgKiBNYXRoLlBJO1xyXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMoWy1kLCAtZF0sIFtkLCBkXSk7XHJcblx0fSkoKVxyXG59O1xyXG4iLCJpbXBvcnQge1BvaW50fSBmcm9tICcuL1BvaW50JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFRyYW5zZm9ybWF0aW9uXHJcbiAqIEBha2EgTC5UcmFuc2Zvcm1hdGlvblxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGFuIGFmZmluZSB0cmFuc2Zvcm1hdGlvbjogYSBzZXQgb2YgY29lZmZpY2llbnRzIGBhYCwgYGJgLCBgY2AsIGBkYFxyXG4gKiBmb3IgdHJhbnNmb3JtaW5nIGEgcG9pbnQgb2YgYSBmb3JtIGAoeCwgeSlgIGludG8gYChhKnggKyBiLCBjKnkgKyBkKWAgYW5kIGRvaW5nXHJcbiAqIHRoZSByZXZlcnNlLiBVc2VkIGJ5IExlYWZsZXQgaW4gaXRzIHByb2plY3Rpb25zIGNvZGUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciB0cmFuc2Zvcm1hdGlvbiA9IEwudHJhbnNmb3JtYXRpb24oMiwgNSwgLTEsIDEwKSxcclxuICogXHRwID0gTC5wb2ludCgxLCAyKSxcclxuICogXHRwMiA9IHRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShwKSwgLy8gIEwucG9pbnQoNywgOClcclxuICogXHRwMyA9IHRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHAyKTsgLy8gIEwucG9pbnQoMSwgMilcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbi8vIGZhY3RvcnkgbmV3IEwuVHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG4vLyBDcmVhdGVzIGEgYFRyYW5zZm9ybWF0aW9uYCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29lZmZpY2llbnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCkge1xyXG5cdGlmIChVdGlsLmlzQXJyYXkoYSkpIHtcclxuXHRcdC8vIHVzZSBhcnJheSBwcm9wZXJ0aWVzXHJcblx0XHR0aGlzLl9hID0gYVswXTtcclxuXHRcdHRoaXMuX2IgPSBhWzFdO1xyXG5cdFx0dGhpcy5fYyA9IGFbMl07XHJcblx0XHR0aGlzLl9kID0gYVszXTtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblx0dGhpcy5fYSA9IGE7XHJcblx0dGhpcy5fYiA9IGI7XHJcblx0dGhpcy5fYyA9IGM7XHJcblx0dGhpcy5fZCA9IGQ7XHJcbn1cclxuXHJcblRyYW5zZm9ybWF0aW9uLnByb3RvdHlwZSA9IHtcclxuXHQvLyBAbWV0aG9kIHRyYW5zZm9ybShwb2ludDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgdHJhbnNmb3JtZWQgcG9pbnQsIG9wdGlvbmFsbHkgbXVsdGlwbGllZCBieSB0aGUgZ2l2ZW4gc2NhbGUuXHJcblx0Ly8gT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG5cdHRyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkgeyAvLyAoUG9pbnQsIE51bWJlcikgLT4gUG9pbnRcclxuXHRcdHJldHVybiB0aGlzLl90cmFuc2Zvcm0ocG9pbnQuY2xvbmUoKSwgc2NhbGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGRlc3RydWN0aXZlIHRyYW5zZm9ybSAoZmFzdGVyKVxyXG5cdF90cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHtcclxuXHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcclxuXHRcdHBvaW50LnggPSBzY2FsZSAqICh0aGlzLl9hICogcG9pbnQueCArIHRoaXMuX2IpO1xyXG5cdFx0cG9pbnQueSA9IHNjYWxlICogKHRoaXMuX2MgKiBwb2ludC55ICsgdGhpcy5fZCk7XHJcblx0XHRyZXR1cm4gcG9pbnQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnRyYW5zZm9ybShwb2ludDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXZlcnNlIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBnaXZlbiBwb2ludCwgb3B0aW9uYWxseSBkaXZpZGVkXHJcblx0Ly8gYnkgdGhlIGdpdmVuIHNjYWxlLiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0dW50cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHtcclxuXHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQoXHJcblx0XHQgICAgICAgIChwb2ludC54IC8gc2NhbGUgLSB0aGlzLl9iKSAvIHRoaXMuX2EsXHJcblx0XHQgICAgICAgIChwb2ludC55IC8gc2NhbGUgLSB0aGlzLl9kKSAvIHRoaXMuX2MpO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcblxyXG4vLyBAZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuLy8gSW5zdGFudGlhdGVzIGEgVHJhbnNmb3JtYXRpb24gb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvZWZmaWNpZW50cy5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGNvZWZmaWNpZW50czogQXJyYXkpOiBUcmFuc2Zvcm1hdGlvblxyXG4vLyBFeHBlY3RzIGFuIGNvZWZmaWNpZW50cyBhcnJheSBvZiB0aGUgZm9ybVxyXG4vLyBgW2E6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcl1gLlxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCkge1xyXG5cdHJldHVybiBuZXcgVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCk7XHJcbn1cclxuIiwiaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9DUlMuRWFydGgnO1xyXG5pbXBvcnQge1NwaGVyaWNhbE1lcmNhdG9yfSBmcm9tICcuLi9wcm9qZWN0aW9uL1Byb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3InO1xyXG5pbXBvcnQge3RvVHJhbnNmb3JtYXRpb259IGZyb20gJy4uLy4uL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5FUFNHMzg1N1xyXG4gKlxyXG4gKiBUaGUgbW9zdCBjb21tb24gQ1JTIGZvciBvbmxpbmUgbWFwcywgdXNlZCBieSBhbG1vc3QgYWxsIGZyZWUgYW5kIGNvbW1lcmNpYWxcclxuICogdGlsZSBwcm92aWRlcnMuIFVzZXMgU3BoZXJpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24uIFNldCBpbiBieSBkZWZhdWx0IGluXHJcbiAqIE1hcCdzIGBjcnNgIG9wdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIEVQU0czODU3ID0gVXRpbC5leHRlbmQoe30sIEVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6Mzg1NycsXHJcblx0cHJvamVjdGlvbjogU3BoZXJpY2FsTWVyY2F0b3IsXHJcblxyXG5cdHRyYW5zZm9ybWF0aW9uOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHNjYWxlID0gMC41IC8gKE1hdGguUEkgKiBTcGhlcmljYWxNZXJjYXRvci5SKTtcclxuXHRcdHJldHVybiB0b1RyYW5zZm9ybWF0aW9uKHNjYWxlLCAwLjUsIC1zY2FsZSwgMC41KTtcclxuXHR9KCkpXHJcbn0pO1xyXG5cclxuZXhwb3J0IHZhciBFUFNHOTAwOTEzID0gVXRpbC5leHRlbmQoe30sIEVQU0czODU3LCB7XHJcblx0Y29kZTogJ0VQU0c6OTAwOTEzJ1xyXG59KTtcclxuIiwiaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcblxuLy8gQG5hbWVzcGFjZSBTVkc7IEBzZWN0aW9uXG4vLyBUaGVyZSBhcmUgc2V2ZXJhbCBzdGF0aWMgZnVuY3Rpb25zIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuU1ZHOlxuXG4vLyBAZnVuY3Rpb24gY3JlYXRlKG5hbWU6IFN0cmluZyk6IFNWR0VsZW1lbnRcbi8vIFJldHVybnMgYSBpbnN0YW5jZSBvZiBbU1ZHRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0VsZW1lbnQpLFxuLy8gY29ycmVzcG9uZGluZyB0byB0aGUgY2xhc3MgbmFtZSBwYXNzZWQuIEZvciBleGFtcGxlLCB1c2luZyAnbGluZScgd2lsbCByZXR1cm5cbi8vIGFuIGluc3RhbmNlIG9mIFtTVkdMaW5lRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0xpbmVFbGVtZW50KS5cbmV4cG9ydCBmdW5jdGlvbiBzdmdDcmVhdGUobmFtZSkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xufVxuXG4vLyBAZnVuY3Rpb24gcG9pbnRzVG9QYXRoKHJpbmdzOiBQb2ludFtdLCBjbG9zZWQ6IEJvb2xlYW4pOiBTdHJpbmdcbi8vIEdlbmVyYXRlcyBhIFNWRyBwYXRoIHN0cmluZyBmb3IgbXVsdGlwbGUgcmluZ3MsIHdpdGggZWFjaCByaW5nIHR1cm5pbmdcbi8vIGludG8gXCJNLi5MLi5MLi5cIiBpbnN0cnVjdGlvbnNcbmV4cG9ydCBmdW5jdGlvbiBwb2ludHNUb1BhdGgocmluZ3MsIGNsb3NlZCkge1xuXHR2YXIgc3RyID0gJycsXG5cdGksIGosIGxlbiwgbGVuMiwgcG9pbnRzLCBwO1xuXG5cdGZvciAoaSA9IDAsIGxlbiA9IHJpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0cG9pbnRzID0gcmluZ3NbaV07XG5cblx0XHRmb3IgKGogPSAwLCBsZW4yID0gcG9pbnRzLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuXHRcdFx0cCA9IHBvaW50c1tqXTtcblx0XHRcdHN0ciArPSAoaiA/ICdMJyA6ICdNJykgKyBwLnggKyAnICcgKyBwLnk7XG5cdFx0fVxuXG5cdFx0Ly8gY2xvc2VzIHRoZSByaW5nIGZvciBwb2x5Z29uczsgXCJ4XCIgaXMgVk1MIHN5bnRheFxuXHRcdHN0ciArPSBjbG9zZWQgPyAoQnJvd3Nlci5zdmcgPyAneicgOiAneCcpIDogJyc7XG5cdH1cblxuXHQvLyBTVkcgY29tcGxhaW5zIGFib3V0IGVtcHR5IHBhdGggc3RyaW5nc1xuXHRyZXR1cm4gc3RyIHx8ICdNMCAwJztcbn1cblxuXG5cblxuIiwiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuL1V0aWwnO1xyXG5pbXBvcnQge3N2Z0NyZWF0ZX0gZnJvbSAnLi4vbGF5ZXIvdmVjdG9yL1NWRy5VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQnJvd3NlclxyXG4gKiBAYWthIEwuQnJvd3NlclxyXG4gKlxyXG4gKiBBIG5hbWVzcGFjZSB3aXRoIHN0YXRpYyBwcm9wZXJ0aWVzIGZvciBicm93c2VyL2ZlYXR1cmUgZGV0ZWN0aW9uIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBpZiAoTC5Ccm93c2VyLmllbHQ5KSB7XHJcbiAqICAgYWxlcnQoJ1VwZ3JhZGUgeW91ciBicm93c2VyLCBkdWRlIScpO1xyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbnZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBpZTogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgKG5vdCBFZGdlKS5cclxudmFyIGllID0gJ0FjdGl2ZVhPYmplY3QnIGluIHdpbmRvdztcclxuXHJcbi8vIEBwcm9wZXJ0eSBpZWx0OTogQm9vbGVhbjsgYHRydWVgIGZvciBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyBsZXNzIHRoYW4gOS5cclxudmFyIGllbHQ5ID0gaWUgJiYgIWRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXI7XHJcblxyXG4vLyBAcHJvcGVydHkgZWRnZTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgRWRnZSB3ZWIgYnJvd3Nlci5cclxudmFyIGVkZ2UgPSAnbXNMYXVuY2hVcmknIGluIG5hdmlnYXRvciAmJiAhKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB3ZWJraXQ6IEJvb2xlYW47XHJcbi8vIGB0cnVlYCBmb3Igd2Via2l0LWJhc2VkIGJyb3dzZXJzIGxpa2UgQ2hyb21lIGFuZCBTYWZhcmkgKGluY2x1ZGluZyBtb2JpbGUgdmVyc2lvbnMpLlxyXG52YXIgd2Via2l0ID0gdXNlckFnZW50Q29udGFpbnMoJ3dlYmtpdCcpO1xyXG5cclxuLy8gQHByb3BlcnR5IGFuZHJvaWQ6IEJvb2xlYW5cclxuLy8gKipEZXByZWNhdGVkLioqIGB0cnVlYCBmb3IgYW55IGJyb3dzZXIgcnVubmluZyBvbiBhbiBBbmRyb2lkIHBsYXRmb3JtLlxyXG52YXIgYW5kcm9pZCA9IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgYW5kcm9pZDIzOiBCb29sZWFuOyAqKkRlcHJlY2F0ZWQuKiogYHRydWVgIGZvciBicm93c2VycyBydW5uaW5nIG9uIEFuZHJvaWQgMiBvciBBbmRyb2lkIDMuXHJcbnZhciBhbmRyb2lkMjMgPSB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCAyJykgfHwgdXNlckFnZW50Q29udGFpbnMoJ2FuZHJvaWQgMycpO1xyXG5cclxuLyogU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNzk2MTI2NiBmb3IgZGV0YWlscyBvbiBkZXRlY3Rpbmcgc3RvY2sgQW5kcm9pZCAqL1xyXG52YXIgd2Via2l0VmVyID0gcGFyc2VJbnQoL1dlYktpdFxcLyhbMC05XSspfCQvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudClbMV0sIDEwKTsgLy8gYWxzbyBtYXRjaGVzIEFwcGxlV2ViS2l0XHJcbi8vIEBwcm9wZXJ0eSBhbmRyb2lkU3RvY2s6IEJvb2xlYW47ICoqRGVwcmVjYXRlZC4qKiBgdHJ1ZWAgZm9yIHRoZSBBbmRyb2lkIHN0b2NrIGJyb3dzZXIgKGkuZS4gbm90IENocm9tZSlcclxudmFyIGFuZHJvaWRTdG9jayA9IGFuZHJvaWQgJiYgdXNlckFnZW50Q29udGFpbnMoJ0dvb2dsZScpICYmIHdlYmtpdFZlciA8IDUzNyAmJiAhKCdBdWRpb05vZGUnIGluIHdpbmRvdyk7XHJcblxyXG4vLyBAcHJvcGVydHkgb3BlcmE6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXJcclxudmFyIG9wZXJhID0gISF3aW5kb3cub3BlcmE7XHJcblxyXG4vLyBAcHJvcGVydHkgY2hyb21lOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBDaHJvbWUgYnJvd3Nlci5cclxudmFyIGNocm9tZSA9ICFlZGdlICYmIHVzZXJBZ2VudENvbnRhaW5zKCdjaHJvbWUnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBnZWNrbzogQm9vbGVhbjsgYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBsaWtlIEZpcmVmb3guXHJcbnZhciBnZWNrbyA9IHVzZXJBZ2VudENvbnRhaW5zKCdnZWNrbycpICYmICF3ZWJraXQgJiYgIW9wZXJhICYmICFpZTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBzYWZhcmk6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIFNhZmFyaSBicm93c2VyLlxyXG52YXIgc2FmYXJpID0gIWNocm9tZSAmJiB1c2VyQWdlbnRDb250YWlucygnc2FmYXJpJyk7XHJcblxyXG52YXIgcGhhbnRvbSA9IHVzZXJBZ2VudENvbnRhaW5zKCdwaGFudG9tJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgb3BlcmExMjogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMgKHZlcnNpb24gMTIgb3IgbGF0ZXIpLlxyXG52YXIgb3BlcmExMiA9ICdPVHJhbnNpdGlvbicgaW4gc3R5bGU7XHJcblxyXG4vLyBAcHJvcGVydHkgd2luOiBCb29sZWFuOyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgV2luZG93cyBwbGF0Zm9ybVxyXG52YXIgd2luID0gbmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoJ1dpbicpID09PSAwO1xyXG5cclxuLy8gQHByb3BlcnR5IGllM2Q6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbnZhciBpZTNkID0gaWUgJiYgKCd0cmFuc2l0aW9uJyBpbiBzdHlsZSk7XHJcblxyXG4vLyBAcHJvcGVydHkgd2Via2l0M2Q6IEJvb2xlYW47IGB0cnVlYCBmb3Igd2Via2l0LWJhc2VkIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbnZhciB3ZWJraXQzZCA9ICgnV2ViS2l0Q1NTTWF0cml4JyBpbiB3aW5kb3cpICYmICgnbTExJyBpbiBuZXcgd2luZG93LldlYktpdENTU01hdHJpeCgpKSAmJiAhYW5kcm9pZDIzO1xyXG5cclxuLy8gQHByb3BlcnR5IGdlY2tvM2Q6IEJvb2xlYW47IGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxudmFyIGdlY2tvM2QgPSAnTW96UGVyc3BlY3RpdmUnIGluIHN0eWxlO1xyXG5cclxuLy8gQHByb3BlcnR5IGFueTNkOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbnZhciBhbnkzZCA9ICF3aW5kb3cuTF9ESVNBQkxFXzNEICYmIChpZTNkIHx8IHdlYmtpdDNkIHx8IGdlY2tvM2QpICYmICFvcGVyYTEyICYmICFwaGFudG9tO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZTogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbnZhciBtb2JpbGUgPSB0eXBlb2Ygb3JpZW50YXRpb24gIT09ICd1bmRlZmluZWQnIHx8IHVzZXJBZ2VudENvbnRhaW5zKCdtb2JpbGUnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGVXZWJraXQ6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIHdlYmtpdC1iYXNlZCBicm93c2VycyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbnZhciBtb2JpbGVXZWJraXQgPSBtb2JpbGUgJiYgd2Via2l0O1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDNkOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIHdlYmtpdC1iYXNlZCBicm93c2VycyBpbiBhIG1vYmlsZSBkZXZpY2Ugc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxudmFyIG1vYmlsZVdlYmtpdDNkID0gbW9iaWxlICYmIHdlYmtpdDNkO1xyXG5cclxuLy8gQHByb3BlcnR5IG1zUG9pbnRlcjogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIGltcGxlbWVudGluZyB0aGUgTWljcm9zb2Z0IHRvdWNoIGV2ZW50cyBtb2RlbCAobm90YWJseSBJRTEwKS5cclxudmFyIG1zUG9pbnRlciA9ICF3aW5kb3cuUG9pbnRlckV2ZW50ICYmIHdpbmRvdy5NU1BvaW50ZXJFdmVudDtcclxuXHJcbi8vIEBwcm9wZXJ0eSBwb2ludGVyOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgW3BvaW50ZXIgZXZlbnRzXShodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2RuNDMzMjQ0JTI4dj12cy44NSUyOS5hc3B4KS5cclxudmFyIHBvaW50ZXIgPSAhISh3aW5kb3cuUG9pbnRlckV2ZW50IHx8IG1zUG9pbnRlcik7XHJcblxyXG4vLyBAcHJvcGVydHkgdG91Y2hOYXRpdmU6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBbdG91Y2ggZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvVG91Y2hfZXZlbnRzKS5cclxuLy8gKipUaGlzIGRvZXMgbm90IG5lY2Vzc2FyaWx5IG1lYW4qKiB0aGF0IHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBjb21wdXRlciB3aXRoXHJcbi8vIGEgdG91Y2hzY3JlZW4sIGl0IG9ubHkgbWVhbnMgdGhhdCB0aGUgYnJvd3NlciBpcyBjYXBhYmxlIG9mIHVuZGVyc3RhbmRpbmdcclxuLy8gdG91Y2ggZXZlbnRzLlxyXG52YXIgdG91Y2hOYXRpdmUgPSAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHwgISF3aW5kb3cuVG91Y2hFdmVudDtcclxuXHJcbi8vIEBwcm9wZXJ0eSB0b3VjaDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIGVpdGhlciBbdG91Y2hdKCNicm93c2VyLXRvdWNoKSBvciBbcG9pbnRlcl0oI2Jyb3dzZXItcG9pbnRlcikgZXZlbnRzLlxyXG4vLyBOb3RlOiBwb2ludGVyIGV2ZW50cyB3aWxsIGJlIHByZWZlcnJlZCAoaWYgYXZhaWxhYmxlKSwgYW5kIHByb2Nlc3NlZCBmb3IgYWxsIGB0b3VjaCpgIGxpc3RlbmVycy5cclxudmFyIHRvdWNoID0gIXdpbmRvdy5MX05PX1RPVUNIICYmICh0b3VjaE5hdGl2ZSB8fCBwb2ludGVyKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGVPcGVyYTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlciBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbnZhciBtb2JpbGVPcGVyYSA9IG1vYmlsZSAmJiBvcGVyYTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGVHZWNrbzogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG52YXIgbW9iaWxlR2Vja28gPSBtb2JpbGUgJiYgZ2Vja287XHJcblxyXG4vLyBAcHJvcGVydHkgcmV0aW5hOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgb24gYSBoaWdoLXJlc29sdXRpb24gXCJyZXRpbmFcIiBzY3JlZW4gb3Igb24gYW55IHNjcmVlbiB3aGVuIGJyb3dzZXIncyBkaXNwbGF5IHpvb20gaXMgbW9yZSB0aGFuIDEwMCUuXHJcbnZhciByZXRpbmEgPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgKHdpbmRvdy5zY3JlZW4uZGV2aWNlWERQSSAvIHdpbmRvdy5zY3JlZW4ubG9naWNhbFhEUEkpKSA+IDE7XHJcblxyXG4vLyBAcHJvcGVydHkgcGFzc2l2ZUV2ZW50czogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBwYXNzaXZlIGV2ZW50cy5cclxudmFyIHBhc3NpdmVFdmVudHMgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHZhciBzdXBwb3J0c1Bhc3NpdmVPcHRpb24gPSBmYWxzZTtcclxuXHR0cnkge1xyXG5cdFx0dmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBnZXR0ZXItcmV0dXJuXHJcblx0XHRcdFx0c3VwcG9ydHNQYXNzaXZlT3B0aW9uID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmVFdmVudFN1cHBvcnQnLCBVdGlsLmZhbHNlRm4sIG9wdHMpO1xyXG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlRXZlbnRTdXBwb3J0JywgVXRpbC5mYWxzZUZuLCBvcHRzKTtcclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvLyBFcnJvcnMgY2FuIHNhZmVseSBiZSBpZ25vcmVkIHNpbmNlIHRoaXMgaXMgb25seSBhIGJyb3dzZXIgc3VwcG9ydCB0ZXN0LlxyXG5cdH1cclxuXHRyZXR1cm4gc3VwcG9ydHNQYXNzaXZlT3B0aW9uO1xyXG59KCkpO1xyXG5cclxuLy8gQHByb3BlcnR5IGNhbnZhczogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbYDxjYW52YXM+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc19BUEkpLlxyXG52YXIgY2FudmFzID0gKGZ1bmN0aW9uICgpIHtcclxuXHRyZXR1cm4gISFkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0O1xyXG59KCkpO1xyXG5cclxuLy8gQHByb3BlcnR5IHN2ZzogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbU1ZHXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcpLlxyXG52YXIgc3ZnID0gISEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmIHN2Z0NyZWF0ZSgnc3ZnJykuY3JlYXRlU1ZHUmVjdCk7XHJcblxyXG52YXIgaW5saW5lU3ZnID0gISFzdmcgJiYgKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0ZGl2LmlubmVySFRNTCA9ICc8c3ZnLz4nO1xyXG5cdHJldHVybiAoZGl2LmZpcnN0Q2hpbGQgJiYgZGl2LmZpcnN0Q2hpbGQubmFtZXNwYWNlVVJJKSA9PT0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcclxufSkoKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB2bWw6IEJvb2xlYW5cclxuLy8gYHRydWVgIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpLlxyXG52YXIgdm1sID0gIXN2ZyAmJiAoZnVuY3Rpb24gKCkge1xyXG5cdHRyeSB7XHJcblx0XHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRkaXYuaW5uZXJIVE1MID0gJzx2OnNoYXBlIGFkaj1cIjFcIi8+JztcclxuXHJcblx0XHR2YXIgc2hhcGUgPSBkaXYuZmlyc3RDaGlsZDtcclxuXHRcdHNoYXBlLnN0eWxlLmJlaGF2aW9yID0gJ3VybCgjZGVmYXVsdCNWTUwpJztcclxuXHJcblx0XHRyZXR1cm4gc2hhcGUgJiYgKHR5cGVvZiBzaGFwZS5hZGogPT09ICdvYmplY3QnKTtcclxuXHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufSgpKTtcclxuXHJcblxyXG4vLyBAcHJvcGVydHkgbWFjOiBCb29sZWFuOyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgTWFjIHBsYXRmb3JtXHJcbnZhciBtYWMgPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignTWFjJykgPT09IDA7XHJcblxyXG4vLyBAcHJvcGVydHkgbWFjOiBCb29sZWFuOyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgTGludXggcGxhdGZvcm1cclxudmFyIGxpbnV4ID0gbmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoJ0xpbnV4JykgPT09IDA7XHJcblxyXG5mdW5jdGlvbiB1c2VyQWdlbnRDb250YWlucyhzdHIpIHtcclxuXHRyZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc3RyKSA+PSAwO1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGllOiBpZSxcclxuXHRpZWx0OTogaWVsdDksXHJcblx0ZWRnZTogZWRnZSxcclxuXHR3ZWJraXQ6IHdlYmtpdCxcclxuXHRhbmRyb2lkOiBhbmRyb2lkLFxyXG5cdGFuZHJvaWQyMzogYW5kcm9pZDIzLFxyXG5cdGFuZHJvaWRTdG9jazogYW5kcm9pZFN0b2NrLFxyXG5cdG9wZXJhOiBvcGVyYSxcclxuXHRjaHJvbWU6IGNocm9tZSxcclxuXHRnZWNrbzogZ2Vja28sXHJcblx0c2FmYXJpOiBzYWZhcmksXHJcblx0cGhhbnRvbTogcGhhbnRvbSxcclxuXHRvcGVyYTEyOiBvcGVyYTEyLFxyXG5cdHdpbjogd2luLFxyXG5cdGllM2Q6IGllM2QsXHJcblx0d2Via2l0M2Q6IHdlYmtpdDNkLFxyXG5cdGdlY2tvM2Q6IGdlY2tvM2QsXHJcblx0YW55M2Q6IGFueTNkLFxyXG5cdG1vYmlsZTogbW9iaWxlLFxyXG5cdG1vYmlsZVdlYmtpdDogbW9iaWxlV2Via2l0LFxyXG5cdG1vYmlsZVdlYmtpdDNkOiBtb2JpbGVXZWJraXQzZCxcclxuXHRtc1BvaW50ZXI6IG1zUG9pbnRlcixcclxuXHRwb2ludGVyOiBwb2ludGVyLFxyXG5cdHRvdWNoOiB0b3VjaCxcclxuXHR0b3VjaE5hdGl2ZTogdG91Y2hOYXRpdmUsXHJcblx0bW9iaWxlT3BlcmE6IG1vYmlsZU9wZXJhLFxyXG5cdG1vYmlsZUdlY2tvOiBtb2JpbGVHZWNrbyxcclxuXHRyZXRpbmE6IHJldGluYSxcclxuXHRwYXNzaXZlRXZlbnRzOiBwYXNzaXZlRXZlbnRzLFxyXG5cdGNhbnZhczogY2FudmFzLFxyXG5cdHN2Zzogc3ZnLFxyXG5cdHZtbDogdm1sLFxyXG5cdGlubGluZVN2ZzogaW5saW5lU3ZnLFxyXG5cdG1hYzogbWFjLFxyXG5cdGxpbnV4OiBsaW51eFxyXG59O1xyXG4iLCJpbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuL0RvbUV2ZW50JztcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQge2ZhbHNlRm59IGZyb20gJy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBFeHRlbmRzIEwuRG9tRXZlbnQgdG8gcHJvdmlkZSB0b3VjaCBzdXBwb3J0IGZvciBJbnRlcm5ldCBFeHBsb3JlciBhbmQgV2luZG93cy1iYXNlZCBkZXZpY2VzLlxuICovXG5cbnZhciBQT0lOVEVSX0RPV04gPSAgIEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckRvd24nICAgOiAncG9pbnRlcmRvd24nO1xudmFyIFBPSU5URVJfTU9WRSA9ICAgQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyTW92ZScgICA6ICdwb2ludGVybW92ZSc7XG52YXIgUE9JTlRFUl9VUCA9ICAgICBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJVcCcgICAgIDogJ3BvaW50ZXJ1cCc7XG52YXIgUE9JTlRFUl9DQU5DRUwgPSBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJDYW5jZWwnIDogJ3BvaW50ZXJjYW5jZWwnO1xudmFyIHBFdmVudCA9IHtcblx0dG91Y2hzdGFydCAgOiBQT0lOVEVSX0RPV04sXG5cdHRvdWNobW92ZSAgIDogUE9JTlRFUl9NT1ZFLFxuXHR0b3VjaGVuZCAgICA6IFBPSU5URVJfVVAsXG5cdHRvdWNoY2FuY2VsIDogUE9JTlRFUl9DQU5DRUxcbn07XG52YXIgaGFuZGxlID0ge1xuXHR0b3VjaHN0YXJ0ICA6IF9vblBvaW50ZXJTdGFydCxcblx0dG91Y2htb3ZlICAgOiBfaGFuZGxlUG9pbnRlcixcblx0dG91Y2hlbmQgICAgOiBfaGFuZGxlUG9pbnRlcixcblx0dG91Y2hjYW5jZWwgOiBfaGFuZGxlUG9pbnRlclxufTtcbnZhciBfcG9pbnRlcnMgPSB7fTtcbnZhciBfcG9pbnRlckRvY0xpc3RlbmVyID0gZmFsc2U7XG5cbi8vIFByb3ZpZGVzIGEgdG91Y2ggZXZlbnRzIHdyYXBwZXIgZm9yIChtcylwb2ludGVyIGV2ZW50cy5cbi8vIHJlZiBodHRwczovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8gaHR0cHM6Ly93d3cudzMub3JnL0J1Z3MvUHVibGljL3Nob3dfYnVnLmNnaT9pZD0yMjg5MFxuXG5leHBvcnQgZnVuY3Rpb24gYWRkUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlcikge1xuXHRpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG5cdFx0X2FkZFBvaW50ZXJEb2NMaXN0ZW5lcigpO1xuXHR9XG5cdGlmICghaGFuZGxlW3R5cGVdKSB7XG5cdFx0Y29uc29sZS53YXJuKCd3cm9uZyBldmVudCBzcGVjaWZpZWQ6JywgdHlwZSk7XG5cdFx0cmV0dXJuIGZhbHNlRm47XG5cdH1cblx0aGFuZGxlciA9IGhhbmRsZVt0eXBlXS5iaW5kKHRoaXMsIGhhbmRsZXIpO1xuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihwRXZlbnRbdHlwZV0sIGhhbmRsZXIsIGZhbHNlKTtcblx0cmV0dXJuIGhhbmRsZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyKSB7XG5cdGlmICghcEV2ZW50W3R5cGVdKSB7XG5cdFx0Y29uc29sZS53YXJuKCd3cm9uZyBldmVudCBzcGVjaWZpZWQ6JywgdHlwZSk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHBFdmVudFt0eXBlXSwgaGFuZGxlciwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBfZ2xvYmFsUG9pbnRlckRvd24oZSkge1xuXHRfcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcbn1cblxuZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJNb3ZlKGUpIHtcblx0aWYgKF9wb2ludGVyc1tlLnBvaW50ZXJJZF0pIHtcblx0XHRfcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcblx0fVxufVxuXG5mdW5jdGlvbiBfZ2xvYmFsUG9pbnRlclVwKGUpIHtcblx0ZGVsZXRlIF9wb2ludGVyc1tlLnBvaW50ZXJJZF07XG59XG5cbmZ1bmN0aW9uIF9hZGRQb2ludGVyRG9jTGlzdGVuZXIoKSB7XG5cdC8vIG5lZWQgdG8ga2VlcCB0cmFjayBvZiB3aGF0IHBvaW50ZXJzIGFuZCBob3cgbWFueSBhcmUgYWN0aXZlIHRvIHByb3ZpZGUgZS50b3VjaGVzIGVtdWxhdGlvblxuXHRpZiAoIV9wb2ludGVyRG9jTGlzdGVuZXIpIHtcblx0XHQvLyB3ZSBsaXN0ZW4gZG9jdW1lbnQgYXMgYW55IGRyYWdzIHRoYXQgZW5kIGJ5IG1vdmluZyB0aGUgdG91Y2ggb2ZmIHRoZSBzY3JlZW4gZ2V0IGZpcmVkIHRoZXJlXG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0RPV04sIF9nbG9iYWxQb2ludGVyRG93biwgdHJ1ZSk7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX01PVkUsIF9nbG9iYWxQb2ludGVyTW92ZSwgdHJ1ZSk7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBfZ2xvYmFsUG9pbnRlclVwLCB0cnVlKTtcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfQ0FOQ0VMLCBfZ2xvYmFsUG9pbnRlclVwLCB0cnVlKTtcblxuXHRcdF9wb2ludGVyRG9jTGlzdGVuZXIgPSB0cnVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIF9oYW5kbGVQb2ludGVyKGhhbmRsZXIsIGUpIHtcblx0aWYgKGUucG9pbnRlclR5cGUgPT09IChlLk1TUE9JTlRFUl9UWVBFX01PVVNFIHx8ICdtb3VzZScpKSB7IHJldHVybjsgfVxuXG5cdGUudG91Y2hlcyA9IFtdO1xuXHRmb3IgKHZhciBpIGluIF9wb2ludGVycykge1xuXHRcdGUudG91Y2hlcy5wdXNoKF9wb2ludGVyc1tpXSk7XG5cdH1cblx0ZS5jaGFuZ2VkVG91Y2hlcyA9IFtlXTtcblxuXHRoYW5kbGVyKGUpO1xufVxuXG5mdW5jdGlvbiBfb25Qb2ludGVyU3RhcnQoaGFuZGxlciwgZSkge1xuXHQvLyBJRTEwIHNwZWNpZmljOiBNc1RvdWNoIG5lZWRzIHByZXZlbnREZWZhdWx0LiBTZWUgIzIwMDBcblx0aWYgKGUuTVNQT0lOVEVSX1RZUEVfVE9VQ0ggJiYgZS5wb2ludGVyVHlwZSA9PT0gZS5NU1BPSU5URVJfVFlQRV9UT1VDSCkge1xuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHR9XG5cdF9oYW5kbGVQb2ludGVyKGhhbmRsZXIsIGUpO1xufVxuIiwiaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi9Eb21FdmVudCc7XHJcblxyXG4vKlxyXG4gKiBFeHRlbmRzIHRoZSBldmVudCBoYW5kbGluZyBjb2RlIHdpdGggZG91YmxlIHRhcCBzdXBwb3J0IGZvciBtb2JpbGUgYnJvd3NlcnMuXHJcbiAqXHJcbiAqIE5vdGU6IGN1cnJlbnRseSBtb3N0IGJyb3dzZXJzIGZpcmUgbmF0aXZlIGRibGNsaWNrLCB3aXRoIG9ubHkgYSBmZXcgZXhjZXB0aW9uc1xyXG4gKiAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzcwMTIjaXNzdWVjb21tZW50LTU5NTA4NzM4NilcclxuICovXHJcblxyXG5mdW5jdGlvbiBtYWtlRGJsY2xpY2soZXZlbnQpIHtcclxuXHQvLyBpbiBtb2Rlcm4gYnJvd3NlcnMgYHR5cGVgIGNhbm5vdCBiZSBqdXN0IG92ZXJyaWRkZW46XHJcblx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRXJyb3JzL0dldHRlcl9vbmx5XHJcblx0dmFyIG5ld0V2ZW50ID0ge30sXHJcblx0ICAgIHByb3AsIGk7XHJcblx0Zm9yIChpIGluIGV2ZW50KSB7XHJcblx0XHRwcm9wID0gZXZlbnRbaV07XHJcblx0XHRuZXdFdmVudFtpXSA9IHByb3AgJiYgcHJvcC5iaW5kID8gcHJvcC5iaW5kKGV2ZW50KSA6IHByb3A7XHJcblx0fVxyXG5cdGV2ZW50ID0gbmV3RXZlbnQ7XHJcblx0bmV3RXZlbnQudHlwZSA9ICdkYmxjbGljayc7XHJcblx0bmV3RXZlbnQuZGV0YWlsID0gMjtcclxuXHRuZXdFdmVudC5pc1RydXN0ZWQgPSBmYWxzZTtcclxuXHRuZXdFdmVudC5fc2ltdWxhdGVkID0gdHJ1ZTsgLy8gZm9yIGRlYnVnIHB1cnBvc2VzXHJcblx0cmV0dXJuIG5ld0V2ZW50O1xyXG59XHJcblxyXG52YXIgZGVsYXkgPSAyMDA7XHJcbmV4cG9ydCBmdW5jdGlvbiBhZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIpIHtcclxuXHQvLyBNb3N0IGJyb3dzZXJzIGhhbmRsZSBkb3VibGUgdGFwIG5hdGl2ZWx5XHJcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgaGFuZGxlcik7XHJcblxyXG5cdC8vIE9uIHNvbWUgcGxhdGZvcm1zIHRoZSBicm93c2VyIGRvZXNuJ3QgZmlyZSBuYXRpdmUgZGJsY2xpY2tzIGZvciB0b3VjaCBldmVudHMuXHJcblx0Ly8gSXQgc2VlbXMgdGhhdCBpbiBhbGwgc3VjaCBjYXNlcyBgZGV0YWlsYCBwcm9wZXJ0eSBvZiBgY2xpY2tgIGV2ZW50IGlzIGFsd2F5cyBgMWAuXHJcblx0Ly8gU28gaGVyZSB3ZSByZWx5IG9uIHRoYXQgZmFjdCB0byBhdm9pZCBleGNlc3NpdmUgJ2RibGNsaWNrJyBzaW11bGF0aW9uIHdoZW4gbm90IG5lZWRlZC5cclxuXHR2YXIgbGFzdCA9IDAsXHJcblx0ICAgIGRldGFpbDtcclxuXHRmdW5jdGlvbiBzaW1EYmxjbGljayhlKSB7XHJcblx0XHRpZiAoZS5kZXRhaWwgIT09IDEpIHtcclxuXHRcdFx0ZGV0YWlsID0gZS5kZXRhaWw7IC8vIGtlZXAgaW4gc3luYyB0byBhdm9pZCBmYWxzZSBkYmxjbGljayBpbiBzb21lIGNhc2VzXHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fFxyXG5cdFx0XHQoZS5zb3VyY2VDYXBhYmlsaXRpZXMgJiYgIWUuc291cmNlQ2FwYWJpbGl0aWVzLmZpcmVzVG91Y2hFdmVudHMpKSB7XHJcblxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gV2hlbiBjbGlja2luZyBvbiBhbiA8aW5wdXQ+LCB0aGUgYnJvd3NlciBnZW5lcmF0ZXMgYSBjbGljayBvbiBpdHNcclxuXHRcdC8vIDxsYWJlbD4gKGFuZCB2aWNlIHZlcnNhKSB0cmlnZ2VyaW5nIHR3byBjbGlja3MgaW4gcXVpY2sgc3VjY2Vzc2lvbi5cclxuXHRcdC8vIFRoaXMgaWdub3JlcyBjbGlja3Mgb24gZWxlbWVudHMgd2hpY2ggYXJlIGEgbGFiZWwgd2l0aCBhICdmb3InXHJcblx0XHQvLyBhdHRyaWJ1dGUgKG9yIGNoaWxkcmVuIG9mIHN1Y2ggYSBsYWJlbCksIGJ1dCBub3QgY2hpbGRyZW4gb2ZcclxuXHRcdC8vIGEgPGlucHV0Pi5cclxuXHRcdHZhciBwYXRoID0gRG9tRXZlbnQuZ2V0UHJvcGFnYXRpb25QYXRoKGUpO1xyXG5cdFx0aWYgKHBhdGguc29tZShmdW5jdGlvbiAoZWwpIHtcclxuXHRcdFx0cmV0dXJuIGVsIGluc3RhbmNlb2YgSFRNTExhYmVsRWxlbWVudCAmJiBlbC5hdHRyaWJ1dGVzLmZvcjtcclxuXHRcdH0pICYmXHJcblx0XHRcdCFwYXRoLnNvbWUoZnVuY3Rpb24gKGVsKSB7XHJcblx0XHRcdFx0cmV0dXJuIChcclxuXHRcdFx0XHRcdGVsIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCB8fFxyXG5cdFx0XHRcdFx0ZWwgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudFxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH0pXHJcblx0XHQpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBub3cgPSBEYXRlLm5vdygpO1xyXG5cdFx0aWYgKG5vdyAtIGxhc3QgPD0gZGVsYXkpIHtcclxuXHRcdFx0ZGV0YWlsKys7XHJcblx0XHRcdGlmIChkZXRhaWwgPT09IDIpIHtcclxuXHRcdFx0XHRoYW5kbGVyKG1ha2VEYmxjbGljayhlKSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGRldGFpbCA9IDE7XHJcblx0XHR9XHJcblx0XHRsYXN0ID0gbm93O1xyXG5cdH1cclxuXHJcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc2ltRGJsY2xpY2spO1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0ZGJsY2xpY2s6IGhhbmRsZXIsXHJcblx0XHRzaW1EYmxjbGljazogc2ltRGJsY2xpY2tcclxuXHR9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVycykge1xyXG5cdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGhhbmRsZXJzLmRibGNsaWNrKTtcclxuXHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVycy5zaW1EYmxjbGljayk7XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBEb21VdGlsXHJcbiAqXHJcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB0aGUgW0RPTV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0RvY3VtZW50X09iamVjdF9Nb2RlbClcclxuICogdHJlZSwgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqXHJcbiAqIE1vc3QgZnVuY3Rpb25zIGV4cGVjdGluZyBvciByZXR1cm5pbmcgYSBgSFRNTEVsZW1lbnRgIGFsc28gd29yayBmb3JcclxuICogU1ZHIGVsZW1lbnRzLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgY2xhc3NlcyByZWZlciB0byBDU1MgY2xhc3Nlc1xyXG4gKiBpbiBIVE1MIGFuZCBTVkcgY2xhc3NlcyBpbiBTVkcuXHJcbiAqL1xyXG5cclxuXHJcbi8vIEBwcm9wZXJ0eSBUUkFOU0ZPUk06IFN0cmluZ1xyXG4vLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNmb3JtIHN0eWxlIG5hbWUgKGUuZy4gYCd3ZWJraXRUcmFuc2Zvcm0nYCBmb3IgV2ViS2l0KS5cclxuZXhwb3J0IHZhciBUUkFOU0ZPUk0gPSB0ZXN0UHJvcChcclxuXHRbJ3RyYW5zZm9ybScsICd3ZWJraXRUcmFuc2Zvcm0nLCAnT1RyYW5zZm9ybScsICdNb3pUcmFuc2Zvcm0nLCAnbXNUcmFuc2Zvcm0nXSk7XHJcblxyXG4vLyB3ZWJraXRUcmFuc2l0aW9uIGNvbWVzIGZpcnN0IGJlY2F1c2Ugc29tZSBicm93c2VyIHZlcnNpb25zIHRoYXQgZHJvcCB2ZW5kb3IgcHJlZml4IGRvbid0IGRvXHJcbi8vIHRoZSBzYW1lIGZvciB0aGUgdHJhbnNpdGlvbmVuZCBldmVudCwgaW4gcGFydGljdWxhciB0aGUgQW5kcm9pZCA0LjEgc3RvY2sgYnJvd3NlclxyXG5cclxuLy8gQHByb3BlcnR5IFRSQU5TSVRJT046IFN0cmluZ1xyXG4vLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNpdGlvbiBzdHlsZSBuYW1lLlxyXG5leHBvcnQgdmFyIFRSQU5TSVRJT04gPSB0ZXN0UHJvcChcclxuXHRbJ3dlYmtpdFRyYW5zaXRpb24nLCAndHJhbnNpdGlvbicsICdPVHJhbnNpdGlvbicsICdNb3pUcmFuc2l0aW9uJywgJ21zVHJhbnNpdGlvbiddKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBUUkFOU0lUSU9OX0VORDogU3RyaW5nXHJcbi8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2l0aW9uZW5kIGV2ZW50IG5hbWUuXHJcbmV4cG9ydCB2YXIgVFJBTlNJVElPTl9FTkQgPVxyXG5cdFRSQU5TSVRJT04gPT09ICd3ZWJraXRUcmFuc2l0aW9uJyB8fCBUUkFOU0lUSU9OID09PSAnT1RyYW5zaXRpb24nID8gVFJBTlNJVElPTiArICdFbmQnIDogJ3RyYW5zaXRpb25lbmQnO1xyXG5cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXQoaWQ6IFN0cmluZ3xIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbi8vIFJldHVybnMgYW4gZWxlbWVudCBnaXZlbiBpdHMgRE9NIGlkLCBvciByZXR1cm5zIHRoZSBlbGVtZW50IGl0c2VsZlxyXG4vLyBpZiBpdCB3YXMgcGFzc2VkIGRpcmVjdGx5LlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0KGlkKSB7XHJcblx0cmV0dXJuIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgOiBpZDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFN0eWxlKGVsOiBIVE1MRWxlbWVudCwgc3R5bGVBdHRyaWI6IFN0cmluZyk6IFN0cmluZ1xyXG4vLyBSZXR1cm5zIHRoZSB2YWx1ZSBmb3IgYSBjZXJ0YWluIHN0eWxlIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LFxyXG4vLyBpbmNsdWRpbmcgY29tcHV0ZWQgdmFsdWVzIG9yIHZhbHVlcyBzZXQgdGhyb3VnaCBDU1MuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdHlsZShlbCwgc3R5bGUpIHtcclxuXHR2YXIgdmFsdWUgPSBlbC5zdHlsZVtzdHlsZV0gfHwgKGVsLmN1cnJlbnRTdHlsZSAmJiBlbC5jdXJyZW50U3R5bGVbc3R5bGVdKTtcclxuXHJcblx0aWYgKCghdmFsdWUgfHwgdmFsdWUgPT09ICdhdXRvJykgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcpIHtcclxuXHRcdHZhciBjc3MgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKTtcclxuXHRcdHZhbHVlID0gY3NzID8gY3NzW3N0eWxlXSA6IG51bGw7XHJcblx0fVxyXG5cdHJldHVybiB2YWx1ZSA9PT0gJ2F1dG8nID8gbnVsbCA6IHZhbHVlO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY3JlYXRlKHRhZ05hbWU6IFN0cmluZywgY2xhc3NOYW1lPzogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbi8vIENyZWF0ZXMgYW4gSFRNTCBlbGVtZW50IHdpdGggYHRhZ05hbWVgLCBzZXRzIGl0cyBjbGFzcyB0byBgY2xhc3NOYW1lYCwgYW5kIG9wdGlvbmFsbHkgYXBwZW5kcyBpdCB0byBgY29udGFpbmVyYCBlbGVtZW50LlxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKHRhZ05hbWUsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XHJcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcclxuXHRlbC5jbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgJyc7XHJcblxyXG5cdGlmIChjb250YWluZXIpIHtcclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XHJcblx0fVxyXG5cdHJldHVybiBlbDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlbW92ZShlbDogSFRNTEVsZW1lbnQpXHJcbi8vIFJlbW92ZXMgYGVsYCBmcm9tIGl0cyBwYXJlbnQgZWxlbWVudFxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlKGVsKSB7XHJcblx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcblx0aWYgKHBhcmVudCkge1xyXG5cdFx0cGFyZW50LnJlbW92ZUNoaWxkKGVsKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBlbXB0eShlbDogSFRNTEVsZW1lbnQpXHJcbi8vIFJlbW92ZXMgYWxsIG9mIGBlbGAncyBjaGlsZHJlbiBlbGVtZW50cyBmcm9tIGBlbGBcclxuZXhwb3J0IGZ1bmN0aW9uIGVtcHR5KGVsKSB7XHJcblx0d2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcclxuXHRcdGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRvRnJvbnQoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBNYWtlcyBgZWxgIHRoZSBsYXN0IGNoaWxkIG9mIGl0cyBwYXJlbnQsIHNvIGl0IHJlbmRlcnMgaW4gZnJvbnQgb2YgdGhlIG90aGVyIGNoaWxkcmVuLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9Gcm9udChlbCkge1xyXG5cdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG5cdGlmIChwYXJlbnQgJiYgcGFyZW50Lmxhc3RDaGlsZCAhPT0gZWwpIHtcclxuXHRcdHBhcmVudC5hcHBlbmRDaGlsZChlbCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdG9CYWNrKGVsOiBIVE1MRWxlbWVudClcclxuLy8gTWFrZXMgYGVsYCB0aGUgZmlyc3QgY2hpbGQgb2YgaXRzIHBhcmVudCwgc28gaXQgcmVuZGVycyBiZWhpbmQgdGhlIG90aGVyIGNoaWxkcmVuLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9CYWNrKGVsKSB7XHJcblx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcblx0aWYgKHBhcmVudCAmJiBwYXJlbnQuZmlyc3RDaGlsZCAhPT0gZWwpIHtcclxuXHRcdHBhcmVudC5pbnNlcnRCZWZvcmUoZWwsIHBhcmVudC5maXJzdENoaWxkKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBoYXNDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZyk6IEJvb2xlYW5cclxuLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUgY29udGFpbnMgYG5hbWVgLlxyXG5leHBvcnQgZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHJldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSk7XHJcblx0fVxyXG5cdHZhciBjbGFzc05hbWUgPSBnZXRDbGFzcyhlbCk7XHJcblx0cmV0dXJuIGNsYXNzTmFtZS5sZW5ndGggPiAwICYmIG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBuYW1lICsgJyhcXFxcc3wkKScpLnRlc3QoY2xhc3NOYW1lKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZENsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4vLyBBZGRzIGBuYW1lYCB0byB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZENsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHR2YXIgY2xhc3NlcyA9IFV0aWwuc3BsaXRXb3JkcyhuYW1lKTtcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGVsLmNsYXNzTGlzdC5hZGQoY2xhc3Nlc1tpXSk7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmICghaGFzQ2xhc3MoZWwsIG5hbWUpKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gZ2V0Q2xhc3MoZWwpO1xyXG5cdFx0c2V0Q2xhc3MoZWwsIChjbGFzc05hbWUgPyBjbGFzc05hbWUgKyAnICcgOiAnJykgKyBuYW1lKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuLy8gUmVtb3ZlcyBgbmFtZWAgZnJvbSB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRlbC5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRzZXRDbGFzcyhlbCwgVXRpbC50cmltKCgnICcgKyBnZXRDbGFzcyhlbCkgKyAnICcpLnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKSkpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldENsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4vLyBTZXRzIHRoZSBlbGVtZW50J3MgY2xhc3MuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRlbC5jbGFzc05hbWUgPSBuYW1lO1xyXG5cdH0gZWxzZSB7XHJcblx0XHQvLyBpbiBjYXNlIG9mIFNWRyBlbGVtZW50XHJcblx0XHRlbC5jbGFzc05hbWUuYmFzZVZhbCA9IG5hbWU7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50KTogU3RyaW5nXHJcbi8vIFJldHVybnMgdGhlIGVsZW1lbnQncyBjbGFzcy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldENsYXNzKGVsKSB7XHJcblx0Ly8gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgYW4gU1ZHRWxlbWVudEluc3RhbmNlIGFuZCB1c2UgdGhlIGNvcnJlc3BvbmRpbmdFbGVtZW50IGluc3RlYWRcclxuXHQvLyAoUmVxdWlyZWQgZm9yIGxpbmtlZCBTVkcgZWxlbWVudHMgaW4gSUUxMS4pXHJcblx0aWYgKGVsLmNvcnJlc3BvbmRpbmdFbGVtZW50KSB7XHJcblx0XHRlbCA9IGVsLmNvcnJlc3BvbmRpbmdFbGVtZW50O1xyXG5cdH1cclxuXHRyZXR1cm4gZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCA/IGVsLmNsYXNzTmFtZSA6IGVsLmNsYXNzTmFtZS5iYXNlVmFsO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0T3BhY2l0eShlbDogSFRNTEVsZW1lbnQsIG9wYWNpdHk6IE51bWJlcilcclxuLy8gU2V0IHRoZSBvcGFjaXR5IG9mIGFuIGVsZW1lbnQgKGluY2x1ZGluZyBvbGQgSUUgc3VwcG9ydCkuXHJcbi8vIGBvcGFjaXR5YCBtdXN0IGJlIGEgbnVtYmVyIGZyb20gYDBgIHRvIGAxYC5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldE9wYWNpdHkoZWwsIHZhbHVlKSB7XHJcblx0aWYgKCdvcGFjaXR5JyBpbiBlbC5zdHlsZSkge1xyXG5cdFx0ZWwuc3R5bGUub3BhY2l0eSA9IHZhbHVlO1xyXG5cdH0gZWxzZSBpZiAoJ2ZpbHRlcicgaW4gZWwuc3R5bGUpIHtcclxuXHRcdF9zZXRPcGFjaXR5SUUoZWwsIHZhbHVlKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9zZXRPcGFjaXR5SUUoZWwsIHZhbHVlKSB7XHJcblx0dmFyIGZpbHRlciA9IGZhbHNlLFxyXG5cdCAgICBmaWx0ZXJOYW1lID0gJ0RYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhJztcclxuXHJcblx0Ly8gZmlsdGVycyBjb2xsZWN0aW9uIHRocm93cyBhbiBlcnJvciBpZiB3ZSB0cnkgdG8gcmV0cmlldmUgYSBmaWx0ZXIgdGhhdCBkb2Vzbid0IGV4aXN0XHJcblx0dHJ5IHtcclxuXHRcdGZpbHRlciA9IGVsLmZpbHRlcnMuaXRlbShmaWx0ZXJOYW1lKTtcclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvLyBkb24ndCBzZXQgb3BhY2l0eSB0byAxIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeSBzZXQgYW4gb3BhY2l0eSxcclxuXHRcdC8vIGl0IGlzbid0IG5lZWRlZCBhbmQgYnJlYWtzIHRyYW5zcGFyZW50IHBuZ3MuXHJcblx0XHRpZiAodmFsdWUgPT09IDEpIHsgcmV0dXJuOyB9XHJcblx0fVxyXG5cclxuXHR2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgKiAxMDApO1xyXG5cclxuXHRpZiAoZmlsdGVyKSB7XHJcblx0XHRmaWx0ZXIuRW5hYmxlZCA9ICh2YWx1ZSAhPT0gMTAwKTtcclxuXHRcdGZpbHRlci5PcGFjaXR5ID0gdmFsdWU7XHJcblx0fSBlbHNlIHtcclxuXHRcdGVsLnN0eWxlLmZpbHRlciArPSAnIHByb2dpZDonICsgZmlsdGVyTmFtZSArICcob3BhY2l0eT0nICsgdmFsdWUgKyAnKSc7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdGVzdFByb3AocHJvcHM6IFN0cmluZ1tdKTogU3RyaW5nfGZhbHNlXHJcbi8vIEdvZXMgdGhyb3VnaCB0aGUgYXJyYXkgb2Ygc3R5bGUgbmFtZXMgYW5kIHJldHVybnMgdGhlIGZpcnN0IG5hbWVcclxuLy8gdGhhdCBpcyBhIHZhbGlkIHN0eWxlIG5hbWUgZm9yIGFuIGVsZW1lbnQuIElmIG5vIHN1Y2ggbmFtZSBpcyBmb3VuZCxcclxuLy8gaXQgcmV0dXJucyBmYWxzZS4gVXNlZnVsIGZvciB2ZW5kb3ItcHJlZml4ZWQgc3R5bGVzIGxpa2UgYHRyYW5zZm9ybWAuXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZXN0UHJvcChwcm9wcykge1xyXG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKHByb3BzW2ldIGluIHN0eWxlKSB7XHJcblx0XHRcdHJldHVybiBwcm9wc1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsOiBIVE1MRWxlbWVudCwgb2Zmc2V0OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpXHJcbi8vIFJlc2V0cyB0aGUgM0QgQ1NTIHRyYW5zZm9ybSBvZiBgZWxgIHNvIGl0IGlzIHRyYW5zbGF0ZWQgYnkgYG9mZnNldGAgcGl4ZWxzXHJcbi8vIGFuZCBvcHRpb25hbGx5IHNjYWxlZCBieSBgc2NhbGVgLiBEb2VzIG5vdCBoYXZlIGFuIGVmZmVjdCBpZiB0aGVcclxuLy8gYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgM0QgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWwsIG9mZnNldCwgc2NhbGUpIHtcclxuXHR2YXIgcG9zID0gb2Zmc2V0IHx8IG5ldyBQb2ludCgwLCAwKTtcclxuXHJcblx0ZWwuc3R5bGVbVFJBTlNGT1JNXSA9XHJcblx0XHQoQnJvd3Nlci5pZTNkID9cclxuXHRcdFx0J3RyYW5zbGF0ZSgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4KScgOlxyXG5cdFx0XHQndHJhbnNsYXRlM2QoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCwwKScpICtcclxuXHRcdChzY2FsZSA/ICcgc2NhbGUoJyArIHNjYWxlICsgJyknIDogJycpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0UG9zaXRpb24oZWw6IEhUTUxFbGVtZW50LCBwb3NpdGlvbjogUG9pbnQpXHJcbi8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGBlbGAgdG8gY29vcmRpbmF0ZXMgc3BlY2lmaWVkIGJ5IGBwb3NpdGlvbmAsXHJcbi8vIHVzaW5nIENTUyB0cmFuc2xhdGUgb3IgdG9wL2xlZnQgcG9zaXRpb25pbmcgZGVwZW5kaW5nIG9uIHRoZSBicm93c2VyXHJcbi8vICh1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseSB0byBwb3NpdGlvbiBpdHMgbGF5ZXJzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFBvc2l0aW9uKGVsLCBwb2ludCkge1xyXG5cclxuXHQvKmVzbGludC1kaXNhYmxlICovXHJcblx0ZWwuX2xlYWZsZXRfcG9zID0gcG9pbnQ7XHJcblx0LyogZXNsaW50LWVuYWJsZSAqL1xyXG5cclxuXHRpZiAoQnJvd3Nlci5hbnkzZCkge1xyXG5cdFx0c2V0VHJhbnNmb3JtKGVsLCBwb2ludCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGVsLnN0eWxlLmxlZnQgPSBwb2ludC54ICsgJ3B4JztcclxuXHRcdGVsLnN0eWxlLnRvcCA9IHBvaW50LnkgKyAncHgnO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsOiBIVE1MRWxlbWVudCk6IFBvaW50XHJcbi8vIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIGFuIGVsZW1lbnQgcHJldmlvdXNseSBwb3NpdGlvbmVkIHdpdGggc2V0UG9zaXRpb24uXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbCkge1xyXG5cdC8vIHRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZCBmb3IgZWxlbWVudHMgcHJldmlvdXNseSBwb3NpdGlvbmVkIHVzaW5nIHNldFBvc2l0aW9uLFxyXG5cdC8vIHNvIGl0J3Mgc2FmZSB0byBjYWNoZSB0aGUgcG9zaXRpb24gZm9yIHBlcmZvcm1hbmNlXHJcblxyXG5cdHJldHVybiBlbC5fbGVhZmxldF9wb3MgfHwgbmV3IFBvaW50KDAsIDApO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZVRleHRTZWxlY3Rpb24oKVxyXG4vLyBQcmV2ZW50cyB0aGUgdXNlciBmcm9tIGdlbmVyYXRpbmcgYHNlbGVjdHN0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZFxyXG4vLyB3aGVuIHRoZSB1c2VyIGRyYWdzIHRoZSBtb3VzZSB0aHJvdWdoIGEgcGFnZSB3aXRoIHRleHQuIFVzZWQgaW50ZXJuYWxseVxyXG4vLyBieSBMZWFmbGV0IHRvIG92ZXJyaWRlIHRoZSBiZWhhdmlvdXIgb2YgYW55IGNsaWNrLWFuZC1kcmFnIGludGVyYWN0aW9uIG9uXHJcbi8vIHRoZSBtYXAuIEFmZmVjdHMgZHJhZyBpbnRlcmFjdGlvbnMgb24gdGhlIHdob2xlIGRvY3VtZW50LlxyXG5cclxuLy8gQGZ1bmN0aW9uIGVuYWJsZVRleHRTZWxlY3Rpb24oKVxyXG4vLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb25gXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXHJcbmV4cG9ydCB2YXIgZGlzYWJsZVRleHRTZWxlY3Rpb247XHJcbmV4cG9ydCB2YXIgZW5hYmxlVGV4dFNlbGVjdGlvbjtcclxudmFyIF91c2VyU2VsZWN0O1xyXG5pZiAoJ29uc2VsZWN0c3RhcnQnIGluIGRvY3VtZW50KSB7XHJcblx0ZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21FdmVudC5vbih3aW5kb3csICdzZWxlY3RzdGFydCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHR9O1xyXG5cdGVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21FdmVudC5vZmYod2luZG93LCAnc2VsZWN0c3RhcnQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0fTtcclxufSBlbHNlIHtcclxuXHR2YXIgdXNlclNlbGVjdFByb3BlcnR5ID0gdGVzdFByb3AoXHJcblx0XHRbJ3VzZXJTZWxlY3QnLCAnV2Via2l0VXNlclNlbGVjdCcsICdPVXNlclNlbGVjdCcsICdNb3pVc2VyU2VsZWN0JywgJ21zVXNlclNlbGVjdCddKTtcclxuXHJcblx0ZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcblx0XHRcdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHRcdFx0X3VzZXJTZWxlY3QgPSBzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldO1xyXG5cdFx0XHRzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gJ25vbmUnO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0ZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSBfdXNlclNlbGVjdDtcclxuXHRcdFx0X3VzZXJTZWxlY3QgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVJbWFnZURyYWcoKVxyXG4vLyBBcyBbYEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbmBdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKSwgYnV0XHJcbi8vIGZvciBgZHJhZ3N0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZCB3aGVuIHRoZSB1c2VyIGRyYWdzIGFuIGltYWdlLlxyXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZUltYWdlRHJhZygpIHtcclxuXHREb21FdmVudC5vbih3aW5kb3csICdkcmFnc3RhcnQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBlbmFibGVJbWFnZURyYWcoKVxyXG4vLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZUltYWdlRHJhZ2BdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUltYWdlRHJhZygpIHtcclxuXHREb21FdmVudC5vZmYod2luZG93LCAnZHJhZ3N0YXJ0JywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG59XHJcblxyXG52YXIgX291dGxpbmVFbGVtZW50LCBfb3V0bGluZVN0eWxlO1xyXG4vLyBAZnVuY3Rpb24gcHJldmVudE91dGxpbmUoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBNYWtlcyB0aGUgW291dGxpbmVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9vdXRsaW5lKVxyXG4vLyBvZiB0aGUgZWxlbWVudCBgZWxgIGludmlzaWJsZS4gVXNlZCBpbnRlcm5hbGx5IGJ5IExlYWZsZXQgdG8gcHJldmVudFxyXG4vLyBmb2N1c2FibGUgZWxlbWVudHMgZnJvbSBkaXNwbGF5aW5nIGFuIG91dGxpbmUgd2hlbiB0aGUgdXNlciBwZXJmb3JtcyBhXHJcbi8vIGRyYWcgaW50ZXJhY3Rpb24gb24gdGhlbS5cclxuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnRPdXRsaW5lKGVsZW1lbnQpIHtcclxuXHR3aGlsZSAoZWxlbWVudC50YWJJbmRleCA9PT0gLTEpIHtcclxuXHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcblx0fVxyXG5cdGlmICghZWxlbWVudC5zdHlsZSkgeyByZXR1cm47IH1cclxuXHRyZXN0b3JlT3V0bGluZSgpO1xyXG5cdF9vdXRsaW5lRWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0X291dGxpbmVTdHlsZSA9IGVsZW1lbnQuc3R5bGUub3V0bGluZVN0eWxlO1xyXG5cdGVsZW1lbnQuc3R5bGUub3V0bGluZVN0eWxlID0gJ25vbmUnO1xyXG5cdERvbUV2ZW50Lm9uKHdpbmRvdywgJ2tleWRvd24nLCByZXN0b3JlT3V0bGluZSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiByZXN0b3JlT3V0bGluZSgpXHJcbi8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5wcmV2ZW50T3V0bGluZWBdKCkuXHJcbmV4cG9ydCBmdW5jdGlvbiByZXN0b3JlT3V0bGluZSgpIHtcclxuXHRpZiAoIV9vdXRsaW5lRWxlbWVudCkgeyByZXR1cm47IH1cclxuXHRfb3V0bGluZUVsZW1lbnQuc3R5bGUub3V0bGluZVN0eWxlID0gX291dGxpbmVTdHlsZTtcclxuXHRfb3V0bGluZUVsZW1lbnQgPSB1bmRlZmluZWQ7XHJcblx0X291dGxpbmVTdHlsZSA9IHVuZGVmaW5lZDtcclxuXHREb21FdmVudC5vZmYod2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFNpemVkUGFyZW50Tm9kZShlbDogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4vLyBGaW5kcyB0aGUgY2xvc2VzdCBwYXJlbnQgbm9kZSB3aGljaCBzaXplICh3aWR0aCBhbmQgaGVpZ2h0KSBpcyBub3QgbnVsbC5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNpemVkUGFyZW50Tm9kZShlbGVtZW50KSB7XHJcblx0ZG8ge1xyXG5cdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcclxuXHR9IHdoaWxlICgoIWVsZW1lbnQub2Zmc2V0V2lkdGggfHwgIWVsZW1lbnQub2Zmc2V0SGVpZ2h0KSAmJiBlbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5KTtcclxuXHRyZXR1cm4gZWxlbWVudDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFNjYWxlKGVsOiBIVE1MRWxlbWVudCk6IE9iamVjdFxyXG4vLyBDb21wdXRlcyB0aGUgQ1NTIHNjYWxlIGN1cnJlbnRseSBhcHBsaWVkIG9uIHRoZSBlbGVtZW50LlxyXG4vLyBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGB4YCBhbmQgYHlgIG1lbWJlcnMgYXMgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgc2NhbGVzIHJlc3BlY3RpdmVseSxcclxuLy8gYW5kIGBib3VuZGluZ0NsaWVudFJlY3RgIGFzIHRoZSByZXN1bHQgb2YgW2BnZXRCb3VuZGluZ0NsaWVudFJlY3QoKWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2dldEJvdW5kaW5nQ2xpZW50UmVjdCkuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2FsZShlbGVtZW50KSB7XHJcblx0dmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBSZWFkLW9ubHkgaW4gb2xkIGJyb3dzZXJzLlxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0eDogcmVjdC53aWR0aCAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMSxcclxuXHRcdHk6IHJlY3QuaGVpZ2h0IC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMSxcclxuXHRcdGJvdW5kaW5nQ2xpZW50UmVjdDogcmVjdFxyXG5cdH07XHJcbn1cclxuIiwiaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCB7YWRkUG9pbnRlckxpc3RlbmVyLCByZW1vdmVQb2ludGVyTGlzdGVuZXJ9IGZyb20gJy4vRG9tRXZlbnQuUG9pbnRlcic7XHJcbmltcG9ydCB7YWRkRG91YmxlVGFwTGlzdGVuZXIsIHJlbW92ZURvdWJsZVRhcExpc3RlbmVyfSBmcm9tICcuL0RvbUV2ZW50LkRvdWJsZVRhcCc7XHJcbmltcG9ydCB7Z2V0U2NhbGV9IGZyb20gJy4vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIERvbUV2ZW50XHJcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB0aGUgW0RPTSBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudCksIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKi9cclxuXHJcbi8vIEluc3BpcmVkIGJ5IEpvaG4gUmVzaWcsIERlYW4gRWR3YXJkcyBhbmQgWVVJIGFkZEV2ZW50IGltcGxlbWVudGF0aW9ucy5cclxuXHJcbi8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgRE9NIGV2ZW50IHR5cGUgb2YgdGhlXHJcbi8vIGVsZW1lbnQgYGVsYC4gWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgdGhlIGNvbnRleHQgb2YgdGhlIGxpc3RlbmVyXHJcbi8vIChvYmplY3QgdGhlIGB0aGlzYCBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsXHJcbi8vIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuZXhwb3J0IGZ1bmN0aW9uIG9uKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdGlmICh0eXBlcyAmJiB0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdGFkZE9uZShvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHR9XHJcblx0fSBlbHNlIHtcclxuXHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0YWRkT25lKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG52YXIgZXZlbnRzS2V5ID0gJ19sZWFmbGV0X2V2ZW50cyc7XHJcblxyXG4vLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4vLyBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lciBmdW5jdGlvbi5cclxuLy8gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBvbiwgeW91IG11c3QgcGFzcyB0aGUgc2FtZVxyXG4vLyBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZyk6IHRoaXNcclxuLy8gUmVtb3ZlcyBhbGwgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lcnMgb2YgZ2l2ZW4gdHlwZXMuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXHJcbi8vIFJlbW92ZXMgYWxsIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXJzIGZyb20gZ2l2ZW4gSFRNTEVsZW1lbnRcclxuZXhwb3J0IGZ1bmN0aW9uIG9mZihvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0YmF0Y2hSZW1vdmUob2JqKTtcclxuXHRcdGRlbGV0ZSBvYmpbZXZlbnRzS2V5XTtcclxuXHJcblx0fSBlbHNlIGlmICh0eXBlcyAmJiB0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdHJlbW92ZU9uZShvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSB7XHJcblx0XHR0eXBlcyA9IFV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcclxuXHRcdFx0YmF0Y2hSZW1vdmUob2JqLCBmdW5jdGlvbiAodHlwZSkge1xyXG5cdFx0XHRcdHJldHVybiBVdGlsLmluZGV4T2YodHlwZXMsIHR5cGUpICE9PSAtMTtcclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuZnVuY3Rpb24gYmF0Y2hSZW1vdmUob2JqLCBmaWx0ZXJGbikge1xyXG5cdGZvciAodmFyIGlkIGluIG9ialtldmVudHNLZXldKSB7XHJcblx0XHR2YXIgdHlwZSA9IGlkLnNwbGl0KC9cXGQvKVswXTtcclxuXHRcdGlmICghZmlsdGVyRm4gfHwgZmlsdGVyRm4odHlwZSkpIHtcclxuXHRcdFx0cmVtb3ZlT25lKG9iaiwgdHlwZSwgbnVsbCwgbnVsbCwgaWQpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxudmFyIG1vdXNlU3Vic3QgPSB7XHJcblx0bW91c2VlbnRlcjogJ21vdXNlb3ZlcicsXHJcblx0bW91c2VsZWF2ZTogJ21vdXNlb3V0JyxcclxuXHR3aGVlbDogISgnb253aGVlbCcgaW4gd2luZG93KSAmJiAnbW91c2V3aGVlbCdcclxufTtcclxuXHJcbmZ1bmN0aW9uIGFkZE9uZShvYmosIHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblx0dmFyIGlkID0gdHlwZSArIFV0aWwuc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBVdGlsLnN0YW1wKGNvbnRleHQpIDogJycpO1xyXG5cclxuXHRpZiAob2JqW2V2ZW50c0tleV0gJiYgb2JqW2V2ZW50c0tleV1baWRdKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiBmbi5jYWxsKGNvbnRleHQgfHwgb2JqLCBlIHx8IHdpbmRvdy5ldmVudCk7XHJcblx0fTtcclxuXHJcblx0dmFyIG9yaWdpbmFsSGFuZGxlciA9IGhhbmRsZXI7XHJcblxyXG5cdGlmICghQnJvd3Nlci50b3VjaE5hdGl2ZSAmJiBCcm93c2VyLnBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XHJcblx0XHQvLyBOZWVkcyBEb21FdmVudC5Qb2ludGVyLmpzXHJcblx0XHRoYW5kbGVyID0gYWRkUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlcik7XHJcblxyXG5cdH0gZWxzZSBpZiAoQnJvd3Nlci50b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykpIHtcclxuXHRcdGhhbmRsZXIgPSBhZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIpO1xyXG5cclxuXHR9IGVsc2UgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiBvYmopIHtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnIHx8IHR5cGUgPT09ICd0b3VjaG1vdmUnIHx8IHR5cGUgPT09ICd3aGVlbCcgfHwgIHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcihtb3VzZVN1YnN0W3R5cGVdIHx8IHR5cGUsIGhhbmRsZXIsIEJyb3dzZXIucGFzc2l2ZUV2ZW50cyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZSk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAnbW91c2VlbnRlcicgfHwgdHlwZSA9PT0gJ21vdXNlbGVhdmUnKSB7XHJcblx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcclxuXHRcdFx0XHRpZiAoaXNFeHRlcm5hbFRhcmdldChvYmosIGUpKSB7XHJcblx0XHRcdFx0XHRvcmlnaW5hbEhhbmRsZXIoZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcihtb3VzZVN1YnN0W3R5cGVdLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgb3JpZ2luYWxIYW5kbGVyLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSB7XHJcblx0XHRvYmouYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xyXG5cdH1cclxuXHJcblx0b2JqW2V2ZW50c0tleV0gPSBvYmpbZXZlbnRzS2V5XSB8fCB7fTtcclxuXHRvYmpbZXZlbnRzS2V5XVtpZF0gPSBoYW5kbGVyO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVPbmUob2JqLCB0eXBlLCBmbiwgY29udGV4dCwgaWQpIHtcclxuXHRpZCA9IGlkIHx8IHR5cGUgKyBVdGlsLnN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgVXRpbC5zdGFtcChjb250ZXh0KSA6ICcnKTtcclxuXHR2YXIgaGFuZGxlciA9IG9ialtldmVudHNLZXldICYmIG9ialtldmVudHNLZXldW2lkXTtcclxuXHJcblx0aWYgKCFoYW5kbGVyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdGlmICghQnJvd3Nlci50b3VjaE5hdGl2ZSAmJiBCcm93c2VyLnBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XHJcblx0XHRyZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyKTtcclxuXHJcblx0fSBlbHNlIGlmIChCcm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSkge1xyXG5cdFx0cmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyKTtcclxuXHJcblx0fSBlbHNlIGlmICgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIobW91c2VTdWJzdFt0eXBlXSB8fCB0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblx0XHRvYmouZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xyXG5cdH1cclxuXHJcblx0b2JqW2V2ZW50c0tleV1baWRdID0gbnVsbDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihldjogRE9NRXZlbnQpOiB0aGlzXHJcbi8vIFN0b3AgdGhlIGdpdmVuIGV2ZW50IGZyb20gcHJvcGFnYXRpb24gdG8gcGFyZW50IGVsZW1lbnRzLiBVc2VkIGluc2lkZSB0aGUgbGlzdGVuZXIgZnVuY3Rpb25zOlxyXG4vLyBgYGBqc1xyXG4vLyBMLkRvbUV2ZW50Lm9uKGRpdiwgJ2NsaWNrJywgZnVuY3Rpb24gKGV2KSB7XHJcbi8vIFx0TC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24oZXYpO1xyXG4vLyB9KTtcclxuLy8gYGBgXHJcbmV4cG9ydCBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZSkge1xyXG5cclxuXHRpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcclxuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0fSBlbHNlIGlmIChlLm9yaWdpbmFsRXZlbnQpIHsgIC8vIEluIGNhc2Ugb2YgTGVhZmxldCBldmVudC5cclxuXHRcdGUub3JpZ2luYWxFdmVudC5fc3RvcHBlZCA9IHRydWU7XHJcblx0fSBlbHNlIHtcclxuXHRcdGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuLy8gQWRkcyBgc3RvcFByb3BhZ2F0aW9uYCB0byB0aGUgZWxlbWVudCdzIGAnd2hlZWwnYCBldmVudHMgKHBsdXMgYnJvd3NlciB2YXJpYW50cykuXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oZWwpIHtcclxuXHRhZGRPbmUoZWwsICd3aGVlbCcsIHN0b3BQcm9wYWdhdGlvbik7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXHJcbi8vIEFkZHMgYHN0b3BQcm9wYWdhdGlvbmAgdG8gdGhlIGVsZW1lbnQncyBgJ2NsaWNrJ2AsIGAnZGJsY2xpY2snYCwgYCdjb250ZXh0bWVudSdgLFxyXG4vLyBgJ21vdXNlZG93bidgIGFuZCBgJ3RvdWNoc3RhcnQnYCBldmVudHMgKHBsdXMgYnJvd3NlciB2YXJpYW50cykuXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihlbCkge1xyXG5cdG9uKGVsLCAnbW91c2Vkb3duIHRvdWNoc3RhcnQgZGJsY2xpY2sgY29udGV4dG1lbnUnLCBzdG9wUHJvcGFnYXRpb24pO1xyXG5cdGVsWydfbGVhZmxldF9kaXNhYmxlX2NsaWNrJ10gPSB0cnVlO1xyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXY6IERPTUV2ZW50KTogdGhpc1xyXG4vLyBQcmV2ZW50cyB0aGUgZGVmYXVsdCBhY3Rpb24gb2YgdGhlIERPTSBFdmVudCBgZXZgIGZyb20gaGFwcGVuaW5nIChzdWNoIGFzXHJcbi8vIGZvbGxvd2luZyBhIGxpbmsgaW4gdGhlIGhyZWYgb2YgdGhlIGEgZWxlbWVudCwgb3IgZG9pbmcgYSBQT1NUIHJlcXVlc3RcclxuLy8gd2l0aCBwYWdlIHJlbG9hZCB3aGVuIGEgYDxmb3JtPmAgaXMgc3VibWl0dGVkKS5cclxuLy8gVXNlIGl0IGluc2lkZSBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChlKSB7XHJcblx0aWYgKGUucHJldmVudERlZmF1bHQpIHtcclxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHN0b3AoZXY6IERPTUV2ZW50KTogdGhpc1xyXG4vLyBEb2VzIGBzdG9wUHJvcGFnYXRpb25gIGFuZCBgcHJldmVudERlZmF1bHRgIGF0IHRoZSBzYW1lIHRpbWUuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdG9wKGUpIHtcclxuXHRwcmV2ZW50RGVmYXVsdChlKTtcclxuXHRzdG9wUHJvcGFnYXRpb24oZSk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRQcm9wYWdhdGlvblBhdGgoZXY6IERPTUV2ZW50KTogQXJyYXlcclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW2BFdmVudC5jb21wb3NlZFBhdGgoKWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudC9jb21wb3NlZFBhdGgpLlxyXG4vLyBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGBIVE1MRWxlbWVudGBzIHRoYXQgdGhlIGdpdmVuIERPTSBldmVudFxyXG4vLyBzaG91bGQgcHJvcGFnYXRlIHRvIChpZiBub3Qgc3RvcHBlZCkuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9wYWdhdGlvblBhdGgoZXYpIHtcclxuXHRpZiAoZXYuY29tcG9zZWRQYXRoKSB7XHJcblx0XHRyZXR1cm4gZXYuY29tcG9zZWRQYXRoKCk7XHJcblx0fVxyXG5cclxuXHR2YXIgcGF0aCA9IFtdO1xyXG5cdHZhciBlbCA9IGV2LnRhcmdldDtcclxuXHJcblx0d2hpbGUgKGVsKSB7XHJcblx0XHRwYXRoLnB1c2goZWwpO1xyXG5cdFx0ZWwgPSBlbC5wYXJlbnROb2RlO1xyXG5cdH1cclxuXHRyZXR1cm4gcGF0aDtcclxufVxyXG5cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRNb3VzZVBvc2l0aW9uKGV2OiBET01FdmVudCwgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBQb2ludFxyXG4vLyBHZXRzIG5vcm1hbGl6ZWQgbW91c2UgcG9zaXRpb24gZnJvbSBhIERPTSBldmVudCByZWxhdGl2ZSB0byB0aGVcclxuLy8gYGNvbnRhaW5lcmAgKGJvcmRlciBleGNsdWRlZCkgb3IgdG8gdGhlIHdob2xlIHBhZ2UgaWYgbm90IHNwZWNpZmllZC5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZSwgY29udGFpbmVyKSB7XHJcblx0aWYgKCFjb250YWluZXIpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xyXG5cdH1cclxuXHJcblx0dmFyIHNjYWxlID0gZ2V0U2NhbGUoY29udGFpbmVyKSxcclxuXHQgICAgb2Zmc2V0ID0gc2NhbGUuYm91bmRpbmdDbGllbnRSZWN0OyAvLyBsZWZ0IGFuZCB0b3AgIHZhbHVlcyBhcmUgaW4gcGFnZSBzY2FsZSAobGlrZSB0aGUgZXZlbnQgY2xpZW50WC9ZKVxyXG5cclxuXHRyZXR1cm4gbmV3IFBvaW50KFxyXG5cdFx0Ly8gb2Zmc2V0LmxlZnQvdG9wIHZhbHVlcyBhcmUgaW4gcGFnZSBzY2FsZSAobGlrZSBjbGllbnRYL1kpLFxyXG5cdFx0Ly8gd2hlcmVhcyBjbGllbnRMZWZ0L1RvcCAoYm9yZGVyIHdpZHRoKSB2YWx1ZXMgYXJlIHRoZSBvcmlnaW5hbCB2YWx1ZXMgKGJlZm9yZSBDU1Mgc2NhbGUgYXBwbGllcykuXHJcblx0XHQoZS5jbGllbnRYIC0gb2Zmc2V0LmxlZnQpIC8gc2NhbGUueCAtIGNvbnRhaW5lci5jbGllbnRMZWZ0LFxyXG5cdFx0KGUuY2xpZW50WSAtIG9mZnNldC50b3ApIC8gc2NhbGUueSAtIGNvbnRhaW5lci5jbGllbnRUb3BcclxuXHQpO1xyXG59XHJcblxyXG5cclxuLy8gIGV4Y2VwdCAsIFNhZmFyaSBhbmRcclxuLy8gV2UgbmVlZCBkb3VibGUgdGhlIHNjcm9sbCBwaXhlbHMgKHNlZSAjNzQwMyBhbmQgIzQ1MzgpIGZvciBhbGwgQnJvd3NlcnNcclxuLy8gZXhjZXB0IE9TWCAoTWFjKSAtPiAzeCwgQ2hyb21lIHJ1bm5pbmcgb24gTGludXggMXhcclxuXHJcbnZhciB3aGVlbFB4RmFjdG9yID1cclxuXHQoQnJvd3Nlci5saW51eCAmJiBCcm93c2VyLmNocm9tZSkgPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6XHJcblx0QnJvd3Nlci5tYWMgPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyAqIDMgOlxyXG5cdHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID4gMCA/IDIgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XHJcbi8vIEBmdW5jdGlvbiBnZXRXaGVlbERlbHRhKGV2OiBET01FdmVudCk6IE51bWJlclxyXG4vLyBHZXRzIG5vcm1hbGl6ZWQgd2hlZWwgZGVsdGEgZnJvbSBhIHdoZWVsIERPTSBldmVudCwgaW4gdmVydGljYWxcclxuLy8gcGl4ZWxzIHNjcm9sbGVkIChuZWdhdGl2ZSBpZiBzY3JvbGxpbmcgZG93bikuXHJcbi8vIEV2ZW50cyBmcm9tIHBvaW50aW5nIGRldmljZXMgd2l0aG91dCBwcmVjaXNlIHNjcm9sbGluZyBhcmUgbWFwcGVkIHRvXHJcbi8vIGEgYmVzdCBndWVzcyBvZiA2MCBwaXhlbHMuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRXaGVlbERlbHRhKGUpIHtcclxuXHRyZXR1cm4gKEJyb3dzZXIuZWRnZSkgPyBlLndoZWVsRGVsdGFZIC8gMiA6IC8vIERvbid0IHRydXN0IHdpbmRvdy1nZW9tZXRyeS1iYXNlZCBkZWx0YVxyXG5cdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDApID8gLWUuZGVsdGFZIC8gd2hlZWxQeEZhY3RvciA6IC8vIFBpeGVsc1xyXG5cdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDEpID8gLWUuZGVsdGFZICogMjAgOiAvLyBMaW5lc1xyXG5cdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDIpID8gLWUuZGVsdGFZICogNjAgOiAvLyBQYWdlc1xyXG5cdCAgICAgICAoZS5kZWx0YVggfHwgZS5kZWx0YVopID8gMCA6XHQvLyBTa2lwIGhvcml6b250YWwvZGVwdGggd2hlZWwgZXZlbnRzXHJcblx0ICAgICAgIGUud2hlZWxEZWx0YSA/IChlLndoZWVsRGVsdGFZIHx8IGUud2hlZWxEZWx0YSkgLyAyIDogLy8gTGVnYWN5IElFIHBpeGVsc1xyXG5cdCAgICAgICAoZS5kZXRhaWwgJiYgTWF0aC5hYnMoZS5kZXRhaWwpIDwgMzI3NjUpID8gLWUuZGV0YWlsICogMjAgOiAvLyBMZWdhY3kgTW96IGxpbmVzXHJcblx0ICAgICAgIGUuZGV0YWlsID8gZS5kZXRhaWwgLyAtMzI3NjUgKiA2MCA6IC8vIExlZ2FjeSBNb3ogcGFnZXNcclxuXHQgICAgICAgMDtcclxufVxyXG5cclxuLy8gY2hlY2sgaWYgZWxlbWVudCByZWFsbHkgbGVmdC9lbnRlcmVkIHRoZSBldmVudCB0YXJnZXQgKGZvciBtb3VzZWVudGVyL21vdXNlbGVhdmUpXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0V4dGVybmFsVGFyZ2V0KGVsLCBlKSB7XHJcblxyXG5cdHZhciByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0O1xyXG5cclxuXHRpZiAoIXJlbGF0ZWQpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0dHJ5IHtcclxuXHRcdHdoaWxlIChyZWxhdGVkICYmIChyZWxhdGVkICE9PSBlbCkpIHtcclxuXHRcdFx0cmVsYXRlZCA9IHJlbGF0ZWQucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblx0cmV0dXJuIChyZWxhdGVkICE9PSBlbCk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBhZGRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgTC5Eb21FdmVudC5vbmBdKCNkb21ldmVudC1vbilcclxuZXhwb3J0IHtvbiBhcyBhZGRMaXN0ZW5lcn07XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYEwuRG9tRXZlbnQub2ZmYF0oI2RvbWV2ZW50LW9mZilcclxuZXhwb3J0IHtvZmYgYXMgcmVtb3ZlTGlzdGVuZXJ9O1xyXG4iLCJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4uL2NvcmUvRXZlbnRzJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xuXG5cbi8qXG4gKiBAY2xhc3MgUG9zQW5pbWF0aW9uXG4gKiBAYWthIEwuUG9zQW5pbWF0aW9uXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxuICogVXNlZCBpbnRlcm5hbGx5IGZvciBwYW5uaW5nIGFuaW1hdGlvbnMsIHV0aWxpemluZyBDU1MzIFRyYW5zaXRpb25zIGZvciBtb2Rlcm4gYnJvd3NlcnMgYW5kIGEgdGltZXIgZmFsbGJhY2sgZm9yIElFNi05LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogdmFyIG15UG9zaXRpb25NYXJrZXIgPSBMLm1hcmtlcihbNDguODY0NzE2LCAyLjI5NDY5NF0pLmFkZFRvKG1hcCk7XG4gKlxuICogbXlQb3NpdGlvbk1hcmtlci5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICogXHR2YXIgcG9zID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChteVBvc2l0aW9uTWFya2VyLmdldExhdExuZygpKTtcbiAqIFx0cG9zLnkgLT0gMjU7XG4gKiBcdHZhciBmeCA9IG5ldyBMLlBvc0FuaW1hdGlvbigpO1xuICpcbiAqIFx0Zngub25jZSgnZW5kJyxmdW5jdGlvbigpIHtcbiAqIFx0XHRwb3MueSArPSAyNTtcbiAqIFx0XHRmeC5ydW4obXlQb3NpdGlvbk1hcmtlci5faWNvbiwgcG9zLCAwLjgpO1xuICogXHR9KTtcbiAqXG4gKiBcdGZ4LnJ1bihteVBvc2l0aW9uTWFya2VyLl9pY29uLCBwb3MsIDAuMyk7XG4gKiB9KTtcbiAqXG4gKiBgYGBcbiAqXG4gKiBAY29uc3RydWN0b3IgTC5Qb3NBbmltYXRpb24oKVxuICogQ3JlYXRlcyBhIGBQb3NBbmltYXRpb25gIG9iamVjdC5cbiAqXG4gKi9cblxuZXhwb3J0IHZhciBQb3NBbmltYXRpb24gPSBFdmVudGVkLmV4dGVuZCh7XG5cblx0Ly8gQG1ldGhvZCBydW4oZWw6IEhUTUxFbGVtZW50LCBuZXdQb3M6IFBvaW50LCBkdXJhdGlvbj86IE51bWJlciwgZWFzZUxpbmVhcml0eT86IE51bWJlcilcblx0Ly8gUnVuIGFuIGFuaW1hdGlvbiBvZiBhIGdpdmVuIGVsZW1lbnQgdG8gYSBuZXcgcG9zaXRpb24sIG9wdGlvbmFsbHkgc2V0dGluZ1xuXHQvLyBkdXJhdGlvbiBpbiBzZWNvbmRzIChgMC4yNWAgYnkgZGVmYXVsdCkgYW5kIGVhc2luZyBsaW5lYXJpdHkgZmFjdG9yICgzcmRcblx0Ly8gYXJndW1lbnQgb2YgdGhlIFtjdWJpYyBiZXppZXIgY3VydmVdKGh0dHBzOi8vY3ViaWMtYmV6aWVyLmNvbS8jMCwwLC41LDEpLFxuXHQvLyBgMC41YCBieSBkZWZhdWx0KS5cblx0cnVuOiBmdW5jdGlvbiAoZWwsIG5ld1BvcywgZHVyYXRpb24sIGVhc2VMaW5lYXJpdHkpIHtcblx0XHR0aGlzLnN0b3AoKTtcblxuXHRcdHRoaXMuX2VsID0gZWw7XG5cdFx0dGhpcy5faW5Qcm9ncmVzcyA9IHRydWU7XG5cdFx0dGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbiB8fCAwLjI1O1xuXHRcdHRoaXMuX2Vhc2VPdXRQb3dlciA9IDEgLyBNYXRoLm1heChlYXNlTGluZWFyaXR5IHx8IDAuNSwgMC4yKTtcblxuXHRcdHRoaXMuX3N0YXJ0UG9zID0gRG9tVXRpbC5nZXRQb3NpdGlvbihlbCk7XG5cdFx0dGhpcy5fb2Zmc2V0ID0gbmV3UG9zLnN1YnRyYWN0KHRoaXMuX3N0YXJ0UG9zKTtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblxuXHRcdC8vIEBldmVudCBzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gc3RhcnRzXG5cdFx0dGhpcy5maXJlKCdzdGFydCcpO1xuXG5cdFx0dGhpcy5fYW5pbWF0ZSgpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc3RvcCgpXG5cdC8vIFN0b3BzIHRoZSBhbmltYXRpb24gKGlmIGN1cnJlbnRseSBydW5uaW5nKS5cblx0c3RvcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5faW5Qcm9ncmVzcykgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX3N0ZXAodHJ1ZSk7XG5cdFx0dGhpcy5fY29tcGxldGUoKTtcblx0fSxcblxuXHRfYW5pbWF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGFuaW1hdGlvbiBsb29wXG5cdFx0dGhpcy5fYW5pbUlkID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FuaW1hdGUsIHRoaXMpO1xuXHRcdHRoaXMuX3N0ZXAoKTtcblx0fSxcblxuXHRfc3RlcDogZnVuY3Rpb24gKHJvdW5kKSB7XG5cdFx0dmFyIGVsYXBzZWQgPSAoK25ldyBEYXRlKCkpIC0gdGhpcy5fc3RhcnRUaW1lLFxuXHRcdCAgICBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uICogMTAwMDtcblxuXHRcdGlmIChlbGFwc2VkIDwgZHVyYXRpb24pIHtcblx0XHRcdHRoaXMuX3J1bkZyYW1lKHRoaXMuX2Vhc2VPdXQoZWxhcHNlZCAvIGR1cmF0aW9uKSwgcm91bmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9ydW5GcmFtZSgxKTtcblx0XHRcdHRoaXMuX2NvbXBsZXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9ydW5GcmFtZTogZnVuY3Rpb24gKHByb2dyZXNzLCByb3VuZCkge1xuXHRcdHZhciBwb3MgPSB0aGlzLl9zdGFydFBvcy5hZGQodGhpcy5fb2Zmc2V0Lm11bHRpcGx5QnkocHJvZ3Jlc3MpKTtcblx0XHRpZiAocm91bmQpIHtcblx0XHRcdHBvcy5fcm91bmQoKTtcblx0XHR9XG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9lbCwgcG9zKTtcblxuXHRcdC8vIEBldmVudCBzdGVwOiBFdmVudFxuXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgdGhlIGFuaW1hdGlvbi5cblx0XHR0aGlzLmZpcmUoJ3N0ZXAnKTtcblx0fSxcblxuXHRfY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltSWQpO1xuXG5cdFx0dGhpcy5faW5Qcm9ncmVzcyA9IGZhbHNlO1xuXHRcdC8vIEBldmVudCBlbmQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGVuZHMuXG5cdFx0dGhpcy5maXJlKCdlbmQnKTtcblx0fSxcblxuXHRfZWFzZU91dDogZnVuY3Rpb24gKHQpIHtcblx0XHRyZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCB0aGlzLl9lYXNlT3V0UG93ZXIpO1xuXHR9XG59KTtcbiIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuLi9jb3JlL0V2ZW50cyc7XHJcbmltcG9ydCB7RVBTRzM4NTd9IGZyb20gJy4uL2dlby9jcnMvQ1JTLkVQU0czODU3JztcclxuaW1wb3J0IHtQb2ludCwgdG9Qb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQge0JvdW5kcywgdG9Cb3VuZHN9IGZyb20gJy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCB7TGF0TG5nLCB0b0xhdExuZ30gZnJvbSAnLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCB7TGF0TG5nQm91bmRzLCB0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQge1Bvc0FuaW1hdGlvbn0gZnJvbSAnLi4vZG9tL1Bvc0FuaW1hdGlvbic7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTWFwXHJcbiAqIEBha2EgTC5NYXBcclxuICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICpcclxuICogVGhlIGNlbnRyYWwgY2xhc3Mgb2YgdGhlIEFQSSDigJQgaXQgaXMgdXNlZCB0byBjcmVhdGUgYSBtYXAgb24gYSBwYWdlIGFuZCBtYW5pcHVsYXRlIGl0LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiAvLyBpbml0aWFsaXplIHRoZSBtYXAgb24gdGhlIFwibWFwXCIgZGl2IHdpdGggYSBnaXZlbiBjZW50ZXIgYW5kIHpvb21cclxuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XHJcbiAqIFx0Y2VudGVyOiBbNTEuNTA1LCAtMC4wOV0sXHJcbiAqIFx0em9vbTogMTNcclxuICogfSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTWFwID0gRXZlbnRlZC5leHRlbmQoe1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAc2VjdGlvbiBNYXAgU3RhdGUgT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IEwuQ1JTLkVQU0czODU3XHJcblx0XHQvLyBUaGUgW0Nvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbV0oI2NycykgdG8gdXNlLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90XHJcblx0XHQvLyBzdXJlIHdoYXQgaXQgbWVhbnMuXHJcblx0XHRjcnM6IEVQU0czODU3LFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2VudGVyOiBMYXRMbmcgPSB1bmRlZmluZWRcclxuXHRcdC8vIEluaXRpYWwgZ2VvZ3JhcGhpYyBjZW50ZXIgb2YgdGhlIG1hcFxyXG5cdFx0Y2VudGVyOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tOiBOdW1iZXIgPSB1bmRlZmluZWRcclxuXHRcdC8vIEluaXRpYWwgbWFwIHpvb20gbGV2ZWxcclxuXHRcdHpvb206IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9ICpcclxuXHRcdC8vIE1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxyXG5cdFx0Ly8gSWYgbm90IHNwZWNpZmllZCBhbmQgYXQgbGVhc3Qgb25lIGBHcmlkTGF5ZXJgIG9yIGBUaWxlTGF5ZXJgIGlzIGluIHRoZSBtYXAsXHJcblx0XHQvLyB0aGUgbG93ZXN0IG9mIHRoZWlyIGBtaW5ab29tYCBvcHRpb25zIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxyXG5cdFx0bWluWm9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gKlxyXG5cdFx0Ly8gTWF4aW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcblx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuXHRcdC8vIHRoZSBoaWdoZXN0IG9mIHRoZWlyIGBtYXhab29tYCBvcHRpb25zIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxyXG5cdFx0bWF4Wm9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbGF5ZXJzOiBMYXllcltdID0gW11cclxuXHRcdC8vIEFycmF5IG9mIGxheWVycyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCBpbml0aWFsbHlcclxuXHRcdGxheWVyczogW10sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhCb3VuZHM6IExhdExuZ0JvdW5kcyA9IG51bGxcclxuXHRcdC8vIFdoZW4gdGhpcyBvcHRpb24gaXMgc2V0LCB0aGUgbWFwIHJlc3RyaWN0cyB0aGUgdmlldyB0byB0aGUgZ2l2ZW5cclxuXHRcdC8vIGdlb2dyYXBoaWNhbCBib3VuZHMsIGJvdW5jaW5nIHRoZSB1c2VyIGJhY2sgaWYgdGhlIHVzZXIgdHJpZXMgdG8gcGFuXHJcblx0XHQvLyBvdXRzaWRlIHRoZSB2aWV3LiBUbyBzZXQgdGhlIHJlc3RyaWN0aW9uIGR5bmFtaWNhbGx5LCB1c2VcclxuXHRcdC8vIFtgc2V0TWF4Qm91bmRzYF0oI21hcC1zZXRtYXhib3VuZHMpIG1ldGhvZC5cclxuXHRcdG1heEJvdW5kczogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmVuZGVyZXI6IFJlbmRlcmVyID0gKlxyXG5cdFx0Ly8gVGhlIGRlZmF1bHQgbWV0aG9kIGZvciBkcmF3aW5nIHZlY3RvciBsYXllcnMgb24gdGhlIG1hcC4gYEwuU1ZHYFxyXG5cdFx0Ly8gb3IgYEwuQ2FudmFzYCBieSBkZWZhdWx0IGRlcGVuZGluZyBvbiBicm93c2VyIHN1cHBvcnQuXHJcblx0XHRyZW5kZXJlcjogdW5kZWZpbmVkLFxyXG5cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBBbmltYXRpb24gT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiB6b29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFwIHpvb20gYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXHJcblx0XHQvLyBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHR6b29tQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvblRocmVzaG9sZDogTnVtYmVyID0gNFxyXG5cdFx0Ly8gV29uJ3QgYW5pbWF0ZSB6b29tIGlmIHRoZSB6b29tIGRpZmZlcmVuY2UgZXhjZWVkcyB0aGlzIHZhbHVlLlxyXG5cdFx0em9vbUFuaW1hdGlvblRocmVzaG9sZDogNCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGZhZGVBbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB0aWxlIGZhZGUgYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXHJcblx0XHQvLyBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHRmYWRlQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWFya2VyWm9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgbWFya2VycyBhbmltYXRlIHRoZWlyIHpvb20gd2l0aCB0aGUgem9vbSBhbmltYXRpb24sIGlmIGRpc2FibGVkXHJcblx0XHQvLyB0aGV5IHdpbGwgZGlzYXBwZWFyIGZvciB0aGUgbGVuZ3RoIG9mIHRoZSBhbmltYXRpb24uIEJ5IGRlZmF1bHQgaXQnc1xyXG5cdFx0Ly8gZW5hYmxlZCBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHRtYXJrZXJab29tQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhbnNmb3JtM0RMaW1pdDogTnVtYmVyID0gMl4yM1xyXG5cdFx0Ly8gRGVmaW5lcyB0aGUgbWF4aW11bSBzaXplIG9mIGEgQ1NTIHRyYW5zbGF0aW9uIHRyYW5zZm9ybS4gVGhlIGRlZmF1bHRcclxuXHRcdC8vIHZhbHVlIHNob3VsZCBub3QgYmUgY2hhbmdlZCB1bmxlc3MgYSB3ZWIgYnJvd3NlciBwb3NpdGlvbnMgbGF5ZXJzIGluXHJcblx0XHQvLyB0aGUgd3JvbmcgcGxhY2UgYWZ0ZXIgZG9pbmcgYSBsYXJnZSBgcGFuQnlgLlxyXG5cdFx0dHJhbnNmb3JtM0RMaW1pdDogODM4ODYwOCwgLy8gUHJlY2lzaW9uIGxpbWl0IG9mIGEgMzItYml0IGZsb2F0XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiB6b29tU25hcDogTnVtYmVyID0gMVxyXG5cdFx0Ly8gRm9yY2VzIHRoZSBtYXAncyB6b29tIGxldmVsIHRvIGFsd2F5cyBiZSBhIG11bHRpcGxlIG9mIHRoaXMsIHBhcnRpY3VsYXJseVxyXG5cdFx0Ly8gcmlnaHQgYWZ0ZXIgYSBbYGZpdEJvdW5kcygpYF0oI21hcC1maXRib3VuZHMpIG9yIGEgcGluY2gtem9vbS5cclxuXHRcdC8vIEJ5IGRlZmF1bHQsIHRoZSB6b29tIGxldmVsIHNuYXBzIHRvIHRoZSBuZWFyZXN0IGludGVnZXI7IGxvd2VyIHZhbHVlc1xyXG5cdFx0Ly8gKGUuZy4gYDAuNWAgb3IgYDAuMWApIGFsbG93IGZvciBncmVhdGVyIGdyYW51bGFyaXR5LiBBIHZhbHVlIG9mIGAwYFxyXG5cdFx0Ly8gbWVhbnMgdGhlIHpvb20gbGV2ZWwgd2lsbCBub3QgYmUgc25hcHBlZCBhZnRlciBgZml0Qm91bmRzYCBvciBhIHBpbmNoLXpvb20uXHJcblx0XHR6b29tU25hcDogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21EZWx0YTogTnVtYmVyID0gMVxyXG5cdFx0Ly8gQ29udHJvbHMgaG93IG11Y2ggdGhlIG1hcCdzIHpvb20gbGV2ZWwgd2lsbCBjaGFuZ2UgYWZ0ZXIgYVxyXG5cdFx0Ly8gW2B6b29tSW4oKWBdKCNtYXAtem9vbWluKSwgW2B6b29tT3V0KClgXSgjbWFwLXpvb21vdXQpLCBwcmVzc2luZyBgK2BcclxuXHRcdC8vIG9yIGAtYCBvbiB0aGUga2V5Ym9hcmQsIG9yIHVzaW5nIHRoZSBbem9vbSBjb250cm9sc10oI2NvbnRyb2wtem9vbSkuXHJcblx0XHQvLyBWYWx1ZXMgc21hbGxlciB0aGFuIGAxYCAoZS5nLiBgMC41YCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuXHJcblx0XHR6b29tRGVsdGE6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFja1Jlc2l6ZTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcCBhdXRvbWF0aWNhbGx5IGhhbmRsZXMgYnJvd3NlciB3aW5kb3cgcmVzaXplIHRvIHVwZGF0ZSBpdHNlbGYuXHJcblx0XHR0cmFja1Jlc2l6ZTogdHJ1ZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykgeyAvLyAoSFRNTEVsZW1lbnQgb3IgU3RyaW5nLCBPYmplY3QpXHJcblx0XHRvcHRpb25zID0gVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdC8vIE1ha2Ugc3VyZSB0byBhc3NpZ24gaW50ZXJuYWwgZmxhZ3MgYXQgdGhlIGJlZ2lubmluZyxcclxuXHRcdC8vIHRvIGF2b2lkIGluY29uc2lzdGVudCBzdGF0ZSBpbiBzb21lIGVkZ2UgY2FzZXMuXHJcblx0XHR0aGlzLl9oYW5kbGVycyA9IFtdO1xyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblx0XHR0aGlzLl96b29tQm91bmRMYXllcnMgPSB7fTtcclxuXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLl9pbml0Q29udGFpbmVyKGlkKTtcclxuXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHJcblx0XHQvLyBoYWNrIGZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8xOTgwXHJcblx0XHR0aGlzLl9vblJlc2l6ZSA9IFV0aWwuYmluZCh0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5faW5pdEV2ZW50cygpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLm1heEJvdW5kcykge1xyXG5cdFx0XHR0aGlzLnNldE1heEJvdW5kcyhvcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuX3pvb20gPSB0aGlzLl9saW1pdFpvb20ob3B0aW9ucy56b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5jZW50ZXIgJiYgb3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5zZXRWaWV3KHRvTGF0TG5nKG9wdGlvbnMuY2VudGVyKSwgb3B0aW9ucy56b29tLCB7cmVzZXQ6IHRydWV9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmNhbGxJbml0SG9va3MoKTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIG9uIGJyb3dzZXJzIHdpdGhvdXQgaGFyZHdhcmUtYWNjZWxlcmF0ZWQgdHJhbnNpdGlvbnMgb3Igb2xkIEFuZHJvaWQvT3BlcmFcclxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IERvbVV0aWwuVFJBTlNJVElPTiAmJiBCcm93c2VyLmFueTNkICYmICFCcm93c2VyLm1vYmlsZU9wZXJhICYmXHJcblx0XHRcdFx0dGhpcy5vcHRpb25zLnpvb21BbmltYXRpb247XHJcblxyXG5cdFx0Ly8gem9vbSB0cmFuc2l0aW9ucyBydW4gd2l0aCB0aGUgc2FtZSBkdXJhdGlvbiBmb3IgYWxsIGxheWVycywgc28gaWYgb25lIG9mIHRyYW5zaXRpb25lbmQgZXZlbnRzXHJcblx0XHQvLyBoYXBwZW5zIGFmdGVyIHN0YXJ0aW5nIHpvb20gYW5pbWF0aW9uIChwcm9wYWdhdGluZyB0byB0aGUgbWFwIHBhbmUpLCB3ZSBrbm93IHRoYXQgaXQgZW5kZWQgZ2xvYmFsbHlcclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0dGhpcy5fY3JlYXRlQW5pbVByb3h5KCk7XHJcblx0XHRcdERvbUV2ZW50Lm9uKHRoaXMuX3Byb3h5LCBEb21VdGlsLlRSQU5TSVRJT05fRU5ELCB0aGlzLl9jYXRjaFRyYW5zaXRpb25FbmQsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2FkZExheWVycyh0aGlzLm9wdGlvbnMubGF5ZXJzKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFZpZXcoY2VudGVyOiBMYXRMbmcsIHpvb206IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIChnZW9ncmFwaGljYWwgY2VudGVyIGFuZCB6b29tKSB3aXRoIHRoZSBnaXZlblxyXG5cdC8vIGFuaW1hdGlvbiBvcHRpb25zLlxyXG5cdHNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcclxuXHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuXHRcdGNlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKHRvTGF0TG5nKGNlbnRlciksIHpvb20sIHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0dGhpcy5fc3RvcCgpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgIW9wdGlvbnMucmVzZXQgJiYgb3B0aW9ucyAhPT0gdHJ1ZSkge1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tID0gVXRpbC5leHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZX0sIG9wdGlvbnMuem9vbSk7XHJcblx0XHRcdFx0b3B0aW9ucy5wYW4gPSBVdGlsLmV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlLCBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbn0sIG9wdGlvbnMucGFuKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gdHJ5IGFuaW1hdGluZyBwYW4gb3Igem9vbVxyXG5cdFx0XHR2YXIgbW92ZWQgPSAodGhpcy5fem9vbSAhPT0gem9vbSkgP1xyXG5cdFx0XHRcdHRoaXMuX3RyeUFuaW1hdGVkWm9vbSAmJiB0aGlzLl90cnlBbmltYXRlZFpvb20oY2VudGVyLCB6b29tLCBvcHRpb25zLnpvb20pIDpcclxuXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFBhbihjZW50ZXIsIG9wdGlvbnMucGFuKTtcclxuXHJcblx0XHRcdGlmIChtb3ZlZCkge1xyXG5cdFx0XHRcdC8vIHByZXZlbnQgcmVzaXplIGhhbmRsZXIgY2FsbCwgdGhlIHZpZXcgd2lsbCByZWZyZXNoIGFmdGVyIGFuaW1hdGlvbiBhbnl3YXlcclxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGFuaW1hdGlvbiBkaWRuJ3Qgc3RhcnQsIGp1c3QgcmVzZXQgdGhlIG1hcCB2aWV3XHJcblx0XHR0aGlzLl9yZXNldFZpZXcoY2VudGVyLCB6b29tLCBvcHRpb25zLnBhbiAmJiBvcHRpb25zLnBhbi5ub01vdmVTdGFydCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tKHpvb206IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgem9vbSBvZiB0aGUgbWFwLlxyXG5cdHNldFpvb206IGZ1bmN0aW9uICh6b29tLCBvcHRpb25zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLl96b29tID0gem9vbTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tSW4oZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gSW5jcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcblx0em9vbUluOiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuXHRcdGRlbHRhID0gZGVsdGEgfHwgKEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbURlbHRhIDogMSk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gKyBkZWx0YSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tT3V0KGRlbHRhPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIERlY3JlYXNlcyB0aGUgem9vbSBvZiB0aGUgbWFwIGJ5IGBkZWx0YWAgKFtgem9vbURlbHRhYF0oI21hcC16b29tZGVsdGEpIGJ5IGRlZmF1bHQpLlxyXG5cdHpvb21PdXQ6IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG5cdFx0ZGVsdGEgPSBkZWx0YSB8fCAoQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tRGVsdGEgOiAxKTtcclxuXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSAtIGRlbHRhLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpvb21Bcm91bmQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBnZW9ncmFwaGljYWwgcG9pbnQgb24gdGhlIG1hcFxyXG5cdC8vIHN0YXRpb25hcnkgKGUuZy4gdXNlZCBpbnRlcm5hbGx5IGZvciBzY3JvbGwgem9vbSBhbmQgZG91YmxlLWNsaWNrIHpvb20pLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChvZmZzZXQ6IFBvaW50LCB6b29tOiBOdW1iZXIsIG9wdGlvbnM6IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBab29tcyB0aGUgbWFwIHdoaWxlIGtlZXBpbmcgYSBzcGVjaWZpZWQgcGl4ZWwgb24gdGhlIG1hcCAocmVsYXRpdmUgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lcikgc3RhdGlvbmFyeS5cclxuXHRzZXRab29tQXJvdW5kOiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcclxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIGNvbnRhaW5lclBvaW50ID0gbGF0bG5nIGluc3RhbmNlb2YgUG9pbnQgPyBsYXRsbmcgOiB0aGlzLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobGF0bG5nKSxcclxuXHJcblx0XHQgICAgY2VudGVyT2Zmc2V0ID0gY29udGFpbmVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLm11bHRpcGx5QnkoMSAtIDEgLyBzY2FsZSksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF0TG5nKHZpZXdIYWxmLmFkZChjZW50ZXJPZmZzZXQpKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KG5ld0NlbnRlciwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Qm91bmRzQ2VudGVyWm9vbTogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0Ym91bmRzID0gYm91bmRzLmdldEJvdW5kcyA/IGJvdW5kcy5nZXRCb3VuZHMoKSA6IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdUTCA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ0JvdHRvbVJpZ2h0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cclxuXHRcdCAgICB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcywgZmFsc2UsIHBhZGRpbmdUTC5hZGQocGFkZGluZ0JSKSk7XHJcblxyXG5cdFx0em9vbSA9ICh0eXBlb2Ygb3B0aW9ucy5tYXhab29tID09PSAnbnVtYmVyJykgPyBNYXRoLm1pbihvcHRpb25zLm1heFpvb20sIHpvb20pIDogem9vbTtcclxuXHJcblx0XHRpZiAoem9vbSA9PT0gSW5maW5pdHkpIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRjZW50ZXI6IGJvdW5kcy5nZXRDZW50ZXIoKSxcclxuXHRcdFx0XHR6b29tOiB6b29tXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdPZmZzZXQgPSBwYWRkaW5nQlIuc3VidHJhY3QocGFkZGluZ1RMKS5kaXZpZGVCeSgyKSxcclxuXHJcblx0XHQgICAgc3dQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pLFxyXG5cdFx0ICAgIG5lUG9pbnQgPSB0aGlzLnByb2plY3QoYm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKSxcclxuXHRcdCAgICBjZW50ZXIgPSB0aGlzLnVucHJvamVjdChzd1BvaW50LmFkZChuZVBvaW50KS5kaXZpZGVCeSgyKS5hZGQocGFkZGluZ09mZnNldCksIHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG5cdFx0XHR6b29tOiB6b29tXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZml0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyBhIG1hcCB2aWV3IHRoYXQgY29udGFpbnMgdGhlIGdpdmVuIGdlb2dyYXBoaWNhbCBib3VuZHMgd2l0aCB0aGVcclxuXHQvLyBtYXhpbXVtIHpvb20gbGV2ZWwgcG9zc2libGUuXHJcblx0Zml0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdCb3VuZHMgYXJlIG5vdCB2YWxpZC4nKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXRXb3JsZChvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyBhIG1hcCB2aWV3IHRoYXQgbW9zdGx5IGNvbnRhaW5zIHRoZSB3aG9sZSB3b3JsZCB3aXRoIHRoZSBtYXhpbXVtXHJcblx0Ly8gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuXHRmaXRXb3JsZDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiB0aGlzLmZpdEJvdW5kcyhbWy05MCwgLTE4MF0sIFs5MCwgMTgwXV0sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuVG8obGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdG8gYSBnaXZlbiBjZW50ZXIuXHJcblx0cGFuVG86IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHsgLy8gKExhdExuZylcclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcoY2VudGVyLCB0aGlzLl96b29tLCB7cGFuOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5CeShvZmZzZXQ6IFBvaW50LCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIGJ5IGEgZ2l2ZW4gbnVtYmVyIG9mIHBpeGVscyAoYW5pbWF0ZWQpLlxyXG5cdHBhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0LCBvcHRpb25zKSB7XHJcblx0XHRvZmZzZXQgPSB0b1BvaW50KG9mZnNldCkucm91bmQoKTtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHRcdH1cclxuXHRcdC8vIElmIHdlIHBhbiB0b28gZmFyLCBDaHJvbWUgZ2V0cyBpc3N1ZXMgd2l0aCB0aWxlc1xyXG5cdFx0Ly8gYW5kIG1ha2VzIHRoZW0gZGlzYXBwZWFyIG9yIGFwcGVhciBpbiB0aGUgd3JvbmcgcGxhY2UgKHNsaWdodGx5IG9mZnNldCkgIzI2MDJcclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHtcclxuXHRcdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMudW5wcm9qZWN0KHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKS5hZGQob2Zmc2V0KSksIHRoaXMuZ2V0Wm9vbSgpKTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9wYW5BbmltKSB7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0gPSBuZXcgUG9zQW5pbWF0aW9uKCk7XHJcblxyXG5cdFx0XHR0aGlzLl9wYW5BbmltLm9uKHtcclxuXHRcdFx0XHQnc3RlcCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvblN0ZXAsXHJcblx0XHRcdFx0J2VuZCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvbkVuZFxyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBkb24ndCBmaXJlIG1vdmVzdGFydCBpZiBhbmltYXRpbmcgaW5lcnRpYVxyXG5cdFx0aWYgKCFvcHRpb25zLm5vTW92ZVN0YXJ0KSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYW5pbWF0ZSBwYW4gdW5sZXNzIGFuaW1hdGU6IGZhbHNlIHNwZWNpZmllZFxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gZmFsc2UpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xyXG5cclxuXHRcdFx0dmFyIG5ld1BvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpLnJvdW5kKCk7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0ucnVuKHRoaXMuX21hcFBhbmUsIG5ld1Bvcywgb3B0aW9ucy5kdXJhdGlvbiB8fCAwLjI1LCBvcHRpb25zLmVhc2VMaW5lYXJpdHkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3ZlJykuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmx5VG8obGF0bG5nOiBMYXRMbmcsIHpvb20/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgcGVyZm9ybWluZyBhIHNtb290aFxyXG5cdC8vIHBhbi16b29tIGFuaW1hdGlvbi5cclxuXHRmbHlUbzogZnVuY3Rpb24gKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgIUJyb3dzZXIuYW55M2QpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20sIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcblx0XHR2YXIgZnJvbSA9IHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKSxcclxuXHRcdCAgICB0byA9IHRoaXMucHJvamVjdCh0YXJnZXRDZW50ZXIpLFxyXG5cdFx0ICAgIHNpemUgPSB0aGlzLmdldFNpemUoKSxcclxuXHRcdCAgICBzdGFydFpvb20gPSB0aGlzLl96b29tO1xyXG5cclxuXHRcdHRhcmdldENlbnRlciA9IHRvTGF0TG5nKHRhcmdldENlbnRlcik7XHJcblx0XHR0YXJnZXRab29tID0gdGFyZ2V0Wm9vbSA9PT0gdW5kZWZpbmVkID8gc3RhcnRab29tIDogdGFyZ2V0Wm9vbTtcclxuXHJcblx0XHR2YXIgdzAgPSBNYXRoLm1heChzaXplLngsIHNpemUueSksXHJcblx0XHQgICAgdzEgPSB3MCAqIHRoaXMuZ2V0Wm9vbVNjYWxlKHN0YXJ0Wm9vbSwgdGFyZ2V0Wm9vbSksXHJcblx0XHQgICAgdTEgPSAodG8uZGlzdGFuY2VUbyhmcm9tKSkgfHwgMSxcclxuXHRcdCAgICByaG8gPSAxLjQyLFxyXG5cdFx0ICAgIHJobzIgPSByaG8gKiByaG87XHJcblxyXG5cdFx0ZnVuY3Rpb24gcihpKSB7XHJcblx0XHRcdHZhciBzMSA9IGkgPyAtMSA6IDEsXHJcblx0XHRcdCAgICBzMiA9IGkgPyB3MSA6IHcwLFxyXG5cdFx0XHQgICAgdDEgPSB3MSAqIHcxIC0gdzAgKiB3MCArIHMxICogcmhvMiAqIHJobzIgKiB1MSAqIHUxLFxyXG5cdFx0XHQgICAgYjEgPSAyICogczIgKiByaG8yICogdTEsXHJcblx0XHRcdCAgICBiID0gdDEgLyBiMSxcclxuXHRcdFx0ICAgIHNxID0gTWF0aC5zcXJ0KGIgKiBiICsgMSkgLSBiO1xyXG5cclxuXHRcdFx0ICAgIC8vIHdvcmthcm91bmQgZm9yIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiBidWcgd2hlbiBzcSA9IDAsIGxvZyA9IC1JbmZpbml0ZSxcclxuXHRcdFx0ICAgIC8vIHRodXMgdHJpZ2dlcmluZyBhbiBpbmZpbml0ZSBsb29wIGluIGZseVRvXHJcblx0XHRcdCAgICB2YXIgbG9nID0gc3EgPCAwLjAwMDAwMDAwMSA/IC0xOCA6IE1hdGgubG9nKHNxKTtcclxuXHJcblx0XHRcdHJldHVybiBsb2c7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc2luaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgLSBNYXRoLmV4cCgtbikpIC8gMjsgfVxyXG5cdFx0ZnVuY3Rpb24gY29zaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgKyBNYXRoLmV4cCgtbikpIC8gMjsgfVxyXG5cdFx0ZnVuY3Rpb24gdGFuaChuKSB7IHJldHVybiBzaW5oKG4pIC8gY29zaChuKTsgfVxyXG5cclxuXHRcdHZhciByMCA9IHIoMCk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gdyhzKSB7IHJldHVybiB3MCAqIChjb3NoKHIwKSAvIGNvc2gocjAgKyByaG8gKiBzKSk7IH1cclxuXHRcdGZ1bmN0aW9uIHUocykgeyByZXR1cm4gdzAgKiAoY29zaChyMCkgKiB0YW5oKHIwICsgcmhvICogcykgLSBzaW5oKHIwKSkgLyByaG8yOyB9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZWFzZU91dCh0KSB7IHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIDEuNSk7IH1cclxuXHJcblx0XHR2YXIgc3RhcnQgPSBEYXRlLm5vdygpLFxyXG5cdFx0ICAgIFMgPSAocigxKSAtIHIwKSAvIHJobyxcclxuXHRcdCAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gPyAxMDAwICogb3B0aW9ucy5kdXJhdGlvbiA6IDEwMDAgKiBTICogMC44O1xyXG5cclxuXHRcdGZ1bmN0aW9uIGZyYW1lKCkge1xyXG5cdFx0XHR2YXIgdCA9IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gZHVyYXRpb24sXHJcblx0XHRcdCAgICBzID0gZWFzZU91dCh0KSAqIFM7XHJcblxyXG5cdFx0XHRpZiAodCA8PSAxKSB7XHJcblx0XHRcdFx0dGhpcy5fZmx5VG9GcmFtZSA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZShmcmFtZSwgdGhpcyk7XHJcblxyXG5cdFx0XHRcdHRoaXMuX21vdmUoXHJcblx0XHRcdFx0XHR0aGlzLnVucHJvamVjdChmcm9tLmFkZCh0by5zdWJ0cmFjdChmcm9tKS5tdWx0aXBseUJ5KHUocykgLyB1MSkpLCBzdGFydFpvb20pLFxyXG5cdFx0XHRcdFx0dGhpcy5nZXRTY2FsZVpvb20odzAgLyB3KHMpLCBzdGFydFpvb20pLFxyXG5cdFx0XHRcdFx0e2ZseVRvOiB0cnVlfSk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXNcclxuXHRcdFx0XHRcdC5fbW92ZSh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20pXHJcblx0XHRcdFx0XHQuX21vdmVFbmQodHJ1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tb3ZlU3RhcnQodHJ1ZSwgb3B0aW9ucy5ub01vdmVTdGFydCk7XHJcblxyXG5cdFx0ZnJhbWUuY2FsbCh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmx5VG9Cb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgd2l0aCBhIHNtb290aCBhbmltYXRpb24gbGlrZSBbYGZseVRvYF0oI21hcC1mbHl0byksXHJcblx0Ly8gYnV0IHRha2VzIGEgYm91bmRzIHBhcmFtZXRlciBsaWtlIFtgZml0Qm91bmRzYF0oI21hcC1maXRib3VuZHMpLlxyXG5cdGZseVRvQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xyXG5cdFx0cmV0dXJuIHRoaXMuZmx5VG8odGFyZ2V0LmNlbnRlciwgdGFyZ2V0Lnpvb20sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWF4Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG5cdC8vIFJlc3RyaWN0cyB0aGUgbWFwIHZpZXcgdG8gdGhlIGdpdmVuIGJvdW5kcyAoc2VlIHRoZSBbbWF4Qm91bmRzXSgjbWFwLW1heGJvdW5kcykgb3B0aW9uKS5cclxuXHRzZXRNYXhCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMubGlzdGVucygnbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcykpIHtcclxuXHRcdFx0dGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghYm91bmRzLmlzVmFsaWQoKSkge1xyXG5cdFx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gbnVsbDtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLm1heEJvdW5kcyA9IGJvdW5kcztcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLm9uKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE1pblpvb20oem9vbTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGxvd2VyIGxpbWl0IGZvciB0aGUgYXZhaWxhYmxlIHpvb20gbGV2ZWxzIChzZWUgdGhlIFttaW5ab29tXSgjbWFwLW1pbnpvb20pIG9wdGlvbikuXHJcblx0c2V0TWluWm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHZhciBvbGRab29tID0gdGhpcy5vcHRpb25zLm1pblpvb207XHJcblx0XHR0aGlzLm9wdGlvbnMubWluWm9vbSA9IHpvb207XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiBvbGRab29tICE9PSB6b29tKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuZ2V0Wm9vbSgpIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHpvb20pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNYXhab29tKHpvb206IE51bWJlcik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB1cHBlciBsaW1pdCBmb3IgdGhlIGF2YWlsYWJsZSB6b29tIGxldmVscyAoc2VlIHRoZSBbbWF4Wm9vbV0oI21hcC1tYXh6b29tKSBvcHRpb24pLlxyXG5cdHNldE1heFpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHR2YXIgb2xkWm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tO1xyXG5cdFx0dGhpcy5vcHRpb25zLm1heFpvb20gPSB6b29tO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgb2xkWm9vbSAhPT0gem9vbSkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLmdldFpvb20oKSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh6b29tKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuSW5zaWRlQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIHRvIHRoZSBjbG9zZXN0IHZpZXcgdGhhdCB3b3VsZCBsaWUgaW5zaWRlIHRoZSBnaXZlbiBib3VuZHMgKGlmIGl0J3Mgbm90IGFscmVhZHkpLCBjb250cm9sbGluZyB0aGUgYW5pbWF0aW9uIHVzaW5nIHRoZSBvcHRpb25zIHNwZWNpZmljLCBpZiBhbnkuXHJcblx0cGFuSW5zaWRlQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSB0cnVlO1xyXG5cdFx0dmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIoY2VudGVyLCB0aGlzLl96b29tLCB0b0xhdExuZ0JvdW5kcyhib3VuZHMpKTtcclxuXHJcblx0XHRpZiAoIWNlbnRlci5lcXVhbHMobmV3Q2VudGVyKSkge1xyXG5cdFx0XHR0aGlzLnBhblRvKG5ld0NlbnRlciwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gZmFsc2U7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhbkluc2lkZShsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IHBhZGRpbmcgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdGhlIG1pbmltdW0gYW1vdW50IHRvIG1ha2UgdGhlIGBsYXRsbmdgIHZpc2libGUuIFVzZVxyXG5cdC8vIHBhZGRpbmcgb3B0aW9ucyB0byBmaXQgdGhlIGRpc3BsYXkgdG8gbW9yZSByZXN0cmljdGVkIGJvdW5kcy5cclxuXHQvLyBJZiBgbGF0bG5nYCBpcyBhbHJlYWR5IHdpdGhpbiB0aGUgKG9wdGlvbmFsbHkgcGFkZGVkKSBkaXNwbGF5IGJvdW5kcyxcclxuXHQvLyB0aGUgbWFwIHdpbGwgbm90IGJlIHBhbm5lZC5cclxuXHRwYW5JbnNpZGU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdHZhciBwYWRkaW5nVEwgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ1RvcExlZnQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdCb3R0b21SaWdodCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHRcdCAgICBwaXhlbENlbnRlciA9IHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKSxcclxuXHRcdCAgICBwaXhlbFBvaW50ID0gdGhpcy5wcm9qZWN0KGxhdGxuZyksXHJcblx0XHQgICAgcGl4ZWxCb3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgcGFkZGVkQm91bmRzID0gdG9Cb3VuZHMoW3BpeGVsQm91bmRzLm1pbi5hZGQocGFkZGluZ1RMKSwgcGl4ZWxCb3VuZHMubWF4LnN1YnRyYWN0KHBhZGRpbmdCUildKSxcclxuXHRcdCAgICBwYWRkZWRTaXplID0gcGFkZGVkQm91bmRzLmdldFNpemUoKTtcclxuXHJcblx0XHRpZiAoIXBhZGRlZEJvdW5kcy5jb250YWlucyhwaXhlbFBvaW50KSkge1xyXG5cdFx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSB0cnVlO1xyXG5cdFx0XHR2YXIgY2VudGVyT2Zmc2V0ID0gcGl4ZWxQb2ludC5zdWJ0cmFjdChwYWRkZWRCb3VuZHMuZ2V0Q2VudGVyKCkpO1xyXG5cdFx0XHR2YXIgb2Zmc2V0ID0gcGFkZGVkQm91bmRzLmV4dGVuZChwaXhlbFBvaW50KS5nZXRTaXplKCkuc3VidHJhY3QocGFkZGVkU2l6ZSk7XHJcblx0XHRcdHBpeGVsQ2VudGVyLnggKz0gY2VudGVyT2Zmc2V0LnggPCAwID8gLW9mZnNldC54IDogb2Zmc2V0Lng7XHJcblx0XHRcdHBpeGVsQ2VudGVyLnkgKz0gY2VudGVyT2Zmc2V0LnkgPCAwID8gLW9mZnNldC55IDogb2Zmc2V0Lnk7XHJcblx0XHRcdHRoaXMucGFuVG8odGhpcy51bnByb2plY3QocGl4ZWxDZW50ZXIpLCBvcHRpb25zKTtcclxuXHRcdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludmFsaWRhdGVTaXplKG9wdGlvbnM6IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQ2hlY2tzIGlmIHRoZSBtYXAgY29udGFpbmVyIHNpemUgY2hhbmdlZCBhbmQgdXBkYXRlcyB0aGUgbWFwIGlmIHNvIOKAlFxyXG5cdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xyXG5cdC8vIHBhbiBieSBkZWZhdWx0LiBJZiBgb3B0aW9ucy5wYW5gIGlzIGBmYWxzZWAsIHBhbm5pbmcgd2lsbCBub3Qgb2NjdXIuXHJcblx0Ly8gSWYgYG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kYCBpcyBgdHJ1ZWAsIGl0IHdpbGwgZGVsYXkgYG1vdmVlbmRgIGV2ZW50IHNvXHJcblx0Ly8gdGhhdCBpdCBkb2Vzbid0IGhhcHBlbiBvZnRlbiBldmVuIGlmIHRoZSBtZXRob2QgaXMgY2FsbGVkIG1hbnlcclxuXHQvLyB0aW1lcyBpbiBhIHJvdy5cclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBpbnZhbGlkYXRlU2l6ZShhbmltYXRlOiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIENoZWNrcyBpZiB0aGUgbWFwIGNvbnRhaW5lciBzaXplIGNoYW5nZWQgYW5kIHVwZGF0ZXMgdGhlIG1hcCBpZiBzbyDigJRcclxuXHQvLyBjYWxsIGl0IGFmdGVyIHlvdSd2ZSBjaGFuZ2VkIHRoZSBtYXAgc2l6ZSBkeW5hbWljYWxseSwgYWxzbyBhbmltYXRpbmdcclxuXHQvLyBwYW4gYnkgZGVmYXVsdC5cclxuXHRpbnZhbGlkYXRlU2l6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0b3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHtcclxuXHRcdFx0YW5pbWF0ZTogZmFsc2UsXHJcblx0XHRcdHBhbjogdHJ1ZVxyXG5cdFx0fSwgb3B0aW9ucyA9PT0gdHJ1ZSA/IHthbmltYXRlOiB0cnVlfSA6IG9wdGlvbnMpO1xyXG5cclxuXHRcdHZhciBvbGRTaXplID0gdGhpcy5nZXRTaXplKCk7XHJcblx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcblx0XHR0aGlzLl9sYXN0Q2VudGVyID0gbnVsbDtcclxuXHJcblx0XHR2YXIgbmV3U2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIG9sZENlbnRlciA9IG9sZFNpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSBuZXdTaXplLmRpdmlkZUJ5KDIpLnJvdW5kKCksXHJcblx0XHQgICAgb2Zmc2V0ID0gb2xkQ2VudGVyLnN1YnRyYWN0KG5ld0NlbnRlcik7XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICYmIG9wdGlvbnMucGFuKSB7XHJcblx0XHRcdHRoaXMucGFuQnkob2Zmc2V0KTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAob3B0aW9ucy5wYW4pIHtcclxuXHRcdFx0XHR0aGlzLl9yYXdQYW5CeShvZmZzZXQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLmRlYm91bmNlTW92ZWVuZCkge1xyXG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9zaXplVGltZXIpO1xyXG5cdFx0XHRcdHRoaXMuX3NpemVUaW1lciA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuZmlyZSwgdGhpcywgJ21vdmVlbmQnKSwgMjAwKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcmVzaXplOiBSZXNpemVFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIHJlc2l6ZWQuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdyZXNpemUnLCB7XHJcblx0XHRcdG9sZFNpemU6IG9sZFNpemUsXHJcblx0XHRcdG5ld1NpemU6IG5ld1NpemVcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcclxuXHQvLyBAbWV0aG9kIHN0b3AoKTogdGhpc1xyXG5cdC8vIFN0b3BzIHRoZSBjdXJyZW50bHkgcnVubmluZyBgcGFuVG9gIG9yIGBmbHlUb2AgYW5pbWF0aW9uLCBpZiBhbnkuXHJcblx0c3RvcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5zZXRab29tKHRoaXMuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSk7XHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy56b29tU25hcCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuX3N0b3AoKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBHZW9sb2NhdGlvbiBtZXRob2RzXHJcblx0Ly8gQG1ldGhvZCBsb2NhdGUob3B0aW9ucz86IExvY2F0ZSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFRyaWVzIHRvIGxvY2F0ZSB0aGUgdXNlciB1c2luZyB0aGUgR2VvbG9jYXRpb24gQVBJLCBmaXJpbmcgYSBbYGxvY2F0aW9uZm91bmRgXSgjbWFwLWxvY2F0aW9uZm91bmQpXHJcblx0Ly8gZXZlbnQgd2l0aCBsb2NhdGlvbiBkYXRhIG9uIHN1Y2Nlc3Mgb3IgYSBbYGxvY2F0aW9uZXJyb3JgXSgjbWFwLWxvY2F0aW9uZXJyb3IpIGV2ZW50IG9uIGZhaWx1cmUsXHJcblx0Ly8gYW5kIG9wdGlvbmFsbHkgc2V0cyB0aGUgbWFwIHZpZXcgdG8gdGhlIHVzZXIncyBsb2NhdGlvbiB3aXRoIHJlc3BlY3QgdG9cclxuXHQvLyBkZXRlY3Rpb24gYWNjdXJhY3kgKG9yIHRvIHRoZSB3b3JsZCB2aWV3IGlmIGdlb2xvY2F0aW9uIGZhaWxlZCkuXHJcblx0Ly8gTm90ZSB0aGF0LCBpZiB5b3VyIHBhZ2UgZG9lc24ndCB1c2UgSFRUUFMsIHRoaXMgbWV0aG9kIHdpbGwgZmFpbCBpblxyXG5cdC8vIG1vZGVybiBicm93c2VycyAoW0Nocm9tZSA1MCBhbmQgbmV3ZXJdKGh0dHBzOi8vc2l0ZXMuZ29vZ2xlLmNvbS9hL2Nocm9taXVtLm9yZy9kZXYvSG9tZS9jaHJvbWl1bS1zZWN1cml0eS9kZXByZWNhdGluZy1wb3dlcmZ1bC1mZWF0dXJlcy1vbi1pbnNlY3VyZS1vcmlnaW5zKSlcclxuXHQvLyBTZWUgYExvY2F0ZSBvcHRpb25zYCBmb3IgbW9yZSBkZXRhaWxzLlxyXG5cdGxvY2F0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHJcblx0XHRvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHtcclxuXHRcdFx0dGltZW91dDogMTAwMDAsXHJcblx0XHRcdHdhdGNoOiBmYWxzZVxyXG5cdFx0XHQvLyBzZXRWaWV3OiBmYWxzZVxyXG5cdFx0XHQvLyBtYXhab29tOiA8TnVtYmVyPlxyXG5cdFx0XHQvLyBtYXhpbXVtQWdlOiAwXHJcblx0XHRcdC8vIGVuYWJsZUhpZ2hBY2N1cmFjeTogZmFsc2VcclxuXHRcdH0sIG9wdGlvbnMpO1xyXG5cclxuXHRcdGlmICghKCdnZW9sb2NhdGlvbicgaW4gbmF2aWdhdG9yKSkge1xyXG5cdFx0XHR0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yKHtcclxuXHRcdFx0XHRjb2RlOiAwLFxyXG5cdFx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBub3Qgc3VwcG9ydGVkLidcclxuXHRcdFx0fSk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvblJlc3BvbnNlID0gVXRpbC5iaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2UsIHRoaXMpLFxyXG5cdFx0ICAgIG9uRXJyb3IgPSBVdGlsLmJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25FcnJvciwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMud2F0Y2gpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRpb25XYXRjaElkID1cclxuXHRcdFx0ICAgICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24ud2F0Y2hQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24ob25SZXNwb25zZSwgb25FcnJvciwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHN0b3BMb2NhdGUoKTogdGhpc1xyXG5cdC8vIFN0b3BzIHdhdGNoaW5nIGxvY2F0aW9uIHByZXZpb3VzbHkgaW5pdGlhdGVkIGJ5IGBtYXAubG9jYXRlKHt3YXRjaDogdHJ1ZX0pYFxyXG5cdC8vIGFuZCBhYm9ydHMgcmVzZXR0aW5nIHRoZSBtYXAgdmlldyBpZiBtYXAubG9jYXRlIHdhcyBjYWxsZWQgd2l0aFxyXG5cdC8vIGB7c2V0VmlldzogdHJ1ZX1gLlxyXG5cdHN0b3BMb2NhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmIChuYXZpZ2F0b3IuZ2VvbG9jYXRpb24gJiYgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2gpIHtcclxuXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2godGhpcy5fbG9jYXRpb25XYXRjaElkKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9sb2NhdGVPcHRpb25zKSB7XHJcblx0XHRcdHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIGMgPSBlcnJvci5jb2RlLFxyXG5cdFx0ICAgIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlIHx8XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMSA/ICdwZXJtaXNzaW9uIGRlbmllZCcgOlxyXG5cdFx0ICAgICAgICAgICAgKGMgPT09IDIgPyAncG9zaXRpb24gdW5hdmFpbGFibGUnIDogJ3RpbWVvdXQnKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyAmJiAhdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuZml0V29ybGQoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBMb2NhdGlvbiBldmVudHNcclxuXHRcdC8vIEBldmVudCBsb2NhdGlvbmVycm9yOiBFcnJvckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGdlb2xvY2F0aW9uICh1c2luZyB0aGUgW2Bsb2NhdGVgXSgjbWFwLWxvY2F0ZSkgbWV0aG9kKSBmYWlsZWQuXHJcblx0XHR0aGlzLmZpcmUoJ2xvY2F0aW9uZXJyb3InLCB7XHJcblx0XHRcdGNvZGU6IGMsXHJcblx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBlcnJvcjogJyArIG1lc3NhZ2UgKyAnLidcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdF9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlOiBmdW5jdGlvbiAocG9zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbGF0ID0gcG9zLmNvb3Jkcy5sYXRpdHVkZSxcclxuXHRcdCAgICBsbmcgPSBwb3MuY29vcmRzLmxvbmdpdHVkZSxcclxuXHRcdCAgICBsYXRsbmcgPSBuZXcgTGF0TG5nKGxhdCwgbG5nKSxcclxuXHRcdCAgICBib3VuZHMgPSBsYXRsbmcudG9Cb3VuZHMocG9zLmNvb3Jkcy5hY2N1cmFjeSAqIDIpLFxyXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnNldFZpZXcpIHtcclxuXHRcdFx0dmFyIHpvb20gPSB0aGlzLmdldEJvdW5kc1pvb20oYm91bmRzKTtcclxuXHRcdFx0dGhpcy5zZXRWaWV3KGxhdGxuZywgb3B0aW9ucy5tYXhab29tID8gTWF0aC5taW4oem9vbSwgb3B0aW9ucy5tYXhab29tKSA6IHpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRsYXRsbmc6IGxhdGxuZyxcclxuXHRcdFx0Ym91bmRzOiBib3VuZHMsXHJcblx0XHRcdHRpbWVzdGFtcDogcG9zLnRpbWVzdGFtcFxyXG5cdFx0fTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIHBvcy5jb29yZHMpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBwb3MuY29vcmRzW2ldID09PSAnbnVtYmVyJykge1xyXG5cdFx0XHRcdGRhdGFbaV0gPSBwb3MuY29vcmRzW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZm91bmQ6IExvY2F0aW9uRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpXHJcblx0XHQvLyB3ZW50IHN1Y2Nlc3NmdWxseS5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25mb3VuZCcsIGRhdGEpO1xyXG5cdH0sXHJcblxyXG5cdC8vIFRPRE8gQXBwcm9wcmlhdGUgZG9jcyBzZWN0aW9uP1xyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGFkZEhhbmRsZXIobmFtZTogU3RyaW5nLCBIYW5kbGVyQ2xhc3M6IEZ1bmN0aW9uKTogdGhpc1xyXG5cdC8vIEFkZHMgYSBuZXcgYEhhbmRsZXJgIHRvIHRoZSBtYXAsIGdpdmVuIGl0cyBuYW1lIGFuZCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cclxuXHRhZGRIYW5kbGVyOiBmdW5jdGlvbiAobmFtZSwgSGFuZGxlckNsYXNzKSB7XHJcblx0XHRpZiAoIUhhbmRsZXJDbGFzcykgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBoYW5kbGVyID0gdGhpc1tuYW1lXSA9IG5ldyBIYW5kbGVyQ2xhc3ModGhpcyk7XHJcblxyXG5cdFx0dGhpcy5faGFuZGxlcnMucHVzaChoYW5kbGVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zW25hbWVdKSB7XHJcblx0XHRcdGhhbmRsZXIuZW5hYmxlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmUoKTogdGhpc1xyXG5cdC8vIERlc3Ryb3lzIHRoZSBtYXAgYW5kIGNsZWFycyBhbGwgcmVsYXRlZCBldmVudCBsaXN0ZW5lcnMuXHJcblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5faW5pdEV2ZW50cyh0cnVlKTtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKSB7IHRoaXMub2ZmKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9jb250YWluZXJJZCAhPT0gdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBpcyBiZWluZyByZXVzZWQgYnkgYW5vdGhlciBpbnN0YW5jZScpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIHRocm93cyBlcnJvciBpbiBJRTYtOFxyXG5cdFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkO1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVySWQ7XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdC8qZXNsaW50LWRpc2FibGUgKi9cclxuXHRcdFx0dGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkID0gdW5kZWZpbmVkO1xyXG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlICovXHJcblx0XHRcdHRoaXMuX2NvbnRhaW5lcklkID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9sb2NhdGlvbldhdGNoSWQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLnN0b3BMb2NhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fbWFwUGFuZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NsZWFyQ29udHJvbFBvcykge1xyXG5cdFx0XHR0aGlzLl9jbGVhckNvbnRyb2xQb3MoKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9yZXNpemVSZXF1ZXN0KSB7XHJcblx0XHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpO1xyXG5cdFx0XHR0aGlzLl9yZXNpemVSZXF1ZXN0ID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jbGVhckhhbmRsZXJzKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG5cdFx0XHQvLyBAZXZlbnQgdW5sb2FkOiBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgZGVzdHJveWVkIHdpdGggW3JlbW92ZV0oI21hcC1yZW1vdmUpIG1ldGhvZC5cclxuXHRcdFx0dGhpcy5maXJlKCd1bmxvYWQnKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaTtcclxuXHRcdGZvciAoaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLnJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cdFx0Zm9yIChpIGluIHRoaXMuX3BhbmVzKSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX3BhbmVzW2ldKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXllcnMgPSBbXTtcclxuXHRcdHRoaXMuX3BhbmVzID0gW107XHJcblx0XHRkZWxldGUgdGhpcy5fbWFwUGFuZTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9yZW5kZXJlcjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVQYW5lKG5hbWU6IFN0cmluZywgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIENyZWF0ZXMgYSBuZXcgW21hcCBwYW5lXSgjbWFwLXBhbmUpIHdpdGggdGhlIGdpdmVuIG5hbWUgaWYgaXQgZG9lc24ndCBleGlzdCBhbHJlYWR5LFxyXG5cdC8vIHRoZW4gcmV0dXJucyBpdC4gVGhlIHBhbmUgaXMgY3JlYXRlZCBhcyBhIGNoaWxkIG9mIGBjb250YWluZXJgLCBvclxyXG5cdC8vIGFzIGEgY2hpbGQgb2YgdGhlIG1haW4gbWFwIHBhbmUgaWYgbm90IHNldC5cclxuXHRjcmVhdGVQYW5lOiBmdW5jdGlvbiAobmFtZSwgY29udGFpbmVyKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtcGFuZScgKyAobmFtZSA/ICcgbGVhZmxldC0nICsgbmFtZS5yZXBsYWNlKCdQYW5lJywgJycpICsgJy1wYW5lJyA6ICcnKSxcclxuXHRcdCAgICBwYW5lID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyIHx8IHRoaXMuX21hcFBhbmUpO1xyXG5cclxuXHRcdGlmIChuYW1lKSB7XHJcblx0XHRcdHRoaXMuX3BhbmVzW25hbWVdID0gcGFuZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBwYW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIEdldHRpbmcgTWFwIFN0YXRlXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBjZW50ZXIgb2YgdGhlIG1hcCB2aWV3XHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xhc3RDZW50ZXIgJiYgIXRoaXMuX21vdmVkKCkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX2xhc3RDZW50ZXIuY2xvbmUoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Wm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgb2YgdGhlIG1hcCB2aWV3XHJcblx0Z2V0Wm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3pvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGJvdW5kcyB2aXNpYmxlIGluIHRoZSBjdXJyZW50IG1hcCB2aWV3XHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIHN3ID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldEJvdHRvbUxlZnQoKSksXHJcblx0XHQgICAgbmUgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0VG9wUmlnaHQoKSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoc3csIG5lKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE1pblpvb20oKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAgKGlmIHNldCBpbiB0aGUgYG1pblpvb21gIG9wdGlvbiBvZiB0aGUgbWFwIG9yIG9mIGFueSBsYXllcnMpLCBvciBgMGAgYnkgZGVmYXVsdC5cclxuXHRnZXRNaW5ab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX2xheWVyc01pblpvb20gfHwgMCA6IHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TWF4Wm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWF4Wm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycykuXHJcblx0Z2V0TWF4Wm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgP1xyXG5cdFx0XHQodGhpcy5fbGF5ZXJzTWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiB0aGlzLl9sYXllcnNNYXhab29tKSA6XHJcblx0XHRcdHRoaXMub3B0aW9ucy5tYXhab29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzWm9vbShib3VuZHM6IExhdExuZ0JvdW5kcywgaW5zaWRlPzogQm9vbGVhbiwgcGFkZGluZz86IFBvaW50KTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBnaXZlbiBib3VuZHMgZml0IHRvIHRoZSBtYXBcclxuXHQvLyB2aWV3IGluIGl0cyBlbnRpcmV0eS4gSWYgYGluc2lkZWAgKG9wdGlvbmFsKSBpcyBzZXQgdG8gYHRydWVgLCB0aGUgbWV0aG9kXHJcblx0Ly8gaW5zdGVhZCByZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIG1hcCB2aWV3IGZpdHMgaW50b1xyXG5cdC8vIHRoZSBnaXZlbiBib3VuZHMgaW4gaXRzIGVudGlyZXR5LlxyXG5cdGdldEJvdW5kc1pvb206IGZ1bmN0aW9uIChib3VuZHMsIGluc2lkZSwgcGFkZGluZykgeyAvLyAoTGF0TG5nQm91bmRzWywgQm9vbGVhbiwgUG9pbnRdKSAtPiBOdW1iZXJcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblx0XHRwYWRkaW5nID0gdG9Qb2ludChwYWRkaW5nIHx8IFswLCAwXSk7XHJcblxyXG5cdFx0dmFyIHpvb20gPSB0aGlzLmdldFpvb20oKSB8fCAwLFxyXG5cdFx0ICAgIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuZ2V0TWF4Wm9vbSgpLFxyXG5cdFx0ICAgIG53ID0gYm91bmRzLmdldE5vcnRoV2VzdCgpLFxyXG5cdFx0ICAgIHNlID0gYm91bmRzLmdldFNvdXRoRWFzdCgpLFxyXG5cdFx0ICAgIHNpemUgPSB0aGlzLmdldFNpemUoKS5zdWJ0cmFjdChwYWRkaW5nKSxcclxuXHRcdCAgICBib3VuZHNTaXplID0gdG9Cb3VuZHModGhpcy5wcm9qZWN0KHNlLCB6b29tKSwgdGhpcy5wcm9qZWN0KG53LCB6b29tKSkuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIHNuYXAgPSBCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21TbmFwIDogMSxcclxuXHRcdCAgICBzY2FsZXggPSBzaXplLnggLyBib3VuZHNTaXplLngsXHJcblx0XHQgICAgc2NhbGV5ID0gc2l6ZS55IC8gYm91bmRzU2l6ZS55LFxyXG5cdFx0ICAgIHNjYWxlID0gaW5zaWRlID8gTWF0aC5tYXgoc2NhbGV4LCBzY2FsZXkpIDogTWF0aC5taW4oc2NhbGV4LCBzY2FsZXkpO1xyXG5cclxuXHRcdHpvb20gPSB0aGlzLmdldFNjYWxlWm9vbShzY2FsZSwgem9vbSk7XHJcblxyXG5cdFx0aWYgKHNuYXApIHtcclxuXHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIChzbmFwIC8gMTAwKSkgKiAoc25hcCAvIDEwMCk7IC8vIGRvbid0IGp1bXAgaWYgd2l0aGluIDElIG9mIGEgc25hcCBsZXZlbFxyXG5cdFx0XHR6b29tID0gaW5zaWRlID8gTWF0aC5jZWlsKHpvb20gLyBzbmFwKSAqIHNuYXAgOiBNYXRoLmZsb29yKHpvb20gLyBzbmFwKSAqIHNuYXA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB6b29tKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBtYXAgY29udGFpbmVyIChpbiBwaXhlbHMpLlxyXG5cdGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fc2l6ZSB8fCB0aGlzLl9zaXplQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLl9zaXplID0gbmV3IFBvaW50KFxyXG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCB8fCAwLFxyXG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQgfHwgMCk7XHJcblxyXG5cdFx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuX3NpemUuY2xvbmUoKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsQm91bmRzKCk6IEJvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgY3VycmVudCBtYXAgdmlldyBpbiBwcm9qZWN0ZWQgcGl4ZWxcclxuXHQvLyBjb29yZGluYXRlcyAoc29tZXRpbWVzIHVzZWZ1bCBpbiBsYXllciBhbmQgb3ZlcmxheSBpbXBsZW1lbnRhdGlvbnMpLlxyXG5cdGdldFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgdG9wTGVmdFBvaW50ID0gdGhpcy5fZ2V0VG9wTGVmdFBvaW50KGNlbnRlciwgem9vbSk7XHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyh0b3BMZWZ0UG9pbnQsIHRvcExlZnRQb2ludC5hZGQodGhpcy5nZXRTaXplKCkpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBUT0RPOiBDaGVjayBzZW1hbnRpY3MgLSBpc24ndCB0aGUgcGl4ZWwgb3JpZ2luIHRoZSAwLDAgY29vcmQgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgbWFwIHBhbmU/IFwibGVmdCBwb2ludCBvZiB0aGUgbWFwIGxheWVyXCIgY2FuIGJlIGNvbmZ1c2luZywgc3BlY2lhbGx5XHJcblx0Ly8gc2luY2UgdGhlcmUgY2FuIGJlIG5lZ2F0aXZlIG9mZnNldHMuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbE9yaWdpbigpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHByb2plY3RlZCBwaXhlbCBjb29yZGluYXRlcyBvZiB0aGUgdG9wIGxlZnQgcG9pbnQgb2ZcclxuXHQvLyB0aGUgbWFwIGxheWVyICh1c2VmdWwgaW4gY3VzdG9tIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXHJcblx0Z2V0UGl4ZWxPcmlnaW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHRcdHJldHVybiB0aGlzLl9waXhlbE9yaWdpbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsV29ybGRCb3VuZHMoem9vbT86IE51bWJlcik6IEJvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIHdvcmxkJ3MgYm91bmRzIGluIHBpeGVsIGNvb3JkaW5hdGVzIGZvciB6b29tIGxldmVsIGB6b29tYC5cclxuXHQvLyBJZiBgem9vbWAgaXMgb21pdHRlZCwgdGhlIG1hcCdzIGN1cnJlbnQgem9vbSBsZXZlbCBpcyB1c2VkLlxyXG5cdGdldFBpeGVsV29ybGRCb3VuZHM6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5nZXRQcm9qZWN0ZWRCb3VuZHMoem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXRab29tKCkgOiB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGFuZShwYW5lOiBTdHJpbmd8SFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgYSBbbWFwIHBhbmVdKCNtYXAtcGFuZSksIGdpdmVuIGl0cyBuYW1lIG9yIGl0cyBIVE1MIGVsZW1lbnQgKGl0cyBpZGVudGl0eSkuXHJcblx0Z2V0UGFuZTogZnVuY3Rpb24gKHBhbmUpIHtcclxuXHRcdHJldHVybiB0eXBlb2YgcGFuZSA9PT0gJ3N0cmluZycgPyB0aGlzLl9wYW5lc1twYW5lXSA6IHBhbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQYW5lcygpOiBPYmplY3RcclxuXHQvLyBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5hbWVzIG9mIGFsbCBbcGFuZXNdKCNtYXAtcGFuZSkgYXMga2V5cyBhbmRcclxuXHQvLyB0aGUgcGFuZXMgYXMgdmFsdWVzLlxyXG5cdGdldFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGFuZXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIG1hcC5cclxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIEBzZWN0aW9uIENvbnZlcnNpb24gTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIGdldFpvb21TY2FsZSh0b1pvb206IE51bWJlciwgZnJvbVpvb206IE51bWJlcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHNjYWxlIGZhY3RvciB0byBiZSBhcHBsaWVkIHRvIGEgbWFwIHRyYW5zaXRpb24gZnJvbSB6b29tIGxldmVsXHJcblx0Ly8gYGZyb21ab29tYCB0byBgdG9ab29tYC4gVXNlZCBpbnRlcm5hbGx5IHRvIGhlbHAgd2l0aCB6b29tIGFuaW1hdGlvbnMuXHJcblx0Z2V0Wm9vbVNjYWxlOiBmdW5jdGlvbiAodG9ab29tLCBmcm9tWm9vbSkge1xyXG5cdFx0Ly8gVE9ETyByZXBsYWNlIHdpdGggdW5pdmVyc2FsIGltcGxlbWVudGF0aW9uIGFmdGVyIHJlZmFjdG9yaW5nIHByb2plY3Rpb25zXHJcblx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuXHRcdGZyb21ab29tID0gZnJvbVpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiBmcm9tWm9vbTtcclxuXHRcdHJldHVybiBjcnMuc2NhbGUodG9ab29tKSAvIGNycy5zY2FsZShmcm9tWm9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTY2FsZVpvb20oc2NhbGU6IE51bWJlciwgZnJvbVpvb206IE51bWJlcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHpvb20gbGV2ZWwgdGhhdCB0aGUgbWFwIHdvdWxkIGVuZCB1cCBhdCwgaWYgaXQgaXMgYXQgYGZyb21ab29tYFxyXG5cdC8vIGxldmVsIGFuZCBldmVyeXRoaW5nIGlzIHNjYWxlZCBieSBhIGZhY3RvciBvZiBgc2NhbGVgLiBJbnZlcnNlIG9mXHJcblx0Ly8gW2BnZXRab29tU2NhbGVgXSgjbWFwLWdldFpvb21TY2FsZSkuXHJcblx0Z2V0U2NhbGVab29tOiBmdW5jdGlvbiAoc2NhbGUsIGZyb21ab29tKSB7XHJcblx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuXHRcdGZyb21ab29tID0gZnJvbVpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiBmcm9tWm9vbTtcclxuXHRcdHZhciB6b29tID0gY3JzLnpvb20oc2NhbGUgKiBjcnMuc2NhbGUoZnJvbVpvb20pKTtcclxuXHRcdHJldHVybiBpc05hTih6b29tKSA/IEluZmluaXR5IDogem9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSBgTGF0TG5nYCBhY2NvcmRpbmcgdG8gdGhlIHByb2plY3Rpb25cclxuXHQvLyBvZiB0aGUgbWFwJ3MgQ1JTLCB0aGVuIHNjYWxlcyBpdCBhY2NvcmRpbmcgdG8gYHpvb21gIGFuZCB0aGUgQ1JTJ3NcclxuXHQvLyBgVHJhbnNmb3JtYXRpb25gLiBUaGUgcmVzdWx0IGlzIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgQ1JTIG9yaWdpbi5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5sYXRMbmdUb1BvaW50KHRvTGF0TG5nKGxhdGxuZyksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcblx0Ly8gSW52ZXJzZSBvZiBbYHByb2plY3RgXSgjbWFwLXByb2plY3QpLlxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50LCB6b29tKSB7XHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5wb2ludFRvTGF0TG5nKHRvUG9pbnQocG9pbnQpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG5cdC8vIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgKGZvciB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cclxuXHRsYXllclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdG9Qb2ludChwb2ludCkuYWRkKHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QocHJvamVjdGVkUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGVcclxuXHQvLyByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikuXHJcblx0bGF0TG5nVG9MYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3QodG9MYXRMbmcobGF0bG5nKSkuX3JvdW5kKCk7XHJcblx0XHRyZXR1cm4gcHJvamVjdGVkUG9pbnQuX3N1YnRyYWN0KHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nKGxhdGxuZzogTGF0TG5nKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdgIHdoZXJlIGBsYXRgIGFuZCBgbG5nYCBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuXHQvLyBtYXAncyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZVxyXG5cdC8vIENSUydzIGJvdW5kcy5cclxuXHQvLyBCeSBkZWZhdWx0IHRoaXMgbWVhbnMgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBkYXRlbGluZSBzbyBpdHNcclxuXHQvLyB2YWx1ZSBpcyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuXHR3cmFwTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy53cmFwTGF0TG5nKHRvTGF0TG5nKGxhdGxuZykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZ0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nQm91bmRzYCB3aXRoIHRoZSBzYW1lIHNpemUgYXMgdGhlIGdpdmVuIG9uZSwgZW5zdXJpbmcgdGhhdFxyXG5cdC8vIGl0cyBjZW50ZXIgaXMgd2l0aGluIHRoZSBDUlMncyBib3VuZHMuXHJcblx0Ly8gQnkgZGVmYXVsdCB0aGlzIG1lYW5zIHRoZSBjZW50ZXIgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBkYXRlbGluZSBzbyBpdHNcclxuXHQvLyB2YWx1ZSBpcyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcywgYW5kIHRoZSBtYWpvcml0eSBvZiB0aGUgYm91bmRzXHJcblx0Ly8gb3ZlcmxhcHMgdGhlIENSUydzIGJvdW5kcy5cclxuXHR3cmFwTGF0TG5nQm91bmRzOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy53cmFwTGF0TG5nQm91bmRzKHRvTGF0TG5nQm91bmRzKGxhdGxuZykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2UobGF0bG5nMTogTGF0TG5nLCBsYXRsbmcyOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgYWNjb3JkaW5nIHRvXHJcblx0Ly8gdGhlIG1hcCdzIENSUy4gQnkgZGVmYXVsdCB0aGlzIG1lYXN1cmVzIGRpc3RhbmNlIGluIG1ldGVycy5cclxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmRpc3RhbmNlKHRvTGF0TG5nKGxhdGxuZzEpLCB0b0xhdExuZyhsYXRsbmcyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChwb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZ1xyXG5cdC8vIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG5cdGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cmV0dXJuIHRvUG9pbnQocG9pbnQpLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXllclBvaW50VG9Db250YWluZXJQb2ludChwb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbiksXHJcblx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG5cdGxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cmV0dXJuIHRvUG9pbnQocG9pbnQpLmFkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbmVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIsIHJldHVybnNcclxuXHQvLyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG5cdGNvbnRhaW5lclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRvUG9pbnQocG9pbnQpKTtcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvQ29udGFpbmVyUG9pbnQobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG5cdC8vIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG5cdGxhdExuZ1RvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHRoaXMubGF0TG5nVG9MYXllclBvaW50KHRvTGF0TG5nKGxhdGxuZykpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGV2OiBNb3VzZUV2ZW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZVxyXG5cdC8vIG1hcCBjb250YWluZXIgd2hlcmUgdGhlIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gRG9tRXZlbnQuZ2V0TW91c2VQb3NpdGlvbihlLCB0aGlzLl9jb250YWluZXIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvTGF5ZXJQb2ludChldjogTW91c2VFdmVudCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyB0aGUgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9MYXRMbmcoZXY6IE1vdXNlRXZlbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIHdoZXJlIHRoZVxyXG5cdC8vIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvTGF0TG5nOiBmdW5jdGlvbiAoZSkgeyAvLyAoTW91c2VFdmVudClcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSkpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBtYXAgaW5pdGlhbGl6YXRpb24gbWV0aG9kc1xyXG5cclxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5nZXQoaWQpO1xyXG5cclxuXHRcdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBub3QgZm91bmQuJyk7XHJcblx0XHR9IGVsc2UgaWYgKGNvbnRhaW5lci5fbGVhZmxldF9pZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgaXMgYWxyZWFkeSBpbml0aWFsaXplZC4nKTtcclxuXHRcdH1cclxuXHJcblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCwgdGhpcyk7XHJcblx0XHR0aGlzLl9jb250YWluZXJJZCA9IFV0aWwuc3RhbXAoY29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcclxuXHJcblx0XHR0aGlzLl9mYWRlQW5pbWF0ZWQgPSB0aGlzLm9wdGlvbnMuZmFkZUFuaW1hdGlvbiAmJiBCcm93c2VyLmFueTNkO1xyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250YWluZXInICtcclxuXHRcdFx0KEJyb3dzZXIudG91Y2ggPyAnIGxlYWZsZXQtdG91Y2gnIDogJycpICtcclxuXHRcdFx0KEJyb3dzZXIucmV0aW5hID8gJyBsZWFmbGV0LXJldGluYScgOiAnJykgK1xyXG5cdFx0XHQoQnJvd3Nlci5pZWx0OSA/ICcgbGVhZmxldC1vbGRpZScgOiAnJykgK1xyXG5cdFx0XHQoQnJvd3Nlci5zYWZhcmkgPyAnIGxlYWZsZXQtc2FmYXJpJyA6ICcnKSArXHJcblx0XHRcdCh0aGlzLl9mYWRlQW5pbWF0ZWQgPyAnIGxlYWZsZXQtZmFkZS1hbmltJyA6ICcnKSk7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uID0gRG9tVXRpbC5nZXRTdHlsZShjb250YWluZXIsICdwb3NpdGlvbicpO1xyXG5cclxuXHRcdGlmIChwb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBwb3NpdGlvbiAhPT0gJ3JlbGF0aXZlJyAmJiBwb3NpdGlvbiAhPT0gJ2ZpeGVkJyAmJiBwb3NpdGlvbiAhPT0gJ3N0aWNreScpIHtcclxuXHRcdFx0Y29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0UGFuZXMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5faW5pdENvbnRyb2xQb3MpIHtcclxuXHRcdFx0dGhpcy5faW5pdENvbnRyb2xQb3MoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaW5pdFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcGFuZXMgPSB0aGlzLl9wYW5lcyA9IHt9O1xyXG5cdFx0dGhpcy5fcGFuZVJlbmRlcmVycyA9IHt9O1xyXG5cclxuXHRcdC8vIEBzZWN0aW9uXHJcblx0XHQvL1xyXG5cdFx0Ly8gUGFuZXMgYXJlIERPTSBlbGVtZW50cyB1c2VkIHRvIGNvbnRyb2wgdGhlIG9yZGVyaW5nIG9mIGxheWVycyBvbiB0aGUgbWFwLiBZb3VcclxuXHRcdC8vIGNhbiBhY2Nlc3MgcGFuZXMgd2l0aCBbYG1hcC5nZXRQYW5lYF0oI21hcC1nZXRwYW5lKSBvclxyXG5cdFx0Ly8gW2BtYXAuZ2V0UGFuZXNgXSgjbWFwLWdldHBhbmVzKSBtZXRob2RzLiBOZXcgcGFuZXMgY2FuIGJlIGNyZWF0ZWQgd2l0aCB0aGVcclxuXHRcdC8vIFtgbWFwLmNyZWF0ZVBhbmVgXSgjbWFwLWNyZWF0ZXBhbmUpIG1ldGhvZC5cclxuXHRcdC8vXHJcblx0XHQvLyBFdmVyeSBtYXAgaGFzIHRoZSBmb2xsb3dpbmcgZGVmYXVsdCBwYW5lcyB0aGF0IGRpZmZlciBvbmx5IGluIHpJbmRleC5cclxuXHRcdC8vXHJcblx0XHQvLyBAcGFuZSBtYXBQYW5lOiBIVE1MRWxlbWVudCA9ICdhdXRvJ1xyXG5cdFx0Ly8gUGFuZSB0aGF0IGNvbnRhaW5zIGFsbCBvdGhlciBtYXAgcGFuZXNcclxuXHJcblx0XHR0aGlzLl9tYXBQYW5lID0gdGhpcy5jcmVhdGVQYW5lKCdtYXBQYW5lJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcblx0XHQvLyBAcGFuZSB0aWxlUGFuZTogSFRNTEVsZW1lbnQgPSAyMDBcclxuXHRcdC8vIFBhbmUgZm9yIGBHcmlkTGF5ZXJgcyBhbmQgYFRpbGVMYXllcmBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3RpbGVQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBvdmVybGF5UGFuZTogSFRNTEVsZW1lbnQgPSA0MDBcclxuXHRcdC8vIFBhbmUgZm9yIHZlY3RvcnMgKGBQYXRoYHMsIGxpa2UgYFBvbHlsaW5lYHMgYW5kIGBQb2x5Z29uYHMpLCBgSW1hZ2VPdmVybGF5YHMgYW5kIGBWaWRlb092ZXJsYXlgc1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdvdmVybGF5UGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgc2hhZG93UGFuZTogSFRNTEVsZW1lbnQgPSA1MDBcclxuXHRcdC8vIFBhbmUgZm9yIG92ZXJsYXkgc2hhZG93cyAoZS5nLiBgTWFya2VyYCBzaGFkb3dzKVxyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdzaGFkb3dQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBtYXJrZXJQYW5lOiBIVE1MRWxlbWVudCA9IDYwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYEljb25gcyBvZiBgTWFya2VyYHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnbWFya2VyUGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgdG9vbHRpcFBhbmU6IEhUTUxFbGVtZW50ID0gNjUwXHJcblx0XHQvLyBQYW5lIGZvciBgVG9vbHRpcGBzLlxyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCd0b29sdGlwUGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgcG9wdXBQYW5lOiBIVE1MRWxlbWVudCA9IDcwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYFBvcHVwYHMuXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3BvcHVwUGFuZScpO1xyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb24pIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5tYXJrZXJQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5zaGFkb3dQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gcHJpdmF0ZSBtZXRob2RzIHRoYXQgbW9kaWZ5IG1hcCBzdGF0ZVxyXG5cclxuXHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG5cdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG5vTW92ZVN0YXJ0KSB7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIG5ldyBQb2ludCgwLCAwKSk7XHJcblxyXG5cdFx0dmFyIGxvYWRpbmcgPSAhdGhpcy5fbG9hZGVkO1xyXG5cdFx0dGhpcy5fbG9hZGVkID0gdHJ1ZTtcclxuXHRcdHpvb20gPSB0aGlzLl9saW1pdFpvb20oem9vbSk7XHJcblxyXG5cdFx0dGhpcy5maXJlKCd2aWV3cHJlcmVzZXQnKTtcclxuXHJcblx0XHR2YXIgem9vbUNoYW5nZWQgPSB0aGlzLl96b29tICE9PSB6b29tO1xyXG5cdFx0dGhpc1xyXG5cdFx0XHQuX21vdmVTdGFydCh6b29tQ2hhbmdlZCwgbm9Nb3ZlU3RhcnQpXHJcblx0XHRcdC5fbW92ZShjZW50ZXIsIHpvb20pXHJcblx0XHRcdC5fbW92ZUVuZCh6b29tQ2hhbmdlZCk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IHZpZXdyZXNldDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBuZWVkcyB0byByZWRyYXcgaXRzIGNvbnRlbnQgKHRoaXMgdXN1YWxseSBoYXBwZW5zXHJcblx0XHQvLyBvbiBtYXAgem9vbSBvciBsb2FkKS4gVmVyeSB1c2VmdWwgZm9yIGNyZWF0aW5nIGN1c3RvbSBvdmVybGF5cy5cclxuXHRcdHRoaXMuZmlyZSgndmlld3Jlc2V0Jyk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgaW5pdGlhbGl6ZWQgKHdoZW4gaXRzIGNlbnRlciBhbmQgem9vbSBhcmUgc2V0XHJcblx0XHQvLyBmb3IgdGhlIGZpcnN0IHRpbWUpLlxyXG5cdFx0aWYgKGxvYWRpbmcpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdsb2FkJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X21vdmVTdGFydDogZnVuY3Rpb24gKHpvb21DaGFuZ2VkLCBub01vdmVTdGFydCkge1xyXG5cdFx0Ly8gQGV2ZW50IHpvb21zdGFydDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCB6b29tIGlzIGFib3V0IHRvIGNoYW5nZSAoZS5nLiBiZWZvcmUgem9vbSBhbmltYXRpb24pLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdmVzdGFydDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHZpZXcgb2YgdGhlIG1hcCBzdGFydHMgY2hhbmdpbmcgKGUuZy4gdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIG1hcCkuXHJcblx0XHRpZiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tc3RhcnQnKTtcclxuXHRcdH1cclxuXHRcdGlmICghbm9Nb3ZlU3RhcnQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBkYXRhLCBzdXByZXNzRXZlbnQpIHtcclxuXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0em9vbSA9IHRoaXMuX3pvb207XHJcblx0XHR9XHJcblx0XHR2YXIgem9vbUNoYW5nZWQgPSB0aGlzLl96b29tICE9PSB6b29tO1xyXG5cclxuXHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG5cdFx0dGhpcy5fbGFzdENlbnRlciA9IGNlbnRlcjtcclxuXHRcdHRoaXMuX3BpeGVsT3JpZ2luID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyKTtcclxuXHJcblx0XHRpZiAoIXN1cHJlc3NFdmVudCkge1xyXG5cdFx0XHQvLyBAZXZlbnQgem9vbTogRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW55IGNoYW5nZSBpbiB6b29tIGxldmVsLFxyXG5cdFx0XHQvLyBpbmNsdWRpbmcgem9vbSBhbmQgZmx5IGFuaW1hdGlvbnMuXHJcblx0XHRcdGlmICh6b29tQ2hhbmdlZCB8fCAoZGF0YSAmJiBkYXRhLnBpbmNoKSkge1x0Ly8gQWx3YXlzIGZpcmUgJ3pvb20nIGlmIHBpbmNoaW5nIGJlY2F1c2UgIzM1MzBcclxuXHRcdFx0XHR0aGlzLmZpcmUoJ3pvb20nLCBkYXRhKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGFueSBtb3ZlbWVudCBvZiB0aGUgbWFwLFxyXG5cdFx0XHQvLyBpbmNsdWRpbmcgcGFuIGFuZCBmbHkgYW5pbWF0aW9ucy5cclxuXHRcdFx0dGhpcy5maXJlKCdtb3ZlJywgZGF0YSk7XHJcblx0XHR9IGVsc2UgaWYgKGRhdGEgJiYgZGF0YS5waW5jaCkge1x0Ly8gQWx3YXlzIGZpcmUgJ3pvb20nIGlmIHBpbmNoaW5nIGJlY2F1c2UgIzM1MzBcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tJywgZGF0YSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfbW92ZUVuZDogZnVuY3Rpb24gKHpvb21DaGFuZ2VkKSB7XHJcblx0XHQvLyBAZXZlbnQgem9vbWVuZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCB6b29tIGNoYW5nZWQsIGFmdGVyIGFueSBhbmltYXRpb25zLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbWVuZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgY2VudGVyIG9mIHRoZSBtYXAgc3RvcHMgY2hhbmdpbmdcclxuXHRcdC8vIChlLmcuIHVzZXIgc3RvcHBlZCBkcmFnZ2luZyB0aGUgbWFwIG9yIGFmdGVyIG5vbi1jZW50ZXJlZCB6b29tKS5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHR9LFxyXG5cclxuXHRfc3RvcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fZmx5VG9GcmFtZSk7XHJcblx0XHRpZiAodGhpcy5fcGFuQW5pbSkge1xyXG5cdFx0XHR0aGlzLl9wYW5BbmltLnN0b3AoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9yYXdQYW5CeTogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCB0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3Qob2Zmc2V0KSk7XHJcblx0fSxcclxuXHJcblx0X2dldFpvb21TcGFuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRNYXhab29tKCkgLSB0aGlzLmdldE1pblpvb20oKTtcclxuXHR9LFxyXG5cclxuXHRfcGFuSW5zaWRlTWF4Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2VuZm9yY2luZ0JvdW5kcykge1xyXG5cdFx0XHR0aGlzLnBhbkluc2lkZUJvdW5kcyh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY2hlY2tJZkxvYWRlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTZXQgbWFwIGNlbnRlciBhbmQgem9vbSBmaXJzdC4nKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBET00gZXZlbnQgaGFuZGxpbmdcclxuXHJcblx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gZXZlbnRzXHJcblx0X2luaXRFdmVudHM6IGZ1bmN0aW9uIChyZW1vdmUpIHtcclxuXHRcdHRoaXMuX3RhcmdldHMgPSB7fTtcclxuXHRcdHRoaXMuX3RhcmdldHNbVXRpbC5zdGFtcCh0aGlzLl9jb250YWluZXIpXSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIG9uT2ZmID0gcmVtb3ZlID8gRG9tRXZlbnQub2ZmIDogRG9tRXZlbnQub247XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyAob3IgdGFwcykgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBkYmxjbGljazogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBkb3VibGUtY2xpY2tzIChvciBkb3VibGUtdGFwcykgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZWRvd246IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZXVwOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW92ZXI6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGVudGVycyB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlb3V0OiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW1vdmU6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoaWxlIHRoZSBtb3VzZSBtb3ZlcyBvdmVyIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgY29udGV4dG1lbnU6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSByaWdodCBtb3VzZSBidXR0b24gb24gdGhlIG1hcCwgcHJldmVudHNcclxuXHRcdC8vIGRlZmF1bHQgYnJvd3NlciBjb250ZXh0IG1lbnUgZnJvbSBzaG93aW5nIGlmIHRoZXJlIGFyZSBsaXN0ZW5lcnMgb25cclxuXHRcdC8vIHRoaXMgZXZlbnQuIEFsc28gZmlyZWQgb24gbW9iaWxlIHdoZW4gdGhlIHVzZXIgaG9sZHMgYSBzaW5nbGUgdG91Y2hcclxuXHRcdC8vIGZvciBhIHNlY29uZCAoYWxzbyBjYWxsZWQgbG9uZyBwcmVzcykuXHJcblx0XHQvLyBAZXZlbnQga2V5cHJlc3M6IEtleWJvYXJkRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB0aGF0IHByb2R1Y2VzIGEgY2hhcmFjdGVyIHZhbHVlIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC5cclxuXHRcdC8vIEBldmVudCBrZXlkb3duOiBLZXlib2FyZEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLiBVbmxpa2UgdGhlIGBrZXlwcmVzc2AgZXZlbnQsXHJcblx0XHQvLyB0aGUgYGtleWRvd25gIGV2ZW50IGlzIGZpcmVkIGZvciBrZXlzIHRoYXQgcHJvZHVjZSBhIGNoYXJhY3RlciB2YWx1ZSBhbmQgZm9yIGtleXNcclxuXHRcdC8vIHRoYXQgZG8gbm90IHByb2R1Y2UgYSBjaGFyYWN0ZXIgdmFsdWUuXHJcblx0XHQvLyBAZXZlbnQga2V5dXA6IEtleWJvYXJkRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLlxyXG5cdFx0b25PZmYodGhpcy5fY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgJyArXHJcblx0XHRcdCdtb3VzZW92ZXIgbW91c2VvdXQgbW91c2Vtb3ZlIGNvbnRleHRtZW51IGtleXByZXNzIGtleWRvd24ga2V5dXAnLCB0aGlzLl9oYW5kbGVET01FdmVudCwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy50cmFja1Jlc2l6ZSkge1xyXG5cdFx0XHRvbk9mZih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKEJyb3dzZXIuYW55M2QgJiYgdGhpcy5vcHRpb25zLnRyYW5zZm9ybTNETGltaXQpIHtcclxuXHRcdFx0KHJlbW92ZSA/IHRoaXMub2ZmIDogdGhpcy5vbikuY2FsbCh0aGlzLCAnbW92ZWVuZCcsIHRoaXMuX29uTW92ZUVuZCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X29uUmVzaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZXNpemVSZXF1ZXN0KTtcclxuXHRcdHRoaXMuX3Jlc2l6ZVJlcXVlc3QgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUoXHJcblx0XHQgICAgICAgIGZ1bmN0aW9uICgpIHsgdGhpcy5pbnZhbGlkYXRlU2l6ZSh7ZGVib3VuY2VNb3ZlZW5kOiB0cnVlfSk7IH0sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9vblNjcm9sbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnNjcm9sbFRvcCAgPSAwO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnNjcm9sbExlZnQgPSAwO1xyXG5cdH0sXHJcblxyXG5cdF9vbk1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcblx0XHRpZiAoTWF0aC5tYXgoTWF0aC5hYnMocG9zLngpLCBNYXRoLmFicyhwb3MueSkpID49IHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcblx0XHRcdC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyMDM4NzMgYnV0IFdlYmtpdCBhbHNvIGhhdmVcclxuXHRcdFx0Ly8gYSBwaXhlbCBvZmZzZXQgb24gdmVyeSBoaWdoIHZhbHVlcywgc2VlOiBodHRwczovL2pzZmlkZGxlLm5ldC9kZzZyNWhoYi9cclxuXHRcdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHRoaXMuZ2V0Wm9vbSgpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZmluZEV2ZW50VGFyZ2V0czogZnVuY3Rpb24gKGUsIHR5cGUpIHtcclxuXHRcdHZhciB0YXJnZXRzID0gW10sXHJcblx0XHQgICAgdGFyZ2V0LFxyXG5cdFx0ICAgIGlzSG92ZXIgPSB0eXBlID09PSAnbW91c2VvdXQnIHx8IHR5cGUgPT09ICdtb3VzZW92ZXInLFxyXG5cdFx0ICAgIHNyYyA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCxcclxuXHRcdCAgICBkcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuXHRcdHdoaWxlIChzcmMpIHtcclxuXHRcdFx0dGFyZ2V0ID0gdGhpcy5fdGFyZ2V0c1tVdGlsLnN0YW1wKHNyYyldO1xyXG5cdFx0XHRpZiAodGFyZ2V0ICYmICh0eXBlID09PSAnY2xpY2snIHx8IHR5cGUgPT09ICdwcmVjbGljaycpICYmIHRoaXMuX2RyYWdnYWJsZU1vdmVkKHRhcmdldCkpIHtcclxuXHRcdFx0XHQvLyBQcmV2ZW50IGZpcmluZyBjbGljayBhZnRlciB5b3UganVzdCBkcmFnZ2VkIGFuIG9iamVjdC5cclxuXHRcdFx0XHRkcmFnZ2luZyA9IHRydWU7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRhcmdldCAmJiB0YXJnZXQubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG5cdFx0XHRcdGlmIChpc0hvdmVyICYmICFEb21FdmVudC5pc0V4dGVybmFsVGFyZ2V0KHNyYywgZSkpIHsgYnJlYWs7IH1cclxuXHRcdFx0XHR0YXJnZXRzLnB1c2godGFyZ2V0KTtcclxuXHRcdFx0XHRpZiAoaXNIb3ZlcikgeyBicmVhazsgfVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChzcmMgPT09IHRoaXMuX2NvbnRhaW5lcikgeyBicmVhazsgfVxyXG5cdFx0XHRzcmMgPSBzcmMucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHRcdGlmICghdGFyZ2V0cy5sZW5ndGggJiYgIWRyYWdnaW5nICYmICFpc0hvdmVyICYmIHRoaXMubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG5cdFx0XHR0YXJnZXRzID0gW3RoaXNdO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRhcmdldHM7XHJcblx0fSxcclxuXHJcblx0X2lzQ2xpY2tEaXNhYmxlZDogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHR3aGlsZSAoZWwgJiYgZWwgIT09IHRoaXMuX2NvbnRhaW5lcikge1xyXG5cdFx0XHRpZiAoZWxbJ19sZWFmbGV0X2Rpc2FibGVfY2xpY2snXSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cdFx0XHRlbCA9IGVsLnBhcmVudE5vZGU7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZURPTUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIGVsID0gKGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCk7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCB8fCBlbFsnX2xlYWZsZXRfZGlzYWJsZV9ldmVudHMnXSB8fCBlLnR5cGUgPT09ICdjbGljaycgJiYgdGhpcy5faXNDbGlja0Rpc2FibGVkKGVsKSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHR5cGUgPSBlLnR5cGU7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdtb3VzZWRvd24nKSB7XHJcblx0XHRcdC8vIHByZXZlbnRzIG91dGxpbmUgd2hlbiBjbGlja2luZyBvbiBrZXlib2FyZC1mb2N1c2FibGUgZWxlbWVudFxyXG5cdFx0XHREb21VdGlsLnByZXZlbnRPdXRsaW5lKGVsKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9maXJlRE9NRXZlbnQoZSwgdHlwZSk7XHJcblx0fSxcclxuXHJcblx0X21vdXNlRXZlbnRzOiBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdjb250ZXh0bWVudSddLFxyXG5cclxuXHRfZmlyZURPTUV2ZW50OiBmdW5jdGlvbiAoZSwgdHlwZSwgY2FudmFzVGFyZ2V0cykge1xyXG5cclxuXHRcdGlmIChlLnR5cGUgPT09ICdjbGljaycpIHtcclxuXHRcdFx0Ly8gRmlyZSBhIHN5bnRoZXRpYyAncHJlY2xpY2snIGV2ZW50IHdoaWNoIHByb3BhZ2F0ZXMgdXAgKG1haW5seSBmb3IgY2xvc2luZyBwb3B1cHMpLlxyXG5cdFx0XHQvLyBAZXZlbnQgcHJlY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgYmVmb3JlIG1vdXNlIGNsaWNrIG9uIHRoZSBtYXAgKHNvbWV0aW1lcyB1c2VmdWwgd2hlbiB5b3VcclxuXHRcdFx0Ly8gd2FudCBzb21ldGhpbmcgdG8gaGFwcGVuIG9uIGNsaWNrIGJlZm9yZSBhbnkgZXhpc3RpbmcgY2xpY2tcclxuXHRcdFx0Ly8gaGFuZGxlcnMgc3RhcnQgcnVubmluZykuXHJcblx0XHRcdHZhciBzeW50aCA9IFV0aWwuZXh0ZW5kKHt9LCBlKTtcclxuXHRcdFx0c3ludGgudHlwZSA9ICdwcmVjbGljayc7XHJcblx0XHRcdHRoaXMuX2ZpcmVET01FdmVudChzeW50aCwgc3ludGgudHlwZSwgY2FudmFzVGFyZ2V0cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRmluZCB0aGUgbGF5ZXIgdGhlIGV2ZW50IGlzIHByb3BhZ2F0aW5nIGZyb20gYW5kIGl0cyBwYXJlbnRzLlxyXG5cdFx0dmFyIHRhcmdldHMgPSB0aGlzLl9maW5kRXZlbnRUYXJnZXRzKGUsIHR5cGUpO1xyXG5cclxuXHRcdGlmIChjYW52YXNUYXJnZXRzKSB7XHJcblx0XHRcdHZhciBmaWx0ZXJlZCA9IFtdOyAvLyBwaWNrIG9ubHkgdGFyZ2V0cyB3aXRoIGxpc3RlbmVyc1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNhbnZhc1RhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRpZiAoY2FudmFzVGFyZ2V0c1tpXS5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdFx0XHRmaWx0ZXJlZC5wdXNoKGNhbnZhc1RhcmdldHNbaV0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR0YXJnZXRzID0gZmlsdGVyZWQuY29uY2F0KHRhcmdldHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGFyZ2V0cy5sZW5ndGgpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdjb250ZXh0bWVudScpIHtcclxuXHRcdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRhcmdldCA9IHRhcmdldHNbMF07XHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0b3JpZ2luYWxFdmVudDogZVxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoZS50eXBlICE9PSAna2V5cHJlc3MnICYmIGUudHlwZSAhPT0gJ2tleWRvd24nICYmIGUudHlwZSAhPT0gJ2tleXVwJykge1xyXG5cdFx0XHR2YXIgaXNNYXJrZXIgPSB0YXJnZXQuZ2V0TGF0TG5nICYmICghdGFyZ2V0Ll9yYWRpdXMgfHwgdGFyZ2V0Ll9yYWRpdXMgPD0gMTApO1xyXG5cdFx0XHRkYXRhLmNvbnRhaW5lclBvaW50ID0gaXNNYXJrZXIgP1xyXG5cdFx0XHRcdHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludCh0YXJnZXQuZ2V0TGF0TG5nKCkpIDogdGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcclxuXHRcdFx0ZGF0YS5sYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChkYXRhLmNvbnRhaW5lclBvaW50KTtcclxuXHRcdFx0ZGF0YS5sYXRsbmcgPSBpc01hcmtlciA/IHRhcmdldC5nZXRMYXRMbmcoKSA6IHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGRhdGEubGF5ZXJQb2ludCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGFyZ2V0c1tpXS5maXJlKHR5cGUsIGRhdGEsIHRydWUpO1xyXG5cdFx0XHRpZiAoZGF0YS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkIHx8XHJcblx0XHRcdFx0KHRhcmdldHNbaV0ub3B0aW9ucy5idWJibGluZ01vdXNlRXZlbnRzID09PSBmYWxzZSAmJiBVdGlsLmluZGV4T2YodGhpcy5fbW91c2VFdmVudHMsIHR5cGUpICE9PSAtMSkpIHsgcmV0dXJuOyB9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2RyYWdnYWJsZU1vdmVkOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRvYmogPSBvYmouZHJhZ2dpbmcgJiYgb2JqLmRyYWdnaW5nLmVuYWJsZWQoKSA/IG9iaiA6IHRoaXM7XHJcblx0XHRyZXR1cm4gKG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcubW92ZWQoKSkgfHwgKHRoaXMuYm94Wm9vbSAmJiB0aGlzLmJveFpvb20ubW92ZWQoKSk7XHJcblx0fSxcclxuXHJcblx0X2NsZWFySGFuZGxlcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9oYW5kbGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHR0aGlzLl9oYW5kbGVyc1tpXS5kaXNhYmxlKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIHdoZW5SZWFkeShmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gUnVucyB0aGUgZ2l2ZW4gZnVuY3Rpb24gYGZuYCB3aGVuIHRoZSBtYXAgZ2V0cyBpbml0aWFsaXplZCB3aXRoXHJcblx0Ly8gYSB2aWV3IChjZW50ZXIgYW5kIHpvb20pIGFuZCBhdCBsZWFzdCBvbmUgbGF5ZXIsIG9yIGltbWVkaWF0ZWx5XHJcblx0Ly8gaWYgaXQncyBhbHJlYWR5IGluaXRpYWxpemVkLCBvcHRpb25hbGx5IHBhc3NpbmcgYSBmdW5jdGlvbiBjb250ZXh0LlxyXG5cdHdoZW5SZWFkeTogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdGNhbGxiYWNrLmNhbGwoY29udGV4dCB8fCB0aGlzLCB7dGFyZ2V0OiB0aGlzfSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm9uKCdsb2FkJywgY2FsbGJhY2ssIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIHByaXZhdGUgbWV0aG9kcyBmb3IgZ2V0dGluZyBtYXAgc3RhdGVcclxuXHJcblx0X2dldE1hcFBhbmVQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBEb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUpIHx8IG5ldyBQb2ludCgwLCAwKTtcclxuXHR9LFxyXG5cclxuXHRfbW92ZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcblx0XHRyZXR1cm4gcG9zICYmICFwb3MuZXF1YWxzKFswLCAwXSk7XHJcblx0fSxcclxuXHJcblx0X2dldFRvcExlZnRQb2ludDogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHBpeGVsT3JpZ2luID0gY2VudGVyICYmIHpvb20gIT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkgOlxyXG5cdFx0XHR0aGlzLmdldFBpeGVsT3JpZ2luKCk7XHJcblx0XHRyZXR1cm4gcGl4ZWxPcmlnaW4uc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0TmV3UGl4ZWxPcmlnaW46IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKS5fc3VidHJhY3Qodmlld0hhbGYpLl9hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKS5fcm91bmQoKTtcclxuXHR9LFxyXG5cclxuXHRfbGF0TG5nVG9OZXdMYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBjZW50ZXIpIHtcclxuXHRcdHZhciB0b3BMZWZ0ID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKTtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3QobGF0bG5nLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCk7XHJcblx0fSxcclxuXHJcblx0X2xhdExuZ0JvdW5kc1RvTmV3TGF5ZXJCb3VuZHM6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMsIHpvb20sIGNlbnRlcikge1xyXG5cdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pO1xyXG5cdFx0cmV0dXJuIHRvQm91bmRzKFtcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldE5vcnRoV2VzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpXHJcblx0XHRdKTtcclxuXHR9LFxyXG5cclxuXHQvLyBsYXllciBwb2ludCBvZiB0aGUgY3VycmVudCBjZW50ZXJcclxuXHRfZ2V0Q2VudGVyTGF5ZXJQb2ludDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBvZmZzZXQgb2YgdGhlIHNwZWNpZmllZCBwbGFjZSB0byB0aGUgY3VycmVudCBjZW50ZXIgaW4gcGl4ZWxzXHJcblx0X2dldENlbnRlck9mZnNldDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZykuc3VidHJhY3QodGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBhZGp1c3QgY2VudGVyIGZvciB2aWV3IHRvIGdldCBpbnNpZGUgYm91bmRzXHJcblx0X2xpbWl0Q2VudGVyOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBib3VuZHMpIHtcclxuXHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gY2VudGVyOyB9XHJcblxyXG5cdFx0dmFyIGNlbnRlclBvaW50ID0gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSksXHJcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcclxuXHRcdCAgICB2aWV3Qm91bmRzID0gbmV3IEJvdW5kcyhjZW50ZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZiksIGNlbnRlclBvaW50LmFkZCh2aWV3SGFsZikpLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldEJvdW5kc09mZnNldCh2aWV3Qm91bmRzLCBib3VuZHMsIHpvb20pO1xyXG5cclxuXHRcdC8vIElmIG9mZnNldCBpcyBsZXNzIHRoYW4gYSBwaXhlbCwgaWdub3JlLlxyXG5cdFx0Ly8gVGhpcyBwcmV2ZW50cyB1bnN0YWJsZSBwcm9qZWN0aW9ucyBmcm9tIGdldHRpbmcgaW50b1xyXG5cdFx0Ly8gYW4gaW5maW5pdGUgbG9vcCBvZiB0aW55IG9mZnNldHMuXHJcblx0XHRpZiAoTWF0aC5hYnMob2Zmc2V0LngpIDw9IDEgJiYgTWF0aC5hYnMob2Zmc2V0LnkpIDw9IDEpIHtcclxuXHRcdFx0cmV0dXJuIGNlbnRlcjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QoY2VudGVyUG9pbnQuYWRkKG9mZnNldCksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIGFkanVzdCBvZmZzZXQgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuXHRfbGltaXRPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQsIGJvdW5kcykge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIG9mZnNldDsgfVxyXG5cclxuXHRcdHZhciB2aWV3Qm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIG5ld0JvdW5kcyA9IG5ldyBCb3VuZHModmlld0JvdW5kcy5taW4uYWRkKG9mZnNldCksIHZpZXdCb3VuZHMubWF4LmFkZChvZmZzZXQpKTtcclxuXHJcblx0XHRyZXR1cm4gb2Zmc2V0LmFkZCh0aGlzLl9nZXRCb3VuZHNPZmZzZXQobmV3Qm91bmRzLCBib3VuZHMpKTtcclxuXHR9LFxyXG5cclxuXHQvLyByZXR1cm5zIG9mZnNldCBuZWVkZWQgZm9yIHB4Qm91bmRzIHRvIGdldCBpbnNpZGUgbWF4Qm91bmRzIGF0IGEgc3BlY2lmaWVkIHpvb21cclxuXHRfZ2V0Qm91bmRzT2Zmc2V0OiBmdW5jdGlvbiAocHhCb3VuZHMsIG1heEJvdW5kcywgem9vbSkge1xyXG5cdFx0dmFyIHByb2plY3RlZE1heEJvdW5kcyA9IHRvQm91bmRzKFxyXG5cdFx0ICAgICAgICB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKSxcclxuXHRcdCAgICAgICAgdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSlcclxuXHRcdCAgICApLFxyXG5cdFx0ICAgIG1pbk9mZnNldCA9IHByb2plY3RlZE1heEJvdW5kcy5taW4uc3VidHJhY3QocHhCb3VuZHMubWluKSxcclxuXHRcdCAgICBtYXhPZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWF4LnN1YnRyYWN0KHB4Qm91bmRzLm1heCksXHJcblxyXG5cdFx0ICAgIGR4ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueCwgLW1heE9mZnNldC54KSxcclxuXHRcdCAgICBkeSA9IHRoaXMuX3JlYm91bmQobWluT2Zmc2V0LnksIC1tYXhPZmZzZXQueSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChkeCwgZHkpO1xyXG5cdH0sXHJcblxyXG5cdF9yZWJvdW5kOiBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcclxuXHRcdHJldHVybiBsZWZ0ICsgcmlnaHQgPiAwID9cclxuXHRcdFx0TWF0aC5yb3VuZChsZWZ0IC0gcmlnaHQpIC8gMiA6XHJcblx0XHRcdE1hdGgubWF4KDAsIE1hdGguY2VpbChsZWZ0KSkgLSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHJpZ2h0KSk7XHJcblx0fSxcclxuXHJcblx0X2xpbWl0Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHZhciBtaW4gPSB0aGlzLmdldE1pblpvb20oKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuXHRcdCAgICBzbmFwID0gQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDE7XHJcblx0XHRpZiAoc25hcCkge1xyXG5cdFx0XHR6b29tID0gTWF0aC5yb3VuZCh6b29tIC8gc25hcCkgKiBzbmFwO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB6b29tKSk7XHJcblx0fSxcclxuXHJcblx0X29uUGFuVHJhbnNpdGlvblN0ZXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cdH0sXHJcblxyXG5cdF9vblBhblRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcclxuXHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdH0sXHJcblxyXG5cdF90cnlBbmltYXRlZFBhbjogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykge1xyXG5cdFx0Ly8gZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBuZXcgYW5kIGN1cnJlbnQgY2VudGVycyBpbiBwaXhlbHNcclxuXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fdHJ1bmMoKTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIHRvbyBmYXIgdW5sZXNzIGFuaW1hdGU6IHRydWUgc3BlY2lmaWVkIGluIG9wdGlvbnNcclxuXHRcdGlmICgob3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGUpICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdHRoaXMucGFuQnkob2Zmc2V0LCBvcHRpb25zKTtcclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlQW5pbVByb3h5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHByb3h5ID0gdGhpcy5fcHJveHkgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtcHJveHkgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcblx0XHR0aGlzLl9wYW5lcy5tYXBQYW5lLmFwcGVuZENoaWxkKHByb3h5KTtcclxuXHJcblx0XHR0aGlzLm9uKCd6b29tYW5pbScsIGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdHZhciBwcm9wID0gRG9tVXRpbC5UUkFOU0ZPUk0sXHJcblx0XHRcdCAgICB0cmFuc2Zvcm0gPSB0aGlzLl9wcm94eS5zdHlsZVtwcm9wXTtcclxuXHJcblx0XHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX3Byb3h5LCB0aGlzLnByb2plY3QoZS5jZW50ZXIsIGUuem9vbSksIHRoaXMuZ2V0Wm9vbVNjYWxlKGUuem9vbSwgMSkpO1xyXG5cclxuXHRcdFx0Ly8gd29ya2Fyb3VuZCBmb3IgY2FzZSB3aGVuIHRyYW5zZm9ybSBpcyB0aGUgc2FtZSBhbmQgc28gdHJhbnNpdGlvbmVuZCBldmVudCBpcyBub3QgZmlyZWRcclxuXHRcdFx0aWYgKHRyYW5zZm9ybSA9PT0gdGhpcy5fcHJveHkuc3R5bGVbcHJvcF0gJiYgdGhpcy5fYW5pbWF0aW5nWm9vbSkge1xyXG5cdFx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5vbignbG9hZCBtb3ZlZW5kJywgdGhpcy5fYW5pbU1vdmVFbmQsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX29uKCd1bmxvYWQnLCB0aGlzLl9kZXN0cm95QW5pbVByb3h5LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfZGVzdHJveUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fcHJveHkpO1xyXG5cdFx0dGhpcy5vZmYoJ2xvYWQgbW92ZWVuZCcsIHRoaXMuX2FuaW1Nb3ZlRW5kLCB0aGlzKTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9wcm94eTtcclxuXHR9LFxyXG5cclxuXHRfYW5pbU1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICB6ID0gdGhpcy5nZXRab29tKCk7XHJcblx0XHREb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9wcm94eSwgdGhpcy5wcm9qZWN0KGMsIHopLCB0aGlzLmdldFpvb21TY2FsZSh6LCAxKSk7XHJcblx0fSxcclxuXHJcblx0X2NhdGNoVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tICYmIGUucHJvcGVydHlOYW1lLmluZGV4T2YoJ3RyYW5zZm9ybScpID49IDApIHtcclxuXHRcdFx0dGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9ub3RoaW5nVG9BbmltYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gIXRoaXMuX2NvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKS5sZW5ndGg7XHJcblx0fSxcclxuXHJcblx0X3RyeUFuaW1hdGVkWm9vbTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBpZiBkaXNhYmxlZCwgbm90IHN1cHBvcnRlZCBvciB6b29tIGRpZmZlcmVuY2UgaXMgdG9vIGxhcmdlXHJcblx0XHRpZiAoIXRoaXMuX3pvb21BbmltYXRlZCB8fCBvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlIHx8IHRoaXMuX25vdGhpbmdUb0FuaW1hdGUoKSB8fFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh6b29tIC0gdGhpcy5fem9vbSkgPiB0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvblRocmVzaG9sZCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHQvLyBvZmZzZXQgaXMgdGhlIHBpeGVsIGNvb3JkcyBvZiB0aGUgem9vbSBvcmlnaW4gcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgY2VudGVyXHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fZGl2aWRlQnkoMSAtIDEgLyBzY2FsZSk7XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBpZiB0aGUgem9vbSBvcmlnaW4gaXNuJ3Qgd2l0aGluIG9uZSBzY3JlZW4gZnJvbSB0aGUgY3VycmVudCBjZW50ZXIsIHVubGVzcyBmb3JjZWRcclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpc1xyXG5cdFx0XHQgICAgLl9tb3ZlU3RhcnQodHJ1ZSwgb3B0aW9ucy5ub01vdmVTdGFydCB8fCBmYWxzZSlcclxuXHRcdFx0ICAgIC5fYW5pbWF0ZVpvb20oY2VudGVyLCB6b29tLCB0cnVlKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgc3RhcnRBbmltLCBub1VwZGF0ZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXBQYW5lKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChzdGFydEFuaW0pIHtcclxuXHRcdFx0dGhpcy5fYW5pbWF0aW5nWm9vbSA9IHRydWU7XHJcblxyXG5cdFx0XHQvLyByZW1lbWJlciB3aGF0IGNlbnRlci96b29tIHRvIHNldCBhZnRlciBhbmltYXRpb25cclxuXHRcdFx0dGhpcy5fYW5pbWF0ZVRvQ2VudGVyID0gY2VudGVyO1xyXG5cdFx0XHR0aGlzLl9hbmltYXRlVG9ab29tID0gem9vbTtcclxuXHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtem9vbS1hbmltJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gT3RoZXIgRXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgem9vbWFuaW06IFpvb21BbmltRXZlbnRcclxuXHRcdC8vIEZpcmVkIGF0IGxlYXN0IG9uY2UgcGVyIHpvb20gYW5pbWF0aW9uLiBGb3IgY29udGludW91cyB6b29tLCBsaWtlIHBpbmNoIHpvb21pbmcsIGZpcmVkIG9uY2UgcGVyIGZyYW1lIGR1cmluZyB6b29tLlxyXG5cdFx0dGhpcy5maXJlKCd6b29tYW5pbScsIHtcclxuXHRcdFx0Y2VudGVyOiBjZW50ZXIsXHJcblx0XHRcdHpvb206IHpvb20sXHJcblx0XHRcdG5vVXBkYXRlOiBub1VwZGF0ZVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl90ZW1wRmlyZVpvb21FdmVudCkge1xyXG5cdFx0XHR0aGlzLl90ZW1wRmlyZVpvb21FdmVudCA9IHRoaXMuX3pvb20gIT09IHRoaXMuX2FuaW1hdGVUb1pvb207XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbW92ZSh0aGlzLl9hbmltYXRlVG9DZW50ZXIsIHRoaXMuX2FuaW1hdGVUb1pvb20sIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcblxyXG5cdFx0Ly8gV29yayBhcm91bmQgd2Via2l0IG5vdCBmaXJpbmcgJ3RyYW5zaXRpb25lbmQnLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMzY4OSwgMjY5M1xyXG5cdFx0c2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCwgdGhpcyksIDI1MCk7XHJcblx0fSxcclxuXHJcblx0X29uWm9vbVRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAodGhpcy5fbWFwUGFuZSkge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXpvb20tYW5pbScpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLl9tb3ZlKHRoaXMuX2FuaW1hdGVUb0NlbnRlciwgdGhpcy5fYW5pbWF0ZVRvWm9vbSwgdW5kZWZpbmVkLCB0cnVlKTtcclxuXHJcblx0XHRpZiAodGhpcy5fdGVtcEZpcmVab29tRXZlbnQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tJyk7XHJcblx0XHR9XHJcblx0XHRkZWxldGUgdGhpcy5fdGVtcEZpcmVab29tRXZlbnQ7XHJcblxyXG5cdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblxyXG5cdFx0dGhpcy5fbW92ZUVuZCh0cnVlKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQHNlY3Rpb25cclxuXHJcbi8vIEBmYWN0b3J5IEwubWFwKGlkOiBTdHJpbmcsIG9wdGlvbnM/OiBNYXAgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgbWFwIG9iamVjdCBnaXZlbiB0aGUgRE9NIElEIG9mIGEgYDxkaXY+YCBlbGVtZW50XHJcbi8vIGFuZCBvcHRpb25hbGx5IGFuIG9iamVjdCBsaXRlcmFsIHdpdGggYE1hcCBvcHRpb25zYC5cclxuLy9cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubWFwKGVsOiBIVE1MRWxlbWVudCwgb3B0aW9ucz86IE1hcCBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIGFuIGluc3RhbmNlIG9mIGEgYDxkaXY+YCBIVE1MIGVsZW1lbnRcclxuLy8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWFwKGlkLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBNYXAoaWQsIG9wdGlvbnMpO1xyXG59XHJcbiIsIlxyXG5pbXBvcnQge0NsYXNzfSBmcm9tICcuLi9jb3JlL0NsYXNzJztcclxuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIENvbnRyb2xcclxuICogQGFrYSBMLkNvbnRyb2xcclxuICogQGluaGVyaXRzIENsYXNzXHJcbiAqXHJcbiAqIEwuQ29udHJvbCBpcyBhIGJhc2UgY2xhc3MgZm9yIGltcGxlbWVudGluZyBtYXAgY29udHJvbHMuIEhhbmRsZXMgcG9zaXRpb25pbmcuXHJcbiAqIEFsbCBvdGhlciBjb250cm9scyBleHRlbmQgZnJvbSB0aGlzIGNsYXNzLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgQ29udHJvbCA9IENsYXNzLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wgT3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gcG9zaXRpb246IFN0cmluZyA9ICd0b3ByaWdodCdcclxuXHRcdC8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCAob25lIG9mIHRoZSBtYXAgY29ybmVycykuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYCd0b3BsZWZ0J2AsXHJcblx0XHQvLyBgJ3RvcHJpZ2h0J2AsIGAnYm90dG9tbGVmdCdgIG9yIGAnYm90dG9tcmlnaHQnYFxyXG5cdFx0cG9zaXRpb246ICd0b3ByaWdodCdcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQ2xhc3NlcyBleHRlbmRpbmcgTC5Db250cm9sIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGdldFBvc2l0aW9uOiBzdHJpbmdcclxuXHQgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC5cclxuXHQgKi9cclxuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFBvc2l0aW9uKHBvc2l0aW9uOiBzdHJpbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuXHJcblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uIChwb3NpdGlvbikge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcclxuXHJcblx0XHRpZiAobWFwKSB7XHJcblx0XHRcdG1hcC5yZW1vdmVDb250cm9sKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG5cclxuXHRcdGlmIChtYXApIHtcclxuXHRcdFx0bWFwLmFkZENvbnRyb2wodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgSFRNTEVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgY29udHJvbC5cclxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRUbyhtYXA6IE1hcCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBjb250cm9sIHRvIHRoZSBnaXZlbiBtYXAuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMucmVtb3ZlKCk7XHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IHRoaXMub25BZGQobWFwKSxcclxuXHRcdCAgICBwb3MgPSB0aGlzLmdldFBvc2l0aW9uKCksXHJcblx0XHQgICAgY29ybmVyID0gbWFwLl9jb250cm9sQ29ybmVyc1twb3NdO1xyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sJyk7XHJcblxyXG5cdFx0aWYgKHBvcy5pbmRleE9mKCdib3R0b20nKSAhPT0gLTEpIHtcclxuXHRcdFx0Y29ybmVyLmluc2VydEJlZm9yZShjb250YWluZXIsIGNvcm5lci5maXJzdENoaWxkKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvcm5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21hcC5vbigndW5sb2FkJywgdGhpcy5yZW1vdmUsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgY29udHJvbCBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cclxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0aWYgKHRoaXMub25SZW1vdmUpIHtcclxuXHRcdFx0dGhpcy5vblJlbW92ZSh0aGlzLl9tYXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21hcC5vZmYoJ3VubG9hZCcsIHRoaXMucmVtb3ZlLCB0aGlzKTtcclxuXHRcdHRoaXMuX21hcCA9IG51bGw7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3JlZm9jdXNPbk1hcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIGlmIG1hcCBleGlzdHMgYW5kIGV2ZW50IGlzIG5vdCBhIGtleWJvYXJkIGV2ZW50XHJcblx0XHRpZiAodGhpcy5fbWFwICYmIGUgJiYgZS5zY3JlZW5YID4gMCAmJiBlLnNjcmVlblkgPiAwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5nZXRDb250YWluZXIoKS5mb2N1cygpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5leHBvcnQgdmFyIGNvbnRyb2wgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgQ29udHJvbChvcHRpb25zKTtcclxufTtcclxuXHJcbi8qIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXHJcbiAqIEB1bmluaGVyaXRhYmxlXHJcbiAqXHJcbiAqIEV2ZXJ5IGNvbnRyb2wgc2hvdWxkIGV4dGVuZCBmcm9tIGBMLkNvbnRyb2xgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXHJcbiAqXHJcbiAqIEBtZXRob2Qgb25BZGQobWFwOiBNYXApOiBIVE1MRWxlbWVudFxyXG4gKiBTaG91bGQgcmV0dXJuIHRoZSBjb250YWluZXIgRE9NIGVsZW1lbnQgZm9yIHRoZSBjb250cm9sIGFuZCBhZGQgbGlzdGVuZXJzIG9uIHJlbGV2YW50IG1hcCBldmVudHMuIENhbGxlZCBvbiBbYGNvbnRyb2wuYWRkVG8obWFwKWBdKCNjb250cm9sLWFkZFRvKS5cclxuICpcclxuICogQG1ldGhvZCBvblJlbW92ZShtYXA6IE1hcClcclxuICogT3B0aW9uYWwgbWV0aG9kLiBTaG91bGQgY29udGFpbiBhbGwgY2xlYW4gdXAgY29kZSB0aGF0IHJlbW92ZXMgdGhlIGxpc3RlbmVycyBwcmV2aW91c2x5IGFkZGVkIGluIFtgb25BZGRgXSgjY29udHJvbC1vbmFkZCkuIENhbGxlZCBvbiBbYGNvbnRyb2wucmVtb3ZlKClgXSgjY29udHJvbC1yZW1vdmUpLlxyXG4gKi9cclxuXHJcbi8qIEBuYW1lc3BhY2UgTWFwXHJcbiAqIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuICovXHJcbk1hcC5pbmNsdWRlKHtcclxuXHQvLyBAbWV0aG9kIGFkZENvbnRyb2woY29udHJvbDogQ29udHJvbCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBnaXZlbiBjb250cm9sIHRvIHRoZSBtYXBcclxuXHRhZGRDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG5cdFx0Y29udHJvbC5hZGRUbyh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGNvbnRyb2wgZnJvbSB0aGUgbWFwXHJcblx0cmVtb3ZlQ29udHJvbDogZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuXHRcdGNvbnRyb2wucmVtb3ZlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdENvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb3JuZXJzID0gdGhpcy5fY29udHJvbENvcm5lcnMgPSB7fSxcclxuXHRcdCAgICBsID0gJ2xlYWZsZXQtJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250cm9sQ29udGFpbmVyID1cclxuXHRcdCAgICAgICAgICAgIERvbVV0aWwuY3JlYXRlKCdkaXYnLCBsICsgJ2NvbnRyb2wtY29udGFpbmVyJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRmdW5jdGlvbiBjcmVhdGVDb3JuZXIodlNpZGUsIGhTaWRlKSB7XHJcblx0XHRcdHZhciBjbGFzc05hbWUgPSBsICsgdlNpZGUgKyAnICcgKyBsICsgaFNpZGU7XHJcblxyXG5cdFx0XHRjb3JuZXJzW3ZTaWRlICsgaFNpZGVdID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRjcmVhdGVDb3JuZXIoJ3RvcCcsICdsZWZ0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ3RvcCcsICdyaWdodCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCdib3R0b20nLCAnbGVmdCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCdib3R0b20nLCAncmlnaHQnKTtcclxuXHR9LFxyXG5cclxuXHRfY2xlYXJDb250cm9sUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2NvbnRyb2xDb3JuZXJzKSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRyb2xDb3JuZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRyb2xDb250YWluZXIpO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRyb2xDb3JuZXJzO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRyb2xDb250YWluZXI7XHJcblx0fVxyXG59KTtcclxuIiwiXHJcbmltcG9ydCB7Q29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLkxheWVyc1xyXG4gKiBAYWthIEwuQ29udHJvbC5MYXllcnNcclxuICogQGluaGVyaXRzIENvbnRyb2xcclxuICpcclxuICogVGhlIGxheWVycyBjb250cm9sIGdpdmVzIHVzZXJzIHRoZSBhYmlsaXR5IHRvIHN3aXRjaCBiZXR3ZWVuIGRpZmZlcmVudCBiYXNlIGxheWVycyBhbmQgc3dpdGNoIG92ZXJsYXlzIG9uL29mZiAoY2hlY2sgb3V0IHRoZSBbZGV0YWlsZWQgZXhhbXBsZV0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL2V4YW1wbGVzL2xheWVycy1jb250cm9sLykpLiBFeHRlbmRzIGBDb250cm9sYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGJhc2VMYXllcnMgPSB7XHJcbiAqIFx0XCJNYXBib3hcIjogbWFwYm94LFxyXG4gKiBcdFwiT3BlblN0cmVldE1hcFwiOiBvc21cclxuICogfTtcclxuICpcclxuICogdmFyIG92ZXJsYXlzID0ge1xyXG4gKiBcdFwiTWFya2VyXCI6IG1hcmtlcixcclxuICogXHRcIlJvYWRzXCI6IHJvYWRzTGF5ZXJcclxuICogfTtcclxuICpcclxuICogTC5jb250cm9sLmxheWVycyhiYXNlTGF5ZXJzLCBvdmVybGF5cykuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFRoZSBgYmFzZUxheWVyc2AgYW5kIGBvdmVybGF5c2AgcGFyYW1ldGVycyBhcmUgb2JqZWN0IGxpdGVyYWxzIHdpdGggbGF5ZXIgbmFtZXMgYXMga2V5cyBhbmQgYExheWVyYCBvYmplY3RzIGFzIHZhbHVlczpcclxuICpcclxuICogYGBganNcclxuICoge1xyXG4gKiAgICAgXCI8c29tZU5hbWUxPlwiOiBsYXllcjEsXHJcbiAqICAgICBcIjxzb21lTmFtZTI+XCI6IGxheWVyMlxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgbGF5ZXIgbmFtZXMgY2FuIGNvbnRhaW4gSFRNTCwgd2hpY2ggYWxsb3dzIHlvdSB0byBhZGQgYWRkaXRpb25hbCBzdHlsaW5nIHRvIHRoZSBpdGVtczpcclxuICpcclxuICogYGBganNcclxuICoge1wiPGltZyBzcmM9J215LWxheWVyLWljb24nIC8+IDxzcGFuIGNsYXNzPSdteS1sYXllci1pdGVtJz5NeSBMYXllcjwvc3Bhbj5cIjogbXlMYXllcn1cclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBMYXllcnMgPSBDb250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuTGF5ZXJzIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGNvbGxhcHNlZDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgd2lsbCBiZSBjb2xsYXBzZWQgaW50byBhbiBpY29uIGFuZCBleHBhbmRlZCBvbiBtb3VzZSBob3ZlciwgdG91Y2gsIG9yIGtleWJvYXJkIGFjdGl2YXRpb24uXHJcblx0XHRjb2xsYXBzZWQ6IHRydWUsXHJcblx0XHRwb3NpdGlvbjogJ3RvcHJpZ2h0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9aSW5kZXg6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIHdpbGwgYXNzaWduIHpJbmRleGVzIGluIGluY3JlYXNpbmcgb3JkZXIgdG8gYWxsIG9mIGl0cyBsYXllcnMgc28gdGhhdCB0aGUgb3JkZXIgaXMgcHJlc2VydmVkIHdoZW4gc3dpdGNoaW5nIHRoZW0gb24vb2ZmLlxyXG5cdFx0YXV0b1pJbmRleDogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGhpZGVTaW5nbGVCYXNlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGJhc2UgbGF5ZXJzIGluIHRoZSBjb250cm9sIHdpbGwgYmUgaGlkZGVuIHdoZW4gdGhlcmUgaXMgb25seSBvbmUuXHJcblx0XHRoaWRlU2luZ2xlQmFzZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzb3J0TGF5ZXJzOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdG8gc29ydCB0aGUgbGF5ZXJzLiBXaGVuIGBmYWxzZWAsIGxheWVycyB3aWxsIGtlZXAgdGhlIG9yZGVyXHJcblx0XHQvLyBpbiB3aGljaCB0aGV5IHdlcmUgYWRkZWQgdG8gdGhlIGNvbnRyb2wuXHJcblx0XHRzb3J0TGF5ZXJzOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHNvcnRGdW5jdGlvbjogRnVuY3Rpb24gPSAqXHJcblx0XHQvLyBBIFtjb21wYXJlIGZ1bmN0aW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0KVxyXG5cdFx0Ly8gdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHNvcnRpbmcgdGhlIGxheWVycywgd2hlbiBgc29ydExheWVyc2AgaXMgYHRydWVgLlxyXG5cdFx0Ly8gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIGJvdGggdGhlIGBMLkxheWVyYCBpbnN0YW5jZXMgYW5kIHRoZWlyIG5hbWVzLCBhcyBpblxyXG5cdFx0Ly8gYHNvcnRGdW5jdGlvbihsYXllckEsIGxheWVyQiwgbmFtZUEsIG5hbWVCKWAuXHJcblx0XHQvLyBCeSBkZWZhdWx0LCBpdCBzb3J0cyBsYXllcnMgYWxwaGFiZXRpY2FsbHkgYnkgdGhlaXIgbmFtZS5cclxuXHRcdHNvcnRGdW5jdGlvbjogZnVuY3Rpb24gKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpIHtcclxuXHRcdFx0cmV0dXJuIG5hbWVBIDwgbmFtZUIgPyAtMSA6IChuYW1lQiA8IG5hbWVBID8gMSA6IDApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cyA9IFtdO1xyXG5cdFx0dGhpcy5fbGF5ZXJzID0gW107XHJcblx0XHR0aGlzLl9sYXN0WkluZGV4ID0gMDtcclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHRcdHRoaXMuX3ByZXZlbnRDbGljayA9IGZhbHNlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gYmFzZUxheWVycykge1xyXG5cdFx0XHR0aGlzLl9hZGRMYXllcihiYXNlTGF5ZXJzW2ldLCBpKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgaW4gb3ZlcmxheXMpIHtcclxuXHRcdFx0dGhpcy5fYWRkTGF5ZXIob3ZlcmxheXNbaV0sIGksIHRydWUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzLCB0aGlzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ubGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRDb250cm9sLnByb3RvdHlwZS5hZGRUby5jYWxsKHRoaXMsIG1hcCk7XHJcblx0XHQvLyBUcmlnZ2VyIGV4cGFuZCBhZnRlciBMYXllcnMgQ29udHJvbCBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIERPTSBzbyB0aGF0IGlzIG5vdyBoYXMgYW4gYWN0dWFsIGhlaWdodC5cclxuXHRcdHJldHVybiB0aGlzLl9leHBhbmRJZk5vdENvbGxhcHNlZCgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9tYXAub2ZmKCd6b29tZW5kJywgdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycywgdGhpcyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLmxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkQmFzZUxheWVyKGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYSBiYXNlIGxheWVyIChyYWRpbyBidXR0b24gZW50cnkpIHdpdGggdGhlIGdpdmVuIG5hbWUgdG8gdGhlIGNvbnRyb2wuXHJcblx0YWRkQmFzZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUpIHtcclxuXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lKTtcclxuXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZE92ZXJsYXkobGF5ZXI6IExheWVyLCBuYW1lOiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBvdmVybGF5IChjaGVja2JveCBlbnRyeSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB0byB0aGUgY29udHJvbC5cclxuXHRhZGRPdmVybGF5OiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUpIHtcclxuXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lLCB0cnVlKTtcclxuXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuXHQvLyBSZW1vdmUgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIGNvbnRyb2wuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0bGF5ZXIub2ZmKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblxyXG5cdFx0dmFyIG9iaiA9IHRoaXMuX2dldExheWVyKFV0aWwuc3RhbXAobGF5ZXIpKTtcclxuXHRcdGlmIChvYmopIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzLnNwbGljZSh0aGlzLl9sYXllcnMuaW5kZXhPZihvYmopLCAxKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGV4cGFuZCgpOiB0aGlzXHJcblx0Ly8gRXhwYW5kIHRoZSBjb250cm9sIGNvbnRhaW5lciBpZiBjb2xsYXBzZWQuXHJcblx0ZXhwYW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnKTtcclxuXHRcdHRoaXMuX3NlY3Rpb24uc3R5bGUuaGVpZ2h0ID0gbnVsbDtcclxuXHRcdHZhciBhY2NlcHRhYmxlSGVpZ2h0ID0gdGhpcy5fbWFwLmdldFNpemUoKS55IC0gKHRoaXMuX2NvbnRhaW5lci5vZmZzZXRUb3AgKyA1MCk7XHJcblx0XHRpZiAoYWNjZXB0YWJsZUhlaWdodCA8IHRoaXMuX3NlY3Rpb24uY2xpZW50SGVpZ2h0KSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fc2VjdGlvbiwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyJyk7XHJcblx0XHRcdHRoaXMuX3NlY3Rpb24uc3R5bGUuaGVpZ2h0ID0gYWNjZXB0YWJsZUhlaWdodCArICdweCc7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3NlY3Rpb24sICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhcicpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb2xsYXBzZSgpOiB0aGlzXHJcblx0Ly8gQ29sbGFwc2UgdGhlIGNvbnRyb2wgY29udGFpbmVyIGlmIGV4cGFuZGVkLlxyXG5cdGNvbGxhcHNlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMnLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpLFxyXG5cdFx0ICAgIGNvbGxhcHNlZCA9IHRoaXMub3B0aW9ucy5jb2xsYXBzZWQ7XHJcblxyXG5cdFx0Ly8gbWFrZXMgdGhpcyB3b3JrIG9uIElFIHRvdWNoIGRldmljZXMgYnkgc3RvcHBpbmcgaXQgZnJvbSBmaXJpbmcgYSBtb3VzZW91dCBldmVudCB3aGVuIHRoZSB0b3VjaCBpcyByZWxlYXNlZFxyXG5cdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnYXJpYS1oYXNwb3B1cCcsIHRydWUpO1xyXG5cclxuXHRcdERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblx0XHREb21FdmVudC5kaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHJcblx0XHR2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb24gPSBEb21VdGlsLmNyZWF0ZSgnc2VjdGlvbicsIGNsYXNzTmFtZSArICctbGlzdCcpO1xyXG5cclxuXHRcdGlmIChjb2xsYXBzZWQpIHtcclxuXHRcdFx0dGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuY29sbGFwc2UsIHRoaXMpO1xyXG5cclxuXHRcdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCB7XHJcblx0XHRcdFx0bW91c2VlbnRlcjogdGhpcy5fZXhwYW5kU2FmZWx5LFxyXG5cdFx0XHRcdG1vdXNlbGVhdmU6IHRoaXMuY29sbGFwc2VcclxuXHRcdFx0fSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGxpbmsgPSB0aGlzLl9sYXllcnNMaW5rID0gRG9tVXRpbC5jcmVhdGUoJ2EnLCBjbGFzc05hbWUgKyAnLXRvZ2dsZScsIGNvbnRhaW5lcik7XHJcblx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcblx0XHRsaW5rLnRpdGxlID0gJ0xheWVycyc7XHJcblx0XHRsaW5rLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcclxuXHJcblx0XHREb21FdmVudC5vbihsaW5rLCB7XHJcblx0XHRcdGtleWRvd246IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0aWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcclxuXHRcdFx0XHRcdHRoaXMuX2V4cGFuZFNhZmVseSgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0Ly8gQ2VydGFpbiBzY3JlZW4gcmVhZGVycyBpbnRlcmNlcHQgdGhlIGtleSBldmVudCBhbmQgaW5zdGVhZCBzZW5kIGEgY2xpY2sgZXZlbnRcclxuXHRcdFx0Y2xpY2s6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XHJcblx0XHRcdFx0dGhpcy5fZXhwYW5kU2FmZWx5KCk7XHJcblx0XHRcdH1cclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdGlmICghY29sbGFwc2VkKSB7XHJcblx0XHRcdHRoaXMuZXhwYW5kKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYmFzZUxheWVyc0xpc3QgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1iYXNlJywgc2VjdGlvbik7XHJcblx0XHR0aGlzLl9zZXBhcmF0b3IgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1zZXBhcmF0b3InLCBzZWN0aW9uKTtcclxuXHRcdHRoaXMuX292ZXJsYXlzTGlzdCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLW92ZXJsYXlzJywgc2VjdGlvbik7XHJcblxyXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHNlY3Rpb24pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuX2xheWVyc1tpXSAmJiBVdGlsLnN0YW1wKHRoaXMuX2xheWVyc1tpXS5sYXllcikgPT09IGlkKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2xheWVyc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9hZGRMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lLCBvdmVybGF5KSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdGxheWVyLm9uKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzLnB1c2goe1xyXG5cdFx0XHRsYXllcjogbGF5ZXIsXHJcblx0XHRcdG5hbWU6IG5hbWUsXHJcblx0XHRcdG92ZXJsYXk6IG92ZXJsYXlcclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuc29ydExheWVycykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnMuc29ydChVdGlsLmJpbmQoZnVuY3Rpb24gKGEsIGIpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnNvcnRGdW5jdGlvbihhLmxheWVyLCBiLmxheWVyLCBhLm5hbWUsIGIubmFtZSk7XHJcblx0XHRcdH0sIHRoaXMpKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmF1dG9aSW5kZXggJiYgbGF5ZXIuc2V0WkluZGV4KSB7XHJcblx0XHRcdHRoaXMuX2xhc3RaSW5kZXgrKztcclxuXHRcdFx0bGF5ZXIuc2V0WkluZGV4KHRoaXMuX2xhc3RaSW5kZXgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2V4cGFuZElmTm90Q29sbGFwc2VkKCk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHREb21VdGlsLmVtcHR5KHRoaXMuX2Jhc2VMYXllcnNMaXN0KTtcclxuXHRcdERvbVV0aWwuZW1wdHkodGhpcy5fb3ZlcmxheXNMaXN0KTtcclxuXHJcblx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMgPSBbXTtcclxuXHRcdHZhciBiYXNlTGF5ZXJzUHJlc2VudCwgb3ZlcmxheXNQcmVzZW50LCBpLCBvYmosIGJhc2VMYXllcnNDb3VudCA9IDA7XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRvYmogPSB0aGlzLl9sYXllcnNbaV07XHJcblx0XHRcdHRoaXMuX2FkZEl0ZW0ob2JqKTtcclxuXHRcdFx0b3ZlcmxheXNQcmVzZW50ID0gb3ZlcmxheXNQcmVzZW50IHx8IG9iai5vdmVybGF5O1xyXG5cdFx0XHRiYXNlTGF5ZXJzUHJlc2VudCA9IGJhc2VMYXllcnNQcmVzZW50IHx8ICFvYmoub3ZlcmxheTtcclxuXHRcdFx0YmFzZUxheWVyc0NvdW50ICs9ICFvYmoub3ZlcmxheSA/IDEgOiAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEhpZGUgYmFzZSBsYXllcnMgc2VjdGlvbiBpZiB0aGVyZSdzIG9ubHkgb25lIGxheWVyLlxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5oaWRlU2luZ2xlQmFzZSkge1xyXG5cdFx0XHRiYXNlTGF5ZXJzUHJlc2VudCA9IGJhc2VMYXllcnNQcmVzZW50ICYmIGJhc2VMYXllcnNDb3VudCA+IDE7XHJcblx0XHRcdHRoaXMuX2Jhc2VMYXllcnNMaXN0LnN0eWxlLmRpc3BsYXkgPSBiYXNlTGF5ZXJzUHJlc2VudCA/ICcnIDogJ25vbmUnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3NlcGFyYXRvci5zdHlsZS5kaXNwbGF5ID0gb3ZlcmxheXNQcmVzZW50ICYmIGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X29uTGF5ZXJDaGFuZ2U6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2hhbmRsaW5nQ2xpY2spIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9iaiA9IHRoaXMuX2dldExheWVyKFV0aWwuc3RhbXAoZS50YXJnZXQpKTtcclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gTGF5ZXIgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgYmFzZWxheWVyY2hhbmdlOiBMYXllcnNDb250cm9sRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGJhc2UgbGF5ZXIgaXMgY2hhbmdlZCB0aHJvdWdoIHRoZSBbbGF5ZXJzIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAZXZlbnQgb3ZlcmxheWFkZDogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVycyBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG5cdFx0Ly8gQGV2ZW50IG92ZXJsYXlyZW1vdmU6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhbiBvdmVybGF5IGlzIGRlc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVycyBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBDb250cm9sLkxheWVyc1xyXG5cdFx0dmFyIHR5cGUgPSBvYmoub3ZlcmxheSA/XHJcblx0XHRcdChlLnR5cGUgPT09ICdhZGQnID8gJ292ZXJsYXlhZGQnIDogJ292ZXJsYXlyZW1vdmUnKSA6XHJcblx0XHRcdChlLnR5cGUgPT09ICdhZGQnID8gJ2Jhc2VsYXllcmNoYW5nZScgOiBudWxsKTtcclxuXHJcblx0XHRpZiAodHlwZSkge1xyXG5cdFx0XHR0aGlzLl9tYXAuZmlyZSh0eXBlLCBvYmopO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIElFNyBidWdzIG91dCBpZiB5b3UgY3JlYXRlIGEgcmFkaW8gZHluYW1pY2FsbHksIHNvIHlvdSBoYXZlIHRvIGRvIGl0IHRoaXMgaGFja3kgd2F5IChzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzExOTA3OSlcclxuXHRfY3JlYXRlUmFkaW9FbGVtZW50OiBmdW5jdGlvbiAobmFtZSwgY2hlY2tlZCkge1xyXG5cclxuXHRcdHZhciByYWRpb0h0bWwgPSAnPGlucHV0IHR5cGU9XCJyYWRpb1wiIGNsYXNzPVwibGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3RvclwiIG5hbWU9XCInICtcclxuXHRcdFx0XHRuYW1lICsgJ1wiJyArIChjaGVja2VkID8gJyBjaGVja2VkPVwiY2hlY2tlZFwiJyA6ICcnKSArICcvPic7XHJcblxyXG5cdFx0dmFyIHJhZGlvRnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdHJhZGlvRnJhZ21lbnQuaW5uZXJIVE1MID0gcmFkaW9IdG1sO1xyXG5cclxuXHRcdHJldHVybiByYWRpb0ZyYWdtZW50LmZpcnN0Q2hpbGQ7XHJcblx0fSxcclxuXHJcblx0X2FkZEl0ZW06IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyksXHJcblx0XHQgICAgY2hlY2tlZCA9IHRoaXMuX21hcC5oYXNMYXllcihvYmoubGF5ZXIpLFxyXG5cdFx0ICAgIGlucHV0O1xyXG5cclxuXHRcdGlmIChvYmoub3ZlcmxheSkge1xyXG5cdFx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcblx0XHRcdGlucHV0LnR5cGUgPSAnY2hlY2tib3gnO1xyXG5cdFx0XHRpbnB1dC5jbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3Rvcic7XHJcblx0XHRcdGlucHV0LmRlZmF1bHRDaGVja2VkID0gY2hlY2tlZDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlucHV0ID0gdGhpcy5fY3JlYXRlUmFkaW9FbGVtZW50KCdsZWFmbGV0LWJhc2UtbGF5ZXJzXycgKyBVdGlsLnN0YW1wKHRoaXMpLCBjaGVja2VkKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMucHVzaChpbnB1dCk7XHJcblx0XHRpbnB1dC5sYXllcklkID0gVXRpbC5zdGFtcChvYmoubGF5ZXIpO1xyXG5cclxuXHRcdERvbUV2ZW50Lm9uKGlucHV0LCAnY2xpY2snLCB0aGlzLl9vbklucHV0Q2xpY2ssIHRoaXMpO1xyXG5cclxuXHRcdHZhciBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG5cdFx0bmFtZS5pbm5lckhUTUwgPSAnICcgKyBvYmoubmFtZTtcclxuXHJcblx0XHQvLyBIZWxwcyBmcm9tIHByZXZlbnRpbmcgbGF5ZXIgY29udHJvbCBmbGlja2VyIHdoZW4gY2hlY2tib3hlcyBhcmUgZGlzYWJsZWRcclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzI3NzFcclxuXHRcdHZhciBob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcblxyXG5cdFx0bGFiZWwuYXBwZW5kQ2hpbGQoaG9sZGVyKTtcclxuXHRcdGhvbGRlci5hcHBlbmRDaGlsZChpbnB1dCk7XHJcblx0XHRob2xkZXIuYXBwZW5kQ2hpbGQobmFtZSk7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lciA9IG9iai5vdmVybGF5ID8gdGhpcy5fb3ZlcmxheXNMaXN0IDogdGhpcy5fYmFzZUxheWVyc0xpc3Q7XHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xyXG5cclxuXHRcdHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKTtcclxuXHRcdHJldHVybiBsYWJlbDtcclxuXHR9LFxyXG5cclxuXHRfb25JbnB1dENsaWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBleHBhbmRpbmcgdGhlIGNvbnRyb2wgb24gbW9iaWxlIHdpdGggYSBjbGljayBjYW4gY2F1c2UgYWRkaW5nIGEgbGF5ZXIgLSB3ZSBkb24ndCB3YW50IHRoaXNcclxuXHRcdGlmICh0aGlzLl9wcmV2ZW50Q2xpY2spIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpbnB1dHMgPSB0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMsXHJcblx0XHQgICAgaW5wdXQsIGxheWVyO1xyXG5cdFx0dmFyIGFkZGVkTGF5ZXJzID0gW10sXHJcblx0XHQgICAgcmVtb3ZlZExheWVycyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSB0cnVlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSBpbnB1dHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aW5wdXQgPSBpbnB1dHNbaV07XHJcblx0XHRcdGxheWVyID0gdGhpcy5fZ2V0TGF5ZXIoaW5wdXQubGF5ZXJJZCkubGF5ZXI7XHJcblxyXG5cdFx0XHRpZiAoaW5wdXQuY2hlY2tlZCkge1xyXG5cdFx0XHRcdGFkZGVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCFpbnB1dC5jaGVja2VkKSB7XHJcblx0XHRcdFx0cmVtb3ZlZExheWVycy5wdXNoKGxheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEJ1Z2ZpeCBpc3N1ZSAyMzE4OiBTaG91bGQgcmVtb3ZlIGFsbCBvbGQgbGF5ZXJzIGJlZm9yZSByZWFkZGluZyBuZXcgb25lc1xyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHJlbW92ZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKHRoaXMuX21hcC5oYXNMYXllcihyZW1vdmVkTGF5ZXJzW2ldKSkge1xyXG5cdFx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcihyZW1vdmVkTGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGFkZGVkTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmICghdGhpcy5fbWFwLmhhc0xheWVyKGFkZGVkTGF5ZXJzW2ldKSkge1xyXG5cdFx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihhZGRlZExheWVyc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5fcmVmb2N1c09uTWFwKCk7XHJcblx0fSxcclxuXHJcblx0X2NoZWNrRGlzYWJsZWRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbnB1dHMgPSB0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMsXHJcblx0XHQgICAgaW5wdXQsXHJcblx0XHQgICAgbGF5ZXIsXHJcblx0XHQgICAgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpbnB1dCA9IGlucHV0c1tpXTtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9nZXRMYXllcihpbnB1dC5sYXllcklkKS5sYXllcjtcclxuXHRcdFx0aW5wdXQuZGlzYWJsZWQgPSAobGF5ZXIub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgem9vbSA8IGxheWVyLm9wdGlvbnMubWluWm9vbSkgfHxcclxuXHRcdFx0ICAgICAgICAgICAgICAgICAobGF5ZXIub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgem9vbSA+IGxheWVyLm9wdGlvbnMubWF4Wm9vbSk7XHJcblxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9leHBhbmRJZk5vdENvbGxhcHNlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiAhdGhpcy5vcHRpb25zLmNvbGxhcHNlZCkge1xyXG5cdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2V4cGFuZFNhZmVseTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uO1xyXG5cdFx0dGhpcy5fcHJldmVudENsaWNrID0gdHJ1ZTtcclxuXHRcdERvbUV2ZW50Lm9uKHNlY3Rpb24sICdjbGljaycsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHRcdHRoaXMuZXhwYW5kKCk7XHJcblx0XHR2YXIgdGhhdCA9IHRoaXM7XHJcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0RG9tRXZlbnQub2ZmKHNlY3Rpb24sICdjbGljaycsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHRcdFx0dGhhdC5fcHJldmVudENsaWNrID0gZmFsc2U7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wubGF5ZXJzKGJhc2VsYXllcnM/OiBPYmplY3QsIG92ZXJsYXlzPzogT2JqZWN0LCBvcHRpb25zPzogQ29udHJvbC5MYXllcnMgb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhIGxheWVycyBjb250cm9sIHdpdGggdGhlIGdpdmVuIGxheWVycy4gQmFzZSBsYXllcnMgd2lsbCBiZSBzd2l0Y2hlZCB3aXRoIHJhZGlvIGJ1dHRvbnMsIHdoaWxlIG92ZXJsYXlzIHdpbGwgYmUgc3dpdGNoZWQgd2l0aCBjaGVja2JveGVzLiBOb3RlIHRoYXQgYWxsIGJhc2UgbGF5ZXJzIHNob3VsZCBiZSBwYXNzZWQgaW4gdGhlIGJhc2UgbGF5ZXJzIG9iamVjdCwgYnV0IG9ubHkgb25lIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgbWFwIGR1cmluZyBtYXAgaW5zdGFudGlhdGlvbi5cclxuZXhwb3J0IHZhciBsYXllcnMgPSBmdW5jdGlvbiAoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IExheWVycyhiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucyk7XHJcbn07XHJcbiIsIlxyXG5pbXBvcnQge0NvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XHJcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5ab29tXHJcbiAqIEBha2EgTC5Db250cm9sLlpvb21cclxuICogQGluaGVyaXRzIENvbnRyb2xcclxuICpcclxuICogQSBiYXNpYyB6b29tIGNvbnRyb2wgd2l0aCB0d28gYnV0dG9ucyAoem9vbSBpbiBhbmQgem9vbSBvdXQpLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYHpvb21Db250cm9sYCBvcHRpb25dKCNtYXAtem9vbWNvbnRyb2wpIHRvIGBmYWxzZWAuIEV4dGVuZHMgYENvbnRyb2xgLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgWm9vbSA9IENvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5ab29tIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3NpdGlvbjogJ3RvcGxlZnQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUluVGV4dDogU3RyaW5nID0gJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPis8L3NwYW4+J1xyXG5cdFx0Ly8gVGhlIHRleHQgc2V0IG9uIHRoZSAnem9vbSBpbicgYnV0dG9uLlxyXG5cdFx0em9vbUluVGV4dDogJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPis8L3NwYW4+JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21JblRpdGxlOiBTdHJpbmcgPSAnWm9vbSBpbidcclxuXHRcdC8vIFRoZSB0aXRsZSBzZXQgb24gdGhlICd6b29tIGluJyBidXR0b24uXHJcblx0XHR6b29tSW5UaXRsZTogJ1pvb20gaW4nLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU91dFRleHQ6IFN0cmluZyA9ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mI3gyMjEyOzwvc3Bhbj4nXHJcblx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG5cdFx0em9vbU91dFRleHQ6ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mI3gyMjEyOzwvc3Bhbj4nLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU91dFRpdGxlOiBTdHJpbmcgPSAnWm9vbSBvdXQnXHJcblx0XHQvLyBUaGUgdGl0bGUgc2V0IG9uIHRoZSAnem9vbSBvdXQnIGJ1dHRvbi5cclxuXHRcdHpvb21PdXRUaXRsZTogJ1pvb20gb3V0J1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR2YXIgem9vbU5hbWUgPSAnbGVhZmxldC1jb250cm9sLXpvb20nLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCB6b29tTmFtZSArICcgbGVhZmxldC1iYXInKSxcclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdHRoaXMuX3pvb21JbkJ1dHRvbiAgPSB0aGlzLl9jcmVhdGVCdXR0b24ob3B0aW9ucy56b29tSW5UZXh0LCBvcHRpb25zLnpvb21JblRpdGxlLFxyXG5cdFx0ICAgICAgICB6b29tTmFtZSArICctaW4nLCAgY29udGFpbmVyLCB0aGlzLl96b29tSW4pO1xyXG5cdFx0dGhpcy5fem9vbU91dEJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21PdXRUZXh0LCBvcHRpb25zLnpvb21PdXRUaXRsZSxcclxuXHRcdCAgICAgICAgem9vbU5hbWUgKyAnLW91dCcsIGNvbnRhaW5lciwgdGhpcy5fem9vbU91dCk7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdG1hcC5vbignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiBjb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vZmYoJ3pvb21lbmQgem9vbWxldmVsc2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc2FibGVkLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9kaXNhYmxlZCA9IHRydWU7XHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF96b29tSW46IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA8IHRoaXMuX21hcC5nZXRNYXhab29tKCkpIHtcclxuXHRcdFx0dGhpcy5fbWFwLnpvb21Jbih0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEgKiAoZS5zaGlmdEtleSA/IDMgOiAxKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3pvb21PdXQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA+IHRoaXMuX21hcC5nZXRNaW5ab29tKCkpIHtcclxuXHRcdFx0dGhpcy5fbWFwLnpvb21PdXQodGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhICogKGUuc2hpZnRLZXkgPyAzIDogMSkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVCdXR0b246IGZ1bmN0aW9uIChodG1sLCB0aXRsZSwgY2xhc3NOYW1lLCBjb250YWluZXIsIGZuKSB7XHJcblx0XHR2YXIgbGluayA9IERvbVV0aWwuY3JlYXRlKCdhJywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG5cdFx0bGluay5pbm5lckhUTUwgPSBodG1sO1xyXG5cdFx0bGluay5ocmVmID0gJyMnO1xyXG5cdFx0bGluay50aXRsZSA9IHRpdGxlO1xyXG5cclxuXHRcdC8qXHJcblx0XHQgKiBXaWxsIGZvcmNlIHNjcmVlbiByZWFkZXJzIGxpa2UgVm9pY2VPdmVyIHRvIHJlYWQgdGhpcyBhcyBcIlpvb20gaW4gLSBidXR0b25cIlxyXG5cdFx0ICovXHJcblx0XHRsaW5rLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcclxuXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdGl0bGUpO1xyXG5cclxuXHRcdERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGxpbmspO1xyXG5cdFx0RG9tRXZlbnQub24obGluaywgJ2NsaWNrJywgRG9tRXZlbnQuc3RvcCk7XHJcblx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCBmbiwgdGhpcyk7XHJcblx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCB0aGlzLl9yZWZvY3VzT25NYXAsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiBsaW5rO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVEaXNhYmxlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBjbGFzc05hbWUgPSAnbGVhZmxldC1kaXNhYmxlZCc7XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHR0aGlzLl96b29tSW5CdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ2ZhbHNlJyk7XHJcblx0XHR0aGlzLl96b29tT3V0QnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsICdmYWxzZScpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9kaXNhYmxlZCB8fCBtYXAuX3pvb20gPT09IG1hcC5nZXRNaW5ab29tKCkpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl96b29tT3V0QnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0XHR0aGlzLl96b29tT3V0QnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsICd0cnVlJyk7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5fZGlzYWJsZWQgfHwgbWFwLl96b29tID09PSBtYXAuZ2V0TWF4Wm9vbSgpKSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0XHR0aGlzLl96b29tSW5CdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbi8vIEBvcHRpb24gem9vbUNvbnRyb2w6IEJvb2xlYW4gPSB0cnVlXHJcbi8vIFdoZXRoZXIgYSBbem9vbSBjb250cm9sXSgjY29udHJvbC16b29tKSBpcyBhZGRlZCB0byB0aGUgbWFwIGJ5IGRlZmF1bHQuXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdHpvb21Db250cm9sOiB0cnVlXHJcbn0pO1xyXG5cclxuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuXHRpZiAodGhpcy5vcHRpb25zLnpvb21Db250cm9sKSB7XHJcblx0XHQvLyBAc2VjdGlvbiBDb250cm9sc1xyXG5cdFx0Ly8gQHByb3BlcnR5IHpvb21Db250cm9sOiBDb250cm9sLlpvb21cclxuXHRcdC8vIFRoZSBkZWZhdWx0IHpvb20gY29udHJvbCAob25seSBhdmFpbGFibGUgaWYgdGhlXHJcblx0XHQvLyBbYHpvb21Db250cm9sYCBvcHRpb25dKCNtYXAtem9vbWNvbnRyb2wpIHdhcyBgdHJ1ZWAgd2hlbiBjcmVhdGluZyB0aGUgbWFwKS5cclxuXHRcdHRoaXMuem9vbUNvbnRyb2wgPSBuZXcgWm9vbSgpO1xyXG5cdFx0dGhpcy5hZGRDb250cm9sKHRoaXMuem9vbUNvbnRyb2wpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENvbnRyb2wuWm9vbVxyXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wuem9vbShvcHRpb25zOiBDb250cm9sLlpvb20gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhIHpvb20gY29udHJvbFxyXG5leHBvcnQgdmFyIHpvb20gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgWm9vbShvcHRpb25zKTtcclxufTtcclxuIiwiXG5pbXBvcnQge0NvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcblxuLypcbiAqIEBjbGFzcyBDb250cm9sLlNjYWxlXG4gKiBAYWthIEwuQ29udHJvbC5TY2FsZVxuICogQGluaGVyaXRzIENvbnRyb2xcbiAqXG4gKiBBIHNpbXBsZSBzY2FsZSBjb250cm9sIHRoYXQgc2hvd3MgdGhlIHNjYWxlIG9mIHRoZSBjdXJyZW50IGNlbnRlciBvZiBzY3JlZW4gaW4gbWV0cmljIChtL2ttKSBhbmQgaW1wZXJpYWwgKG1pL2Z0KSBzeXN0ZW1zLiBFeHRlbmRzIGBDb250cm9sYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBMLmNvbnRyb2wuc2NhbGUoKS5hZGRUbyhtYXApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBTY2FsZSA9IENvbnRyb2wuZXh0ZW5kKHtcblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBDb250cm9sLlNjYWxlIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdHBvc2l0aW9uOiAnYm90dG9tbGVmdCcsXG5cblx0XHQvLyBAb3B0aW9uIG1heFdpZHRoOiBOdW1iZXIgPSAxMDBcblx0XHQvLyBNYXhpbXVtIHdpZHRoIG9mIHRoZSBjb250cm9sIGluIHBpeGVscy4gVGhlIHdpZHRoIGlzIHNldCBkeW5hbWljYWxseSB0byBzaG93IHJvdW5kIHZhbHVlcyAoZS5nLiAxMDAsIDIwMCwgNTAwKS5cblx0XHRtYXhXaWR0aDogMTAwLFxuXG5cdFx0Ly8gQG9wdGlvbiBtZXRyaWM6IEJvb2xlYW4gPSBUcnVlXG5cdFx0Ly8gV2hldGhlciB0byBzaG93IHRoZSBtZXRyaWMgc2NhbGUgbGluZSAobS9rbSkuXG5cdFx0bWV0cmljOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiBpbXBlcmlhbDogQm9vbGVhbiA9IFRydWVcblx0XHQvLyBXaGV0aGVyIHRvIHNob3cgdGhlIGltcGVyaWFsIHNjYWxlIGxpbmUgKG1pL2Z0KS5cblx0XHRpbXBlcmlhbDogdHJ1ZVxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCBpcyB1cGRhdGVkIG9uIFtgbW92ZWVuZGBdKCNtYXAtbW92ZWVuZCksIG90aGVyd2lzZSBpdCdzIGFsd2F5cyB1cC10by1kYXRlICh1cGRhdGVkIG9uIFtgbW92ZWBdKCNtYXAtbW92ZSkpLlxuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtc2NhbGUnLFxuXHRcdCAgICBjb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lKSxcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdHRoaXMuX2FkZFNjYWxlcyhvcHRpb25zLCBjbGFzc05hbWUgKyAnLWxpbmUnLCBjb250YWluZXIpO1xuXG5cdFx0bWFwLm9uKG9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdFx0bWFwLndoZW5SZWFkeSh0aGlzLl91cGRhdGUsIHRoaXMpO1xuXG5cdFx0cmV0dXJuIGNvbnRhaW5lcjtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5vZmYodGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuXHR9LFxuXG5cdF9hZGRTY2FsZXM6IGZ1bmN0aW9uIChvcHRpb25zLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xuXHRcdGlmIChvcHRpb25zLm1ldHJpYykge1xuXHRcdFx0dGhpcy5fbVNjYWxlID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcblx0XHR9XG5cdFx0aWYgKG9wdGlvbnMuaW1wZXJpYWwpIHtcblx0XHRcdHRoaXMuX2lTY2FsZSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB5ID0gbWFwLmdldFNpemUoKS55IC8gMjtcblxuXHRcdHZhciBtYXhNZXRlcnMgPSBtYXAuZGlzdGFuY2UoXG5cdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbMCwgeV0pLFxuXHRcdFx0bWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoW3RoaXMub3B0aW9ucy5tYXhXaWR0aCwgeV0pKTtcblxuXHRcdHRoaXMuX3VwZGF0ZVNjYWxlcyhtYXhNZXRlcnMpO1xuXHR9LFxuXG5cdF91cGRhdGVTY2FsZXM6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHRpZiAodGhpcy5vcHRpb25zLm1ldHJpYyAmJiBtYXhNZXRlcnMpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZU1ldHJpYyhtYXhNZXRlcnMpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5vcHRpb25zLmltcGVyaWFsICYmIG1heE1ldGVycykge1xuXHRcdFx0dGhpcy5fdXBkYXRlSW1wZXJpYWwobWF4TWV0ZXJzKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZU1ldHJpYzogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdHZhciBtZXRlcnMgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhNZXRlcnMpLFxuXHRcdCAgICBsYWJlbCA9IG1ldGVycyA8IDEwMDAgPyBtZXRlcnMgKyAnIG0nIDogKG1ldGVycyAvIDEwMDApICsgJyBrbSc7XG5cblx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9tU2NhbGUsIGxhYmVsLCBtZXRlcnMgLyBtYXhNZXRlcnMpO1xuXHR9LFxuXG5cdF91cGRhdGVJbXBlcmlhbDogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdHZhciBtYXhGZWV0ID0gbWF4TWV0ZXJzICogMy4yODA4Mzk5LFxuXHRcdCAgICBtYXhNaWxlcywgbWlsZXMsIGZlZXQ7XG5cblx0XHRpZiAobWF4RmVldCA+IDUyODApIHtcblx0XHRcdG1heE1pbGVzID0gbWF4RmVldCAvIDUyODA7XG5cdFx0XHRtaWxlcyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1pbGVzKTtcblx0XHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX2lTY2FsZSwgbWlsZXMgKyAnIG1pJywgbWlsZXMgLyBtYXhNaWxlcyk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZmVldCA9IHRoaXMuX2dldFJvdW5kTnVtKG1heEZlZXQpO1xuXHRcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLCBmZWV0ICsgJyBmdCcsIGZlZXQgLyBtYXhGZWV0KTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVNjYWxlOiBmdW5jdGlvbiAoc2NhbGUsIHRleHQsIHJhdGlvKSB7XG5cdFx0c2NhbGUuc3R5bGUud2lkdGggPSBNYXRoLnJvdW5kKHRoaXMub3B0aW9ucy5tYXhXaWR0aCAqIHJhdGlvKSArICdweCc7XG5cdFx0c2NhbGUuaW5uZXJIVE1MID0gdGV4dDtcblx0fSxcblxuXHRfZ2V0Um91bmROdW06IGZ1bmN0aW9uIChudW0pIHtcblx0XHR2YXIgcG93MTAgPSBNYXRoLnBvdygxMCwgKE1hdGguZmxvb3IobnVtKSArICcnKS5sZW5ndGggLSAxKSxcblx0XHQgICAgZCA9IG51bSAvIHBvdzEwO1xuXG5cdFx0ZCA9IGQgPj0gMTAgPyAxMCA6XG5cdFx0ICAgIGQgPj0gNSA/IDUgOlxuXHRcdCAgICBkID49IDMgPyAzIDpcblx0XHQgICAgZCA+PSAyID8gMiA6IDE7XG5cblx0XHRyZXR1cm4gcG93MTAgKiBkO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wuc2NhbGUob3B0aW9ucz86IENvbnRyb2wuU2NhbGUgb3B0aW9ucylcbi8vIENyZWF0ZXMgYW4gc2NhbGUgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZXhwb3J0IHZhciBzY2FsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgU2NhbGUob3B0aW9ucyk7XG59O1xuIiwiXHJcbmltcG9ydCB7Q29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcclxuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xyXG5cclxudmFyIHVrcmFpbmlhbkZsYWcgPSAnPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxMlwiIGhlaWdodD1cIjhcIiB2aWV3Qm94PVwiMCAwIDEyIDhcIiBjbGFzcz1cImxlYWZsZXQtYXR0cmlidXRpb24tZmxhZ1wiPjxwYXRoIGZpbGw9XCIjNEM3QkUxXCIgZD1cIk0wIDBoMTJ2NEgwelwiLz48cGF0aCBmaWxsPVwiI0ZGRDUwMFwiIGQ9XCJNMCA0aDEydjNIMHpcIi8+PHBhdGggZmlsbD1cIiNFMEJDMDBcIiBkPVwiTTAgN2gxMnYxSDB6XCIvPjwvc3ZnPic7XHJcblxyXG5cclxuLypcclxuICogQGNsYXNzIENvbnRyb2wuQXR0cmlidXRpb25cclxuICogQGFrYSBMLkNvbnRyb2wuQXR0cmlidXRpb25cclxuICogQGluaGVyaXRzIENvbnRyb2xcclxuICpcclxuICogVGhlIGF0dHJpYnV0aW9uIGNvbnRyb2wgYWxsb3dzIHlvdSB0byBkaXNwbGF5IGF0dHJpYnV0aW9uIGRhdGEgaW4gYSBzbWFsbCB0ZXh0IGJveCBvbiBhIG1hcC4gSXQgaXMgcHV0IG9uIHRoZSBtYXAgYnkgZGVmYXVsdCB1bmxlc3MgeW91IHNldCBpdHMgW2BhdHRyaWJ1dGlvbkNvbnRyb2xgIG9wdGlvbl0oI21hcC1hdHRyaWJ1dGlvbmNvbnRyb2wpIHRvIGBmYWxzZWAsIGFuZCBpdCBmZXRjaGVzIGF0dHJpYnV0aW9uIHRleHRzIGZyb20gbGF5ZXJzIHdpdGggdGhlIFtgZ2V0QXR0cmlidXRpb25gIG1ldGhvZF0oI2xheWVyLWdldGF0dHJpYnV0aW9uKSBhdXRvbWF0aWNhbGx5LiBFeHRlbmRzIENvbnRyb2wuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBBdHRyaWJ1dGlvbiA9IENvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5BdHRyaWJ1dGlvbiBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9zaXRpb246ICdib3R0b21yaWdodCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwcmVmaXg6IFN0cmluZ3xmYWxzZSA9ICdMZWFmbGV0J1xyXG5cdFx0Ly8gVGhlIEhUTUwgdGV4dCBzaG93biBiZWZvcmUgdGhlIGF0dHJpYnV0aW9ucy4gUGFzcyBgZmFsc2VgIHRvIGRpc2FibGUuXHJcblx0XHRwcmVmaXg6ICc8YSBocmVmPVwiaHR0cHM6Ly9sZWFmbGV0anMuY29tXCIgdGl0bGU9XCJBIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgaW50ZXJhY3RpdmUgbWFwc1wiPicgKyAoQnJvd3Nlci5pbmxpbmVTdmcgPyB1a3JhaW5pYW5GbGFnICsgJyAnIDogJycpICsgJ0xlYWZsZXQ8L2E+J1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fYXR0cmlidXRpb25zID0ge307XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wgPSB0aGlzO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24nKTtcclxuXHRcdERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0Ly8gVE9ETyB1Z2x5LCByZWZhY3RvclxyXG5cdFx0Zm9yICh2YXIgaSBpbiBtYXAuX2xheWVycykge1xyXG5cdFx0XHRpZiAobWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24pIHtcclxuXHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0aW9uKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0bWFwLm9uKCdsYXllcmFkZCcsIHRoaXMuX2FkZEF0dHJpYnV0aW9uLCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAub2ZmKCdsYXllcmFkZCcsIHRoaXMuX2FkZEF0dHJpYnV0aW9uLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfYWRkQXR0cmlidXRpb246IGZ1bmN0aW9uIChldikge1xyXG5cdFx0aWYgKGV2LmxheWVyLmdldEF0dHJpYnV0aW9uKSB7XHJcblx0XHRcdHRoaXMuYWRkQXR0cmlidXRpb24oZXYubGF5ZXIuZ2V0QXR0cmlidXRpb24oKSk7XHJcblx0XHRcdGV2LmxheWVyLm9uY2UoJ3JlbW92ZScsIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHR0aGlzLnJlbW92ZUF0dHJpYnV0aW9uKGV2LmxheWVyLmdldEF0dHJpYnV0aW9uKCkpO1xyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFByZWZpeChwcmVmaXg6IFN0cmluZ3xmYWxzZSk6IHRoaXNcclxuXHQvLyBUaGUgSFRNTCB0ZXh0IHNob3duIGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLiBQYXNzIGBmYWxzZWAgdG8gZGlzYWJsZS5cclxuXHRzZXRQcmVmaXg6IGZ1bmN0aW9uIChwcmVmaXgpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5wcmVmaXggPSBwcmVmaXg7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gYXR0cmlidXRpb24gdGV4dCAoZS5nLiBgJyZjb3B5OyBPcGVuU3RyZWV0TWFwIGNvbnRyaWJ1dG9ycydgKS5cclxuXHRhZGRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKHRleHQpIHtcclxuXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmICghdGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcblx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSA9IDA7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0rKztcclxuXHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUF0dHJpYnV0aW9uKHRleHQ6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFuIGF0dHJpYnV0aW9uIHRleHQuXHJcblx0cmVtb3ZlQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcblx0XHRpZiAoIXRleHQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAodGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcblx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XS0tO1xyXG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgYXR0cmlicyA9IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fYXR0cmlidXRpb25zKSB7XHJcblx0XHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbaV0pIHtcclxuXHRcdFx0XHRhdHRyaWJzLnB1c2goaSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcHJlZml4QW5kQXR0cmlicyA9IFtdO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucHJlZml4KSB7XHJcblx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaCh0aGlzLm9wdGlvbnMucHJlZml4KTtcclxuXHRcdH1cclxuXHRcdGlmIChhdHRyaWJzLmxlbmd0aCkge1xyXG5cdFx0XHRwcmVmaXhBbmRBdHRyaWJzLnB1c2goYXR0cmlicy5qb2luKCcsICcpKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuaW5uZXJIVE1MID0gcHJlZml4QW5kQXR0cmlicy5qb2luKCcgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+fDwvc3Bhbj4gJyk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIENvbnRyb2wgb3B0aW9uc1xyXG4vLyBAb3B0aW9uIGF0dHJpYnV0aW9uQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuLy8gV2hldGhlciBhIFthdHRyaWJ1dGlvbiBjb250cm9sXSgjY29udHJvbC1hdHRyaWJ1dGlvbikgaXMgYWRkZWQgdG8gdGhlIG1hcCBieSBkZWZhdWx0LlxyXG5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHRhdHRyaWJ1dGlvbkNvbnRyb2w6IHRydWVcclxufSk7XHJcblxyXG5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xyXG5cdGlmICh0aGlzLm9wdGlvbnMuYXR0cmlidXRpb25Db250cm9sKSB7XHJcblx0XHRuZXcgQXR0cmlidXRpb24oKS5hZGRUbyh0aGlzKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBDb250cm9sLkF0dHJpYnV0aW9uXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC5hdHRyaWJ1dGlvbihvcHRpb25zOiBDb250cm9sLkF0dHJpYnV0aW9uIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYW4gYXR0cmlidXRpb24gY29udHJvbC5cclxuZXhwb3J0IHZhciBhdHRyaWJ1dGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBBdHRyaWJ1dGlvbihvcHRpb25zKTtcclxufTtcclxuIiwiaW1wb3J0IHtDb250cm9sLCBjb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xuaW1wb3J0IHtMYXllcnMsIGxheWVyc30gZnJvbSAnLi9Db250cm9sLkxheWVycyc7XG5pbXBvcnQge1pvb20sIHpvb219IGZyb20gJy4vQ29udHJvbC5ab29tJztcbmltcG9ydCB7U2NhbGUsIHNjYWxlfSBmcm9tICcuL0NvbnRyb2wuU2NhbGUnO1xuaW1wb3J0IHtBdHRyaWJ1dGlvbiwgYXR0cmlidXRpb259IGZyb20gJy4vQ29udHJvbC5BdHRyaWJ1dGlvbic7XG5cbkNvbnRyb2wuTGF5ZXJzID0gTGF5ZXJzO1xuQ29udHJvbC5ab29tID0gWm9vbTtcbkNvbnRyb2wuU2NhbGUgPSBTY2FsZTtcbkNvbnRyb2wuQXR0cmlidXRpb24gPSBBdHRyaWJ1dGlvbjtcblxuY29udHJvbC5sYXllcnMgPSBsYXllcnM7XG5jb250cm9sLnpvb20gPSB6b29tO1xuY29udHJvbC5zY2FsZSA9IHNjYWxlO1xuY29udHJvbC5hdHRyaWJ1dGlvbiA9IGF0dHJpYnV0aW9uO1xuXG5leHBvcnQge0NvbnRyb2wsIGNvbnRyb2x9O1xuIiwiaW1wb3J0IHtDbGFzc30gZnJvbSAnLi9DbGFzcyc7XG5cbi8qXG5cdEwuSGFuZGxlciBpcyBhIGJhc2UgY2xhc3MgZm9yIGhhbmRsZXIgY2xhc3NlcyB0aGF0IGFyZSB1c2VkIGludGVybmFsbHkgdG8gaW5qZWN0XG5cdGludGVyYWN0aW9uIGZlYXR1cmVzIGxpa2UgZHJhZ2dpbmcgdG8gY2xhc3NlcyBsaWtlIE1hcCBhbmQgTWFya2VyLlxuKi9cblxuLy8gQGNsYXNzIEhhbmRsZXJcbi8vIEBha2EgTC5IYW5kbGVyXG4vLyBBYnN0cmFjdCBjbGFzcyBmb3IgbWFwIGludGVyYWN0aW9uIGhhbmRsZXJzXG5cbmV4cG9ydCB2YXIgSGFuZGxlciA9IENsYXNzLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBlbmFibGUoKTogdGhpc1xuXHQvLyBFbmFibGVzIHRoZSBoYW5kbGVyXG5cdGVuYWJsZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHR0aGlzLl9lbmFibGVkID0gdHJ1ZTtcblx0XHR0aGlzLmFkZEhvb2tzKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBkaXNhYmxlKCk6IHRoaXNcblx0Ly8gRGlzYWJsZXMgdGhlIGhhbmRsZXJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuXHRcdHRoaXMucmVtb3ZlSG9va3MoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGVuYWJsZWQoKTogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgaGFuZGxlciBpcyBlbmFibGVkXG5cdGVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gISF0aGlzLl9lbmFibGVkO1xuXHR9XG5cblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcblx0Ly8gQ2xhc3NlcyBpbmhlcml0aW5nIGZyb20gYEhhbmRsZXJgIG11c3QgaW1wbGVtZW50IHRoZSB0d28gZm9sbG93aW5nIG1ldGhvZHM6XG5cdC8vIEBtZXRob2QgYWRkSG9va3MoKVxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBlbmFibGVkLCBzaG91bGQgYWRkIGV2ZW50IGhvb2tzLlxuXHQvLyBAbWV0aG9kIHJlbW92ZUhvb2tzKClcblx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGhhbmRsZXIgaXMgZGlzYWJsZWQsIHNob3VsZCByZW1vdmUgdGhlIGV2ZW50IGhvb2tzIGFkZGVkIHByZXZpb3VzbHkuXG59KTtcblxuLy8gQHNlY3Rpb24gVGhlcmUgaXMgc3RhdGljIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuSGFuZGxlcjpcbi8vIEBmdW5jdGlvbiBhZGRUbyhtYXA6IE1hcCwgbmFtZTogU3RyaW5nKTogdGhpc1xuLy8gQWRkcyBhIG5ldyBIYW5kbGVyIHRvIHRoZSBnaXZlbiBtYXAgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbkhhbmRsZXIuYWRkVG8gPSBmdW5jdGlvbiAobWFwLCBuYW1lKSB7XG5cdG1hcC5hZGRIYW5kbGVyKG5hbWUsIHRoaXMpO1xuXHRyZXR1cm4gdGhpcztcbn07XG4iLCJpbXBvcnQgQnJvd3NlciBmcm9tICcuL0Jyb3dzZXInO1xuZXhwb3J0IHtCcm93c2VyfTtcblxuZXhwb3J0IHtDbGFzc30gZnJvbSAnLi9DbGFzcyc7XG5cbmltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi9FdmVudHMnO1xuaW1wb3J0IHtFdmVudHN9IGZyb20gJy4vRXZlbnRzJztcbmV4cG9ydCB7RXZlbnRlZH07XG5leHBvcnQgdmFyIE1peGluID0ge0V2ZW50czogRXZlbnRzfTtcblxuZXhwb3J0IHtIYW5kbGVyfSBmcm9tICcuL0hhbmRsZXInO1xuXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4vVXRpbCc7XG5leHBvcnQge1V0aWx9O1xuZXhwb3J0IHtleHRlbmQsIGJpbmQsIHN0YW1wLCBzZXRPcHRpb25zfSBmcm9tICcuL1V0aWwnO1xuIiwiaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuLi9jb3JlL0V2ZW50cyc7XHJcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4vRG9tVXRpbCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQGNsYXNzIERyYWdnYWJsZVxyXG4gKiBAYWthIEwuRHJhZ2dhYmxlXHJcbiAqIEBpbmhlcml0cyBFdmVudGVkXHJcbiAqXHJcbiAqIEEgY2xhc3MgZm9yIG1ha2luZyBET00gZWxlbWVudHMgZHJhZ2dhYmxlIChpbmNsdWRpbmcgdG91Y2ggc3VwcG9ydCkuXHJcbiAqIFVzZWQgaW50ZXJuYWxseSBmb3IgbWFwIGFuZCBtYXJrZXIgZHJhZ2dpbmcuIE9ubHkgd29ya3MgZm9yIGVsZW1lbnRzXHJcbiAqIHRoYXQgd2VyZSBwb3NpdGlvbmVkIHdpdGggW2BMLkRvbVV0aWwuc2V0UG9zaXRpb25gXSgjZG9tdXRpbC1zZXRwb3NpdGlvbikuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBkcmFnZ2FibGUgPSBuZXcgTC5EcmFnZ2FibGUoZWxlbWVudFRvRHJhZyk7XHJcbiAqIGRyYWdnYWJsZS5lbmFibGUoKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxudmFyIFNUQVJUID0gQnJvd3Nlci50b3VjaCA/ICd0b3VjaHN0YXJ0IG1vdXNlZG93bicgOiAnbW91c2Vkb3duJztcclxuXHJcbmV4cG9ydCB2YXIgRHJhZ2dhYmxlID0gRXZlbnRlZC5leHRlbmQoe1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAc2VjdGlvblxyXG5cdFx0Ly8gQGFrYSBEcmFnZ2FibGUgb3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBjbGlja1RvbGVyYW5jZTogTnVtYmVyID0gM1xyXG5cdFx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgdGhlIG1vdXNlIHBvaW50ZXIgZHVyaW5nIGEgY2xpY2tcclxuXHRcdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgY2xpY2sgKGFzIG9wcG9zZWQgdG8gYSBtb3VzZSBkcmFnKS5cclxuXHRcdGNsaWNrVG9sZXJhbmNlOiAzXHJcblx0fSxcclxuXHJcblx0Ly8gQGNvbnN0cnVjdG9yIEwuRHJhZ2dhYmxlKGVsOiBIVE1MRWxlbWVudCwgZHJhZ0hhbmRsZT86IEhUTUxFbGVtZW50LCBwcmV2ZW50T3V0bGluZT86IEJvb2xlYW4sIG9wdGlvbnM/OiBEcmFnZ2FibGUgb3B0aW9ucylcclxuXHQvLyBDcmVhdGVzIGEgYERyYWdnYWJsZWAgb2JqZWN0IGZvciBtb3ZpbmcgYGVsYCB3aGVuIHlvdSBzdGFydCBkcmFnZ2luZyB0aGUgYGRyYWdIYW5kbGVgIGVsZW1lbnQgKGVxdWFscyBgZWxgIGl0c2VsZiBieSBkZWZhdWx0KS5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZWxlbWVudCwgZHJhZ1N0YXJ0VGFyZ2V0LCBwcmV2ZW50T3V0bGluZSwgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xyXG5cdFx0dGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0ID0gZHJhZ1N0YXJ0VGFyZ2V0IHx8IGVsZW1lbnQ7XHJcblx0XHR0aGlzLl9wcmV2ZW50T3V0bGluZSA9IHByZXZlbnRPdXRsaW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZW5hYmxlKClcclxuXHQvLyBFbmFibGVzIHRoZSBkcmFnZ2luZyBhYmlsaXR5XHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHREb21FdmVudC5vbih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIFNUQVJULCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzYWJsZSgpXHJcblx0Ly8gRGlzYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gSWYgd2UncmUgY3VycmVudGx5IGRyYWdnaW5nIHRoaXMgZHJhZ2dhYmxlLFxyXG5cdFx0Ly8gZGlzYWJsaW5nIGl0IGNvdW50cyBhcyBmaXJzdCBlbmRpbmcgdGhlIGRyYWcuXHJcblx0XHRpZiAoRHJhZ2dhYmxlLl9kcmFnZ2luZyA9PT0gdGhpcykge1xyXG5cdFx0XHR0aGlzLmZpbmlzaERyYWcodHJ1ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgU1RBUlQsIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHRfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gSWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKERvbVV0aWwuaGFzQ2xhc3ModGhpcy5fZWxlbWVudCwgJ2xlYWZsZXQtem9vbS1hbmltJykpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoICE9PSAxKSB7XHJcblx0XHRcdC8vIEZpbmlzaCBkcmFnZ2luZyB0byBhdm9pZCBjb25mbGljdCB3aXRoIHRvdWNoWm9vbVxyXG5cdFx0XHRpZiAoRHJhZ2dhYmxlLl9kcmFnZ2luZyA9PT0gdGhpcykge1xyXG5cdFx0XHRcdHRoaXMuZmluaXNoRHJhZygpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoRHJhZ2dhYmxlLl9kcmFnZ2luZyB8fCBlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSAmJiAhZS50b3VjaGVzKSkgeyByZXR1cm47IH1cclxuXHRcdERyYWdnYWJsZS5fZHJhZ2dpbmcgPSB0aGlzOyAgLy8gUHJldmVudCBkcmFnZ2luZyBtdWx0aXBsZSBvYmplY3RzIGF0IG9uY2UuXHJcblxyXG5cdFx0aWYgKHRoaXMuX3ByZXZlbnRPdXRsaW5lKSB7XHJcblx0XHRcdERvbVV0aWwucHJldmVudE91dGxpbmUodGhpcy5fZWxlbWVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnKCk7XHJcblx0XHREb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21vdmluZykgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBAZXZlbnQgZG93bjogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIGlzIGFib3V0IHRvIHN0YXJ0LlxyXG5cdFx0dGhpcy5maXJlKCdkb3duJyk7XHJcblxyXG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZSxcclxuXHRcdCAgICBzaXplZFBhcmVudCA9IERvbVV0aWwuZ2V0U2l6ZWRQYXJlbnROb2RlKHRoaXMuX2VsZW1lbnQpO1xyXG5cclxuXHRcdHRoaXMuX3N0YXJ0UG9pbnQgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XHJcblx0XHR0aGlzLl9zdGFydFBvcyA9IERvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCk7XHJcblxyXG5cdFx0Ly8gQ2FjaGUgdGhlIHNjYWxlLCBzbyB0aGF0IHdlIGNhbiBjb250aW51b3VzbHkgY29tcGVuc2F0ZSBmb3IgaXQgZHVyaW5nIGRyYWcgKF9vbk1vdmUpLlxyXG5cdFx0dGhpcy5fcGFyZW50U2NhbGUgPSBEb21VdGlsLmdldFNjYWxlKHNpemVkUGFyZW50KTtcclxuXHJcblx0XHR2YXIgbW91c2VldmVudCA9IGUudHlwZSA9PT0gJ21vdXNlZG93bic7XHJcblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgbW91c2VldmVudCA/ICdtb3VzZW1vdmUnIDogJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgdGhpcyk7XHJcblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgbW91c2VldmVudCA/ICdtb3VzZXVwJyA6ICd0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xyXG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZmlyc3QgPSAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPT09IDEgPyBlLnRvdWNoZXNbMF0gOiBlKSxcclxuXHRcdCAgICBvZmZzZXQgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSkuX3N1YnRyYWN0KHRoaXMuX3N0YXJ0UG9pbnQpO1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybjsgfVxyXG5cdFx0aWYgKE1hdGguYWJzKG9mZnNldC54KSArIE1hdGguYWJzKG9mZnNldC55KSA8IHRoaXMub3B0aW9ucy5jbGlja1RvbGVyYW5jZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBXZSBhc3N1bWUgdGhhdCB0aGUgcGFyZW50IGNvbnRhaW5lcidzIHBvc2l0aW9uLCBib3JkZXIgYW5kIHNjYWxlIGRvIG5vdCBjaGFuZ2UgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgZHJhZy5cclxuXHRcdC8vIFRoZXJlZm9yZSB0aGVyZSBpcyBubyBuZWVkIHRvIGFjY291bnQgZm9yIHRoZSBwb3NpdGlvbiBhbmQgYm9yZGVyICh0aGV5IGFyZSBlbGltaW5hdGVkIGJ5IHRoZSBzdWJ0cmFjdGlvbilcclxuXHRcdC8vIGFuZCB3ZSBjYW4gdXNlIHRoZSBjYWNoZWQgdmFsdWUgZm9yIHRoZSBzY2FsZS5cclxuXHRcdG9mZnNldC54IC89IHRoaXMuX3BhcmVudFNjYWxlLng7XHJcblx0XHRvZmZzZXQueSAvPSB0aGlzLl9wYXJlbnRTY2FsZS55O1xyXG5cclxuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cclxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcclxuXHRcdFx0Ly8gQGV2ZW50IGRyYWdzdGFydDogRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIGRyYWcgc3RhcnRzXHJcblx0XHRcdHRoaXMuZmlyZSgnZHJhZ3N0YXJ0Jyk7XHJcblxyXG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XHJcblxyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblxyXG5cdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xyXG5cdFx0XHQvLyBJRSBhbmQgRWRnZSBkbyBub3QgZ2l2ZSB0aGUgPHVzZT4gZWxlbWVudCwgc28gZmV0Y2ggaXRcclxuXHRcdFx0Ly8gaWYgbmVjZXNzYXJ5XHJcblx0XHRcdGlmICh3aW5kb3cuU1ZHRWxlbWVudEluc3RhbmNlICYmIHRoaXMuX2xhc3RUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuU1ZHRWxlbWVudEluc3RhbmNlKSB7XHJcblx0XHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IHRoaXMuX2xhc3RUYXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XHJcblx0XHRcdH1cclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX25ld1BvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZChvZmZzZXQpO1xyXG5cdFx0dGhpcy5fbW92aW5nID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLl9sYXN0RXZlbnQgPSBlO1xyXG5cdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBlID0ge29yaWdpbmFsRXZlbnQ6IHRoaXMuX2xhc3RFdmVudH07XHJcblxyXG5cdFx0Ly8gQGV2ZW50IHByZWRyYWc6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIGRyYWdnaW5nICpiZWZvcmUqIGVhY2ggY29ycmVzcG9uZGluZ1xyXG5cdFx0Ly8gdXBkYXRlIG9mIHRoZSBlbGVtZW50J3MgcG9zaXRpb24uXHJcblx0XHR0aGlzLmZpcmUoJ3ByZWRyYWcnLCBlKTtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCwgdGhpcy5fbmV3UG9zKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgZHJhZzogRXZlbnRcclxuXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcuXHJcblx0XHR0aGlzLmZpcmUoJ2RyYWcnLCBlKTtcclxuXHR9LFxyXG5cclxuXHRfb25VcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gSWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cdFx0dGhpcy5maW5pc2hEcmFnKCk7XHJcblx0fSxcclxuXHJcblx0ZmluaXNoRHJhZzogZnVuY3Rpb24gKG5vSW5lcnRpYSkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sYXN0VGFyZ2V0KSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCAnbW91c2Vtb3ZlIHRvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgdGhpcyk7XHJcblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICdtb3VzZXVwIHRvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fb25VcCwgdGhpcyk7XHJcblxyXG5cdFx0RG9tVXRpbC5lbmFibGVJbWFnZURyYWcoKTtcclxuXHRcdERvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xyXG5cclxuXHRcdHZhciBmaXJlRHJhZ2VuZCA9IHRoaXMuX21vdmVkICYmIHRoaXMuX21vdmluZztcclxuXHJcblx0XHR0aGlzLl9tb3ZpbmcgPSBmYWxzZTtcclxuXHRcdERyYWdnYWJsZS5fZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoZmlyZURyYWdlbmQpIHtcclxuXHRcdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBkcmFnIGVuZHMuXHJcblx0XHRcdHRoaXMuZmlyZSgnZHJhZ2VuZCcsIHtcclxuXHRcdFx0XHRub0luZXJ0aWE6IG5vSW5lcnRpYSxcclxuXHRcdFx0XHRkaXN0YW5jZTogdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcbn0pO1xyXG4iLCJpbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuL0xpbmVVdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZ30gZnJvbSAnLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCB7dG9Qb2ludH0gZnJvbSAnLi9Qb2ludCc7XHJcbmltcG9ydCB7dG9MYXRMbmdCb3VuZHN9IGZyb20gJy4uL2dlby9MYXRMbmdCb3VuZHMnO1xyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFBvbHlVdGlsXHJcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHBvbHlnb24gZ2VvbWV0cmllcy5cclxuICovXHJcblxyXG4vKiBAZnVuY3Rpb24gY2xpcFBvbHlnb24ocG9pbnRzOiBQb2ludFtdLCBib3VuZHM6IEJvdW5kcywgcm91bmQ/OiBCb29sZWFuKTogUG9pbnRbXVxyXG4gKiBDbGlwcyB0aGUgcG9seWdvbiBnZW9tZXRyeSBkZWZpbmVkIGJ5IHRoZSBnaXZlbiBgcG9pbnRzYCBieSB0aGUgZ2l2ZW4gYm91bmRzICh1c2luZyB0aGUgW1N1dGhlcmxhbmQtSG9kZ21hbiBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1dGhlcmxhbmQlRTIlODAlOTNIb2RnbWFuX2FsZ29yaXRobSkpLlxyXG4gKiBVc2VkIGJ5IExlYWZsZXQgdG8gb25seSBzaG93IHBvbHlnb24gcG9pbnRzIHRoYXQgYXJlIG9uIHRoZSBzY3JlZW4gb3IgbmVhciwgaW5jcmVhc2luZ1xyXG4gKiBwZXJmb3JtYW5jZS4gTm90ZSB0aGF0IHBvbHlnb24gcG9pbnRzIG5lZWRzIGRpZmZlcmVudCBhbGdvcml0aG0gZm9yIGNsaXBwaW5nXHJcbiAqIHRoYW4gcG9seWxpbmUsIHNvIHRoZXJlJ3MgYSBzZXBhcmF0ZSBtZXRob2QgZm9yIGl0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50cywgYm91bmRzLCByb3VuZCkge1xyXG5cdHZhciBjbGlwcGVkUG9pbnRzLFxyXG5cdCAgICBlZGdlcyA9IFsxLCA0LCAyLCA4XSxcclxuXHQgICAgaSwgaiwgayxcclxuXHQgICAgYSwgYixcclxuXHQgICAgbGVuLCBlZGdlLCBwO1xyXG5cclxuXHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHBvaW50c1tpXS5fY29kZSA9IExpbmVVdGlsLl9nZXRCaXRDb2RlKHBvaW50c1tpXSwgYm91bmRzKTtcclxuXHR9XHJcblxyXG5cdC8vIGZvciBlYWNoIGVkZ2UgKGxlZnQsIGJvdHRvbSwgcmlnaHQsIHRvcClcclxuXHRmb3IgKGsgPSAwOyBrIDwgNDsgaysrKSB7XHJcblx0XHRlZGdlID0gZWRnZXNba107XHJcblx0XHRjbGlwcGVkUG9pbnRzID0gW107XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcclxuXHRcdFx0YSA9IHBvaW50c1tpXTtcclxuXHRcdFx0YiA9IHBvaW50c1tqXTtcclxuXHJcblx0XHRcdC8vIGlmIGEgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvd1xyXG5cdFx0XHRpZiAoIShhLl9jb2RlICYgZWRnZSkpIHtcclxuXHRcdFx0XHQvLyBpZiBiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGdvZXMgb3V0IG9mIHNjcmVlbilcclxuXHRcdFx0XHRpZiAoYi5fY29kZSAmIGVkZ2UpIHtcclxuXHRcdFx0XHRcdHAgPSBMaW5lVXRpbC5fZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdFx0XHRcdHAuX2NvZGUgPSBMaW5lVXRpbC5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2goYSk7XHJcblxyXG5cdFx0XHQvLyBlbHNlIGlmIGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBlbnRlcnMgdGhlIHNjcmVlbilcclxuXHRcdFx0fSBlbHNlIGlmICghKGIuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdHAgPSBMaW5lVXRpbC5fZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdFx0XHRwLl9jb2RlID0gTGluZVV0aWwuX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHBvaW50cyA9IGNsaXBwZWRQb2ludHM7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcG9pbnRzO1xyXG59XHJcblxyXG4vKiBAZnVuY3Rpb24gcG9seWdvbkNlbnRlcihsYXRsbmdzOiBMYXRMbmdbXSwgY3JzOiBDUlMpOiBMYXRMbmdcclxuICogUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgcGFzc2VkIExhdExuZ3MgKGZpcnN0IHJpbmcpIGZyb20gYSBwb2x5Z29uLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlnb25DZW50ZXIobGF0bG5ncywgY3JzKSB7XHJcblx0dmFyIGksIGosIHAxLCBwMiwgZiwgYXJlYSwgeCwgeSwgY2VudGVyO1xyXG5cclxuXHRpZiAoIWxhdGxuZ3MgfHwgbGF0bG5ncy5sZW5ndGggPT09IDApIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcignbGF0bG5ncyBub3QgcGFzc2VkJyk7XHJcblx0fVxyXG5cclxuXHRpZiAoIUxpbmVVdGlsLmlzRmxhdChsYXRsbmdzKSkge1xyXG5cdFx0Y29uc29sZS53YXJuKCdsYXRsbmdzIGFyZSBub3QgZmxhdCEgT25seSB0aGUgZmlyc3QgcmluZyB3aWxsIGJlIHVzZWQnKTtcclxuXHRcdGxhdGxuZ3MgPSBsYXRsbmdzWzBdO1xyXG5cdH1cclxuXHJcblx0dmFyIGNlbnRyb2lkTGF0TG5nID0gdG9MYXRMbmcoWzAsIDBdKTtcclxuXHJcblx0dmFyIGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGxhdGxuZ3MpO1xyXG5cdHZhciBhcmVhQm91bmRzID0gYm91bmRzLmdldE5vcnRoV2VzdCgpLmRpc3RhbmNlVG8oYm91bmRzLmdldFNvdXRoV2VzdCgpKSAqIGJvdW5kcy5nZXROb3J0aEVhc3QoKS5kaXN0YW5jZVRvKGJvdW5kcy5nZXROb3J0aFdlc3QoKSk7XHJcblx0Ly8gdGVzdHMgc2hvd2VkIHRoYXQgYmVsb3cgMTcwMCByb3VuZGluZyBlcnJvcnMgYXJlIGhhcHBlbmluZ1xyXG5cdGlmIChhcmVhQm91bmRzIDwgMTcwMCkge1xyXG5cdFx0Ly8gZ2V0dGluZyBhIGluZXhhY3QgY2VudGVyLCB0byBtb3ZlIHRoZSBsYXRsbmdzIG5lYXIgdG8gWzAsIDBdIHRvIHByZXZlbnQgcm91bmRpbmcgZXJyb3JzXHJcblx0XHRjZW50cm9pZExhdExuZyA9IGNlbnRyb2lkKGxhdGxuZ3MpO1xyXG5cdH1cclxuXHJcblx0dmFyIGxlbiA9IGxhdGxuZ3MubGVuZ3RoO1xyXG5cdHZhciBwb2ludHMgPSBbXTtcclxuXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHZhciBsYXRsbmcgPSB0b0xhdExuZyhsYXRsbmdzW2ldKTtcclxuXHRcdHBvaW50cy5wdXNoKGNycy5wcm9qZWN0KHRvTGF0TG5nKFtsYXRsbmcubGF0IC0gY2VudHJvaWRMYXRMbmcubGF0LCBsYXRsbmcubG5nIC0gY2VudHJvaWRMYXRMbmcubG5nXSkpKTtcclxuXHR9XHJcblxyXG5cdGFyZWEgPSB4ID0geSA9IDA7XHJcblxyXG5cdC8vIHBvbHlnb24gY2VudHJvaWQgYWxnb3JpdGhtO1xyXG5cdGZvciAoaSA9IDAsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XHJcblx0XHRwMSA9IHBvaW50c1tpXTtcclxuXHRcdHAyID0gcG9pbnRzW2pdO1xyXG5cclxuXHRcdGYgPSBwMS55ICogcDIueCAtIHAyLnkgKiBwMS54O1xyXG5cdFx0eCArPSAocDEueCArIHAyLngpICogZjtcclxuXHRcdHkgKz0gKHAxLnkgKyBwMi55KSAqIGY7XHJcblx0XHRhcmVhICs9IGYgKiAzO1xyXG5cdH1cclxuXHJcblx0aWYgKGFyZWEgPT09IDApIHtcclxuXHRcdC8vIFBvbHlnb24gaXMgc28gc21hbGwgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiBzYW1lIHBpeGVsLlxyXG5cdFx0Y2VudGVyID0gcG9pbnRzWzBdO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRjZW50ZXIgPSBbeCAvIGFyZWEsIHkgLyBhcmVhXTtcclxuXHR9XHJcblxyXG5cdHZhciBsYXRsbmdDZW50ZXIgPSBjcnMudW5wcm9qZWN0KHRvUG9pbnQoY2VudGVyKSk7XHJcblx0cmV0dXJuIHRvTGF0TG5nKFtsYXRsbmdDZW50ZXIubGF0ICsgY2VudHJvaWRMYXRMbmcubGF0LCBsYXRsbmdDZW50ZXIubG5nICsgY2VudHJvaWRMYXRMbmcubG5nXSk7XHJcbn1cclxuXHJcbi8qIEBmdW5jdGlvbiBjZW50cm9pZChsYXRsbmdzOiBMYXRMbmdbXSk6IExhdExuZ1xyXG4gKiBSZXR1cm5zIHRoZSAnY2VudGVyIG9mIG1hc3MnIG9mIHRoZSBwYXNzZWQgTGF0TG5ncy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjZW50cm9pZChjb29yZHMpIHtcclxuXHR2YXIgbGF0U3VtID0gMDtcclxuXHR2YXIgbG5nU3VtID0gMDtcclxuXHR2YXIgbGVuID0gMDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGxhdGxuZyA9IHRvTGF0TG5nKGNvb3Jkc1tpXSk7XHJcblx0XHRsYXRTdW0gKz0gbGF0bG5nLmxhdDtcclxuXHRcdGxuZ1N1bSArPSBsYXRsbmcubG5nO1xyXG5cdFx0bGVuKys7XHJcblx0fVxyXG5cdHJldHVybiB0b0xhdExuZyhbbGF0U3VtIC8gbGVuLCBsbmdTdW0gLyBsZW5dKTtcclxufVxyXG4iLCJpbXBvcnQge1BvaW50LCB0b1BvaW50fSBmcm9tICcuL1BvaW50JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3RvTGF0TG5nfSBmcm9tICcuLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0IHtjZW50cm9pZH0gZnJvbSAnLi9Qb2x5VXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmdCb3VuZHN9IGZyb20gJy4uL2dlby9MYXRMbmdCb3VuZHMnO1xyXG5cclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgTGluZVV0aWxcclxuICpcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWxpbmUgcG9pbnRzIHByb2Nlc3NpbmcsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5IHRvIG1ha2UgcG9seWxpbmVzIGxpZ2h0bmluZy1mYXN0LlxyXG4gKi9cclxuXHJcbi8vIFNpbXBsaWZ5IHBvbHlsaW5lIHdpdGggdmVydGV4IHJlZHVjdGlvbiBhbmQgRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLlxyXG4vLyBJbXByb3ZlcyByZW5kZXJpbmcgcGVyZm9ybWFuY2UgZHJhbWF0aWNhbGx5IGJ5IGxlc3NlbmluZyB0aGUgbnVtYmVyIG9mIHBvaW50cyB0byBkcmF3LlxyXG5cclxuLy8gQGZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50czogUG9pbnRbXSwgdG9sZXJhbmNlOiBOdW1iZXIpOiBQb2ludFtdXHJcbi8vIERyYW1hdGljYWxseSByZWR1Y2VzIHRoZSBudW1iZXIgb2YgcG9pbnRzIGluIGEgcG9seWxpbmUgd2hpbGUgcmV0YWluaW5nXHJcbi8vIGl0cyBzaGFwZSBhbmQgcmV0dXJucyBhIG5ldyBhcnJheSBvZiBzaW1wbGlmaWVkIHBvaW50cywgdXNpbmcgdGhlXHJcbi8vIFtSYW1lci1Eb3VnbGFzLVBldWNrZXIgYWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYW1lci1Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtKS5cclxuLy8gVXNlZCBmb3IgYSBodWdlIHBlcmZvcm1hbmNlIGJvb3N0IHdoZW4gcHJvY2Vzc2luZy9kaXNwbGF5aW5nIExlYWZsZXQgcG9seWxpbmVzIGZvclxyXG4vLyBlYWNoIHpvb20gbGV2ZWwgYW5kIGFsc28gcmVkdWNpbmcgdmlzdWFsIG5vaXNlLiB0b2xlcmFuY2UgYWZmZWN0cyB0aGUgYW1vdW50IG9mXHJcbi8vIHNpbXBsaWZpY2F0aW9uIChsZXNzZXIgdmFsdWUgbWVhbnMgaGlnaGVyIHF1YWxpdHkgYnV0IHNsb3dlciBhbmQgd2l0aCBtb3JlIHBvaW50cykuXHJcbi8vIEFsc28gcmVsZWFzZWQgYXMgYSBzZXBhcmF0ZWQgbWljcm8tbGlicmFyeSBbU2ltcGxpZnkuanNdKGh0dHBzOi8vbW91cm5lci5naXRodWIuaW8vc2ltcGxpZnktanMvKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50cywgdG9sZXJhbmNlKSB7XHJcblx0aWYgKCF0b2xlcmFuY2UgfHwgIXBvaW50cy5sZW5ndGgpIHtcclxuXHRcdHJldHVybiBwb2ludHMuc2xpY2UoKTtcclxuXHR9XHJcblxyXG5cdHZhciBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAqIHRvbGVyYW5jZTtcclxuXHJcblx0ICAgIC8vIHN0YWdlIDE6IHZlcnRleCByZWR1Y3Rpb25cclxuXHQgICAgcG9pbnRzID0gX3JlZHVjZVBvaW50cyhwb2ludHMsIHNxVG9sZXJhbmNlKTtcclxuXHJcblx0ICAgIC8vIHN0YWdlIDI6IERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvblxyXG5cdCAgICBwb2ludHMgPSBfc2ltcGxpZnlEUChwb2ludHMsIHNxVG9sZXJhbmNlKTtcclxuXHJcblx0cmV0dXJuIHBvaW50cztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHBvaW50VG9TZWdtZW50RGlzdGFuY2UocDogUG9pbnQsIHAxOiBQb2ludCwgcDI6IFBvaW50KTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gcG9pbnQgYHBgIGFuZCBzZWdtZW50IGBwMWAgdG8gYHAyYC5cclxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcDEsIHAyKSB7XHJcblx0cmV0dXJuIE1hdGguc3FydChfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyLCB0cnVlKSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocDogUG9pbnQsIHAxOiBQb2ludCwgcDI6IFBvaW50KTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIGNsb3Nlc3QgcG9pbnQgZnJvbSBhIHBvaW50IGBwYCBvbiBhIHNlZ21lbnQgYHAxYCB0byBgcDJgLlxyXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMikge1xyXG5cdHJldHVybiBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyKTtcclxufVxyXG5cclxuLy8gUmFtZXItRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLCBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmFtZXItRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobVxyXG5mdW5jdGlvbiBfc2ltcGxpZnlEUChwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcblxyXG5cdHZhciBsZW4gPSBwb2ludHMubGVuZ3RoLFxyXG5cdCAgICBBcnJheUNvbnN0cnVjdG9yID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IHVuZGVmaW5lZCArICcnID8gVWludDhBcnJheSA6IEFycmF5LFxyXG5cdCAgICBtYXJrZXJzID0gbmV3IEFycmF5Q29uc3RydWN0b3IobGVuKTtcclxuXHJcblx0ICAgIG1hcmtlcnNbMF0gPSBtYXJrZXJzW2xlbiAtIDFdID0gMTtcclxuXHJcblx0X3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIDAsIGxlbiAtIDEpO1xyXG5cclxuXHR2YXIgaSxcclxuXHQgICAgbmV3UG9pbnRzID0gW107XHJcblxyXG5cdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0aWYgKG1hcmtlcnNbaV0pIHtcclxuXHRcdFx0bmV3UG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBuZXdQb2ludHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgbGFzdCkge1xyXG5cclxuXHR2YXIgbWF4U3FEaXN0ID0gMCxcclxuXHRpbmRleCwgaSwgc3FEaXN0O1xyXG5cclxuXHRmb3IgKGkgPSBmaXJzdCArIDE7IGkgPD0gbGFzdCAtIDE7IGkrKykge1xyXG5cdFx0c3FEaXN0ID0gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHBvaW50c1tpXSwgcG9pbnRzW2ZpcnN0XSwgcG9pbnRzW2xhc3RdLCB0cnVlKTtcclxuXHJcblx0XHRpZiAoc3FEaXN0ID4gbWF4U3FEaXN0KSB7XHJcblx0XHRcdGluZGV4ID0gaTtcclxuXHRcdFx0bWF4U3FEaXN0ID0gc3FEaXN0O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0aWYgKG1heFNxRGlzdCA+IHNxVG9sZXJhbmNlKSB7XHJcblx0XHRtYXJrZXJzW2luZGV4XSA9IDE7XHJcblxyXG5cdFx0X3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBpbmRleCk7XHJcblx0XHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgaW5kZXgsIGxhc3QpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gcmVkdWNlIHBvaW50cyB0aGF0IGFyZSB0b28gY2xvc2UgdG8gZWFjaCBvdGhlciB0byBhIHNpbmdsZSBwb2ludFxyXG5mdW5jdGlvbiBfcmVkdWNlUG9pbnRzKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcclxuXHR2YXIgcmVkdWNlZFBvaW50cyA9IFtwb2ludHNbMF1dO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMSwgcHJldiA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0aWYgKF9zcURpc3QocG9pbnRzW2ldLCBwb2ludHNbcHJldl0pID4gc3FUb2xlcmFuY2UpIHtcclxuXHRcdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tpXSk7XHJcblx0XHRcdHByZXYgPSBpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAocHJldiA8IGxlbiAtIDEpIHtcclxuXHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbbGVuIC0gMV0pO1xyXG5cdH1cclxuXHRyZXR1cm4gcmVkdWNlZFBvaW50cztcclxufVxyXG5cclxudmFyIF9sYXN0Q29kZTtcclxuXHJcbi8vIEBmdW5jdGlvbiBjbGlwU2VnbWVudChhOiBQb2ludCwgYjogUG9pbnQsIGJvdW5kczogQm91bmRzLCB1c2VMYXN0Q29kZT86IEJvb2xlYW4sIHJvdW5kPzogQm9vbGVhbik6IFBvaW50W118Qm9vbGVhblxyXG4vLyBDbGlwcyB0aGUgc2VnbWVudCBhIHRvIGIgYnkgcmVjdGFuZ3VsYXIgYm91bmRzIHdpdGggdGhlXHJcbi8vIFtDb2hlbi1TdXRoZXJsYW5kIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29oZW4lRTIlODAlOTNTdXRoZXJsYW5kX2FsZ29yaXRobSlcclxuLy8gKG1vZGlmeWluZyB0aGUgc2VnbWVudCBwb2ludHMgZGlyZWN0bHkhKS4gVXNlZCBieSBMZWFmbGV0IHRvIG9ubHkgc2hvdyBwb2x5bGluZVxyXG4vLyBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nIHBlcmZvcm1hbmNlLlxyXG5leHBvcnQgZnVuY3Rpb24gY2xpcFNlZ21lbnQoYSwgYiwgYm91bmRzLCB1c2VMYXN0Q29kZSwgcm91bmQpIHtcclxuXHR2YXIgY29kZUEgPSB1c2VMYXN0Q29kZSA/IF9sYXN0Q29kZSA6IF9nZXRCaXRDb2RlKGEsIGJvdW5kcyksXHJcblx0ICAgIGNvZGVCID0gX2dldEJpdENvZGUoYiwgYm91bmRzKSxcclxuXHJcblx0ICAgIGNvZGVPdXQsIHAsIG5ld0NvZGU7XHJcblxyXG5cdCAgICAvLyBzYXZlIDJuZCBjb2RlIHRvIGF2b2lkIGNhbGN1bGF0aW5nIGl0IG9uIHRoZSBuZXh0IHNlZ21lbnRcclxuXHQgICAgX2xhc3RDb2RlID0gY29kZUI7XHJcblxyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHQvLyBpZiBhLGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAodHJpdmlhbCBhY2NlcHQpXHJcblx0XHRpZiAoIShjb2RlQSB8IGNvZGVCKSkge1xyXG5cdFx0XHRyZXR1cm4gW2EsIGJdO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGlmIGEsYiBpcyBvdXRzaWRlIHRoZSBjbGlwIHdpbmRvdyAodHJpdmlhbCByZWplY3QpXHJcblx0XHRpZiAoY29kZUEgJiBjb2RlQikge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gb3RoZXIgY2FzZXNcclxuXHRcdGNvZGVPdXQgPSBjb2RlQSB8fCBjb2RlQjtcclxuXHRcdHAgPSBfZ2V0RWRnZUludGVyc2VjdGlvbihhLCBiLCBjb2RlT3V0LCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdG5ld0NvZGUgPSBfZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cclxuXHRcdGlmIChjb2RlT3V0ID09PSBjb2RlQSkge1xyXG5cdFx0XHRhID0gcDtcclxuXHRcdFx0Y29kZUEgPSBuZXdDb2RlO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0YiA9IHA7XHJcblx0XHRcdGNvZGVCID0gbmV3Q29kZTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfZ2V0RWRnZUludGVyc2VjdGlvbihhLCBiLCBjb2RlLCBib3VuZHMsIHJvdW5kKSB7XHJcblx0dmFyIGR4ID0gYi54IC0gYS54LFxyXG5cdCAgICBkeSA9IGIueSAtIGEueSxcclxuXHQgICAgbWluID0gYm91bmRzLm1pbixcclxuXHQgICAgbWF4ID0gYm91bmRzLm1heCxcclxuXHQgICAgeCwgeTtcclxuXHJcblx0aWYgKGNvZGUgJiA4KSB7IC8vIHRvcFxyXG5cdFx0eCA9IGEueCArIGR4ICogKG1heC55IC0gYS55KSAvIGR5O1xyXG5cdFx0eSA9IG1heC55O1xyXG5cclxuXHR9IGVsc2UgaWYgKGNvZGUgJiA0KSB7IC8vIGJvdHRvbVxyXG5cdFx0eCA9IGEueCArIGR4ICogKG1pbi55IC0gYS55KSAvIGR5O1xyXG5cdFx0eSA9IG1pbi55O1xyXG5cclxuXHR9IGVsc2UgaWYgKGNvZGUgJiAyKSB7IC8vIHJpZ2h0XHJcblx0XHR4ID0gbWF4Lng7XHJcblx0XHR5ID0gYS55ICsgZHkgKiAobWF4LnggLSBhLngpIC8gZHg7XHJcblxyXG5cdH0gZWxzZSBpZiAoY29kZSAmIDEpIHsgLy8gbGVmdFxyXG5cdFx0eCA9IG1pbi54O1xyXG5cdFx0eSA9IGEueSArIGR5ICogKG1pbi54IC0gYS54KSAvIGR4O1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5ldyBQb2ludCh4LCB5LCByb3VuZCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfZ2V0Qml0Q29kZShwLCBib3VuZHMpIHtcclxuXHR2YXIgY29kZSA9IDA7XHJcblxyXG5cdGlmIChwLnggPCBib3VuZHMubWluLngpIHsgLy8gbGVmdFxyXG5cdFx0Y29kZSB8PSAxO1xyXG5cdH0gZWxzZSBpZiAocC54ID4gYm91bmRzLm1heC54KSB7IC8vIHJpZ2h0XHJcblx0XHRjb2RlIHw9IDI7XHJcblx0fVxyXG5cclxuXHRpZiAocC55IDwgYm91bmRzLm1pbi55KSB7IC8vIGJvdHRvbVxyXG5cdFx0Y29kZSB8PSA0O1xyXG5cdH0gZWxzZSBpZiAocC55ID4gYm91bmRzLm1heC55KSB7IC8vIHRvcFxyXG5cdFx0Y29kZSB8PSA4O1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGNvZGU7XHJcbn1cclxuXHJcbi8vIHNxdWFyZSBkaXN0YW5jZSAodG8gYXZvaWQgdW5uZWNlc3NhcnkgTWF0aC5zcXJ0IGNhbGxzKVxyXG5mdW5jdGlvbiBfc3FEaXN0KHAxLCBwMikge1xyXG5cdHZhciBkeCA9IHAyLnggLSBwMS54LFxyXG5cdCAgICBkeSA9IHAyLnkgLSBwMS55O1xyXG5cdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxufVxyXG5cclxuLy8gcmV0dXJuIGNsb3Nlc3QgcG9pbnQgb24gc2VnbWVudCBvciBkaXN0YW5jZSB0byB0aGF0IHBvaW50XHJcbmV4cG9ydCBmdW5jdGlvbiBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyLCBzcURpc3QpIHtcclxuXHR2YXIgeCA9IHAxLngsXHJcblx0ICAgIHkgPSBwMS55LFxyXG5cdCAgICBkeCA9IHAyLnggLSB4LFxyXG5cdCAgICBkeSA9IHAyLnkgLSB5LFxyXG5cdCAgICBkb3QgPSBkeCAqIGR4ICsgZHkgKiBkeSxcclxuXHQgICAgdDtcclxuXHJcblx0aWYgKGRvdCA+IDApIHtcclxuXHRcdHQgPSAoKHAueCAtIHgpICogZHggKyAocC55IC0geSkgKiBkeSkgLyBkb3Q7XHJcblxyXG5cdFx0aWYgKHQgPiAxKSB7XHJcblx0XHRcdHggPSBwMi54O1xyXG5cdFx0XHR5ID0gcDIueTtcclxuXHRcdH0gZWxzZSBpZiAodCA+IDApIHtcclxuXHRcdFx0eCArPSBkeCAqIHQ7XHJcblx0XHRcdHkgKz0gZHkgKiB0O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZHggPSBwLnggLSB4O1xyXG5cdGR5ID0gcC55IC0geTtcclxuXHJcblx0cmV0dXJuIHNxRGlzdCA/IGR4ICogZHggKyBkeSAqIGR5IDogbmV3IFBvaW50KHgsIHkpO1xyXG59XHJcblxyXG5cclxuLy8gQGZ1bmN0aW9uIGlzRmxhdChsYXRsbmdzOiBMYXRMbmdbXSk6IEJvb2xlYW5cclxuLy8gUmV0dXJucyB0cnVlIGlmIGBsYXRsbmdzYCBpcyBhIGZsYXQgYXJyYXksIGZhbHNlIGlzIG5lc3RlZC5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRmxhdChsYXRsbmdzKSB7XHJcblx0cmV0dXJuICFVdGlsLmlzQXJyYXkobGF0bG5nc1swXSkgfHwgKHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ3VuZGVmaW5lZCcpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX2ZsYXQobGF0bG5ncykge1xyXG5cdGNvbnNvbGUud2FybignRGVwcmVjYXRlZCB1c2Ugb2YgX2ZsYXQsIHBsZWFzZSB1c2UgTC5MaW5lVXRpbC5pc0ZsYXQgaW5zdGVhZC4nKTtcclxuXHRyZXR1cm4gaXNGbGF0KGxhdGxuZ3MpO1xyXG59XHJcblxyXG4vKiBAZnVuY3Rpb24gcG9seWxpbmVDZW50ZXIobGF0bG5nczogTGF0TG5nW10sIGNyczogQ1JTKTogTGF0TG5nXHJcbiAqIFJldHVybnMgdGhlIGNlbnRlciAoW2NlbnRyb2lkXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIHBhc3NlZCBMYXRMbmdzIChmaXJzdCByaW5nKSBmcm9tIGEgcG9seWxpbmUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcG9seWxpbmVDZW50ZXIobGF0bG5ncywgY3JzKSB7XHJcblx0dmFyIGksIGhhbGZEaXN0LCBzZWdEaXN0LCBkaXN0LCBwMSwgcDIsIHJhdGlvLCBjZW50ZXI7XHJcblxyXG5cdGlmICghbGF0bG5ncyB8fCBsYXRsbmdzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdsYXRsbmdzIG5vdCBwYXNzZWQnKTtcclxuXHR9XHJcblxyXG5cdGlmICghaXNGbGF0KGxhdGxuZ3MpKSB7XHJcblx0XHRjb25zb2xlLndhcm4oJ2xhdGxuZ3MgYXJlIG5vdCBmbGF0ISBPbmx5IHRoZSBmaXJzdCByaW5nIHdpbGwgYmUgdXNlZCcpO1xyXG5cdFx0bGF0bG5ncyA9IGxhdGxuZ3NbMF07XHJcblx0fVxyXG5cclxuXHR2YXIgY2VudHJvaWRMYXRMbmcgPSB0b0xhdExuZyhbMCwgMF0pO1xyXG5cclxuXHR2YXIgYm91bmRzID0gdG9MYXRMbmdCb3VuZHMobGF0bG5ncyk7XHJcblx0dmFyIGFyZWFCb3VuZHMgPSBib3VuZHMuZ2V0Tm9ydGhXZXN0KCkuZGlzdGFuY2VUbyhib3VuZHMuZ2V0U291dGhXZXN0KCkpICogYm91bmRzLmdldE5vcnRoRWFzdCgpLmRpc3RhbmNlVG8oYm91bmRzLmdldE5vcnRoV2VzdCgpKTtcclxuXHQvLyB0ZXN0cyBzaG93ZWQgdGhhdCBiZWxvdyAxNzAwIHJvdW5kaW5nIGVycm9ycyBhcmUgaGFwcGVuaW5nXHJcblx0aWYgKGFyZWFCb3VuZHMgPCAxNzAwKSB7XHJcblx0XHQvLyBnZXR0aW5nIGEgaW5leGFjdCBjZW50ZXIsIHRvIG1vdmUgdGhlIGxhdGxuZ3MgbmVhciB0byBbMCwgMF0gdG8gcHJldmVudCByb3VuZGluZyBlcnJvcnNcclxuXHRcdGNlbnRyb2lkTGF0TG5nID0gY2VudHJvaWQobGF0bG5ncyk7XHJcblx0fVxyXG5cclxuXHR2YXIgbGVuID0gbGF0bG5ncy5sZW5ndGg7XHJcblx0dmFyIHBvaW50cyA9IFtdO1xyXG5cdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dmFyIGxhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZ3NbaV0pO1xyXG5cdFx0cG9pbnRzLnB1c2goY3JzLnByb2plY3QodG9MYXRMbmcoW2xhdGxuZy5sYXQgLSBjZW50cm9pZExhdExuZy5sYXQsIGxhdGxuZy5sbmcgLSBjZW50cm9pZExhdExuZy5sbmddKSkpO1xyXG5cdH1cclxuXHJcblx0Zm9yIChpID0gMCwgaGFsZkRpc3QgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XHJcblx0XHRoYWxmRGlzdCArPSBwb2ludHNbaV0uZGlzdGFuY2VUbyhwb2ludHNbaSArIDFdKSAvIDI7XHJcblx0fVxyXG5cclxuXHQvLyBUaGUgbGluZSBpcyBzbyBzbWFsbCBpbiB0aGUgY3VycmVudCB2aWV3IHRoYXQgYWxsIHBvaW50cyBhcmUgb24gdGhlIHNhbWUgcGl4ZWwuXHJcblx0aWYgKGhhbGZEaXN0ID09PSAwKSB7XHJcblx0XHRjZW50ZXIgPSBwb2ludHNbMF07XHJcblx0fSBlbHNlIHtcclxuXHRcdGZvciAoaSA9IDAsIGRpc3QgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XHJcblx0XHRcdHAxID0gcG9pbnRzW2ldO1xyXG5cdFx0XHRwMiA9IHBvaW50c1tpICsgMV07XHJcblx0XHRcdHNlZ0Rpc3QgPSBwMS5kaXN0YW5jZVRvKHAyKTtcclxuXHRcdFx0ZGlzdCArPSBzZWdEaXN0O1xyXG5cclxuXHRcdFx0aWYgKGRpc3QgPiBoYWxmRGlzdCkge1xyXG5cdFx0XHRcdHJhdGlvID0gKGRpc3QgLSBoYWxmRGlzdCkgLyBzZWdEaXN0O1xyXG5cdFx0XHRcdGNlbnRlciA9IFtcclxuXHRcdFx0XHRcdHAyLnggLSByYXRpbyAqIChwMi54IC0gcDEueCksXHJcblx0XHRcdFx0XHRwMi55IC0gcmF0aW8gKiAocDIueSAtIHAxLnkpXHJcblx0XHRcdFx0XTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0dmFyIGxhdGxuZ0NlbnRlciA9IGNycy51bnByb2plY3QodG9Qb2ludChjZW50ZXIpKTtcclxuXHRyZXR1cm4gdG9MYXRMbmcoW2xhdGxuZ0NlbnRlci5sYXQgKyBjZW50cm9pZExhdExuZy5sYXQsIGxhdGxuZ0NlbnRlci5sbmcgKyBjZW50cm9pZExhdExuZy5sbmddKTtcclxufVxyXG4iLCJpbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vTGF0TG5nJztcclxuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gKiBAc2VjdGlvblxyXG4gKiBMZWFmbGV0IGNvbWVzIHdpdGggYSBzZXQgb2YgYWxyZWFkeSBkZWZpbmVkIFByb2plY3Rpb25zIG91dCBvZiB0aGUgYm94OlxyXG4gKlxyXG4gKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTG9uTGF0XHJcbiAqXHJcbiAqIEVxdWlyZWN0YW5ndWxhciwgb3IgUGxhdGUgQ2FycmVlIHByb2plY3Rpb24g4oCUIHRoZSBtb3N0IHNpbXBsZSBwcm9qZWN0aW9uLFxyXG4gKiBtb3N0bHkgdXNlZCBieSBHSVMgZW50aHVzaWFzdHMuIERpcmVjdGx5IG1hcHMgYHhgIGFzIGxvbmdpdHVkZSwgYW5kIGB5YCBhc1xyXG4gKiBsYXRpdHVkZS4gQWxzbyBzdWl0YWJsZSBmb3IgZmxhdCB3b3JsZHMsIGUuZy4gZ2FtZSBtYXBzLiBVc2VkIGJ5IHRoZVxyXG4gKiBgRVBTRzo0MzI2YCBhbmQgYFNpbXBsZWAgQ1JTLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTG9uTGF0ID0ge1xyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQobGF0bG5nLmxuZywgbGF0bG5nLmxhdCk7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHBvaW50LnksIHBvaW50LngpO1xyXG5cdH0sXHJcblxyXG5cdGJvdW5kczogbmV3IEJvdW5kcyhbLTE4MCwgLTkwXSwgWzE4MCwgOTBdKVxyXG59O1xyXG4iLCJpbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vTGF0TG5nJztcclxuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTWVyY2F0b3JcclxuICpcclxuICogRWxsaXB0aWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uIOKAlCBtb3JlIGNvbXBsZXggdGhhbiBTcGhlcmljYWwgTWVyY2F0b3IuIEFzc3VtZXMgdGhhdCBFYXJ0aCBpcyBhbiBlbGxpcHNvaWQuIFVzZWQgYnkgdGhlIEVQU0c6MzM5NSBDUlMuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBNZXJjYXRvciA9IHtcclxuXHRSOiA2Mzc4MTM3LFxyXG5cdFJfTUlOT1I6IDYzNTY3NTIuMzE0MjQ1MTc5LFxyXG5cclxuXHRib3VuZHM6IG5ldyBCb3VuZHMoWy0yMDAzNzUwOC4zNDI3OSwgLTE1NDk2NTcwLjczOTcyXSwgWzIwMDM3NTA4LjM0Mjc5LCAxODc2NDY1Ni4yMzEzOF0pLFxyXG5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXHJcblx0XHQgICAgciA9IHRoaXMuUixcclxuXHRcdCAgICB5ID0gbGF0bG5nLmxhdCAqIGQsXHJcblx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuXHRcdCAgICBlID0gTWF0aC5zcXJ0KDEgLSB0bXAgKiB0bXApLFxyXG5cdFx0ICAgIGNvbiA9IGUgKiBNYXRoLnNpbih5KTtcclxuXHJcblx0XHR2YXIgdHMgPSBNYXRoLnRhbihNYXRoLlBJIC8gNCAtIHkgLyAyKSAvIE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZSAvIDIpO1xyXG5cdFx0eSA9IC1yICogTWF0aC5sb2coTWF0aC5tYXgodHMsIDFFLTEwKSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nICogZCAqIHIsIHkpO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgZCA9IDE4MCAvIE1hdGguUEksXHJcblx0XHQgICAgciA9IHRoaXMuUixcclxuXHRcdCAgICB0bXAgPSB0aGlzLlJfTUlOT1IgLyByLFxyXG5cdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXHJcblx0XHQgICAgdHMgPSBNYXRoLmV4cCgtcG9pbnQueSAvIHIpLFxyXG5cdFx0ICAgIHBoaSA9IE1hdGguUEkgLyAyIC0gMiAqIE1hdGguYXRhbih0cyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGRwaGkgPSAwLjEsIGNvbjsgaSA8IDE1ICYmIE1hdGguYWJzKGRwaGkpID4gMWUtNzsgaSsrKSB7XHJcblx0XHRcdGNvbiA9IGUgKiBNYXRoLnNpbihwaGkpO1xyXG5cdFx0XHRjb24gPSBNYXRoLnBvdygoMSAtIGNvbikgLyAoMSArIGNvbiksIGUgLyAyKTtcclxuXHRcdFx0ZHBoaSA9IE1hdGguUEkgLyAyIC0gMiAqIE1hdGguYXRhbih0cyAqIGNvbikgLSBwaGk7XHJcblx0XHRcdHBoaSArPSBkcGhpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHBoaSAqIGQsIHBvaW50LnggKiBkIC8gcik7XHJcblx0fVxyXG59O1xyXG4iLCIvKlxuICogQGNsYXNzIFByb2plY3Rpb25cblxuICogQW4gb2JqZWN0IHdpdGggbWV0aG9kcyBmb3IgcHJvamVjdGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHdvcmxkIG9udG9cbiAqIGEgZmxhdCBzdXJmYWNlIChhbmQgYmFjaykuIFNlZSBbTWFwIHByb2plY3Rpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcF9wcm9qZWN0aW9uKS5cblxuICogQHByb3BlcnR5IGJvdW5kczogQm91bmRzXG4gKiBUaGUgYm91bmRzIChzcGVjaWZpZWQgaW4gQ1JTIHVuaXRzKSB3aGVyZSB0aGUgcHJvamVjdGlvbiBpcyB2YWxpZFxuXG4gKiBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxuICogUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gYSAyRCBwb2ludC5cbiAqIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuTGF0TG5nYCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXG5cbiAqIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCk6IExhdExuZ1xuICogVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLiBQcm9qZWN0cyBhIDJEIHBvaW50IGludG8gYSBnZW9ncmFwaGljYWwgbG9jYXRpb24uXG4gKiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXG5cbiAqIE5vdGUgdGhhdCB0aGUgcHJvamVjdGlvbiBpbnN0YW5jZXMgZG8gbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXG4gKiBhbmQgY2FuJ3QgYmUgaW5zdGFudGlhdGVkLiBBbHNvLCBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gdGhlbSxcbiAqIGFuZCBtZXRob2RzIGNhbid0IGJlIGFkZGVkIHRvIHRoZW0gd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxuXG4gKi9cblxuZXhwb3J0IHtMb25MYXR9IGZyb20gJy4vUHJvamVjdGlvbi5Mb25MYXQnO1xuZXhwb3J0IHtNZXJjYXRvcn0gZnJvbSAnLi9Qcm9qZWN0aW9uLk1lcmNhdG9yJztcbmV4cG9ydCB7U3BoZXJpY2FsTWVyY2F0b3J9IGZyb20gJy4vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvcic7XG4iLCJpbXBvcnQge0VhcnRofSBmcm9tICcuL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7TWVyY2F0b3J9IGZyb20gJy4uL3Byb2plY3Rpb24vUHJvamVjdGlvbi5NZXJjYXRvcic7XHJcbmltcG9ydCB7dG9UcmFuc2Zvcm1hdGlvbn0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24nO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0czMzk1XHJcbiAqXHJcbiAqIFJhcmVseSB1c2VkIGJ5IHNvbWUgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gVXNlcyBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24uXHJcbiAqL1xyXG5leHBvcnQgdmFyIEVQU0czMzk1ID0gVXRpbC5leHRlbmQoe30sIEVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6MzM5NScsXHJcblx0cHJvamVjdGlvbjogTWVyY2F0b3IsXHJcblxyXG5cdHRyYW5zZm9ybWF0aW9uOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHNjYWxlID0gMC41IC8gKE1hdGguUEkgKiBNZXJjYXRvci5SKTtcclxuXHRcdHJldHVybiB0b1RyYW5zZm9ybWF0aW9uKHNjYWxlLCAwLjUsIC1zY2FsZSwgMC41KTtcclxuXHR9KCkpXHJcbn0pO1xyXG4iLCJpbXBvcnQge0VhcnRofSBmcm9tICcuL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7TG9uTGF0fSBmcm9tICcuLi9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTG9uTGF0JztcclxuaW1wb3J0IHt0b1RyYW5zZm9ybWF0aW9ufSBmcm9tICcuLi8uLi9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzQzMjZcclxuICpcclxuICogQSBjb21tb24gQ1JTIGFtb25nIEdJUyBlbnRodXNpYXN0cy4gVXNlcyBzaW1wbGUgRXF1aXJlY3Rhbmd1bGFyIHByb2plY3Rpb24uXHJcbiAqXHJcbiAqIExlYWZsZXQgMS4wLnggY29tcGxpZXMgd2l0aCB0aGUgW1RNUyBjb29yZGluYXRlIHNjaGVtZSBmb3IgRVBTRzo0MzI2XShodHRwczovL3dpa2kub3NnZW8ub3JnL3dpa2kvVGlsZV9NYXBfU2VydmljZV9TcGVjaWZpY2F0aW9uI2dsb2JhbC1nZW9kZXRpYyksXHJcbiAqIHdoaWNoIGlzIGEgYnJlYWtpbmcgY2hhbmdlIGZyb20gMC43LnggYmVoYXZpb3VyLiAgSWYgeW91IGFyZSB1c2luZyBhIGBUaWxlTGF5ZXJgXHJcbiAqIHdpdGggdGhpcyBDUlMsIGVuc3VyZSB0aGF0IHRoZXJlIGFyZSB0d28gMjU2eDI1NiBwaXhlbCB0aWxlcyBjb3ZlcmluZyB0aGVcclxuICogd2hvbGUgZWFydGggYXQgem9vbSBsZXZlbCB6ZXJvLCBhbmQgdGhhdCB0aGUgdGlsZSBjb29yZGluYXRlIG9yaWdpbiBpcyAoLTE4MCwrOTApLFxyXG4gKiBvciAoLTE4MCwtOTApIGZvciBgVGlsZUxheWVyYHMgd2l0aCBbdGhlIGB0bXNgIG9wdGlvbl0oI3RpbGVsYXllci10bXMpIHNldC5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIEVQU0c0MzI2ID0gVXRpbC5leHRlbmQoe30sIEVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6NDMyNicsXHJcblx0cHJvamVjdGlvbjogTG9uTGF0LFxyXG5cdHRyYW5zZm9ybWF0aW9uOiB0b1RyYW5zZm9ybWF0aW9uKDEgLyAxODAsIDEsIC0xIC8gMTgwLCAwLjUpXHJcbn0pO1xyXG4iLCJpbXBvcnQge0NSU30gZnJvbSAnLi9DUlMnO1xuaW1wb3J0IHtMb25MYXR9IGZyb20gJy4uL3Byb2plY3Rpb24vUHJvamVjdGlvbi5Mb25MYXQnO1xuaW1wb3J0IHt0b1RyYW5zZm9ybWF0aW9ufSBmcm9tICcuLi8uLi9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBAbmFtZXNwYWNlIENSU1xuICogQGNycyBMLkNSUy5TaW1wbGVcbiAqXG4gKiBBIHNpbXBsZSBDUlMgdGhhdCBtYXBzIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgaW50byBgeGAgYW5kIGB5YCBkaXJlY3RseS5cbiAqIE1heSBiZSB1c2VkIGZvciBtYXBzIG9mIGZsYXQgc3VyZmFjZXMgKGUuZy4gZ2FtZSBtYXBzKS4gTm90ZSB0aGF0IHRoZSBgeWBcbiAqIGF4aXMgc2hvdWxkIHN0aWxsIGJlIGludmVydGVkIChnb2luZyBmcm9tIGJvdHRvbSB0byB0b3ApLiBgZGlzdGFuY2UoKWAgcmV0dXJuc1xuICogc2ltcGxlIGV1Y2xpZGVhbiBkaXN0YW5jZS5cbiAqL1xuXG5leHBvcnQgdmFyIFNpbXBsZSA9IFV0aWwuZXh0ZW5kKHt9LCBDUlMsIHtcblx0cHJvamVjdGlvbjogTG9uTGF0LFxuXHR0cmFuc2Zvcm1hdGlvbjogdG9UcmFuc2Zvcm1hdGlvbigxLCAwLCAtMSwgMCksXG5cblx0c2NhbGU6IGZ1bmN0aW9uICh6b29tKSB7XG5cdFx0cmV0dXJuIE1hdGgucG93KDIsIHpvb20pO1xuXHR9LFxuXG5cdHpvb206IGZ1bmN0aW9uIChzY2FsZSkge1xuXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSkgLyBNYXRoLkxOMjtcblx0fSxcblxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcblx0XHR2YXIgZHggPSBsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nLFxuXHRcdCAgICBkeSA9IGxhdGxuZzIubGF0IC0gbGF0bG5nMS5sYXQ7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0fSxcblxuXHRpbmZpbml0ZTogdHJ1ZVxufSk7XG4iLCJpbXBvcnQge0NSU30gZnJvbSAnLi9DUlMnO1xuaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9DUlMuRWFydGgnO1xuaW1wb3J0IHtFUFNHMzM5NX0gZnJvbSAnLi9DUlMuRVBTRzMzOTUnO1xuaW1wb3J0IHtFUFNHMzg1NywgRVBTRzkwMDkxM30gZnJvbSAnLi9DUlMuRVBTRzM4NTcnO1xuaW1wb3J0IHtFUFNHNDMyNn0gZnJvbSAnLi9DUlMuRVBTRzQzMjYnO1xuaW1wb3J0IHtTaW1wbGV9IGZyb20gJy4vQ1JTLlNpbXBsZSc7XG5cbkNSUy5FYXJ0aCA9IEVhcnRoO1xuQ1JTLkVQU0czMzk1ID0gRVBTRzMzOTU7XG5DUlMuRVBTRzM4NTcgPSBFUFNHMzg1NztcbkNSUy5FUFNHOTAwOTEzID0gRVBTRzkwMDkxMztcbkNSUy5FUFNHNDMyNiA9IEVQU0c0MzI2O1xuQ1JTLlNpbXBsZSA9IFNpbXBsZTtcblxuZXhwb3J0IHtDUlN9O1xuIiwiaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuLi9jb3JlL0V2ZW50cyc7XG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgTGF5ZXJcbiAqIEBpbmhlcml0cyBFdmVudGVkXG4gKiBAYWthIEwuTGF5ZXJcbiAqIEBha2EgSUxheWVyXG4gKlxuICogQSBzZXQgb2YgbWV0aG9kcyBmcm9tIHRoZSBMYXllciBiYXNlIGNsYXNzIHRoYXQgYWxsIExlYWZsZXQgbGF5ZXJzIHVzZS5cbiAqIEluaGVyaXRzIGFsbCBtZXRob2RzLCBvcHRpb25zIGFuZCBldmVudHMgZnJvbSBgTC5FdmVudGVkYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF5ZXIgPSBMLm1hcmtlcihsYXRsbmcpLmFkZFRvKG1hcCk7XG4gKiBsYXllci5hZGRUbyhtYXApO1xuICogbGF5ZXIucmVtb3ZlKCk7XG4gKiBgYGBcbiAqXG4gKiBAZXZlbnQgYWRkOiBFdmVudFxuICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIGFkZGVkIHRvIGEgbWFwXG4gKlxuICogQGV2ZW50IHJlbW92ZTogRXZlbnRcbiAqIEZpcmVkIGFmdGVyIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gYSBtYXBcbiAqL1xuXG5cbmV4cG9ydCB2YXIgTGF5ZXIgPSBFdmVudGVkLmV4dGVuZCh7XG5cblx0Ly8gQ2xhc3NlcyBleHRlbmRpbmcgYEwuTGF5ZXJgIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG9wdGlvbnM6XG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdvdmVybGF5UGFuZSdcblx0XHQvLyBCeSBkZWZhdWx0IHRoZSBsYXllciB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtYXAncyBbb3ZlcmxheSBwYW5lXSgjbWFwLW92ZXJsYXlwYW5lKS4gT3ZlcnJpZGluZyB0aGlzIG9wdGlvbiB3aWxsIGNhdXNlIHRoZSBsYXllciB0byBiZSBwbGFjZWQgb24gYW5vdGhlciBwYW5lIGJ5IGRlZmF1bHQuXG5cdFx0cGFuZTogJ292ZXJsYXlQYW5lJyxcblxuXHRcdC8vIEBvcHRpb24gYXR0cmlidXRpb246IFN0cmluZyA9IG51bGxcblx0XHQvLyBTdHJpbmcgdG8gYmUgc2hvd24gaW4gdGhlIGF0dHJpYnV0aW9uIGNvbnRyb2wsIGUuZy4gXCLCqSBPcGVuU3RyZWV0TWFwIGNvbnRyaWJ1dG9yc1wiLiBJdCBkZXNjcmliZXMgdGhlIGxheWVyIGRhdGEgYW5kIGlzIG9mdGVuIGEgbGVnYWwgb2JsaWdhdGlvbiB0b3dhcmRzIGNvcHlyaWdodCBob2xkZXJzIGFuZCB0aWxlIHByb3ZpZGVycy5cblx0XHRhdHRyaWJ1dGlvbjogbnVsbCxcblxuXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IHRydWVcblx0fSxcblxuXHQvKiBAc2VjdGlvblxuXHQgKiBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcblx0ICpcblx0ICogQG1ldGhvZCBhZGRUbyhtYXA6IE1hcHxMYXllckdyb3VwKTogdGhpc1xuXHQgKiBBZGRzIHRoZSBsYXllciB0byB0aGUgZ2l2ZW4gbWFwIG9yIGxheWVyIGdyb3VwLlxuXHQgKi9cblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAuYWRkTGF5ZXIodGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmU6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgbWFwIGl0IGlzIGN1cnJlbnRseSBhY3RpdmUgb24uXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnJlbW92ZUZyb20odGhpcy5fbWFwIHx8IHRoaXMuX21hcFRvQWRkKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZUZyb20obWFwOiBNYXApOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIGdpdmVuIG1hcFxuXHQvL1xuXHQvLyBAYWx0ZXJuYXRpdmVcblx0Ly8gQG1ldGhvZCByZW1vdmVGcm9tKGdyb3VwOiBMYXllckdyb3VwKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBnaXZlbiBgTGF5ZXJHcm91cGBcblx0cmVtb3ZlRnJvbTogZnVuY3Rpb24gKG9iaikge1xuXHRcdGlmIChvYmopIHtcblx0XHRcdG9iai5yZW1vdmVMYXllcih0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRQYW5lKG5hbWU/IDogU3RyaW5nKTogSFRNTEVsZW1lbnRcblx0Ly8gUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCByZXByZXNlbnRpbmcgdGhlIG5hbWVkIHBhbmUgb24gdGhlIG1hcC4gSWYgYG5hbWVgIGlzIG9taXR0ZWQsIHJldHVybnMgdGhlIHBhbmUgZm9yIHRoaXMgbGF5ZXIuXG5cdGdldFBhbmU6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hcC5nZXRQYW5lKG5hbWUgPyAodGhpcy5vcHRpb25zW25hbWVdIHx8IG5hbWUpIDogdGhpcy5vcHRpb25zLnBhbmUpO1xuXHR9LFxuXG5cdGFkZEludGVyYWN0aXZlVGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0RWwpIHtcblx0XHR0aGlzLl9tYXAuX3RhcmdldHNbVXRpbC5zdGFtcCh0YXJnZXRFbCldID0gdGhpcztcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVJbnRlcmFjdGl2ZVRhcmdldDogZnVuY3Rpb24gKHRhcmdldEVsKSB7XG5cdFx0ZGVsZXRlIHRoaXMuX21hcC5fdGFyZ2V0c1tVdGlsLnN0YW1wKHRhcmdldEVsKV07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRBdHRyaWJ1dGlvbjogU3RyaW5nXG5cdC8vIFVzZWQgYnkgdGhlIGBhdHRyaWJ1dGlvbiBjb250cm9sYCwgcmV0dXJucyB0aGUgW2F0dHJpYnV0aW9uIG9wdGlvbl0oI2dyaWRsYXllci1hdHRyaWJ1dGlvbikuXG5cdGdldEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbjtcblx0fSxcblxuXHRfbGF5ZXJBZGQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IGUudGFyZ2V0O1xuXG5cdFx0Ly8gY2hlY2sgaW4gY2FzZSBsYXllciBnZXRzIGFkZGVkIGFuZCB0aGVuIHJlbW92ZWQgYmVmb3JlIHRoZSBtYXAgaXMgcmVhZHlcblx0XHRpZiAoIW1hcC5oYXNMYXllcih0aGlzKSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBtYXAuX3pvb21BbmltYXRlZDtcblxuXHRcdGlmICh0aGlzLmdldEV2ZW50cykge1xuXHRcdFx0dmFyIGV2ZW50cyA9IHRoaXMuZ2V0RXZlbnRzKCk7XG5cdFx0XHRtYXAub24oZXZlbnRzLCB0aGlzKTtcblx0XHRcdHRoaXMub25jZSgncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRtYXAub2ZmKGV2ZW50cywgdGhpcyk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLm9uQWRkKG1hcCk7XG5cblx0XHR0aGlzLmZpcmUoJ2FkZCcpO1xuXHRcdG1hcC5maXJlKCdsYXllcmFkZCcsIHtsYXllcjogdGhpc30pO1xuXHR9XG59KTtcblxuLyogQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcbiAqIEB1bmluaGVyaXRhYmxlXG4gKlxuICogRXZlcnkgbGF5ZXIgc2hvdWxkIGV4dGVuZCBmcm9tIGBMLkxheWVyYCBhbmQgKHJlLSlpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2RzLlxuICpcbiAqIEBtZXRob2Qgb25BZGQobWFwOiBNYXApOiB0aGlzXG4gKiBTaG91bGQgY29udGFpbiBjb2RlIHRoYXQgY3JlYXRlcyBET00gZWxlbWVudHMgZm9yIHRoZSBsYXllciwgYWRkcyB0aGVtIHRvIGBtYXAgcGFuZXNgIHdoZXJlIHRoZXkgc2hvdWxkIGJlbG9uZyBhbmQgcHV0cyBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLlxuICpcbiAqIEBtZXRob2Qgb25SZW1vdmUobWFwOiBNYXApOiB0aGlzXG4gKiBTaG91bGQgY29udGFpbiBhbGwgY2xlYW4gdXAgY29kZSB0aGF0IHJlbW92ZXMgdGhlIGxheWVyJ3MgZWxlbWVudHMgZnJvbSB0aGUgRE9NIGFuZCByZW1vdmVzIGxpc3RlbmVycyBwcmV2aW91c2x5IGFkZGVkIGluIFtgb25BZGRgXSgjbGF5ZXItb25hZGQpLiBDYWxsZWQgb24gW2BtYXAucmVtb3ZlTGF5ZXIobGF5ZXIpYF0oI21hcC1yZW1vdmVsYXllcikuXG4gKlxuICogQG1ldGhvZCBnZXRFdmVudHMoKTogT2JqZWN0XG4gKiBUaGlzIG9wdGlvbmFsIG1ldGhvZCBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCBsaWtlIGB7IHZpZXdyZXNldDogdGhpcy5fcmVzZXQgfWAgZm9yIFtgYWRkRXZlbnRMaXN0ZW5lcmBdKCNldmVudGVkLWFkZGV2ZW50bGlzdGVuZXIpLiBUaGUgZXZlbnQgaGFuZGxlcnMgaW4gdGhpcyBvYmplY3Qgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFkZGVkIGFuZCByZW1vdmVkIGZyb20gdGhlIG1hcCB3aXRoIHlvdXIgbGF5ZXIuXG4gKlxuICogQG1ldGhvZCBnZXRBdHRyaWJ1dGlvbigpOiBTdHJpbmdcbiAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYSBzdHJpbmcgY29udGFpbmluZyBIVE1MIHRvIGJlIHNob3duIG9uIHRoZSBgQXR0cmlidXRpb24gY29udHJvbGAgd2hlbmV2ZXIgdGhlIGxheWVyIGlzIHZpc2libGUuXG4gKlxuICogQG1ldGhvZCBiZWZvcmVBZGQobWFwOiBNYXApOiB0aGlzXG4gKiBPcHRpb25hbCBtZXRob2QuIENhbGxlZCBvbiBbYG1hcC5hZGRMYXllcihsYXllcilgXSgjbWFwLWFkZGxheWVyKSwgYmVmb3JlIHRoZSBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLCBiZWZvcmUgZXZlbnRzIGFyZSBpbml0aWFsaXplZCwgd2l0aG91dCB3YWl0aW5nIHVudGlsIHRoZSBtYXAgaXMgaW4gYSB1c2FibGUgc3RhdGUuIFVzZSBmb3IgZWFybHkgaW5pdGlhbGl6YXRpb24gb25seS5cbiAqL1xuXG5cbi8qIEBuYW1lc3BhY2UgTWFwXG4gKiBAc2VjdGlvbiBMYXllciBldmVudHNcbiAqXG4gKiBAZXZlbnQgbGF5ZXJhZGQ6IExheWVyRXZlbnRcbiAqIEZpcmVkIHdoZW4gYSBuZXcgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcC5cbiAqXG4gKiBAZXZlbnQgbGF5ZXJyZW1vdmU6IExheWVyRXZlbnRcbiAqIEZpcmVkIHdoZW4gc29tZSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcFxuICpcbiAqIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbiAqL1xuTWFwLmluY2x1ZGUoe1xuXHQvLyBAbWV0aG9kIGFkZExheWVyKGxheWVyOiBMYXllcik6IHRoaXNcblx0Ly8gQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIG1hcFxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCFsYXllci5fbGF5ZXJBZGQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignVGhlIHByb3ZpZGVkIG9iamVjdCBpcyBub3QgYSBMYXllci4nKTtcblx0XHR9XG5cblx0XHR2YXIgaWQgPSBVdGlsLnN0YW1wKGxheWVyKTtcblx0XHRpZiAodGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcblxuXHRcdGxheWVyLl9tYXBUb0FkZCA9IHRoaXM7XG5cblx0XHRpZiAobGF5ZXIuYmVmb3JlQWRkKSB7XG5cdFx0XHRsYXllci5iZWZvcmVBZGQodGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy53aGVuUmVhZHkobGF5ZXIuX2xheWVyQWRkLCBsYXllcik7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgbWFwLlxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGlkID0gVXRpbC5zdGFtcChsYXllcik7XG5cblx0XHRpZiAoIXRoaXMuX2xheWVyc1tpZF0pIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcblx0XHRcdGxheWVyLm9uUmVtb3ZlKHRoaXMpO1xuXHRcdH1cblxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xuXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuXHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcblx0XHRcdGxheWVyLmZpcmUoJ3JlbW92ZScpO1xuXHRcdH1cblxuXHRcdGxheWVyLl9tYXAgPSBsYXllci5fbWFwVG9BZGQgPSBudWxsO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBoYXNMYXllcihsYXllcjogTGF5ZXIpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIG1hcFxuXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0cmV0dXJuIFV0aWwuc3RhbXAobGF5ZXIpIGluIHRoaXMuX2xheWVycztcblx0fSxcblxuXHQvKiBAbWV0aG9kIGVhY2hMYXllcihmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXG5cdCAqIEl0ZXJhdGVzIG92ZXIgdGhlIGxheWVycyBvZiB0aGUgbWFwLCBvcHRpb25hbGx5IHNwZWNpZnlpbmcgY29udGV4dCBvZiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24uXG5cdCAqIGBgYFxuXHQgKiBtYXAuZWFjaExheWVyKGZ1bmN0aW9uKGxheWVyKXtcblx0ICogICAgIGxheWVyLmJpbmRQb3B1cCgnSGVsbG8nKTtcblx0ICogfSk7XG5cdCAqIGBgYFxuXHQgKi9cblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9hZGRMYXllcnM6IGZ1bmN0aW9uIChsYXllcnMpIHtcblx0XHRsYXllcnMgPSBsYXllcnMgPyAoVXRpbC5pc0FycmF5KGxheWVycykgPyBsYXllcnMgOiBbbGF5ZXJzXSkgOiBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcblx0XHR9XG5cdH0sXG5cblx0X2FkZFpvb21MaW1pdDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCFpc05hTihsYXllci5vcHRpb25zLm1heFpvb20pIHx8ICFpc05hTihsYXllci5vcHRpb25zLm1pblpvb20pKSB7XG5cdFx0XHR0aGlzLl96b29tQm91bmRMYXllcnNbVXRpbC5zdGFtcChsYXllcildID0gbGF5ZXI7XG5cdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVab29tTGltaXQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBpZCA9IFV0aWwuc3RhbXAobGF5ZXIpO1xuXG5cdFx0aWYgKHRoaXMuX3pvb21Cb3VuZExheWVyc1tpZF0pIHtcblx0XHRcdGRlbGV0ZSB0aGlzLl96b29tQm91bmRMYXllcnNbaWRdO1xuXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlWm9vbUxldmVsczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtaW5ab29tID0gSW5maW5pdHksXG5cdFx0ICAgIG1heFpvb20gPSAtSW5maW5pdHksXG5cdFx0ICAgIG9sZFpvb21TcGFuID0gdGhpcy5fZ2V0Wm9vbVNwYW4oKTtcblxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fem9vbUJvdW5kTGF5ZXJzKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuX3pvb21Cb3VuZExheWVyc1tpXS5vcHRpb25zO1xuXG5cdFx0XHRtaW5ab29tID0gb3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgPyBtaW5ab29tIDogTWF0aC5taW4obWluWm9vbSwgb3B0aW9ucy5taW5ab29tKTtcblx0XHRcdG1heFpvb20gPSBvcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCA/IG1heFpvb20gOiBNYXRoLm1heChtYXhab29tLCBvcHRpb25zLm1heFpvb20pO1xuXHRcdH1cblxuXHRcdHRoaXMuX2xheWVyc01heFpvb20gPSBtYXhab29tID09PSAtSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtYXhab29tO1xuXHRcdHRoaXMuX2xheWVyc01pblpvb20gPSBtaW5ab29tID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IG1pblpvb207XG5cblx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xuXHRcdC8vIEBldmVudCB6b29tbGV2ZWxzY2hhbmdlOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG51bWJlciBvZiB6b29tbGV2ZWxzIG9uIHRoZSBtYXAgaXMgY2hhbmdlZCBkdWVcblx0XHQvLyB0byBhZGRpbmcgb3IgcmVtb3ZpbmcgYSBsYXllci5cblx0XHRpZiAob2xkWm9vbVNwYW4gIT09IHRoaXMuX2dldFpvb21TcGFuKCkpIHtcblx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2xheWVyc01heFpvb20gJiYgdGhpcy5nZXRab29tKCkgPiB0aGlzLl9sYXllcnNNYXhab29tKSB7XG5cdFx0XHR0aGlzLnNldFpvb20odGhpcy5fbGF5ZXJzTWF4Wm9vbSk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2xheWVyc01pblpvb20gJiYgdGhpcy5nZXRab29tKCkgPCB0aGlzLl9sYXllcnNNaW5ab29tKSB7XG5cdFx0XHR0aGlzLnNldFpvb20odGhpcy5fbGF5ZXJzTWluWm9vbSk7XG5cdFx0fVxuXHR9XG59KTtcbiIsIlxyXG5pbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIExheWVyR3JvdXBcclxuICogQGFrYSBMLkxheWVyR3JvdXBcclxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAqXHJcbiAqIFVzZWQgdG8gZ3JvdXAgc2V2ZXJhbCBsYXllcnMgYW5kIGhhbmRsZSB0aGVtIGFzIG9uZS4gSWYgeW91IGFkZCBpdCB0byB0aGUgbWFwLFxyXG4gKiBhbnkgbGF5ZXJzIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSB0aGUgZ3JvdXAgd2lsbCBiZSBhZGRlZC9yZW1vdmVkIG9uIHRoZSBtYXAgYXNcclxuICogd2VsbC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmxheWVyR3JvdXAoW21hcmtlcjEsIG1hcmtlcjJdKVxyXG4gKiBcdC5hZGRMYXllcihwb2x5bGluZSlcclxuICogXHQuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBMYXllckdyb3VwID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxheWVycywgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cclxuXHRcdHZhciBpLCBsZW47XHJcblxyXG5cdFx0aWYgKGxheWVycykge1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLmFkZExheWVyKGxheWVyc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZExheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBnaXZlbiBsYXllciB0byB0aGUgZ3JvdXAuXHJcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0dmFyIGlkID0gdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnNbaWRdID0gbGF5ZXI7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIobGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIGdyb3VwLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIoaWQ6IE51bWJlcik6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBpbnRlcm5hbCBJRCBmcm9tIHRoZSBncm91cC5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWQgPSBsYXllciBpbiB0aGlzLl9sYXllcnMgPyBsYXllciA6IHRoaXMuZ2V0TGF5ZXJJZChsYXllcik7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiB0aGlzLl9sYXllcnNbaWRdKSB7XHJcblx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYXllcnNbaWRdKTtcclxuXHRcdH1cclxuXHJcblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGhhc0xheWVyKGxheWVyOiBMYXllcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBncm91cC5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGhhc0xheWVyKGlkOiBOdW1iZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGludGVybmFsIElEIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcblx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0dmFyIGxheWVySWQgPSB0eXBlb2YgbGF5ZXIgPT09ICdudW1iZXInID8gbGF5ZXIgOiB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cdFx0cmV0dXJuIGxheWVySWQgaW4gdGhpcy5fbGF5ZXJzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xlYXJMYXllcnMoKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYWxsIHRoZSBsYXllcnMgZnJvbSB0aGUgZ3JvdXAuXHJcblx0Y2xlYXJMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmVhY2hMYXllcih0aGlzLnJlbW92ZUxheWVyLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludm9rZShtZXRob2ROYW1lOiBTdHJpbmcsIOKApik6IHRoaXNcclxuXHQvLyBDYWxscyBgbWV0aG9kTmFtZWAgb24gZXZlcnkgbGF5ZXIgY29udGFpbmVkIGluIHRoaXMgZ3JvdXAsIHBhc3NpbmcgYW55XHJcblx0Ly8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzLiBIYXMgbm8gZWZmZWN0IGlmIHRoZSBsYXllcnMgY29udGFpbmVkIGRvIG5vdFxyXG5cdC8vIGltcGxlbWVudCBgbWV0aG9kTmFtZWAuXHJcblx0aW52b2tlOiBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xyXG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxyXG5cdFx0ICAgIGksIGxheWVyO1xyXG5cclxuXHRcdGZvciAoaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaV07XHJcblxyXG5cdFx0XHRpZiAobGF5ZXJbbWV0aG9kTmFtZV0pIHtcclxuXHRcdFx0XHRsYXllclttZXRob2ROYW1lXS5hcHBseShsYXllciwgYXJncyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIobWFwLmFkZExheWVyLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLmVhY2hMYXllcihtYXAucmVtb3ZlTGF5ZXIsIG1hcCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlYWNoTGF5ZXIoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdC8vIEl0ZXJhdGVzIG92ZXIgdGhlIGxheWVycyBvZiB0aGUgZ3JvdXAsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBjb250ZXh0IG9mIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cclxuXHQvLyBgYGBqc1xyXG5cdC8vIGdyb3VwLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHQvLyBcdGxheWVyLmJpbmRQb3B1cCgnSGVsbG8nKTtcclxuXHQvLyB9KTtcclxuXHQvLyBgYGBcclxuXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExheWVyKGlkOiBOdW1iZXIpOiBMYXllclxyXG5cdC8vIFJldHVybnMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGludGVybmFsIElELlxyXG5cdGdldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXllcnNbaWRdO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXJzKCk6IExheWVyW11cclxuXHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUgbGF5ZXJzIGFkZGVkIHRvIHRoZSBncm91cC5cclxuXHRnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBsYXllcnMgPSBbXTtcclxuXHRcdHRoaXMuZWFjaExheWVyKGxheWVycy5wdXNoLCBsYXllcnMpO1xyXG5cdFx0cmV0dXJuIGxheWVycztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDYWxscyBgc2V0WkluZGV4YCBvbiBldmVyeSBsYXllciBjb250YWluZWQgaW4gdGhpcyBncm91cCwgcGFzc2luZyB0aGUgei1pbmRleC5cclxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnc2V0WkluZGV4JywgekluZGV4KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExheWVySWQobGF5ZXI6IExheWVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgaW50ZXJuYWwgSUQgZm9yIGEgbGF5ZXJcclxuXHRnZXRMYXllcklkOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHJldHVybiBVdGlsLnN0YW1wKGxheWVyKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF5ZXJHcm91cChsYXllcnM/OiBMYXllcltdLCBvcHRpb25zPzogT2JqZWN0KVxyXG4vLyBDcmVhdGUgYSBsYXllciBncm91cCwgb3B0aW9uYWxseSBnaXZlbiBhbiBpbml0aWFsIHNldCBvZiBsYXllcnMgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbmV4cG9ydCB2YXIgbGF5ZXJHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IExheWVyR3JvdXAobGF5ZXJzLCBvcHRpb25zKTtcclxufTtcclxuIiwiaW1wb3J0IHtMYXllckdyb3VwfSBmcm9tICcuL0xheWVyR3JvdXAnO1xyXG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRmVhdHVyZUdyb3VwXHJcbiAqIEBha2EgTC5GZWF0dXJlR3JvdXBcclxuICogQGluaGVyaXRzIExheWVyR3JvdXBcclxuICpcclxuICogRXh0ZW5kZWQgYExheWVyR3JvdXBgIHRoYXQgbWFrZXMgaXQgZWFzaWVyIHRvIGRvIHRoZSBzYW1lIHRoaW5nIHRvIGFsbCBpdHMgbWVtYmVyIGxheWVyczpcclxuICogICogW2BiaW5kUG9wdXBgXSgjbGF5ZXItYmluZHBvcHVwKSBiaW5kcyBhIHBvcHVwIHRvIGFsbCBvZiB0aGUgbGF5ZXJzIGF0IG9uY2UgKGxpa2V3aXNlIHdpdGggW2BiaW5kVG9vbHRpcGBdKCNsYXllci1iaW5kdG9vbHRpcCkpXHJcbiAqICAqIEV2ZW50cyBhcmUgcHJvcGFnYXRlZCB0byB0aGUgYEZlYXR1cmVHcm91cGAsIHNvIGlmIHRoZSBncm91cCBoYXMgYW4gZXZlbnRcclxuICogaGFuZGxlciwgaXQgd2lsbCBoYW5kbGUgZXZlbnRzIGZyb20gYW55IG9mIHRoZSBsYXllcnMuIFRoaXMgaW5jbHVkZXMgbW91c2UgZXZlbnRzXHJcbiAqIGFuZCBjdXN0b20gZXZlbnRzLlxyXG4gKiAgKiBIYXMgYGxheWVyYWRkYCBhbmQgYGxheWVycmVtb3ZlYCBldmVudHNcclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5mZWF0dXJlR3JvdXAoW21hcmtlcjEsIG1hcmtlcjIsIHBvbHlsaW5lXSlcclxuICogXHQuYmluZFBvcHVwKCdIZWxsbyB3b3JsZCEnKVxyXG4gKiBcdC5vbignY2xpY2snLCBmdW5jdGlvbigpIHsgYWxlcnQoJ0NsaWNrZWQgb24gYSBtZW1iZXIgb2YgdGhlIGdyb3VwIScpOyB9KVxyXG4gKiBcdC5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEZlYXR1cmVHcm91cCA9IExheWVyR3JvdXAuZXh0ZW5kKHtcclxuXHJcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxheWVyLmFkZEV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuXHRcdExheWVyR3JvdXAucHJvdG90eXBlLmFkZExheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsYXllcmFkZDogTGF5ZXJFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGxheWVyIGlzIGFkZGVkIHRvIHRoaXMgYEZlYXR1cmVHcm91cGBcclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiBsYXllcn0pO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICghdGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRpZiAobGF5ZXIgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2xheWVyXTtcclxuXHRcdH1cclxuXHJcblx0XHRsYXllci5yZW1vdmVFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcblx0XHRMYXllckdyb3VwLnByb3RvdHlwZS5yZW1vdmVMYXllci5jYWxsKHRoaXMsIGxheWVyKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbGF5ZXJyZW1vdmU6IExheWVyRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhpcyBgRmVhdHVyZUdyb3VwYFxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7bGF5ZXI6IGxheWVyfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRTdHlsZShzdHlsZTogUGF0aCBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGdpdmVuIHBhdGggb3B0aW9ucyB0byBlYWNoIGxheWVyIG9mIHRoZSBncm91cCB0aGF0IGhhcyBhIGBzZXRTdHlsZWAgbWV0aG9kLlxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnc2V0U3R5bGUnLCBzdHlsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgZ3JvdXAgdG8gdGhlIHRvcCBvZiBhbGwgb3RoZXIgbGF5ZXJzXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9Gcm9udCcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgZ3JvdXAgdG8gdGhlIGJhY2sgb2YgYWxsIG90aGVyIGxheWVyc1xyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9CYWNrJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgTGF0TG5nQm91bmRzIG9mIHRoZSBGZWF0dXJlIEdyb3VwIChjcmVhdGVkIGZyb20gYm91bmRzIGFuZCBjb29yZGluYXRlcyBvZiBpdHMgY2hpbGRyZW4pLlxyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoKTtcclxuXHJcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0dmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHRcdFx0Ym91bmRzLmV4dGVuZChsYXllci5nZXRCb3VuZHMgPyBsYXllci5nZXRCb3VuZHMoKSA6IGxheWVyLmdldExhdExuZygpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBib3VuZHM7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBmYWN0b3J5IEwuZmVhdHVyZUdyb3VwKGxheWVycz86IExheWVyW10sIG9wdGlvbnM/OiBPYmplY3QpXHJcbi8vIENyZWF0ZSBhIGZlYXR1cmUgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG5leHBvcnQgdmFyIGZlYXR1cmVHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMsIG9wdGlvbnMpO1xyXG59O1xyXG4iLCJpbXBvcnQge0NsYXNzfSBmcm9tICcuLi8uLi9jb3JlL0NsYXNzJztcclxuaW1wb3J0IHtzZXRPcHRpb25zfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3RvUG9pbnQgYXMgcG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBJY29uXHJcbiAqIEBha2EgTC5JY29uXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYW4gaWNvbiB0byBwcm92aWRlIHdoZW4gY3JlYXRpbmcgYSBtYXJrZXIuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBteUljb24gPSBMLmljb24oe1xyXG4gKiAgICAgaWNvblVybDogJ215LWljb24ucG5nJyxcclxuICogICAgIGljb25SZXRpbmFVcmw6ICdteS1pY29uQDJ4LnBuZycsXHJcbiAqICAgICBpY29uU2l6ZTogWzM4LCA5NV0sXHJcbiAqICAgICBpY29uQW5jaG9yOiBbMjIsIDk0XSxcclxuICogICAgIHBvcHVwQW5jaG9yOiBbLTMsIC03Nl0sXHJcbiAqICAgICBzaGFkb3dVcmw6ICdteS1pY29uLXNoYWRvdy5wbmcnLFxyXG4gKiAgICAgc2hhZG93UmV0aW5hVXJsOiAnbXktaWNvbi1zaGFkb3dAMngucG5nJyxcclxuICogICAgIHNoYWRvd1NpemU6IFs2OCwgOTVdLFxyXG4gKiAgICAgc2hhZG93QW5jaG9yOiBbMjIsIDk0XVxyXG4gKiB9KTtcclxuICpcclxuICogTC5tYXJrZXIoWzUwLjUwNSwgMzAuNTddLCB7aWNvbjogbXlJY29ufSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIGBMLkljb24uRGVmYXVsdGAgZXh0ZW5kcyBgTC5JY29uYCBhbmQgaXMgdGhlIGJsdWUgaWNvbiBMZWFmbGV0IHVzZXMgZm9yIG1hcmtlcnMgYnkgZGVmYXVsdC5cclxuICpcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEljb24gPSBDbGFzcy5leHRlbmQoe1xyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqIEBha2EgSWNvbiBvcHRpb25zXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25Vcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiAqKihyZXF1aXJlZCkqKiBUaGUgVVJMIHRvIHRoZSBpY29uIGltYWdlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB5b3VyIHNjcmlwdCBwYXRoKS5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblJldGluYVVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqIFRoZSBVUkwgdG8gYSByZXRpbmEgc2l6ZWQgdmVyc2lvbiBvZiB0aGUgaWNvbiBpbWFnZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8geW91clxyXG5cdCAqIHNjcmlwdCBwYXRoKS4gVXNlZCBmb3IgUmV0aW5hIHNjcmVlbiBkZXZpY2VzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uU2l6ZTogUG9pbnQgPSBudWxsXHJcblx0ICogU2l6ZSBvZiB0aGUgaWNvbiBpbWFnZSBpbiBwaXhlbHMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25BbmNob3I6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgXCJ0aXBcIiBvZiB0aGUgaWNvbiAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikuIFRoZSBpY29uXHJcblx0ICogd2lsbCBiZSBhbGlnbmVkIHNvIHRoYXQgdGhpcyBwb2ludCBpcyBhdCB0aGUgbWFya2VyJ3MgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uLiBDZW50ZXJlZFxyXG5cdCAqIGJ5IGRlZmF1bHQgaWYgc2l6ZSBpcyBzcGVjaWZpZWQsIGFsc28gY2FuIGJlIHNldCBpbiBDU1Mgd2l0aCBuZWdhdGl2ZSBtYXJnaW5zLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBwb3B1cEFuY2hvcjogUG9pbnQgPSBbMCwgMF1cclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggcG9wdXBzIHdpbGwgXCJvcGVuXCIsIHJlbGF0aXZlIHRvIHRoZSBpY29uIGFuY2hvci5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gdG9vbHRpcEFuY2hvcjogUG9pbnQgPSBbMCwgMF1cclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggdG9vbHRpcHMgd2lsbCBcIm9wZW5cIiwgcmVsYXRpdmUgdG8gdGhlIGljb24gYW5jaG9yLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiBUaGUgVVJMIHRvIHRoZSBpY29uIHNoYWRvdyBpbWFnZS4gSWYgbm90IHNwZWNpZmllZCwgbm8gc2hhZG93IGltYWdlIHdpbGwgYmUgY3JlYXRlZC5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93UmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1NpemU6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFNpemUgb2YgdGhlIHNoYWRvdyBpbWFnZSBpbiBwaXhlbHMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd0FuY2hvcjogUG9pbnQgPSBudWxsXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBzaGFkb3cgKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpICh0aGUgc2FtZVxyXG5cdCAqIGFzIGljb25BbmNob3IgaWYgbm90IHNwZWNpZmllZCkuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHQgKiBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byBib3RoIGljb24gYW5kIHNoYWRvdyBpbWFnZXMuIEVtcHR5IGJ5IGRlZmF1bHQuXHJcblx0ICovXHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvcHVwQW5jaG9yOiBbMCwgMF0sXHJcblx0XHR0b29sdGlwQW5jaG9yOiBbMCwgMF0sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjcm9zc09yaWdpbjogQm9vbGVhbnxTdHJpbmcgPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRpbGVzLlxyXG5cdFx0Ly8gSWYgYSBTdHJpbmcgaXMgcHJvdmlkZWQsIGFsbCB0aWxlcyB3aWxsIGhhdmUgdGhlaXIgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byB0aGUgU3RyaW5nIHByb3ZpZGVkLiBUaGlzIGlzIG5lZWRlZCBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgdGlsZSBwaXhlbCBkYXRhLlxyXG5cdFx0Ly8gUmVmZXIgdG8gW0NPUlMgU2V0dGluZ3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzKSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuXHRcdGNyb3NzT3JpZ2luOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY3JlYXRlSWNvbihvbGRJY29uPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIENhbGxlZCBpbnRlcm5hbGx5IHdoZW4gdGhlIGljb24gaGFzIHRvIGJlIHNob3duLCByZXR1cm5zIGEgYDxpbWc+YCBIVE1MIGVsZW1lbnRcclxuXHQvLyBzdHlsZWQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zLlxyXG5cdGNyZWF0ZUljb246IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlSWNvbignaWNvbicsIG9sZEljb24pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY3JlYXRlU2hhZG93KG9sZEljb24/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQXMgYGNyZWF0ZUljb25gLCBidXQgZm9yIHRoZSBzaGFkb3cgYmVuZWF0aCBpdC5cclxuXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlSWNvbignc2hhZG93Jywgb2xkSWNvbik7XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUljb246IGZ1bmN0aW9uIChuYW1lLCBvbGRJY29uKSB7XHJcblx0XHR2YXIgc3JjID0gdGhpcy5fZ2V0SWNvblVybChuYW1lKTtcclxuXHJcblx0XHRpZiAoIXNyYykge1xyXG5cdFx0XHRpZiAobmFtZSA9PT0gJ2ljb24nKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpY29uVXJsIG5vdCBzZXQgaW4gSWNvbiBvcHRpb25zIChzZWUgdGhlIGRvY3MpLicpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpbWcgPSB0aGlzLl9jcmVhdGVJbWcoc3JjLCBvbGRJY29uICYmIG9sZEljb24udGFnTmFtZSA9PT0gJ0lNRycgPyBvbGRJY29uIDogbnVsbCk7XHJcblx0XHR0aGlzLl9zZXRJY29uU3R5bGVzKGltZywgbmFtZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcblx0XHRcdGltZy5jcm9zc09yaWdpbiA9IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICcnIDogdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpbWc7XHJcblx0fSxcclxuXHJcblx0X3NldEljb25TdHlsZXM6IGZ1bmN0aW9uIChpbWcsIG5hbWUpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cdFx0dmFyIHNpemVPcHRpb24gPSBvcHRpb25zW25hbWUgKyAnU2l6ZSddO1xyXG5cclxuXHRcdGlmICh0eXBlb2Ygc2l6ZU9wdGlvbiA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0c2l6ZU9wdGlvbiA9IFtzaXplT3B0aW9uLCBzaXplT3B0aW9uXTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc2l6ZSA9IHBvaW50KHNpemVPcHRpb24pLFxyXG5cdFx0ICAgIGFuY2hvciA9IHBvaW50KG5hbWUgPT09ICdzaGFkb3cnICYmIG9wdGlvbnMuc2hhZG93QW5jaG9yIHx8IG9wdGlvbnMuaWNvbkFuY2hvciB8fFxyXG5cdFx0ICAgICAgICAgICAgc2l6ZSAmJiBzaXplLmRpdmlkZUJ5KDIsIHRydWUpKTtcclxuXHJcblx0XHRpbWcuY2xhc3NOYW1lID0gJ2xlYWZsZXQtbWFya2VyLScgKyBuYW1lICsgJyAnICsgKG9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKTtcclxuXHJcblx0XHRpZiAoYW5jaG9yKSB7XHJcblx0XHRcdGltZy5zdHlsZS5tYXJnaW5MZWZ0ID0gKC1hbmNob3IueCkgKyAncHgnO1xyXG5cdFx0XHRpbWcuc3R5bGUubWFyZ2luVG9wICA9ICgtYW5jaG9yLnkpICsgJ3B4JztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2l6ZSkge1xyXG5cdFx0XHRpbWcuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuXHRcdFx0aW1nLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUltZzogZnVuY3Rpb24gKHNyYywgZWwpIHtcclxuXHRcdGVsID0gZWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblx0XHRlbC5zcmMgPSBzcmM7XHJcblx0XHRyZXR1cm4gZWw7XHJcblx0fSxcclxuXHJcblx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIChuYW1lKSB7XHJcblx0XHRyZXR1cm4gQnJvd3Nlci5yZXRpbmEgJiYgdGhpcy5vcHRpb25zW25hbWUgKyAnUmV0aW5hVXJsJ10gfHwgdGhpcy5vcHRpb25zW25hbWUgKyAnVXJsJ107XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmljb24ob3B0aW9uczogSWNvbiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGFuIGljb24gaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cclxuZXhwb3J0IGZ1bmN0aW9uIGljb24ob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgSWNvbihvcHRpb25zKTtcclxufVxyXG4iLCJpbXBvcnQge0ljb259IGZyb20gJy4vSWNvbic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcblxuLypcbiAqIEBtaW5pY2xhc3MgSWNvbi5EZWZhdWx0IChJY29uKVxuICogQGFrYSBMLkljb24uRGVmYXVsdFxuICogQHNlY3Rpb25cbiAqXG4gKiBBIHRyaXZpYWwgc3ViY2xhc3Mgb2YgYEljb25gLCByZXByZXNlbnRzIHRoZSBpY29uIHRvIHVzZSBpbiBgTWFya2VyYHMgd2hlblxuICogbm8gaWNvbiBpcyBzcGVjaWZpZWQuIFBvaW50cyB0byB0aGUgYmx1ZSBtYXJrZXIgaW1hZ2UgZGlzdHJpYnV0ZWQgd2l0aCBMZWFmbGV0XG4gKiByZWxlYXNlcy5cbiAqXG4gKiBJbiBvcmRlciB0byBjdXN0b21pemUgdGhlIGRlZmF1bHQgaWNvbiwganVzdCBjaGFuZ2UgdGhlIHByb3BlcnRpZXMgb2YgYEwuSWNvbi5EZWZhdWx0LnByb3RvdHlwZS5vcHRpb25zYFxuICogKHdoaWNoIGlzIGEgc2V0IG9mIGBJY29uIG9wdGlvbnNgKS5cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBfY29tcGxldGVseV8gcmVwbGFjZSB0aGUgZGVmYXVsdCBpY29uLCBvdmVycmlkZSB0aGVcbiAqIGBMLk1hcmtlci5wcm90b3R5cGUub3B0aW9ucy5pY29uYCB3aXRoIHlvdXIgb3duIGljb24gaW5zdGVhZC5cbiAqL1xuXG5leHBvcnQgdmFyIEljb25EZWZhdWx0ID0gSWNvbi5leHRlbmQoe1xuXG5cdG9wdGlvbnM6IHtcblx0XHRpY29uVXJsOiAgICAgICAnbWFya2VyLWljb24ucG5nJyxcblx0XHRpY29uUmV0aW5hVXJsOiAnbWFya2VyLWljb24tMngucG5nJyxcblx0XHRzaGFkb3dVcmw6ICAgICAnbWFya2VyLXNoYWRvdy5wbmcnLFxuXHRcdGljb25TaXplOiAgICBbMjUsIDQxXSxcblx0XHRpY29uQW5jaG9yOiAgWzEyLCA0MV0sXG5cdFx0cG9wdXBBbmNob3I6IFsxLCAtMzRdLFxuXHRcdHRvb2x0aXBBbmNob3I6IFsxNiwgLTI4XSxcblx0XHRzaGFkb3dTaXplOiAgWzQxLCA0MV1cblx0fSxcblxuXHRfZ2V0SWNvblVybDogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAodHlwZW9mIEljb25EZWZhdWx0LmltYWdlUGF0aCAhPT0gJ3N0cmluZycpIHtcdC8vIERlcHJlY2F0ZWQsIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IG9ubHlcblx0XHRcdEljb25EZWZhdWx0LmltYWdlUGF0aCA9IHRoaXMuX2RldGVjdEljb25QYXRoKCk7XG5cdFx0fVxuXG5cdFx0Ly8gQG9wdGlvbiBpbWFnZVBhdGg6IFN0cmluZ1xuXHRcdC8vIGBJY29uLkRlZmF1bHRgIHdpbGwgdHJ5IHRvIGF1dG8tZGV0ZWN0IHRoZSBsb2NhdGlvbiBvZiB0aGVcblx0XHQvLyBibHVlIGljb24gaW1hZ2VzLiBJZiB5b3UgYXJlIHBsYWNpbmcgdGhlc2UgaW1hZ2VzIGluIGEgbm9uLXN0YW5kYXJkXG5cdFx0Ly8gd2F5LCBzZXQgdGhpcyBvcHRpb24gdG8gcG9pbnQgdG8gdGhlIHJpZ2h0IHBhdGguXG5cdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuaW1hZ2VQYXRoIHx8IEljb25EZWZhdWx0LmltYWdlUGF0aCkgKyBJY29uLnByb3RvdHlwZS5fZ2V0SWNvblVybC5jYWxsKHRoaXMsIG5hbWUpO1xuXHR9LFxuXG5cdF9zdHJpcFVybDogZnVuY3Rpb24gKHBhdGgpIHtcdC8vIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIHVzZSBpbiB0ZXN0c1xuXHRcdHZhciBzdHJpcCA9IGZ1bmN0aW9uIChzdHIsIHJlLCBpZHgpIHtcblx0XHRcdHZhciBtYXRjaCA9IHJlLmV4ZWMoc3RyKTtcblx0XHRcdHJldHVybiBtYXRjaCAmJiBtYXRjaFtpZHhdO1xuXHRcdH07XG5cdFx0cGF0aCA9IHN0cmlwKHBhdGgsIC9edXJsXFwoKFsnXCJdKT8oLispXFwxXFwpJC8sIDIpO1xuXHRcdHJldHVybiBwYXRoICYmIHN0cmlwKHBhdGgsIC9eKC4qKW1hcmtlci1pY29uXFwucG5nJC8sIDEpO1xuXHR9LFxuXG5cdF9kZXRlY3RJY29uUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBlbCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAgJ2xlYWZsZXQtZGVmYXVsdC1pY29uLXBhdGgnLCBkb2N1bWVudC5ib2R5KTtcblx0XHR2YXIgcGF0aCA9IERvbVV0aWwuZ2V0U3R5bGUoZWwsICdiYWNrZ3JvdW5kLWltYWdlJykgfHxcblx0XHQgICAgICAgICAgIERvbVV0aWwuZ2V0U3R5bGUoZWwsICdiYWNrZ3JvdW5kSW1hZ2UnKTtcdC8vIElFOFxuXG5cdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG5cdFx0cGF0aCA9IHRoaXMuX3N0cmlwVXJsKHBhdGgpO1xuXHRcdGlmIChwYXRoKSB7IHJldHVybiBwYXRoOyB9XG5cdFx0dmFyIGxpbmsgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdsaW5rW2hyZWYkPVwibGVhZmxldC5jc3NcIl0nKTtcblx0XHRpZiAoIWxpbmspIHsgcmV0dXJuICcnOyB9XG5cdFx0cmV0dXJuIGxpbmsuaHJlZi5zdWJzdHJpbmcoMCwgbGluay5ocmVmLmxlbmd0aCAtICdsZWFmbGV0LmNzcycubGVuZ3RoIC0gMSk7XG5cdH1cbn0pO1xuIiwiaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQge0RyYWdnYWJsZX0gZnJvbSAnLi4vLi4vZG9tL0RyYWdnYWJsZSc7XG5pbXBvcnQge3RvQm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuaW1wb3J0IHt0b1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQge3JlcXVlc3RBbmltRnJhbWUsIGNhbmNlbEFuaW1GcmFtZX0gZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEwuSGFuZGxlci5NYXJrZXJEcmFnIGlzIHVzZWQgaW50ZXJuYWxseSBieSBMLk1hcmtlciB0byBtYWtlIHRoZSBtYXJrZXJzIGRyYWdnYWJsZS5cbiAqL1xuXG5cbi8qIEBuYW1lc3BhY2UgTWFya2VyXG4gKiBAc2VjdGlvbiBJbnRlcmFjdGlvbiBoYW5kbGVyc1xuICpcbiAqIEludGVyYWN0aW9uIGhhbmRsZXJzIGFyZSBwcm9wZXJ0aWVzIG9mIGEgbWFya2VyIGluc3RhbmNlIHRoYXQgYWxsb3cgeW91IHRvIGNvbnRyb2wgaW50ZXJhY3Rpb24gYmVoYXZpb3IgaW4gcnVudGltZSwgZW5hYmxpbmcgb3IgZGlzYWJsaW5nIGNlcnRhaW4gZmVhdHVyZXMgc3VjaCBhcyBkcmFnZ2luZyAoc2VlIGBIYW5kbGVyYCBtZXRob2RzKS4gRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogbWFya2VyLmRyYWdnaW5nLmRpc2FibGUoKTtcbiAqIGBgYFxuICpcbiAqIEBwcm9wZXJ0eSBkcmFnZ2luZzogSGFuZGxlclxuICogTWFya2VyIGRyYWdnaW5nIGhhbmRsZXIgKGJ5IGJvdGggbW91c2UgYW5kIHRvdWNoKS4gT25seSB2YWxpZCB3aGVuIHRoZSBtYXJrZXIgaXMgb24gdGhlIG1hcCAoT3RoZXJ3aXNlIHNldCBbYG1hcmtlci5vcHRpb25zLmRyYWdnYWJsZWBdKCNtYXJrZXItZHJhZ2dhYmxlKSkuXG4gKi9cblxuZXhwb3J0IHZhciBNYXJrZXJEcmFnID0gSGFuZGxlci5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFya2VyKSB7XG5cdFx0dGhpcy5fbWFya2VyID0gbWFya2VyO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGljb24gPSB0aGlzLl9tYXJrZXIuX2ljb247XG5cblx0XHRpZiAoIXRoaXMuX2RyYWdnYWJsZSkge1xuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlID0gbmV3IERyYWdnYWJsZShpY29uLCBpY29uLCB0cnVlKTtcblx0XHR9XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdHByZWRyYWc6IHRoaXMuX29uUHJlRHJhZyxcblx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdH0sIHRoaXMpLmVuYWJsZSgpO1xuXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhpY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9kcmFnZ2FibGUub2ZmKHtcblx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRwcmVkcmFnOiB0aGlzLl9vblByZURyYWcsXG5cdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcblx0XHR9LCB0aGlzKS5kaXNhYmxlKCk7XG5cblx0XHRpZiAodGhpcy5fbWFya2VyLl9pY29uKSB7XG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcmtlci5faWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuXHRcdH1cblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcblx0fSxcblxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG5cdFx0ICAgIG1hcCA9IG1hcmtlci5fbWFwLFxuXHRcdCAgICBzcGVlZCA9IHRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW5TcGVlZCxcblx0XHQgICAgcGFkZGluZyA9IHRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW5QYWRkaW5nLFxuXHRcdCAgICBpY29uUG9zID0gRG9tVXRpbC5nZXRQb3NpdGlvbihtYXJrZXIuX2ljb24pLFxuXHRcdCAgICBib3VuZHMgPSBtYXAuZ2V0UGl4ZWxCb3VuZHMoKSxcblx0XHQgICAgb3JpZ2luID0gbWFwLmdldFBpeGVsT3JpZ2luKCk7XG5cblx0XHR2YXIgcGFuQm91bmRzID0gdG9Cb3VuZHMoXG5cdFx0XHRib3VuZHMubWluLl9zdWJ0cmFjdChvcmlnaW4pLmFkZChwYWRkaW5nKSxcblx0XHRcdGJvdW5kcy5tYXguX3N1YnRyYWN0KG9yaWdpbikuc3VidHJhY3QocGFkZGluZylcblx0XHQpO1xuXG5cdFx0aWYgKCFwYW5Cb3VuZHMuY29udGFpbnMoaWNvblBvcykpIHtcblx0XHRcdC8vIENvbXB1dGUgaW5jcmVtZW50YWwgbW92ZW1lbnRcblx0XHRcdHZhciBtb3ZlbWVudCA9IHRvUG9pbnQoXG5cdFx0XHRcdChNYXRoLm1heChwYW5Cb3VuZHMubWF4LngsIGljb25Qb3MueCkgLSBwYW5Cb3VuZHMubWF4LngpIC8gKGJvdW5kcy5tYXgueCAtIHBhbkJvdW5kcy5tYXgueCkgLVxuXHRcdFx0XHQoTWF0aC5taW4ocGFuQm91bmRzLm1pbi54LCBpY29uUG9zLngpIC0gcGFuQm91bmRzLm1pbi54KSAvIChib3VuZHMubWluLnggLSBwYW5Cb3VuZHMubWluLngpLFxuXG5cdFx0XHRcdChNYXRoLm1heChwYW5Cb3VuZHMubWF4LnksIGljb25Qb3MueSkgLSBwYW5Cb3VuZHMubWF4LnkpIC8gKGJvdW5kcy5tYXgueSAtIHBhbkJvdW5kcy5tYXgueSkgLVxuXHRcdFx0XHQoTWF0aC5taW4ocGFuQm91bmRzLm1pbi55LCBpY29uUG9zLnkpIC0gcGFuQm91bmRzLm1pbi55KSAvIChib3VuZHMubWluLnkgLSBwYW5Cb3VuZHMubWluLnkpXG5cdFx0XHQpLm11bHRpcGx5Qnkoc3BlZWQpO1xuXG5cdFx0XHRtYXAucGFuQnkobW92ZW1lbnQsIHthbmltYXRlOiBmYWxzZX0pO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5fYWRkKG1vdmVtZW50KTtcblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MuX2FkZChtb3ZlbWVudCk7XG5cblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24obWFya2VyLl9pY29uLCB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcyk7XG5cdFx0XHR0aGlzLl9vbkRyYWcoZSk7XG5cblx0XHRcdHRoaXMuX3BhblJlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FkanVzdFBhbi5iaW5kKHRoaXMsIGUpKTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gQHNlY3Rpb24gRHJhZ2dpbmcgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IGRyYWdzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG5cdFx0Ly8gQGV2ZW50IG1vdmVzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RhcnRzIG1vdmluZyAoYmVjYXVzZSBvZiBkcmFnZ2luZykuXG5cblx0XHR0aGlzLl9vbGRMYXRMbmcgPSB0aGlzLl9tYXJrZXIuZ2V0TGF0TG5nKCk7XG5cblx0XHQvLyBXaGVuIHVzaW5nIEVTNiBpbXBvcnRzIGl0IGNvdWxkIG5vdCBiZSBzZXQgd2hlbiBgUG9wdXBgIHdhcyBub3QgaW1wb3J0ZWQgYXMgd2VsbFxuXHRcdHRoaXMuX21hcmtlci5jbG9zZVBvcHVwICYmIHRoaXMuX21hcmtlci5jbG9zZVBvcHVwKCk7XG5cblx0XHR0aGlzLl9tYXJrZXJcblx0XHRcdC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdFx0LmZpcmUoJ2RyYWdzdGFydCcpO1xuXHR9LFxuXG5cdF9vblByZURyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKHRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW4pIHtcblx0XHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9wYW5SZXF1ZXN0KTtcblx0XHRcdHRoaXMuX3BhblJlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FkanVzdFBhbi5iaW5kKHRoaXMsIGUpKTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFya2VyID0gdGhpcy5fbWFya2VyLFxuXHRcdCAgICBzaGFkb3cgPSBtYXJrZXIuX3NoYWRvdyxcblx0XHQgICAgaWNvblBvcyA9IERvbVV0aWwuZ2V0UG9zaXRpb24obWFya2VyLl9pY29uKSxcblx0XHQgICAgbGF0bG5nID0gbWFya2VyLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGljb25Qb3MpO1xuXG5cdFx0Ly8gdXBkYXRlIHNoYWRvdyBwb3NpdGlvblxuXHRcdGlmIChzaGFkb3cpIHtcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24oc2hhZG93LCBpY29uUG9zKTtcblx0XHR9XG5cblx0XHRtYXJrZXIuX2xhdGxuZyA9IGxhdGxuZztcblx0XHRlLmxhdGxuZyA9IGxhdGxuZztcblx0XHRlLm9sZExhdExuZyA9IHRoaXMuX29sZExhdExuZztcblxuXHRcdC8vIEBldmVudCBkcmFnOiBFdmVudFxuXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIG1hcmtlci5cblx0XHRtYXJrZXJcblx0XHQgICAgLmZpcmUoJ21vdmUnLCBlKVxuXHRcdCAgICAuZmlyZSgnZHJhZycsIGUpO1xuXHR9LFxuXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuXHRcdCBjYW5jZWxBbmltRnJhbWUodGhpcy5fcGFuUmVxdWVzdCk7XG5cblx0XHQvLyBAZXZlbnQgbW92ZWVuZDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RvcHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblx0XHRkZWxldGUgdGhpcy5fb2xkTGF0TG5nO1xuXHRcdHRoaXMuX21hcmtlclxuXHRcdCAgICAuZmlyZSgnbW92ZWVuZCcpXG5cdFx0ICAgIC5maXJlKCdkcmFnZW5kJywgZSk7XG5cdH1cbn0pO1xuIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vTGF5ZXInO1xyXG5pbXBvcnQge0ljb25EZWZhdWx0fSBmcm9tICcuL0ljb24uRGVmYXVsdCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZyBhcyBsYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQge3RvUG9pbnQgYXMgcG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCB7TWFya2VyRHJhZ30gZnJvbSAnLi9NYXJrZXIuRHJhZyc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTWFya2VyXHJcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gKiBAYWthIEwuTWFya2VyXHJcbiAqIEwuTWFya2VyIGlzIHVzZWQgdG8gZGlzcGxheSBjbGlja2FibGUvZHJhZ2dhYmxlIGljb25zIG9uIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5tYXJrZXIoWzUwLjUsIDMwLjVdKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIE1hcmtlciA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBNYXJrZXIgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gaWNvbjogSWNvbiA9ICpcclxuXHRcdC8vIEljb24gaW5zdGFuY2UgdG8gdXNlIGZvciByZW5kZXJpbmcgdGhlIG1hcmtlci5cclxuXHRcdC8vIFNlZSBbSWNvbiBkb2N1bWVudGF0aW9uXSgjTC5JY29uKSBmb3IgZGV0YWlscyBvbiBob3cgdG8gY3VzdG9taXplIHRoZSBtYXJrZXIgaWNvbi5cclxuXHRcdC8vIElmIG5vdCBzcGVjaWZpZWQsIGEgY29tbW9uIGluc3RhbmNlIG9mIGBMLkljb24uRGVmYXVsdGAgaXMgdXNlZC5cclxuXHRcdGljb246IG5ldyBJY29uRGVmYXVsdCgpLFxyXG5cclxuXHRcdC8vIE9wdGlvbiBpbmhlcml0ZWQgZnJvbSBcIkludGVyYWN0aXZlIGxheWVyXCIgYWJzdHJhY3QgY2xhc3NcclxuXHRcdGludGVyYWN0aXZlOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24ga2V5Ym9hcmQ6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXJrZXIgY2FuIGJlIHRhYmJlZCB0byB3aXRoIGEga2V5Ym9hcmQgYW5kIGNsaWNrZWQgYnkgcHJlc3NpbmcgZW50ZXIuXHJcblx0XHRrZXlib2FyZDogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRpdGxlOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVGV4dCBmb3IgdGhlIGJyb3dzZXIgdG9vbHRpcCB0aGF0IGFwcGVhciBvbiBtYXJrZXIgaG92ZXIgKG5vIHRvb2x0aXAgYnkgZGVmYXVsdCkuXHJcblx0XHQvLyBbVXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5XShodHRwczovL2xlYWZsZXRqcy5jb20vZXhhbXBsZXMvYWNjZXNzaWJpbGl0eS8jbWFya2Vycy1tdXN0LWJlLWxhYmVsbGVkKS5cclxuXHRcdHRpdGxlOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGFsdDogU3RyaW5nID0gJ01hcmtlcidcclxuXHRcdC8vIFRleHQgZm9yIHRoZSBgYWx0YCBhdHRyaWJ1dGUgb2YgdGhlIGljb24gaW1hZ2UuXHJcblx0XHQvLyBbVXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5XShodHRwczovL2xlYWZsZXRqcy5jb20vZXhhbXBsZXMvYWNjZXNzaWJpbGl0eS8jbWFya2Vycy1tdXN0LWJlLWxhYmVsbGVkKS5cclxuXHRcdGFsdDogJ01hcmtlcicsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6SW5kZXhPZmZzZXQ6IE51bWJlciA9IDBcclxuXHRcdC8vIEJ5IGRlZmF1bHQsIG1hcmtlciBpbWFnZXMgekluZGV4IGlzIHNldCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIGl0cyBsYXRpdHVkZS4gVXNlIHRoaXMgb3B0aW9uIGlmIHlvdSB3YW50IHRvIHB1dCB0aGUgbWFya2VyIG9uIHRvcCBvZiBhbGwgb3RoZXJzIChvciBiZWxvdyksIHNwZWNpZnlpbmcgYSBoaWdoIHZhbHVlIGxpa2UgYDEwMDBgIChvciBoaWdoIG5lZ2F0aXZlIHZhbHVlLCByZXNwZWN0aXZlbHkpLlxyXG5cdFx0ekluZGV4T2Zmc2V0OiAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcblx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgbWFya2VyLlxyXG5cdFx0b3BhY2l0eTogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJpc2VPbkhvdmVyOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIG1hcmtlciB3aWxsIGdldCBvbiB0b3Agb2Ygb3RoZXJzIHdoZW4geW91IGhvdmVyIHRoZSBtb3VzZSBvdmVyIGl0LlxyXG5cdFx0cmlzZU9uSG92ZXI6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmlzZU9mZnNldDogTnVtYmVyID0gMjUwXHJcblx0XHQvLyBUaGUgei1pbmRleCBvZmZzZXQgdXNlZCBmb3IgdGhlIGByaXNlT25Ib3ZlcmAgZmVhdHVyZS5cclxuXHRcdHJpc2VPZmZzZXQ6IDI1MCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdtYXJrZXJQYW5lJ1xyXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgbWFya2VycyBpY29uIHdpbGwgYmUgYWRkZWQuXHJcblx0XHRwYW5lOiAnbWFya2VyUGFuZScsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzaGFkb3dQYW5lOiBTdHJpbmcgPSAnc2hhZG93UGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIG1hcmtlcnMgc2hhZG93IHdpbGwgYmUgYWRkZWQuXHJcblx0XHRzaGFkb3dQYW5lOiAnc2hhZG93UGFuZScsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBidWJibGluZ01vdXNlRXZlbnRzOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZW4gYHRydWVgLCBhIG1vdXNlIGV2ZW50IG9uIHRoaXMgbWFya2VyIHdpbGwgdHJpZ2dlciB0aGUgc2FtZSBldmVudCBvbiB0aGUgbWFwXHJcblx0XHQvLyAodW5sZXNzIFtgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb25gXSgjZG9tZXZlbnQtc3RvcHByb3BhZ2F0aW9uKSBpcyB1c2VkKS5cclxuXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1Bhbk9uRm9jdXM6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGVuIGB0cnVlYCwgdGhlIG1hcCB3aWxsIHBhbiB3aGVuZXZlciB0aGUgbWFya2VyIGlzIGZvY3VzZWQgKHZpYVxyXG5cdFx0Ly8gZS5nLiBwcmVzc2luZyBgdGFiYCBvbiB0aGUga2V5Ym9hcmQpIHRvIGVuc3VyZSB0aGUgbWFya2VyIGlzXHJcblx0XHQvLyB2aXNpYmxlIHdpdGhpbiB0aGUgbWFwJ3MgYm91bmRzXHJcblx0XHRhdXRvUGFuT25Gb2N1czogdHJ1ZSxcclxuXHJcblx0XHQvLyBAc2VjdGlvbiBEcmFnZ2FibGUgbWFya2VyIG9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gZHJhZ2dhYmxlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBpcyBkcmFnZ2FibGUgd2l0aCBtb3VzZS90b3VjaCBvciBub3QuXHJcblx0XHRkcmFnZ2FibGU6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhbjogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRvIHBhbiB0aGUgbWFwIHdoZW4gZHJhZ2dpbmcgdGhpcyBtYXJrZXIgbmVhciBpdHMgZWRnZSBvciBub3QuXHJcblx0XHRhdXRvUGFuOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nOiBQb2ludCA9IFBvaW50KDUwLCA1MClcclxuXHRcdC8vIERpc3RhbmNlIChpbiBwaXhlbHMgdG8gdGhlIGxlZnQvcmlnaHQgYW5kIHRvIHRoZSB0b3AvYm90dG9tKSBvZiB0aGVcclxuXHRcdC8vIG1hcCBlZGdlIHRvIHN0YXJ0IHBhbm5pbmcgdGhlIG1hcC5cclxuXHRcdGF1dG9QYW5QYWRkaW5nOiBbNTAsIDUwXSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5TcGVlZDogTnVtYmVyID0gMTBcclxuXHRcdC8vIE51bWJlciBvZiBwaXhlbHMgdGhlIG1hcCBzaG91bGQgcGFuIGJ5LlxyXG5cdFx0YXV0b1BhblNwZWVkOiAxMFxyXG5cdH0sXHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICpcclxuXHQgKiBJbiBhZGRpdGlvbiB0byBbc2hhcmVkIGxheWVyIG1ldGhvZHNdKCNMYXllcikgbGlrZSBgYWRkVG8oKWAgYW5kIGByZW1vdmUoKWAgYW5kIFtwb3B1cCBtZXRob2RzXSgjUG9wdXApIGxpa2UgYmluZFBvcHVwKCkgeW91IGNhbiBhbHNvIHVzZSB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XHJcblx0ICovXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHRcdHRoaXMuX2xhdGxuZyA9IGxhdExuZyhsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSB0aGlzLl96b29tQW5pbWF0ZWQgJiYgbWFwLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbjtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdG1hcC5vbignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdEljb24oKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGlmICh0aGlzLmRyYWdnaW5nICYmIHRoaXMuZHJhZ2dpbmcuZW5hYmxlZCgpKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5kcmFnZ2FibGUgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLmRyYWdnaW5nLnJlbW92ZUhvb2tzKCk7XHJcblx0XHR9XHJcblx0XHRkZWxldGUgdGhpcy5kcmFnZ2luZztcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdG1hcC5vZmYoJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVpvb20sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuXHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0em9vbTogdGhpcy51cGRhdGUsXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy51cGRhdGVcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgZ2VvZ3JhcGhpY2FsIHBvc2l0aW9uIG9mIHRoZSBtYXJrZXIuXHJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG1hcmtlciBwb3NpdGlvbiB0byB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgb2xkTGF0TG5nID0gdGhpcy5fbGF0bG5nO1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gbGF0TG5nKGxhdGxuZyk7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIGlzIG1vdmVkIHZpYSBbYHNldExhdExuZ2BdKCNtYXJrZXItc2V0bGF0bG5nKSBvciBieSBbZHJhZ2dpbmddKCNtYXJrZXItZHJhZ2dpbmcpLiBPbGQgYW5kIG5ldyBjb29yZGluYXRlcyBhcmUgaW5jbHVkZWQgaW4gZXZlbnQgYXJndW1lbnRzIGFzIGBvbGRMYXRMbmdgLCBgbGF0bG5nYC5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCB7b2xkTGF0TG5nOiBvbGRMYXRMbmcsIGxhdGxuZzogdGhpcy5fbGF0bG5nfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXhPZmZzZXQob2Zmc2V0OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleCBvZmZzZXRdKCNtYXJrZXItemluZGV4b2Zmc2V0KSBvZiB0aGUgbWFya2VyLlxyXG5cdHNldFpJbmRleE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleE9mZnNldCA9IG9mZnNldDtcclxuXHRcdHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0SWNvbjogSWNvblxyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgaWNvbiB1c2VkIGJ5IHRoZSBtYXJrZXJcclxuXHRnZXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb247XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRJY29uKGljb246IEljb24pOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgbWFya2VyIGljb24uXHJcblx0c2V0SWNvbjogZnVuY3Rpb24gKGljb24pIHtcclxuXHJcblx0XHR0aGlzLm9wdGlvbnMuaWNvbiA9IGljb247XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLmJpbmRQb3B1cCh0aGlzLl9wb3B1cCwgdGhpcy5fcG9wdXAub3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2ljb247XHJcblx0fSxcclxuXHJcblx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ljb24gJiYgdGhpcy5fbWFwKSB7XHJcblx0XHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZykucm91bmQoKTtcclxuXHRcdFx0dGhpcy5fc2V0UG9zKHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuXHRcdCAgICBjbGFzc1RvQWRkID0gJ2xlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpO1xyXG5cclxuXHRcdHZhciBpY29uID0gb3B0aW9ucy5pY29uLmNyZWF0ZUljb24odGhpcy5faWNvbiksXHJcblx0XHQgICAgYWRkSWNvbiA9IGZhbHNlO1xyXG5cclxuXHRcdC8vIGlmIHdlJ3JlIG5vdCByZXVzaW5nIHRoZSBpY29uLCByZW1vdmUgdGhlIG9sZCBvbmUgYW5kIGluaXQgbmV3IG9uZVxyXG5cdFx0aWYgKGljb24gIT09IHRoaXMuX2ljb24pIHtcclxuXHRcdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YWRkSWNvbiA9IHRydWU7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy50aXRsZSkge1xyXG5cdFx0XHRcdGljb24udGl0bGUgPSBvcHRpb25zLnRpdGxlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoaWNvbi50YWdOYW1lID09PSAnSU1HJykge1xyXG5cdFx0XHRcdGljb24uYWx0ID0gb3B0aW9ucy5hbHQgfHwgJyc7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKGljb24sIGNsYXNzVG9BZGQpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLmtleWJvYXJkKSB7XHJcblx0XHRcdGljb24udGFiSW5kZXggPSAnMCc7XHJcblx0XHRcdGljb24uc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ljb24gPSBpY29uO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnJpc2VPbkhvdmVyKSB7XHJcblx0XHRcdHRoaXMub24oe1xyXG5cdFx0XHRcdG1vdXNlb3ZlcjogdGhpcy5fYnJpbmdUb0Zyb250LFxyXG5cdFx0XHRcdG1vdXNlb3V0OiB0aGlzLl9yZXNldFpJbmRleFxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmF1dG9QYW5PbkZvY3VzKSB7XHJcblx0XHRcdERvbUV2ZW50Lm9uKGljb24sICdmb2N1cycsIHRoaXMuX3Bhbk9uRm9jdXMsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBuZXdTaGFkb3cgPSBvcHRpb25zLmljb24uY3JlYXRlU2hhZG93KHRoaXMuX3NoYWRvdyksXHJcblx0XHQgICAgYWRkU2hhZG93ID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdyAhPT0gdGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xyXG5cdFx0XHRhZGRTaGFkb3cgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChuZXdTaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhuZXdTaGFkb3csIGNsYXNzVG9BZGQpO1xyXG5cdFx0XHRuZXdTaGFkb3cuYWx0ID0gJyc7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9zaGFkb3cgPSBuZXdTaGFkb3c7XHJcblxyXG5cclxuXHRcdGlmIChvcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0aWYgKGFkZEljb24pIHtcclxuXHRcdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faWNvbik7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9pbml0SW50ZXJhY3Rpb24oKTtcclxuXHRcdGlmIChuZXdTaGFkb3cgJiYgYWRkU2hhZG93KSB7XHJcblx0XHRcdHRoaXMuZ2V0UGFuZShvcHRpb25zLnNoYWRvd1BhbmUpLmFwcGVuZENoaWxkKHRoaXMuX3NoYWRvdyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZUljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vZmYoe1xyXG5cdFx0XHRcdG1vdXNlb3ZlcjogdGhpcy5fYnJpbmdUb0Zyb250LFxyXG5cdFx0XHRcdG1vdXNlb3V0OiB0aGlzLl9yZXNldFpJbmRleFxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmF1dG9QYW5PbkZvY3VzKSB7XHJcblx0XHRcdERvbUV2ZW50Lm9mZih0aGlzLl9pY29uLCAnZm9jdXMnLCB0aGlzLl9wYW5PbkZvY3VzLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9pY29uKTtcclxuXHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG5cdFx0dGhpcy5faWNvbiA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9zaGFkb3cpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fc2hhZG93ID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfc2V0UG9zOiBmdW5jdGlvbiAocG9zKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9pY29uLCBwb3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9zaGFkb3csIHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fekluZGV4ID0gcG9zLnkgKyB0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0O1xyXG5cclxuXHRcdHRoaXMuX3Jlc2V0WkluZGV4KCk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0dGhpcy5faWNvbi5zdHlsZS56SW5kZXggPSB0aGlzLl96SW5kZXggKyBvZmZzZXQ7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAob3B0KSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBvcHQuem9vbSwgb3B0LmNlbnRlcikucm91bmQoKTtcclxuXHJcblx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEludGVyYWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pY29uLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cclxuXHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG5cdFx0aWYgKE1hcmtlckRyYWcpIHtcclxuXHRcdFx0dmFyIGRyYWdnYWJsZSA9IHRoaXMub3B0aW9ucy5kcmFnZ2FibGU7XHJcblx0XHRcdGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcblx0XHRcdFx0ZHJhZ2dhYmxlID0gdGhpcy5kcmFnZ2luZy5lbmFibGVkKCk7XHJcblx0XHRcdFx0dGhpcy5kcmFnZ2luZy5kaXNhYmxlKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcgPSBuZXcgTWFya2VyRHJhZyh0aGlzKTtcclxuXHJcblx0XHRcdGlmIChkcmFnZ2FibGUpIHtcclxuXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmVuYWJsZSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgb3BhY2l0eSA9IHRoaXMub3B0aW9ucy5vcGFjaXR5O1xyXG5cclxuXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9pY29uLCBvcGFjaXR5KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9zaGFkb3csIG9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCh0aGlzLm9wdGlvbnMucmlzZU9mZnNldCk7XHJcblx0fSxcclxuXHJcblx0X3Jlc2V0WkluZGV4OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoMCk7XHJcblx0fSxcclxuXHJcblx0X3Bhbk9uRm9jdXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XHJcblx0XHRpZiAoIW1hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgaWNvbk9wdHMgPSB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zO1xyXG5cdFx0dmFyIHNpemUgPSBpY29uT3B0cy5pY29uU2l6ZSA/IHBvaW50KGljb25PcHRzLmljb25TaXplKSA6IHBvaW50KDAsIDApO1xyXG5cdFx0dmFyIGFuY2hvciA9IGljb25PcHRzLmljb25BbmNob3IgPyBwb2ludChpY29uT3B0cy5pY29uQW5jaG9yKSA6IHBvaW50KDAsIDApO1xyXG5cclxuXHRcdG1hcC5wYW5JbnNpZGUodGhpcy5fbGF0bG5nLCB7XHJcblx0XHRcdHBhZGRpbmdUb3BMZWZ0OiBhbmNob3IsXHJcblx0XHRcdHBhZGRpbmdCb3R0b21SaWdodDogc2l6ZS5zdWJ0cmFjdChhbmNob3IpXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0UG9wdXBBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnBvcHVwQW5jaG9yO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRUb29sdGlwQW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy50b29sdGlwQW5jaG9yO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcclxuXHJcbi8vIEBmYWN0b3J5IEwubWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPyA6IE1hcmtlciBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBNYXJrZXIgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IGFuZCBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LlxyXG5leHBvcnQgZnVuY3Rpb24gbWFya2VyKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XHJcbn1cclxuIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vTGF5ZXInO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogQGNsYXNzIFBhdGhcbiAqIEBha2EgTC5QYXRoXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcbiAqXG4gKiBBbiBhYnN0cmFjdCBjbGFzcyB0aGF0IGNvbnRhaW5zIG9wdGlvbnMgYW5kIGNvbnN0YW50cyBzaGFyZWQgYmV0d2VlbiB2ZWN0b3JcbiAqIG92ZXJsYXlzIChQb2x5Z29uLCBQb2x5bGluZSwgQ2lyY2xlKS4gRG8gbm90IHVzZSBpdCBkaXJlY3RseS4gRXh0ZW5kcyBgTGF5ZXJgLlxuICovXG5cbmV4cG9ydCB2YXIgUGF0aCA9IExheWVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBQYXRoIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gc3Ryb2tlOiBCb29sZWFuID0gdHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gZHJhdyBzdHJva2UgYWxvbmcgdGhlIHBhdGguIFNldCBpdCB0byBgZmFsc2VgIHRvIGRpc2FibGUgYm9yZGVycyBvbiBwb2x5Z29ucyBvciBjaXJjbGVzLlxuXHRcdHN0cm9rZTogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gY29sb3I6IFN0cmluZyA9ICcjMzM4OGZmJ1xuXHRcdC8vIFN0cm9rZSBjb2xvclxuXHRcdGNvbG9yOiAnIzMzODhmZicsXG5cblx0XHQvLyBAb3B0aW9uIHdlaWdodDogTnVtYmVyID0gM1xuXHRcdC8vIFN0cm9rZSB3aWR0aCBpbiBwaXhlbHNcblx0XHR3ZWlnaHQ6IDMsXG5cblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxuXHRcdC8vIFN0cm9rZSBvcGFjaXR5XG5cdFx0b3BhY2l0eTogMSxcblxuXHRcdC8vIEBvcHRpb24gbGluZUNhcDogU3RyaW5nPSAncm91bmQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtzaGFwZSB0byBiZSB1c2VkIGF0IHRoZSBlbmRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWxpbmVjYXApIG9mIHRoZSBzdHJva2UuXG5cdFx0bGluZUNhcDogJ3JvdW5kJyxcblxuXHRcdC8vIEBvcHRpb24gbGluZUpvaW46IFN0cmluZyA9ICdyb3VuZCdcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW3NoYXBlIHRvIGJlIHVzZWQgYXQgdGhlIGNvcm5lcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWxpbmVqb2luKSBvZiB0aGUgc3Ryb2tlLlxuXHRcdGxpbmVKb2luOiAncm91bmQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBkYXNoQXJyYXk6IFN0cmluZyA9IG51bGxcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgdGhlIHN0cm9rZSBbZGFzaCBwYXR0ZXJuXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1kYXNoYXJyYXkpLiBEb2Vzbid0IHdvcmsgb24gYENhbnZhc2AtcG93ZXJlZCBsYXllcnMgaW4gW3NvbWUgb2xkIGJyb3dzZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoI0Jyb3dzZXJfY29tcGF0aWJpbGl0eSkuXG5cdFx0ZGFzaEFycmF5OiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBkYXNoT2Zmc2V0OiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBbZGlzdGFuY2UgaW50byB0aGUgZGFzaCBwYXR0ZXJuIHRvIHN0YXJ0IHRoZSBkYXNoXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1kYXNob2Zmc2V0KS4gRG9lc24ndCB3b3JrIG9uIGBDYW52YXNgLXBvd2VyZWQgbGF5ZXJzIGluIFtzb21lIG9sZCBicm93c2Vyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuXHRcdGRhc2hPZmZzZXQ6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGw6IEJvb2xlYW4gPSBkZXBlbmRzXG5cdFx0Ly8gV2hldGhlciB0byBmaWxsIHRoZSBwYXRoIHdpdGggY29sb3IuIFNldCBpdCB0byBgZmFsc2VgIHRvIGRpc2FibGUgZmlsbGluZyBvbiBwb2x5Z29ucyBvciBjaXJjbGVzLlxuXHRcdGZpbGw6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsQ29sb3I6IFN0cmluZyA9ICpcblx0XHQvLyBGaWxsIGNvbG9yLiBEZWZhdWx0cyB0byB0aGUgdmFsdWUgb2YgdGhlIFtgY29sb3JgXSgjcGF0aC1jb2xvcikgb3B0aW9uXG5cdFx0ZmlsbENvbG9yOiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsT3BhY2l0eTogTnVtYmVyID0gMC4yXG5cdFx0Ly8gRmlsbCBvcGFjaXR5LlxuXHRcdGZpbGxPcGFjaXR5OiAwLjIsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxSdWxlOiBTdHJpbmcgPSAnZXZlbm9kZCdcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW2hvdyB0aGUgaW5zaWRlIG9mIGEgc2hhcGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvZmlsbC1ydWxlKSBpcyBkZXRlcm1pbmVkLlxuXHRcdGZpbGxSdWxlOiAnZXZlbm9kZCcsXG5cblx0XHQvLyBjbGFzc05hbWU6ICcnLFxuXG5cdFx0Ly8gT3B0aW9uIGluaGVyaXRlZCBmcm9tIFwiSW50ZXJhY3RpdmUgbGF5ZXJcIiBhYnN0cmFjdCBjbGFzc1xuXHRcdGludGVyYWN0aXZlOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiBidWJibGluZ01vdXNlRXZlbnRzOiBCb29sZWFuID0gdHJ1ZVxuXHRcdC8vIFdoZW4gYHRydWVgLCBhIG1vdXNlIGV2ZW50IG9uIHRoaXMgcGF0aCB3aWxsIHRyaWdnZXIgdGhlIHNhbWUgZXZlbnQgb24gdGhlIG1hcFxuXHRcdC8vICh1bmxlc3MgW2BMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbmBdKCNkb21ldmVudC1zdG9wcHJvcGFnYXRpb24pIGlzIHVzZWQpLlxuXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IHRydWVcblx0fSxcblxuXHRiZWZvcmVBZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHQvLyBSZW5kZXJlciBpcyBzZXQgaGVyZSBiZWNhdXNlIHdlIG5lZWQgdG8gY2FsbCByZW5kZXJlci5nZXRFdmVudHNcblx0XHQvLyBiZWZvcmUgdGhpcy5nZXRFdmVudHMuXG5cdFx0dGhpcy5fcmVuZGVyZXIgPSBtYXAuZ2V0UmVuZGVyZXIodGhpcyk7XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5faW5pdFBhdGgodGhpcyk7XG5cdFx0dGhpcy5fcmVzZXQoKTtcblx0XHR0aGlzLl9yZW5kZXJlci5fYWRkUGF0aCh0aGlzKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9yZW1vdmVQYXRoKHRoaXMpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVkcmF3KCk6IHRoaXNcblx0Ly8gUmVkcmF3cyB0aGUgbGF5ZXIuIFNvbWV0aW1lcyB1c2VmdWwgYWZ0ZXIgeW91IGNoYW5nZWQgdGhlIGNvb3JkaW5hdGVzIHRoYXQgdGhlIHBhdGggdXNlcy5cblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBhdGgodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoc3R5bGU6IFBhdGggb3B0aW9ucyk6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgYXBwZWFyYW5jZSBvZiBhIFBhdGggYmFzZWQgb24gdGhlIG9wdGlvbnMgaW4gdGhlIGBQYXRoIG9wdGlvbnNgIG9iamVjdC5cblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBzdHlsZSk7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlU3R5bGUodGhpcyk7XG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnN0cm9rZSAmJiBzdHlsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3R5bGUsICd3ZWlnaHQnKSkge1xuXHRcdFx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIHBhdGggbGF5ZXJzLlxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvRnJvbnQodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIHBhdGggbGF5ZXJzLlxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9CYWNrKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhdGg7XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gZGVmaW5lZCBpbiBjaGlsZCBjbGFzc2VzXG5cdFx0dGhpcy5fcHJvamVjdCgpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF9jbGlja1RvbGVyYW5jZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHVzZWQgd2hlbiBkb2luZyBoaXQgZGV0ZWN0aW9uIGZvciBDYW52YXMgbGF5ZXJzXG5cdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuc3Ryb2tlID8gdGhpcy5vcHRpb25zLndlaWdodCAvIDIgOiAwKSArXG5cdFx0ICAodGhpcy5fcmVuZGVyZXIub3B0aW9ucy50b2xlcmFuY2UgfHwgMCk7XG5cdH1cbn0pO1xuIiwiaW1wb3J0IHtQYXRofSBmcm9tICcuL1BhdGgnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHt0b0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuXG4vKlxuICogQGNsYXNzIENpcmNsZU1hcmtlclxuICogQGFrYSBMLkNpcmNsZU1hcmtlclxuICogQGluaGVyaXRzIFBhdGhcbiAqXG4gKiBBIGNpcmNsZSBvZiBhIGZpeGVkIHNpemUgd2l0aCByYWRpdXMgc3BlY2lmaWVkIGluIHBpeGVscy4gRXh0ZW5kcyBgUGF0aGAuXG4gKi9cblxuZXhwb3J0IHZhciBDaXJjbGVNYXJrZXIgPSBQYXRoLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBDaXJjbGVNYXJrZXIgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0ZmlsbDogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXIgPSAxMFxuXHRcdC8vIFJhZGl1cyBvZiB0aGUgY2lyY2xlIG1hcmtlciwgaW4gcGl4ZWxzXG5cdFx0cmFkaXVzOiAxMFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdExuZzogTGF0TG5nKTogdGhpc1xuXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBhIGNpcmNsZSBtYXJrZXIgdG8gYSBuZXcgbG9jYXRpb24uXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdHZhciBvbGRMYXRMbmcgPSB0aGlzLl9sYXRsbmc7XG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblx0XHR0aGlzLnJlZHJhdygpO1xuXG5cdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIGlzIG1vdmVkIHZpYSBbYHNldExhdExuZ2BdKCNjaXJjbGVtYXJrZXItc2V0bGF0bG5nKS4gT2xkIGFuZCBuZXcgY29vcmRpbmF0ZXMgYXJlIGluY2x1ZGVkIGluIGV2ZW50IGFyZ3VtZW50cyBhcyBgb2xkTGF0TG5nYCwgYGxhdGxuZ2AuXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIHtvbGRMYXRMbmc6IG9sZExhdExuZywgbGF0bG5nOiB0aGlzLl9sYXRsbmd9KTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldExhdExuZygpOiBMYXRMbmdcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgcG9zaXRpb24gb2YgdGhlIGNpcmNsZSBtYXJrZXJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFJhZGl1cyhyYWRpdXM6IE51bWJlcik6IHRoaXNcblx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlIG1hcmtlci4gVW5pdHMgYXJlIGluIHBpeGVscy5cblx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XG5cdFx0dGhpcy5vcHRpb25zLnJhZGl1cyA9IHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFJhZGl1cygpOiBOdW1iZXJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCByYWRpdXMgb2YgdGhlIGNpcmNsZVxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaXVzO1xuXHR9LFxuXG5cdHNldFN0eWxlIDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHR2YXIgcmFkaXVzID0gb3B0aW9ucyAmJiBvcHRpb25zLnJhZGl1cyB8fCB0aGlzLl9yYWRpdXM7XG5cdFx0UGF0aC5wcm90b3R5cGUuc2V0U3R5bGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLnNldFJhZGl1cyhyYWRpdXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG5cdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdH0sXG5cblx0X3VwZGF0ZUJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByID0gdGhpcy5fcmFkaXVzLFxuXHRcdCAgICByMiA9IHRoaXMuX3JhZGl1c1kgfHwgcixcblx0XHQgICAgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCksXG5cdFx0ICAgIHAgPSBbciArIHcsIHIyICsgd107XG5cdFx0dGhpcy5fcHhCb3VuZHMgPSBuZXcgQm91bmRzKHRoaXMuX3BvaW50LnN1YnRyYWN0KHApLCB0aGlzLl9wb2ludC5hZGQocCkpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZUNpcmNsZSh0aGlzKTtcblx0fSxcblxuXHRfZW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaXVzICYmICF0aGlzLl9yZW5kZXJlci5fYm91bmRzLmludGVyc2VjdHModGhpcy5fcHhCb3VuZHMpO1xuXHR9LFxuXG5cdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG5cdFx0cmV0dXJuIHAuZGlzdGFuY2VUbyh0aGlzLl9wb2ludCkgPD0gdGhpcy5fcmFkaXVzICsgdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5jaXJjbGVNYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGVNYXJrZXIgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIGNpcmNsZSBtYXJrZXIgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50LCBhbmQgYW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3QuXG5leHBvcnQgZnVuY3Rpb24gY2lyY2xlTWFya2VyKGxhdGxuZywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IENpcmNsZU1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xufVxuIiwiaW1wb3J0IHtDaXJjbGVNYXJrZXJ9IGZyb20gJy4vQ2lyY2xlTWFya2VyJztcbmltcG9ydCB7UGF0aH0gZnJvbSAnLi9QYXRoJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7dG9MYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi4vLi4vZ2VvL2Nycy9DUlMuRWFydGgnO1xuXG5cbi8qXG4gKiBAY2xhc3MgQ2lyY2xlXG4gKiBAYWthIEwuQ2lyY2xlXG4gKiBAaW5oZXJpdHMgQ2lyY2xlTWFya2VyXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBjaXJjbGUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYENpcmNsZU1hcmtlcmAuXG4gKlxuICogSXQncyBhbiBhcHByb3hpbWF0aW9uIGFuZCBzdGFydHMgdG8gZGl2ZXJnZSBmcm9tIGEgcmVhbCBjaXJjbGUgY2xvc2VyIHRvIHBvbGVzIChkdWUgdG8gcHJvamVjdGlvbiBkaXN0b3J0aW9uKS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBMLmNpcmNsZShbNTAuNSwgMzAuNV0sIHtyYWRpdXM6IDIwMH0pLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIENpcmNsZSA9IENpcmNsZU1hcmtlci5leHRlbmQoe1xuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpIHtcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG5cdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIDAuNy54IGZhY3RvcnkgKGxhdGxuZywgcmFkaXVzLCBvcHRpb25zPylcblx0XHRcdG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgbGVnYWN5T3B0aW9ucywge3JhZGl1czogb3B0aW9uc30pO1xuXHRcdH1cblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblxuXHRcdGlmIChpc05hTih0aGlzLm9wdGlvbnMucmFkaXVzKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0NpcmNsZSByYWRpdXMgY2Fubm90IGJlIE5hTicpOyB9XG5cblx0XHQvLyBAc2VjdGlvblxuXHRcdC8vIEBha2EgQ2lyY2xlIG9wdGlvbnNcblx0XHQvLyBAb3B0aW9uIHJhZGl1czogTnVtYmVyOyBSYWRpdXMgb2YgdGhlIGNpcmNsZSwgaW4gbWV0ZXJzLlxuXHRcdHRoaXMuX21SYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0UmFkaXVzKHJhZGl1czogTnVtYmVyKTogdGhpc1xuXHQvLyBTZXRzIHRoZSByYWRpdXMgb2YgYSBjaXJjbGUuIFVuaXRzIGFyZSBpbiBtZXRlcnMuXG5cdHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xuXHRcdHRoaXMuX21SYWRpdXMgPSByYWRpdXM7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRSYWRpdXMoKTogTnVtYmVyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgcmFkaXVzIG9mIGEgY2lyY2xlLiBVbml0cyBhcmUgaW4gbWV0ZXJzLlxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbVJhZGl1cztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcblx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBoYWxmID0gW3RoaXMuX3JhZGl1cywgdGhpcy5fcmFkaXVzWSB8fCB0aGlzLl9yYWRpdXNdO1xuXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoXG5cdFx0XHR0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LnN1YnRyYWN0KGhhbGYpKSxcblx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuYWRkKGhhbGYpKSk7XG5cdH0sXG5cblx0c2V0U3R5bGU6IFBhdGgucHJvdG90eXBlLnNldFN0eWxlLFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbG5nID0gdGhpcy5fbGF0bG5nLmxuZyxcblx0XHQgICAgbGF0ID0gdGhpcy5fbGF0bG5nLmxhdCxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBjcnMgPSBtYXAub3B0aW9ucy5jcnM7XG5cblx0XHRpZiAoY3JzLmRpc3RhbmNlID09PSBFYXJ0aC5kaXN0YW5jZSkge1xuXHRcdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdFx0ICAgIGxhdFIgPSAodGhpcy5fbVJhZGl1cyAvIEVhcnRoLlIpIC8gZCxcblx0XHRcdCAgICB0b3AgPSBtYXAucHJvamVjdChbbGF0ICsgbGF0UiwgbG5nXSksXG5cdFx0XHQgICAgYm90dG9tID0gbWFwLnByb2plY3QoW2xhdCAtIGxhdFIsIGxuZ10pLFxuXHRcdFx0ICAgIHAgPSB0b3AuYWRkKGJvdHRvbSkuZGl2aWRlQnkoMiksXG5cdFx0XHQgICAgbGF0MiA9IG1hcC51bnByb2plY3QocCkubGF0LFxuXHRcdFx0ICAgIGxuZ1IgPSBNYXRoLmFjb3MoKE1hdGguY29zKGxhdFIgKiBkKSAtIE1hdGguc2luKGxhdCAqIGQpICogTWF0aC5zaW4obGF0MiAqIGQpKSAvXG5cdFx0XHQgICAgICAgICAgICAoTWF0aC5jb3MobGF0ICogZCkgKiBNYXRoLmNvcyhsYXQyICogZCkpKSAvIGQ7XG5cblx0XHRcdGlmIChpc05hTihsbmdSKSB8fCBsbmdSID09PSAwKSB7XG5cdFx0XHRcdGxuZ1IgPSBsYXRSIC8gTWF0aC5jb3MoTWF0aC5QSSAvIDE4MCAqIGxhdCk7IC8vIEZhbGxiYWNrIGZvciBlZGdlIGNhc2UsICMyNDI1XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3BvaW50ID0gcC5zdWJ0cmFjdChtYXAuZ2V0UGl4ZWxPcmlnaW4oKSk7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSBpc05hTihsbmdSKSA/IDAgOiBwLnggLSBtYXAucHJvamVjdChbbGF0MiwgbG5nIC0gbG5nUl0pLng7XG5cdFx0XHR0aGlzLl9yYWRpdXNZID0gcC55IC0gdG9wLnk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGxhdGxuZzIgPSBjcnMudW5wcm9qZWN0KGNycy5wcm9qZWN0KHRoaXMuX2xhdGxuZykuc3VidHJhY3QoW3RoaXMuX21SYWRpdXMsIDBdKSk7XG5cblx0XHRcdHRoaXMuX3BvaW50ID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdFx0dGhpcy5fcmFkaXVzID0gdGhpcy5fcG9pbnQueCAtIG1hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nMikueDtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuY2lyY2xlKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogQ2lyY2xlIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBjaXJjbGUgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50LCBhbmQgYW4gb3B0aW9ucyBvYmplY3Rcbi8vIHdoaWNoIGNvbnRhaW5zIHRoZSBjaXJjbGUgcmFkaXVzLlxuLy8gQGFsdGVybmF0aXZlXG4vLyBAZmFjdG9yeSBMLmNpcmNsZShsYXRsbmc6IExhdExuZywgcmFkaXVzOiBOdW1iZXIsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcbi8vIE9ic29sZXRlIHdheSBvZiBpbnN0YW50aWF0aW5nIGEgY2lyY2xlLCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIDAuNy54IGNvZGUuXG4vLyBEbyBub3QgdXNlIGluIG5ldyBhcHBsaWNhdGlvbnMgb3IgcGx1Z2lucy5cbmV4cG9ydCBmdW5jdGlvbiBjaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG5cdHJldHVybiBuZXcgQ2lyY2xlKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge1BhdGh9IGZyb20gJy4vUGF0aCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuLi8uLi9nZW9tZXRyeS9MaW5lVXRpbCc7XG5pbXBvcnQge0xhdExuZywgdG9MYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5cbi8qXG4gKiBAY2xhc3MgUG9seWxpbmVcbiAqIEBha2EgTC5Qb2x5bGluZVxuICogQGluaGVyaXRzIFBhdGhcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHBvbHlsaW5lIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQYXRoYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWxpbmUgZnJvbSBhbiBhcnJheSBvZiBMYXRMbmcgcG9pbnRzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqIFx0WzQ1LjUxLCAtMTIyLjY4XSxcbiAqIFx0WzM3Ljc3LCAtMTIyLjQzXSxcbiAqIFx0WzM0LjA0LCAtMTE4LjJdXG4gKiBdO1xuICpcbiAqIHZhciBwb2x5bGluZSA9IEwucG9seWxpbmUobGF0bG5ncywge2NvbG9yOiAncmVkJ30pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSBwb2x5bGluZVxuICogbWFwLmZpdEJvdW5kcyhwb2x5bGluZS5nZXRCb3VuZHMoKSk7XG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIGFsc28gcGFzcyBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IHRvIHJlcHJlc2VudCBhIGBNdWx0aVBvbHlsaW5lYCBzaGFwZTpcbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGEgcmVkIHBvbHlsaW5lIGZyb20gYW4gYXJyYXkgb2YgYXJyYXlzIG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogXHRbWzQ1LjUxLCAtMTIyLjY4XSxcbiAqIFx0IFszNy43NywgLTEyMi40M10sXG4gKiBcdCBbMzQuMDQsIC0xMTguMl1dLFxuICogXHRbWzQwLjc4LCAtNzMuOTFdLFxuICogXHQgWzQxLjgzLCAtODcuNjJdLFxuICogXHQgWzMyLjc2LCAtOTYuNzJdXVxuICogXTtcbiAqIGBgYFxuICovXG5cblxuZXhwb3J0IHZhciBQb2x5bGluZSA9IFBhdGguZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFBvbHlsaW5lIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gc21vb3RoRmFjdG9yOiBOdW1iZXIgPSAxLjBcblx0XHQvLyBIb3cgbXVjaCB0byBzaW1wbGlmeSB0aGUgcG9seWxpbmUgb24gZWFjaCB6b29tIGxldmVsLiBNb3JlIG1lYW5zXG5cdFx0Ly8gYmV0dGVyIHBlcmZvcm1hbmNlIGFuZCBzbW9vdGhlciBsb29rLCBhbmQgbGVzcyBtZWFucyBtb3JlIGFjY3VyYXRlIHJlcHJlc2VudGF0aW9uLlxuXHRcdHNtb290aEZhY3RvcjogMS4wLFxuXG5cdFx0Ly8gQG9wdGlvbiBub0NsaXA6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIERpc2FibGUgcG9seWxpbmUgY2xpcHBpbmcuXG5cdFx0bm9DbGlwOiBmYWxzZVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX3NldExhdExuZ3MobGF0bG5ncyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmdzKCk6IExhdExuZ1tdXG5cdC8vIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHBvaW50cyBpbiB0aGUgcGF0aCwgb3IgbmVzdGVkIGFycmF5cyBvZiBwb2ludHMgaW4gY2FzZSBvZiBtdWx0aS1wb2x5bGluZS5cblx0Z2V0TGF0TG5nczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sYXRsbmdzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5ncyhsYXRsbmdzOiBMYXRMbmdbXSk6IHRoaXNcblx0Ly8gUmVwbGFjZXMgYWxsIHRoZSBwb2ludHMgaW4gdGhlIHBvbHlsaW5lIHdpdGggdGhlIGdpdmVuIGFycmF5IG9mIGdlb2dyYXBoaWNhbCBwb2ludHMuXG5cdHNldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dGhpcy5fc2V0TGF0TG5ncyhsYXRsbmdzKTtcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzRW1wdHkoKTogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgUG9seWxpbmUgaGFzIG5vIExhdExuZ3MuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2xhdGxuZ3MubGVuZ3RoO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvc2VzdExheWVyUG9pbnQocDogUG9pbnQpOiBQb2ludFxuXHQvLyBSZXR1cm5zIHRoZSBwb2ludCBjbG9zZXN0IHRvIGBwYCBvbiB0aGUgUG9seWxpbmUuXG5cdGNsb3Nlc3RMYXllclBvaW50OiBmdW5jdGlvbiAocCkge1xuXHRcdHZhciBtaW5EaXN0YW5jZSA9IEluZmluaXR5LFxuXHRcdCAgICBtaW5Qb2ludCA9IG51bGwsXG5cdFx0ICAgIGNsb3Nlc3QgPSBMaW5lVXRpbC5fc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQsXG5cdFx0ICAgIHAxLCBwMjtcblxuXHRcdGZvciAodmFyIGogPSAwLCBqTGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XG5cdFx0XHR2YXIgcG9pbnRzID0gdGhpcy5fcGFydHNbal07XG5cblx0XHRcdGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cDEgPSBwb2ludHNbaSAtIDFdO1xuXHRcdFx0XHRwMiA9IHBvaW50c1tpXTtcblxuXHRcdFx0XHR2YXIgc3FEaXN0ID0gY2xvc2VzdChwLCBwMSwgcDIsIHRydWUpO1xuXG5cdFx0XHRcdGlmIChzcURpc3QgPCBtaW5EaXN0YW5jZSkge1xuXHRcdFx0XHRcdG1pbkRpc3RhbmNlID0gc3FEaXN0O1xuXHRcdFx0XHRcdG1pblBvaW50ID0gY2xvc2VzdChwLCBwMSwgcDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChtaW5Qb2ludCkge1xuXHRcdFx0bWluUG9pbnQuZGlzdGFuY2UgPSBNYXRoLnNxcnQobWluRGlzdGFuY2UpO1xuXHRcdH1cblx0XHRyZXR1cm4gbWluUG9pbnQ7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciAoW2NlbnRyb2lkXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cm9pZCkpIG9mIHRoZSBwb2x5bGluZS5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTXVzdCBhZGQgbGF5ZXIgdG8gbWFwIGJlZm9yZSB1c2luZyBnZXRDZW50ZXIoKScpO1xuXHRcdH1cblx0XHRyZXR1cm4gTGluZVV0aWwucG9seWxpbmVDZW50ZXIodGhpcy5fZGVmYXVsdFNoYXBlKCksIHRoaXMuX21hcC5vcHRpb25zLmNycyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXG5cdC8vIFJldHVybnMgdGhlIGBMYXRMbmdCb3VuZHNgIG9mIHRoZSBwYXRoLlxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYWRkTGF0TG5nKGxhdGxuZzogTGF0TG5nLCBsYXRsbmdzPzogTGF0TG5nW10pOiB0aGlzXG5cdC8vIEFkZHMgYSBnaXZlbiBwb2ludCB0byB0aGUgcG9seWxpbmUuIEJ5IGRlZmF1bHQsIGFkZHMgdG8gdGhlIGZpcnN0IHJpbmcgb2Zcblx0Ly8gdGhlIHBvbHlsaW5lIGluIGNhc2Ugb2YgYSBtdWx0aS1wb2x5bGluZSwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3Npbmdcblx0Ly8gYSBzcGVjaWZpYyByaW5nIGFzIGEgTGF0TG5nIGFycmF5ICh0aGF0IHlvdSBjYW4gZWFybGllciBhY2Nlc3Mgd2l0aCBbYGdldExhdExuZ3NgXSgjcG9seWxpbmUtZ2V0bGF0bG5ncykpLlxuXHRhZGRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcsIGxhdGxuZ3MpIHtcblx0XHRsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLl9kZWZhdWx0U2hhcGUoKTtcblx0XHRsYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xuXHRcdHRoaXMuX2JvdW5kcy5leHRlbmQobGF0bG5nKTtcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHRfc2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR0aGlzLl9ib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKCk7XG5cdFx0dGhpcy5fbGF0bG5ncyA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3MpO1xuXHR9LFxuXG5cdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3MpID8gdGhpcy5fbGF0bG5ncyA6IHRoaXMuX2xhdGxuZ3NbMF07XG5cdH0sXG5cblx0Ly8gcmVjdXJzaXZlbHkgY29udmVydCBsYXRsbmdzIGlucHV0IGludG8gYWN0dWFsIExhdExuZyBpbnN0YW5jZXM7IGNhbGN1bGF0ZSBib3VuZHMgYWxvbmcgdGhlIHdheVxuXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFtdLFxuXHRcdCAgICBmbGF0ID0gTGluZVV0aWwuaXNGbGF0KGxhdGxuZ3MpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChmbGF0KSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IHRvTGF0TG5nKGxhdGxuZ3NbaV0pO1xuXHRcdFx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKHJlc3VsdFtpXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHRbaV0gPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHB4Qm91bmRzID0gbmV3IEJvdW5kcygpO1xuXHRcdHRoaXMuX3JpbmdzID0gW107XG5cdFx0dGhpcy5fcHJvamVjdExhdGxuZ3ModGhpcy5fbGF0bG5ncywgdGhpcy5fcmluZ3MsIHB4Qm91bmRzKTtcblxuXHRcdGlmICh0aGlzLl9ib3VuZHMuaXNWYWxpZCgpICYmIHB4Qm91bmRzLmlzVmFsaWQoKSkge1xuXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMgPSBweEJvdW5kcztcblx0XHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpLFxuXHRcdCAgICBwID0gbmV3IFBvaW50KHcsIHcpO1xuXG5cdFx0aWYgKCF0aGlzLl9yYXdQeEJvdW5kcykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3B4Qm91bmRzID0gbmV3IEJvdW5kcyhbXG5cdFx0XHR0aGlzLl9yYXdQeEJvdW5kcy5taW4uc3VidHJhY3QocCksXG5cdFx0XHR0aGlzLl9yYXdQeEJvdW5kcy5tYXguYWRkKHApXG5cdFx0XSk7XG5cdH0sXG5cblx0Ly8gcmVjdXJzaXZlbHkgdHVybnMgbGF0bG5ncyBpbnRvIGEgc2V0IG9mIHJpbmdzIHdpdGggcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdF9wcm9qZWN0TGF0bG5nczogZnVuY3Rpb24gKGxhdGxuZ3MsIHJlc3VsdCwgcHJvamVjdGVkQm91bmRzKSB7XG5cdFx0dmFyIGZsYXQgPSBsYXRsbmdzWzBdIGluc3RhbmNlb2YgTGF0TG5nLFxuXHRcdCAgICBsZW4gPSBsYXRsbmdzLmxlbmd0aCxcblx0XHQgICAgaSwgcmluZztcblxuXHRcdGlmIChmbGF0KSB7XG5cdFx0XHRyaW5nID0gW107XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cmluZ1tpXSA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nc1tpXSk7XG5cdFx0XHRcdHByb2plY3RlZEJvdW5kcy5leHRlbmQocmluZ1tpXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQucHVzaChyaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX3Byb2plY3RMYXRsbmdzKGxhdGxuZ3NbaV0sIHJlc3VsdCwgcHJvamVjdGVkQm91bmRzKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gY2xpcCBwb2x5bGluZSBieSByZW5kZXJlciBib3VuZHMgc28gdGhhdCB3ZSBoYXZlIGxlc3MgdG8gcmVuZGVyIGZvciBwZXJmb3JtYW5jZVxuXHRfY2xpcFBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZW5kZXJlci5fYm91bmRzO1xuXG5cdFx0dGhpcy5fcGFydHMgPSBbXTtcblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm5vQ2xpcCkge1xuXHRcdFx0dGhpcy5fcGFydHMgPSB0aGlzLl9yaW5ncztcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcblx0XHQgICAgaSwgaiwgaywgbGVuLCBsZW4yLCBzZWdtZW50LCBwb2ludHM7XG5cblx0XHRmb3IgKGkgPSAwLCBrID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBvaW50cyA9IHRoaXMuX3JpbmdzW2ldO1xuXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcG9pbnRzLmxlbmd0aDsgaiA8IGxlbjIgLSAxOyBqKyspIHtcblx0XHRcdFx0c2VnbWVudCA9IExpbmVVdGlsLmNsaXBTZWdtZW50KHBvaW50c1tqXSwgcG9pbnRzW2ogKyAxXSwgYm91bmRzLCBqLCB0cnVlKTtcblxuXHRcdFx0XHRpZiAoIXNlZ21lbnQpIHsgY29udGludWU7IH1cblxuXHRcdFx0XHRwYXJ0c1trXSA9IHBhcnRzW2tdIHx8IFtdO1xuXHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMF0pO1xuXG5cdFx0XHRcdC8vIGlmIHNlZ21lbnQgZ29lcyBvdXQgb2Ygc2NyZWVuLCBvciBpdCdzIHRoZSBsYXN0IG9uZSwgaXQncyB0aGUgZW5kIG9mIHRoZSBsaW5lIHBhcnRcblx0XHRcdFx0aWYgKChzZWdtZW50WzFdICE9PSBwb2ludHNbaiArIDFdKSB8fCAoaiA9PT0gbGVuMiAtIDIpKSB7XG5cdFx0XHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzFdKTtcblx0XHRcdFx0XHRrKys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gc2ltcGxpZnkgZWFjaCBjbGlwcGVkIHBhcnQgb2YgdGhlIHBvbHlsaW5lIGZvciBwZXJmb3JtYW5jZVxuXHRfc2ltcGxpZnlQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcblx0XHQgICAgdG9sZXJhbmNlID0gdGhpcy5vcHRpb25zLnNtb290aEZhY3RvcjtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cGFydHNbaV0gPSBMaW5lVXRpbC5zaW1wbGlmeShwYXJ0c1tpXSwgdG9sZXJhbmNlKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fY2xpcFBvaW50cygpO1xuXHRcdHRoaXMuX3NpbXBsaWZ5UG9pbnRzKCk7XG5cdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcyk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHAsIGNsb3NlZCkge1xuXHRcdHZhciBpLCBqLCBrLCBsZW4sIGxlbjIsIHBhcnQsXG5cdFx0ICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuXG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyBoaXQgZGV0ZWN0aW9uIGZvciBwb2x5bGluZXNcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cGFydCA9IHRoaXMuX3BhcnRzW2ldO1xuXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydC5sZW5ndGgsIGsgPSBsZW4yIC0gMTsgaiA8IGxlbjI7IGsgPSBqKyspIHtcblx0XHRcdFx0aWYgKCFjbG9zZWQgJiYgKGogPT09IDApKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0aWYgKExpbmVVdGlsLnBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcGFydFtrXSwgcGFydFtqXSkgPD0gdykge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwucG9seWxpbmUobGF0bG5nczogTGF0TG5nW10sIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgcG9seWxpbmUgb2JqZWN0IGdpdmVuIGFuIGFycmF5IG9mIGdlb2dyYXBoaWNhbCBwb2ludHMgYW5kXG4vLyBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LiBZb3UgY2FuIGNyZWF0ZSBhIGBQb2x5bGluZWAgb2JqZWN0IHdpdGhcbi8vIG11bHRpcGxlIHNlcGFyYXRlIGxpbmVzIChgTXVsdGlQb2x5bGluZWApIGJ5IHBhc3NpbmcgYW4gYXJyYXkgb2YgYXJyYXlzXG4vLyBvZiBnZW9ncmFwaGljIHBvaW50cy5cbmV4cG9ydCBmdW5jdGlvbiBwb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XG59XG5cbi8vIFJldHJvY29tcGF0LiBBbGxvdyBwbHVnaW5zIHRvIHN1cHBvcnQgTGVhZmxldCB2ZXJzaW9ucyBiZWZvcmUgYW5kIGFmdGVyIDEuMS5cblBvbHlsaW5lLl9mbGF0ID0gTGluZVV0aWwuX2ZsYXQ7XG4iLCJpbXBvcnQge1BvbHlsaW5lfSBmcm9tICcuL1BvbHlsaW5lJztcbmltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcbmltcG9ydCAqIGFzIExpbmVVdGlsIGZyb20gJy4uLy4uL2dlb21ldHJ5L0xpbmVVdGlsJztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuaW1wb3J0ICogYXMgUG9seVV0aWwgZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9seVV0aWwnO1xuXG4vKlxuICogQGNsYXNzIFBvbHlnb25cbiAqIEBha2EgTC5Qb2x5Z29uXG4gKiBAaW5oZXJpdHMgUG9seWxpbmVcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHBvbHlnb24gb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBvbHlsaW5lYC5cbiAqXG4gKiBOb3RlIHRoYXQgcG9pbnRzIHlvdSBwYXNzIHdoZW4gY3JlYXRpbmcgYSBwb2x5Z29uIHNob3VsZG4ndCBoYXZlIGFuIGFkZGl0aW9uYWwgbGFzdCBwb2ludCBlcXVhbCB0byB0aGUgZmlyc3Qgb25lIOKAlCBpdCdzIGJldHRlciB0byBmaWx0ZXIgb3V0IHN1Y2ggcG9pbnRzLlxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWdvbiBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dO1xuICpcbiAqIHZhciBwb2x5Z29uID0gTC5wb2x5Z29uKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWdvblxuICogbWFwLmZpdEJvdW5kcyhwb2x5Z29uLmdldEJvdW5kcygpKTtcbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGFycmF5IG9mIGFycmF5cyBvZiBsYXRsbmdzLCB3aXRoIHRoZSBmaXJzdCBhcnJheSByZXByZXNlbnRpbmcgdGhlIG91dGVyIHNoYXBlIGFuZCB0aGUgb3RoZXIgYXJyYXlzIHJlcHJlc2VudGluZyBob2xlcyBpbiB0aGUgb3V0ZXIgc2hhcGU6XG4gKlxuICogYGBganNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogICBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV0sIC8vIG91dGVyIHJpbmdcbiAqICAgW1szNy4yOSwgLTEwOC41OF0sWzQwLjcxLCAtMTA4LjU4XSxbNDAuNzEsIC0xMDIuNTBdLFszNy4yOSwgLTEwMi41MF1dIC8vIGhvbGVcbiAqIF07XG4gKiBgYGBcbiAqXG4gKiBBZGRpdGlvbmFsbHksIHlvdSBjYW4gcGFzcyBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IHRvIHJlcHJlc2VudCBhIE11bHRpUG9seWdvbiBzaGFwZS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiAgIFsgLy8gZmlyc3QgcG9seWdvblxuICogICAgIFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXSwgLy8gb3V0ZXIgcmluZ1xuICogICAgIFtbMzcuMjksIC0xMDguNThdLFs0MC43MSwgLTEwOC41OF0sWzQwLjcxLCAtMTAyLjUwXSxbMzcuMjksIC0xMDIuNTBdXSAvLyBob2xlXG4gKiAgIF0sXG4gKiAgIFsgLy8gc2Vjb25kIHBvbHlnb25cbiAqICAgICBbWzQxLCAtMTExLjAzXSxbNDUsIC0xMTEuMDRdLFs0NSwgLTEwNC4wNV0sWzQxLCAtMTA0LjA1XV1cbiAqICAgXVxuICogXTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgUG9seWdvbiA9IFBvbHlsaW5lLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdGZpbGw6IHRydWVcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9sYXRsbmdzLmxlbmd0aCB8fCAhdGhpcy5fbGF0bG5nc1swXS5sZW5ndGg7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciAoW2NlbnRyb2lkXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIFBvbHlnb24uXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHRocm93cyBlcnJvciB3aGVuIG5vdCB5ZXQgYWRkZWQgdG8gbWFwIGFzIHRoaXMgY2VudGVyIGNhbGN1bGF0aW9uIHJlcXVpcmVzIHByb2plY3RlZCBjb29yZGluYXRlc1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcblx0XHR9XG5cdFx0cmV0dXJuIFBvbHlVdGlsLnBvbHlnb25DZW50ZXIodGhpcy5fZGVmYXVsdFNoYXBlKCksIHRoaXMuX21hcC5vcHRpb25zLmNycyk7XG5cdH0sXG5cblx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHZhciByZXN1bHQgPSBQb2x5bGluZS5wcm90b3R5cGUuX2NvbnZlcnRMYXRMbmdzLmNhbGwodGhpcywgbGF0bG5ncyksXG5cdFx0ICAgIGxlbiA9IHJlc3VsdC5sZW5ndGg7XG5cblx0XHQvLyByZW1vdmUgbGFzdCBwb2ludCBpZiBpdCBlcXVhbHMgZmlyc3Qgb25lXG5cdFx0aWYgKGxlbiA+PSAyICYmIHJlc3VsdFswXSBpbnN0YW5jZW9mIExhdExuZyAmJiByZXN1bHRbMF0uZXF1YWxzKHJlc3VsdFtsZW4gLSAxXSkpIHtcblx0XHRcdHJlc3VsdC5wb3AoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHRfc2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHRQb2x5bGluZS5wcm90b3R5cGUuX3NldExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKTtcblx0XHRpZiAoTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3MpKSB7XG5cdFx0XHR0aGlzLl9sYXRsbmdzID0gW3RoaXMuX2xhdGxuZ3NdO1xuXHRcdH1cblx0fSxcblxuXHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIExpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzWzBdKSA/IHRoaXMuX2xhdGxuZ3NbMF0gOiB0aGlzLl9sYXRsbmdzWzBdWzBdO1xuXHR9LFxuXG5cdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcG9seWdvbnMgbmVlZCBhIGRpZmZlcmVudCBjbGlwcGluZyBhbGdvcml0aG0gc28gd2UgcmVkZWZpbmUgdGhhdFxuXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlbmRlcmVyLl9ib3VuZHMsXG5cdFx0ICAgIHcgPSB0aGlzLm9wdGlvbnMud2VpZ2h0LFxuXHRcdCAgICBwID0gbmV3IFBvaW50KHcsIHcpO1xuXG5cdFx0Ly8gaW5jcmVhc2UgY2xpcCBwYWRkaW5nIGJ5IHN0cm9rZSB3aWR0aCB0byBhdm9pZCBzdHJva2Ugb24gY2xpcCBlZGdlc1xuXHRcdGJvdW5kcyA9IG5ldyBCb3VuZHMoYm91bmRzLm1pbi5zdWJ0cmFjdChwKSwgYm91bmRzLm1heC5hZGQocCkpO1xuXG5cdFx0dGhpcy5fcGFydHMgPSBbXTtcblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm5vQ2xpcCkge1xuXHRcdFx0dGhpcy5fcGFydHMgPSB0aGlzLl9yaW5ncztcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoLCBjbGlwcGVkOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGNsaXBwZWQgPSBQb2x5VXRpbC5jbGlwUG9seWdvbih0aGlzLl9yaW5nc1tpXSwgYm91bmRzLCB0cnVlKTtcblx0XHRcdGlmIChjbGlwcGVkLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLl9wYXJ0cy5wdXNoKGNsaXBwZWQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQb2x5KHRoaXMsIHRydWUpO1xuXHR9LFxuXG5cdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG5cdFx0dmFyIGluc2lkZSA9IGZhbHNlLFxuXHRcdCAgICBwYXJ0LCBwMSwgcDIsIGksIGosIGssIGxlbiwgbGVuMjtcblxuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmNvbnRhaW5zKHApKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gcmF5IGNhc3RpbmcgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgaWYgcG9pbnQgaXMgaW4gcG9seWdvblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuXHRcdFx0XHRwMSA9IHBhcnRbal07XG5cdFx0XHRcdHAyID0gcGFydFtrXTtcblxuXHRcdFx0XHRpZiAoKChwMS55ID4gcC55KSAhPT0gKHAyLnkgPiBwLnkpKSAmJiAocC54IDwgKHAyLnggLSBwMS54KSAqIChwLnkgLSBwMS55KSAvIChwMi55IC0gcDEueSkgKyBwMS54KSkge1xuXHRcdFx0XHRcdGluc2lkZSA9ICFpbnNpZGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBhbHNvIGNoZWNrIGlmIGl0J3Mgb24gcG9seWdvbiBzdHJva2Vcblx0XHRyZXR1cm4gaW5zaWRlIHx8IFBvbHlsaW5lLnByb3RvdHlwZS5fY29udGFpbnNQb2ludC5jYWxsKHRoaXMsIHAsIHRydWUpO1xuXHR9XG5cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwucG9seWdvbihsYXRsbmdzOiBMYXRMbmdbXSwgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG5leHBvcnQgZnVuY3Rpb24gcG9seWdvbihsYXRsbmdzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcbn1cbiIsImltcG9ydCB7TGF5ZXJHcm91cH0gZnJvbSAnLi9MYXllckdyb3VwJztcclxuaW1wb3J0IHtGZWF0dXJlR3JvdXB9IGZyb20gJy4vRmVhdHVyZUdyb3VwJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge01hcmtlcn0gZnJvbSAnLi9tYXJrZXIvTWFya2VyJztcclxuaW1wb3J0IHtDaXJjbGV9IGZyb20gJy4vdmVjdG9yL0NpcmNsZSc7XHJcbmltcG9ydCB7Q2lyY2xlTWFya2VyfSBmcm9tICcuL3ZlY3Rvci9DaXJjbGVNYXJrZXInO1xyXG5pbXBvcnQge1BvbHlsaW5lfSBmcm9tICcuL3ZlY3Rvci9Qb2x5bGluZSc7XHJcbmltcG9ydCB7UG9seWdvbn0gZnJvbSAnLi92ZWN0b3IvUG9seWdvbic7XHJcbmltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0ICogYXMgTGluZVV0aWwgZnJvbSAnLi4vZ2VvbWV0cnkvTGluZVV0aWwnO1xyXG5pbXBvcnQge3RvTGF0TG5nfSBmcm9tICcuLi9nZW8vTGF0TG5nJztcclxuXHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgR2VvSlNPTlxyXG4gKiBAYWthIEwuR2VvSlNPTlxyXG4gKiBAaW5oZXJpdHMgRmVhdHVyZUdyb3VwXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBHZW9KU09OIG9iamVjdCBvciBhbiBhcnJheSBvZiBHZW9KU09OIG9iamVjdHMuIEFsbG93cyB5b3UgdG8gcGFyc2VcclxuICogR2VvSlNPTiBkYXRhIGFuZCBkaXNwbGF5IGl0IG9uIHRoZSBtYXAuIEV4dGVuZHMgYEZlYXR1cmVHcm91cGAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwuZ2VvSlNPTihkYXRhLCB7XHJcbiAqIFx0c3R5bGU6IGZ1bmN0aW9uIChmZWF0dXJlKSB7XHJcbiAqIFx0XHRyZXR1cm4ge2NvbG9yOiBmZWF0dXJlLnByb3BlcnRpZXMuY29sb3J9O1xyXG4gKiBcdH1cclxuICogfSkuYmluZFBvcHVwKGZ1bmN0aW9uIChsYXllcikge1xyXG4gKiBcdHJldHVybiBsYXllci5mZWF0dXJlLnByb3BlcnRpZXMuZGVzY3JpcHRpb247XHJcbiAqIH0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgR2VvSlNPTiA9IEZlYXR1cmVHcm91cC5leHRlbmQoe1xyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqIEBha2EgR2VvSlNPTiBvcHRpb25zXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHBvaW50VG9MYXllcjogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIGhvdyBHZW9KU09OIHBvaW50cyBzcGF3biBMZWFmbGV0IGxheWVycy4gSXQgaXMgaW50ZXJuYWxseVxyXG5cdCAqIGNhbGxlZCB3aGVuIGRhdGEgaXMgYWRkZWQsIHBhc3NpbmcgdGhlIEdlb0pTT04gcG9pbnQgZmVhdHVyZSBhbmQgaXRzIGBMYXRMbmdgLlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIHNwYXduIGEgZGVmYXVsdCBgTWFya2VyYDpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uKGdlb0pzb25Qb2ludCwgbGF0bG5nKSB7XHJcblx0ICogXHRyZXR1cm4gTC5tYXJrZXIobGF0bG5nKTtcclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHN0eWxlOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgZGVmaW5pbmcgdGhlIGBQYXRoIG9wdGlvbnNgIGZvciBzdHlsaW5nIEdlb0pTT04gbGluZXMgYW5kIHBvbHlnb25zLFxyXG5cdCAqIGNhbGxlZCBpbnRlcm5hbGx5IHdoZW4gZGF0YSBpcyBhZGRlZC5cclxuXHQgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0byBub3Qgb3ZlcnJpZGUgYW55IGRlZmF1bHRzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGdlb0pzb25GZWF0dXJlKSB7XHJcblx0ICogXHRyZXR1cm4ge31cclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIG9uRWFjaEZlYXR1cmU6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uY2UgZm9yIGVhY2ggY3JlYXRlZCBgRmVhdHVyZWAsIGFmdGVyIGl0IGhhc1xyXG5cdCAqIGJlZW4gY3JlYXRlZCBhbmQgc3R5bGVkLiBVc2VmdWwgZm9yIGF0dGFjaGluZyBldmVudHMgYW5kIHBvcHVwcyB0byBmZWF0dXJlcy5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBkbyBub3RoaW5nIHdpdGggdGhlIG5ld2x5IGNyZWF0ZWQgbGF5ZXJzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGZlYXR1cmUsIGxheWVyKSB7fVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBmaWx0ZXI6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgdXNlZCB0byBkZWNpZGUgd2hldGhlciB0byBpbmNsdWRlIGEgZmVhdHVyZSBvciBub3QuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gaW5jbHVkZSBhbGwgZmVhdHVyZXM6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbiAoZ2VvSnNvbkZlYXR1cmUpIHtcclxuXHQgKiBcdHJldHVybiB0cnVlO1xyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKiBOb3RlOiBkeW5hbWljYWxseSBjaGFuZ2luZyB0aGUgYGZpbHRlcmAgb3B0aW9uIHdpbGwgaGF2ZSBlZmZlY3Qgb25seSBvbiBuZXdseVxyXG5cdCAqIGFkZGVkIGRhdGEuIEl0IHdpbGwgX25vdF8gcmUtZXZhbHVhdGUgYWxyZWFkeSBpbmNsdWRlZCBmZWF0dXJlcy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gY29vcmRzVG9MYXRMbmc6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgY29udmVydGluZyBHZW9KU09OIGNvb3JkaW5hdGVzIHRvIGBMYXRMbmdgcy5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0aGUgYGNvb3Jkc1RvTGF0TG5nYCBzdGF0aWMgbWV0aG9kLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBtYXJrZXJzSW5oZXJpdE9wdGlvbnM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdCAqIFdoZXRoZXIgZGVmYXVsdCBNYXJrZXJzIGZvciBcIlBvaW50XCIgdHlwZSBGZWF0dXJlcyBpbmhlcml0IGZyb20gZ3JvdXAgb3B0aW9ucy5cclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcblx0XHRpZiAoZ2VvanNvbikge1xyXG5cdFx0XHR0aGlzLmFkZERhdGEoZ2VvanNvbik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGREYXRhKCA8R2VvSlNPTj4gZGF0YSApOiB0aGlzXHJcblx0Ly8gQWRkcyBhIEdlb0pTT04gb2JqZWN0IHRvIHRoZSBsYXllci5cclxuXHRhZGREYXRhOiBmdW5jdGlvbiAoZ2VvanNvbikge1xyXG5cdFx0dmFyIGZlYXR1cmVzID0gVXRpbC5pc0FycmF5KGdlb2pzb24pID8gZ2VvanNvbiA6IGdlb2pzb24uZmVhdHVyZXMsXHJcblx0XHQgICAgaSwgbGVuLCBmZWF0dXJlO1xyXG5cclxuXHRcdGlmIChmZWF0dXJlcykge1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdC8vIG9ubHkgYWRkIHRoaXMgaWYgZ2VvbWV0cnkgb3IgZ2VvbWV0cmllcyBhcmUgc2V0IGFuZCBub3QgbnVsbFxyXG5cdFx0XHRcdGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcclxuXHRcdFx0XHRpZiAoZmVhdHVyZS5nZW9tZXRyaWVzIHx8IGZlYXR1cmUuZ2VvbWV0cnkgfHwgZmVhdHVyZS5mZWF0dXJlcyB8fCBmZWF0dXJlLmNvb3JkaW5hdGVzKSB7XHJcblx0XHRcdFx0XHR0aGlzLmFkZERhdGEoZmVhdHVyZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLmZpbHRlciAmJiAhb3B0aW9ucy5maWx0ZXIoZ2VvanNvbikpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgbGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXIoZ2VvanNvbiwgb3B0aW9ucyk7XHJcblx0XHRpZiAoIWxheWVyKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0bGF5ZXIuZmVhdHVyZSA9IGFzRmVhdHVyZShnZW9qc29uKTtcclxuXHJcblx0XHRsYXllci5kZWZhdWx0T3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XHJcblx0XHR0aGlzLnJlc2V0U3R5bGUobGF5ZXIpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLm9uRWFjaEZlYXR1cmUpIHtcclxuXHRcdFx0b3B0aW9ucy5vbkVhY2hGZWF0dXJlKGdlb2pzb24sIGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihsYXllcik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZXNldFN0eWxlKCA8UGF0aD4gbGF5ZXI/ICk6IHRoaXNcclxuXHQvLyBSZXNldHMgdGhlIGdpdmVuIHZlY3RvciBsYXllcidzIHN0eWxlIHRvIHRoZSBvcmlnaW5hbCBHZW9KU09OIHN0eWxlLCB1c2VmdWwgZm9yIHJlc2V0dGluZyBzdHlsZSBhZnRlciBob3ZlciBldmVudHMuXHJcblx0Ly8gSWYgYGxheWVyYCBpcyBvbWl0dGVkLCB0aGUgc3R5bGUgb2YgYWxsIGZlYXR1cmVzIGluIHRoZSBjdXJyZW50IGxheWVyIGlzIHJlc2V0LlxyXG5cdHJlc2V0U3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKHRoaXMucmVzZXRTdHlsZSwgdGhpcyk7XHJcblx0XHR9XHJcblx0XHQvLyByZXNldCBhbnkgY3VzdG9tIHN0eWxlc1xyXG5cdFx0bGF5ZXIub3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBsYXllci5kZWZhdWx0T3B0aW9ucyk7XHJcblx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCB0aGlzLm9wdGlvbnMuc3R5bGUpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRTdHlsZSggPEZ1bmN0aW9uPiBzdHlsZSApOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyBzdHlsZXMgb2YgR2VvSlNPTiB2ZWN0b3IgbGF5ZXJzIHdpdGggdGhlIGdpdmVuIHN0eWxlIGZ1bmN0aW9uLlxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgc3R5bGUpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X3NldExheWVyU3R5bGU6IGZ1bmN0aW9uIChsYXllciwgc3R5bGUpIHtcclxuXHRcdGlmIChsYXllci5zZXRTdHlsZSkge1xyXG5cdFx0XHRpZiAodHlwZW9mIHN0eWxlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0c3R5bGUgPSBzdHlsZShsYXllci5mZWF0dXJlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRsYXllci5zZXRTdHlsZShzdHlsZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBzZWN0aW9uXHJcbi8vIFRoZXJlIGFyZSBzZXZlcmFsIHN0YXRpYyBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5HZW9KU09OOlxyXG5cclxuLy8gQGZ1bmN0aW9uIGdlb21ldHJ5VG9MYXllcihmZWF0dXJlRGF0YTogT2JqZWN0LCBvcHRpb25zPzogR2VvSlNPTiBvcHRpb25zKTogTGF5ZXJcclxuLy8gQ3JlYXRlcyBhIGBMYXllcmAgZnJvbSBhIGdpdmVuIEdlb0pTT04gZmVhdHVyZS4gQ2FuIHVzZSBhIGN1c3RvbVxyXG4vLyBbYHBvaW50VG9MYXllcmBdKCNnZW9qc29uLXBvaW50dG9sYXllcikgYW5kL29yIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZylcclxuLy8gZnVuY3Rpb25zIGlmIHByb3ZpZGVkIGFzIG9wdGlvbnMuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW9tZXRyeVRvTGF5ZXIoZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uLFxyXG5cdCAgICBjb29yZHMgPSBnZW9tZXRyeSA/IGdlb21ldHJ5LmNvb3JkaW5hdGVzIDogbnVsbCxcclxuXHQgICAgbGF5ZXJzID0gW10sXHJcblx0ICAgIHBvaW50VG9MYXllciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wb2ludFRvTGF5ZXIsXHJcblx0ICAgIF9jb29yZHNUb0xhdExuZyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb29yZHNUb0xhdExuZyB8fCBjb29yZHNUb0xhdExuZyxcclxuXHQgICAgbGF0bG5nLCBsYXRsbmdzLCBpLCBsZW47XHJcblxyXG5cdGlmICghY29vcmRzICYmICFnZW9tZXRyeSkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cclxuXHRzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcclxuXHRjYXNlICdQb2ludCc6XHJcblx0XHRsYXRsbmcgPSBfY29vcmRzVG9MYXRMbmcoY29vcmRzKTtcclxuXHRcdHJldHVybiBfcG9pbnRUb0xheWVyKHBvaW50VG9MYXllciwgZ2VvanNvbiwgbGF0bG5nLCBvcHRpb25zKTtcclxuXHJcblx0Y2FzZSAnTXVsdGlQb2ludCc6XHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0bGF0bG5nID0gX2Nvb3Jkc1RvTGF0TG5nKGNvb3Jkc1tpXSk7XHJcblx0XHRcdGxheWVycy5wdXNoKF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyLCBnZW9qc29uLCBsYXRsbmcsIG9wdGlvbnMpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcblxyXG5cdGNhc2UgJ0xpbmVTdHJpbmcnOlxyXG5cdGNhc2UgJ011bHRpTGluZVN0cmluZyc6XHJcblx0XHRsYXRsbmdzID0gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgZ2VvbWV0cnkudHlwZSA9PT0gJ0xpbmVTdHJpbmcnID8gMCA6IDEsIF9jb29yZHNUb0xhdExuZyk7XHJcblx0XHRyZXR1cm4gbmV3IFBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG5cclxuXHRjYXNlICdQb2x5Z29uJzpcclxuXHRjYXNlICdNdWx0aVBvbHlnb24nOlxyXG5cdFx0bGF0bG5ncyA9IGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJyA/IDEgOiAyLCBfY29vcmRzVG9MYXRMbmcpO1xyXG5cdFx0cmV0dXJuIG5ldyBQb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG5cclxuXHRjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOlxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gZ2VvbWV0cnkuZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHR2YXIgZ2VvTGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXIoe1xyXG5cdFx0XHRcdGdlb21ldHJ5OiBnZW9tZXRyeS5nZW9tZXRyaWVzW2ldLFxyXG5cdFx0XHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuXHRcdFx0XHRwcm9wZXJ0aWVzOiBnZW9qc29uLnByb3BlcnRpZXNcclxuXHRcdFx0fSwgb3B0aW9ucyk7XHJcblxyXG5cdFx0XHRpZiAoZ2VvTGF5ZXIpIHtcclxuXHRcdFx0XHRsYXllcnMucHVzaChnZW9MYXllcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcblxyXG5cdGNhc2UgJ0ZlYXR1cmVDb2xsZWN0aW9uJzpcclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGdlb21ldHJ5LmZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHZhciBmZWF0dXJlTGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXIoZ2VvbWV0cnkuZmVhdHVyZXNbaV0sIG9wdGlvbnMpO1xyXG5cclxuXHRcdFx0aWYgKGZlYXR1cmVMYXllcikge1xyXG5cdFx0XHRcdGxheWVycy5wdXNoKGZlYXR1cmVMYXllcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcblxyXG5cdGRlZmF1bHQ6XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgR2VvSlNPTiBvYmplY3QuJyk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBfcG9pbnRUb0xheWVyKHBvaW50VG9MYXllckZuLCBnZW9qc29uLCBsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gcG9pbnRUb0xheWVyRm4gP1xyXG5cdFx0cG9pbnRUb0xheWVyRm4oZ2VvanNvbiwgbGF0bG5nKSA6XHJcblx0XHRuZXcgTWFya2VyKGxhdGxuZywgb3B0aW9ucyAmJiBvcHRpb25zLm1hcmtlcnNJbmhlcml0T3B0aW9ucyAmJiBvcHRpb25zKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuLy8gQ3JlYXRlcyBhIGBMYXRMbmdgIG9iamVjdCBmcm9tIGFuIGFycmF5IG9mIDIgbnVtYmVycyAobG9uZ2l0dWRlLCBsYXRpdHVkZSlcclxuLy8gb3IgMyBudW1iZXJzIChsb25naXR1ZGUsIGxhdGl0dWRlLCBhbHRpdHVkZSkgdXNlZCBpbiBHZW9KU09OIGZvciBwb2ludHMuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb29yZHNUb0xhdExuZyhjb29yZHMpIHtcclxuXHRyZXR1cm4gbmV3IExhdExuZyhjb29yZHNbMV0sIGNvb3Jkc1swXSwgY29vcmRzWzJdKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5ncyhjb29yZHM6IEFycmF5LCBsZXZlbHNEZWVwPzogTnVtYmVyLCBjb29yZHNUb0xhdExuZz86IEZ1bmN0aW9uKTogQXJyYXlcclxuLy8gQ3JlYXRlcyBhIG11bHRpZGltZW5zaW9uYWwgYXJyYXkgb2YgYExhdExuZ2BzIGZyb20gYSBHZW9KU09OIGNvb3JkaW5hdGVzIGFycmF5LlxyXG4vLyBgbGV2ZWxzRGVlcGAgc3BlY2lmaWVzIHRoZSBuZXN0aW5nIGxldmVsICgwIGlzIGZvciBhbiBhcnJheSBvZiBwb2ludHMsIDEgZm9yIGFuIGFycmF5IG9mIGFycmF5cyBvZiBwb2ludHMsIGV0Yy4sIDAgYnkgZGVmYXVsdCkuXHJcbi8vIENhbiB1c2UgYSBjdXN0b20gW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKSBmdW5jdGlvbi5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGxldmVsc0RlZXAsIF9jb29yZHNUb0xhdExuZykge1xyXG5cdHZhciBsYXRsbmdzID0gW107XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoLCBsYXRsbmc7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0bGF0bG5nID0gbGV2ZWxzRGVlcCA/XHJcblx0XHRcdGNvb3Jkc1RvTGF0TG5ncyhjb29yZHNbaV0sIGxldmVsc0RlZXAgLSAxLCBfY29vcmRzVG9MYXRMbmcpIDpcclxuXHRcdFx0KF9jb29yZHNUb0xhdExuZyB8fCBjb29yZHNUb0xhdExuZykoY29vcmRzW2ldKTtcclxuXHJcblx0XHRsYXRsbmdzLnB1c2gobGF0bG5nKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBsYXRsbmdzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gbGF0TG5nVG9Db29yZHMobGF0bG5nOiBMYXRMbmcsIHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IEFycmF5XHJcbi8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKVxyXG4vLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24uXHJcbmV4cG9ydCBmdW5jdGlvbiBsYXRMbmdUb0Nvb3JkcyhsYXRsbmcsIHByZWNpc2lvbikge1xyXG5cdGxhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XHJcblx0cmV0dXJuIGxhdGxuZy5hbHQgIT09IHVuZGVmaW5lZCA/XHJcblx0XHRbVXRpbC5mb3JtYXROdW0obGF0bG5nLmxuZywgcHJlY2lzaW9uKSwgVXRpbC5mb3JtYXROdW0obGF0bG5nLmxhdCwgcHJlY2lzaW9uKSwgVXRpbC5mb3JtYXROdW0obGF0bG5nLmFsdCwgcHJlY2lzaW9uKV0gOlxyXG5cdFx0W1V0aWwuZm9ybWF0TnVtKGxhdGxuZy5sbmcsIHByZWNpc2lvbiksIFV0aWwuZm9ybWF0TnVtKGxhdGxuZy5sYXQsIHByZWNpc2lvbildO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gbGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3M6IEFycmF5LCBsZXZlbHNEZWVwPzogTnVtYmVyLCBjbG9zZWQ/OiBCb29sZWFuLCBwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBBcnJheVxyXG4vLyBSZXZlcnNlIG9mIFtgY29vcmRzVG9MYXRMbmdzYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmdzKVxyXG4vLyBgY2xvc2VkYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGZpcnN0IHBvaW50IHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheSB0byBjbG9zZSB0aGUgZmVhdHVyZSwgb25seSB1c2VkIHdoZW4gYGxldmVsc0RlZXBgIGlzIDAuIEZhbHNlIGJ5IGRlZmF1bHQuXHJcbi8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbi5cclxuZXhwb3J0IGZ1bmN0aW9uIGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzLCBsZXZlbHNEZWVwLCBjbG9zZWQsIHByZWNpc2lvbikge1xyXG5cdHZhciBjb29yZHMgPSBbXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdC8vIENoZWNrIGZvciBmbGF0IGFycmF5cyByZXF1aXJlZCB0byBlbnN1cmUgdW5iYWxhbmNlZCBhcnJheXMgYXJlIGNvcnJlY3RseSBjb252ZXJ0ZWQgaW4gcmVjdXJzaW9uXHJcblx0XHRjb29yZHMucHVzaChsZXZlbHNEZWVwID9cclxuXHRcdFx0bGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3NbaV0sIExpbmVVdGlsLmlzRmxhdChsYXRsbmdzW2ldKSA/IDAgOiBsZXZlbHNEZWVwIC0gMSwgY2xvc2VkLCBwcmVjaXNpb24pIDpcclxuXHRcdFx0bGF0TG5nVG9Db29yZHMobGF0bG5nc1tpXSwgcHJlY2lzaW9uKSk7XHJcblx0fVxyXG5cclxuXHRpZiAoIWxldmVsc0RlZXAgJiYgY2xvc2VkICYmIGNvb3Jkcy5sZW5ndGggPiAwKSB7XHJcblx0XHRjb29yZHMucHVzaChjb29yZHNbMF0uc2xpY2UoKSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gY29vcmRzO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmVhdHVyZShsYXllciwgbmV3R2VvbWV0cnkpIHtcclxuXHRyZXR1cm4gbGF5ZXIuZmVhdHVyZSA/XHJcblx0XHRVdGlsLmV4dGVuZCh7fSwgbGF5ZXIuZmVhdHVyZSwge2dlb21ldHJ5OiBuZXdHZW9tZXRyeX0pIDpcclxuXHRcdGFzRmVhdHVyZShuZXdHZW9tZXRyeSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBhc0ZlYXR1cmUoZ2VvanNvbjogT2JqZWN0KTogT2JqZWN0XHJcbi8vIE5vcm1hbGl6ZSBHZW9KU09OIGdlb21ldHJpZXMvZmVhdHVyZXMgaW50byBHZW9KU09OIGZlYXR1cmVzLlxyXG5leHBvcnQgZnVuY3Rpb24gYXNGZWF0dXJlKGdlb2pzb24pIHtcclxuXHRpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScgfHwgZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XHJcblx0XHRyZXR1cm4gZ2VvanNvbjtcclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHR0eXBlOiAnRmVhdHVyZScsXHJcblx0XHRwcm9wZXJ0aWVzOiB7fSxcclxuXHRcdGdlb21ldHJ5OiBnZW9qc29uXHJcblx0fTtcclxufVxyXG5cclxudmFyIFBvaW50VG9HZW9KU09OID0ge1xyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAnUG9pbnQnLFxyXG5cdFx0XHRjb29yZGluYXRlczogbGF0TG5nVG9Db29yZHModGhpcy5nZXRMYXRMbmcoKSwgcHJlY2lzaW9uKVxyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXJrZXJcclxuLy8gQHNlY3Rpb24gT3RoZXIgbWV0aG9kc1xyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBPYmplY3RcclxuLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uIHdpdGggZ2l2ZW4gYHByZWNpc2lvbmAuXHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWFya2VyIChhcyBhIEdlb0pTT04gYFBvaW50YCBGZWF0dXJlKS5cclxuTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBDaXJjbGVNYXJrZXJcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogT2JqZWN0XHJcbi8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNpcmNsZSBtYXJrZXIgKGFzIGEgR2VvSlNPTiBgUG9pbnRgIEZlYXR1cmUpLlxyXG5DaXJjbGUuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcbkNpcmNsZU1hcmtlci5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvbHlsaW5lXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE9iamVjdFxyXG4vLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24gd2l0aCBnaXZlbiBgcHJlY2lzaW9uYC5cclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5bGluZSAoYXMgYSBHZW9KU09OIGBMaW5lU3RyaW5nYCBvciBgTXVsdGlMaW5lU3RyaW5nYCBGZWF0dXJlKS5cclxuUG9seWxpbmUuaW5jbHVkZSh7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHR2YXIgbXVsdGkgPSAhTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3MpO1xyXG5cclxuXHRcdHZhciBjb29yZHMgPSBsYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAxIDogMCwgZmFsc2UsIHByZWNpc2lvbik7XHJcblxyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAobXVsdGkgPyAnTXVsdGknIDogJycpICsgJ0xpbmVTdHJpbmcnLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBQb2x5Z29uXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE9iamVjdFxyXG4vLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24gd2l0aCBnaXZlbiBgcHJlY2lzaW9uYC5cclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5Z29uIChhcyBhIEdlb0pTT04gYFBvbHlnb25gIG9yIGBNdWx0aVBvbHlnb25gIEZlYXR1cmUpLlxyXG5Qb2x5Z29uLmluY2x1ZGUoe1xyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0dmFyIGhvbGVzID0gIUxpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzKSxcclxuXHRcdCAgICBtdWx0aSA9IGhvbGVzICYmICFMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5nc1swXSk7XHJcblxyXG5cdFx0dmFyIGNvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDIgOiBob2xlcyA/IDEgOiAwLCB0cnVlLCBwcmVjaXNpb24pO1xyXG5cclxuXHRcdGlmICghaG9sZXMpIHtcclxuXHRcdFx0Y29vcmRzID0gW2Nvb3Jkc107XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAobXVsdGkgPyAnTXVsdGknIDogJycpICsgJ1BvbHlnb24nLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgTGF5ZXJHcm91cFxyXG5MYXllckdyb3VwLmluY2x1ZGUoe1xyXG5cdHRvTXVsdGlQb2ludDogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHRjb29yZHMucHVzaChsYXllci50b0dlb0pTT04ocHJlY2lzaW9uKS5nZW9tZXRyeS5jb29yZGluYXRlcyk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdNdWx0aVBvaW50JyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogT2JqZWN0XHJcblx0Ly8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uIHdpdGggZ2l2ZW4gYHByZWNpc2lvbmAuXHJcblx0Ly8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsYXllciBncm91cCAoYXMgYSBHZW9KU09OIGBGZWF0dXJlQ29sbGVjdGlvbmAsIGBHZW9tZXRyeUNvbGxlY3Rpb25gLCBvciBgTXVsdGlQb2ludGApLlxyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cclxuXHRcdHZhciB0eXBlID0gdGhpcy5mZWF0dXJlICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeSAmJiB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkudHlwZTtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRvTXVsdGlQb2ludChwcmVjaXNpb24pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpc0dlb21ldHJ5Q29sbGVjdGlvbiA9IHR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nLFxyXG5cdFx0ICAgIGpzb25zID0gW107XHJcblxyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdGlmIChsYXllci50b0dlb0pTT04pIHtcclxuXHRcdFx0XHR2YXIganNvbiA9IGxheWVyLnRvR2VvSlNPTihwcmVjaXNpb24pO1xyXG5cdFx0XHRcdGlmIChpc0dlb21ldHJ5Q29sbGVjdGlvbikge1xyXG5cdFx0XHRcdFx0anNvbnMucHVzaChqc29uLmdlb21ldHJ5KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dmFyIGZlYXR1cmUgPSBhc0ZlYXR1cmUoanNvbik7XHJcblx0XHRcdFx0XHQvLyBTcXVhc2ggbmVzdGVkIGZlYXR1cmUgY29sbGVjdGlvbnNcclxuXHRcdFx0XHRcdGlmIChmZWF0dXJlLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcclxuXHRcdFx0XHRcdFx0anNvbnMucHVzaC5hcHBseShqc29ucywgZmVhdHVyZS5mZWF0dXJlcyk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRqc29ucy5wdXNoKGZlYXR1cmUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKGlzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XHJcblx0XHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0XHRnZW9tZXRyaWVzOiBqc29ucyxcclxuXHRcdFx0XHR0eXBlOiAnR2VvbWV0cnlDb2xsZWN0aW9uJ1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxyXG5cdFx0XHRmZWF0dXJlczoganNvbnNcclxuXHRcdH07XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgR2VvSlNPTlxyXG4vLyBAZmFjdG9yeSBMLmdlb0pTT04oZ2VvanNvbj86IE9iamVjdCwgb3B0aW9ucz86IEdlb0pTT04gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhIEdlb0pTT04gbGF5ZXIuIE9wdGlvbmFsbHkgYWNjZXB0cyBhbiBvYmplY3QgaW5cclxuLy8gW0dlb0pTT04gZm9ybWF0XShodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzk0NikgdG8gZGlzcGxheSBvbiB0aGUgbWFwXHJcbi8vICh5b3UgY2FuIGFsdGVybmF0aXZlbHkgYWRkIGl0IGxhdGVyIHdpdGggYGFkZERhdGFgIG1ldGhvZCkgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW9KU09OKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEdlb0pTT04oZ2VvanNvbiwgb3B0aW9ucyk7XHJcbn1cclxuXHJcbi8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXHJcbmV4cG9ydCB2YXIgZ2VvSnNvbiA9IGdlb0pTT047XHJcbiIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmdCb3VuZHN9IGZyb20gJy4uL2dlby9MYXRMbmdCb3VuZHMnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgSW1hZ2VPdmVybGF5XHJcbiAqIEBha2EgTC5JbWFnZU92ZXJsYXlcclxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAqXHJcbiAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSBhIHNpbmdsZSBpbWFnZSBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBpbWFnZVVybCA9ICdodHRwczovL21hcHMubGliLnV0ZXhhcy5lZHUvbWFwcy9oaXN0b3JpY2FsL25ld2Fya19ual8xOTIyLmpwZycsXHJcbiAqIFx0aW1hZ2VCb3VuZHMgPSBbWzQwLjcxMjIxNiwgLTc0LjIyNjU1XSwgWzQwLjc3Mzk0MSwgLTc0LjEyNTQ0XV07XHJcbiAqIEwuaW1hZ2VPdmVybGF5KGltYWdlVXJsLCBpbWFnZUJvdW5kcykuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBJbWFnZU92ZXJsYXkgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgSW1hZ2VPdmVybGF5IG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG5cdFx0Ly8gVGhlIG9wYWNpdHkgb2YgdGhlIGltYWdlIG92ZXJsYXkuXHJcblx0XHRvcGFjaXR5OiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVGV4dCBmb3IgdGhlIGBhbHRgIGF0dHJpYnV0ZSBvZiB0aGUgaW1hZ2UgKHVzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eSkuXHJcblx0XHRhbHQ6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgaW1hZ2Ugb3ZlcmxheSB3aWxsIGVtaXQgW21vdXNlIGV2ZW50c10oI2ludGVyYWN0aXZlLWxheWVyKSB3aGVuIGNsaWNrZWQgb3IgaG92ZXJlZC5cclxuXHRcdGludGVyYWN0aXZlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgaW1hZ2UuXHJcblx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgdGhlIGltYWdlIHdpbGwgaGF2ZSBpdHMgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byB0aGUgU3RyaW5nIHByb3ZpZGVkLiBUaGlzIGlzIG5lZWRlZCBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgaW1hZ2UgcGl4ZWwgZGF0YS5cclxuXHRcdC8vIFJlZmVyIHRvIFtDT1JTIFNldHRpbmdzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlcykgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcblx0XHRjcm9zc09yaWdpbjogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBlcnJvck92ZXJsYXlVcmw6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBVUkwgdG8gdGhlIG92ZXJsYXkgaW1hZ2UgdG8gc2hvdyBpbiBwbGFjZSBvZiB0aGUgb3ZlcmxheSB0aGF0IGZhaWxlZCB0byBsb2FkLlxyXG5cdFx0ZXJyb3JPdmVybGF5VXJsOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpJbmRleDogTnVtYmVyID0gMVxyXG5cdFx0Ly8gVGhlIGV4cGxpY2l0IFt6SW5kZXhdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9DU1NfUG9zaXRpb25pbmcvVW5kZXJzdGFuZGluZ196X2luZGV4KSBvZiB0aGUgb3ZlcmxheSBsYXllci5cclxuXHRcdHpJbmRleDogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBpbWFnZS4gRW1wdHkgYnkgZGVmYXVsdC5cclxuXHRcdGNsYXNzTmFtZTogJydcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHsgLy8gKFN0cmluZywgTGF0TG5nQm91bmRzLCBPYmplY3QpXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblx0XHR0aGlzLl9ib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9pbWFnZSkge1xyXG5cdFx0XHR0aGlzLl9pbml0SW1hZ2UoKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuXHRcdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5faW1hZ2UsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcblx0XHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2ltYWdlKTtcclxuXHRcdHRoaXMuX3Jlc2V0KCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2ltYWdlKTtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBvcGFjaXR5IG9mIHRoZSBvdmVybGF5LlxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGVPcHRzKSB7XHJcblx0XHRpZiAoc3R5bGVPcHRzLm9wYWNpdHkpIHtcclxuXHRcdFx0dGhpcy5zZXRPcGFjaXR5KHN0eWxlT3B0cy5vcGFjaXR5KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIG92ZXJsYXlzLlxyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHREb21VdGlsLnRvRnJvbnQodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBvdmVybGF5cy5cclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHREb21VdGlsLnRvQmFjayh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFVybCh1cmw6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBVUkwgb2YgdGhlIGltYWdlLlxyXG5cdHNldFVybDogZnVuY3Rpb24gKHVybCkge1xyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbWFnZSkge1xyXG5cdFx0XHR0aGlzLl9pbWFnZS5zcmMgPSB1cmw7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuXHQvLyBVcGRhdGUgdGhlIGJvdW5kcyB0aGF0IHRoaXMgSW1hZ2VPdmVybGF5IGNvdmVyc1xyXG5cdHNldEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0dGhpcy5fYm91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3Jlc2V0KCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSB7XHJcblx0XHRcdHpvb206IHRoaXMuX3Jlc2V0LFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpJbmRleCh2YWx1ZTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIFt6SW5kZXhdKCNpbWFnZW92ZXJsYXktemluZGV4KSBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cclxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IHZhbHVlO1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBHZXQgdGhlIGJvdW5kcyB0aGF0IHRoaXMgSW1hZ2VPdmVybGF5IGNvdmVyc1xyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQoKTogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYEhUTUxJbWFnZUVsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvSFRNTEltYWdlRWxlbWVudClcclxuXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cclxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2U7XHJcblx0fSxcclxuXHJcblx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHdhc0VsZW1lbnRTdXBwbGllZCA9IHRoaXMuX3VybC50YWdOYW1lID09PSAnSU1HJztcclxuXHRcdHZhciBpbWcgPSB0aGlzLl9pbWFnZSA9IHdhc0VsZW1lbnRTdXBwbGllZCA/IHRoaXMuX3VybCA6IERvbVV0aWwuY3JlYXRlKCdpbWcnKTtcclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKGltZywgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHsgRG9tVXRpbC5hZGRDbGFzcyhpbWcsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHsgRG9tVXRpbC5hZGRDbGFzcyhpbWcsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XHJcblxyXG5cdFx0aW1nLm9uc2VsZWN0c3RhcnQgPSBVdGlsLmZhbHNlRm47XHJcblx0XHRpbWcub25tb3VzZW1vdmUgPSBVdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBJbWFnZU92ZXJsYXkgbGF5ZXIgaGFzIGxvYWRlZCBpdHMgaW1hZ2VcclxuXHRcdGltZy5vbmxvYWQgPSBVdGlsLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbG9hZCcpO1xyXG5cdFx0aW1nLm9uZXJyb3IgPSBVdGlsLmJpbmQodGhpcy5fb3ZlcmxheU9uRXJyb3IsIHRoaXMsICdlcnJvcicpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gfHwgdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSAnJykge1xyXG5cdFx0XHRpbWcuY3Jvc3NPcmlnaW4gPSB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IHRydWUgPyAnJyA6IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnpJbmRleCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAod2FzRWxlbWVudFN1cHBsaWVkKSB7XHJcblx0XHRcdHRoaXMuX3VybCA9IGltZy5zcmM7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpbWcuc3JjID0gdGhpcy5fdXJsO1xyXG5cdFx0aW1nLmFsdCA9IHRoaXMub3B0aW9ucy5hbHQ7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZShlLnpvb20pLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX21hcC5fbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kcyh0aGlzLl9ib3VuZHMsIGUuem9vbSwgZS5jZW50ZXIpLm1pbjtcclxuXHJcblx0XHREb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9pbWFnZSwgb2Zmc2V0LCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZSxcclxuXHRcdCAgICBib3VuZHMgPSBuZXcgQm91bmRzKFxyXG5cdFx0ICAgICAgICB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXROb3J0aFdlc3QoKSksXHJcblx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldFNvdXRoRWFzdCgpKSksXHJcblx0XHQgICAgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XHJcblxyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihpbWFnZSwgYm91bmRzLm1pbik7XHJcblxyXG5cdFx0aW1hZ2Uuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuXHRcdGltYWdlLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9pbWFnZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9pbWFnZSAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gbnVsbCkge1xyXG5cdFx0XHR0aGlzLl9pbWFnZS5zdHlsZS56SW5kZXggPSB0aGlzLm9wdGlvbnMuekluZGV4O1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vdmVybGF5T25FcnJvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gQGV2ZW50IGVycm9yOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgSW1hZ2VPdmVybGF5IGxheWVyIGZhaWxzIHRvIGxvYWQgaXRzIGltYWdlXHJcblx0XHR0aGlzLmZpcmUoJ2Vycm9yJyk7XHJcblxyXG5cdFx0dmFyIGVycm9yVXJsID0gdGhpcy5vcHRpb25zLmVycm9yT3ZlcmxheVVybDtcclxuXHRcdGlmIChlcnJvclVybCAmJiB0aGlzLl91cmwgIT09IGVycm9yVXJsKSB7XHJcblx0XHRcdHRoaXMuX3VybCA9IGVycm9yVXJsO1xyXG5cdFx0XHR0aGlzLl9pbWFnZS5zcmMgPSBlcnJvclVybDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgb2YgdGhlIEltYWdlT3ZlcmxheS5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ib3VuZHMuZ2V0Q2VudGVyKCk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBmYWN0b3J5IEwuaW1hZ2VPdmVybGF5KGltYWdlVXJsOiBTdHJpbmcsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogSW1hZ2VPdmVybGF5IG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiB0aGUgVVJMIG9mIHRoZSBpbWFnZSBhbmQgdGhlXHJcbi8vIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cclxuZXhwb3J0IHZhciBpbWFnZU92ZXJsYXkgPSBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEltYWdlT3ZlcmxheSh1cmwsIGJvdW5kcywgb3B0aW9ucyk7XHJcbn07XHJcbiIsImltcG9ydCB7SW1hZ2VPdmVybGF5fSBmcm9tICcuL0ltYWdlT3ZlcmxheSc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgVmlkZW9PdmVybGF5XHJcbiAqIEBha2EgTC5WaWRlb092ZXJsYXlcclxuICogQGluaGVyaXRzIEltYWdlT3ZlcmxheVxyXG4gKlxyXG4gKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgYSB2aWRlbyBwbGF5ZXIgb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgSW1hZ2VPdmVybGF5YC5cclxuICpcclxuICogQSB2aWRlbyBvdmVybGF5IHVzZXMgdGhlIFtgPHZpZGVvPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0hUTUwvRWxlbWVudC92aWRlbylcclxuICogSFRNTDUgZWxlbWVudC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHZpZGVvVXJsID0gJ2h0dHBzOi8vd3d3Lm1hcGJveC5jb20vYml0ZXMvMDAxODgvcGF0cmljaWFfbmFzYS53ZWJtJyxcclxuICogXHR2aWRlb0JvdW5kcyA9IFtbIDMyLCAtMTMwXSwgWyAxMywgLTEwMF1dO1xyXG4gKiBMLnZpZGVvT3ZlcmxheSh2aWRlb1VybCwgdmlkZW9Cb3VuZHMgKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIFZpZGVvT3ZlcmxheSA9IEltYWdlT3ZlcmxheS5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgVmlkZW9PdmVybGF5IG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGF1dG9wbGF5OiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gc3RhcnRzIHBsYXlpbmcgYXV0b21hdGljYWxseSB3aGVuIGxvYWRlZC5cclxuXHRcdC8vIE9uIHNvbWUgYnJvd3NlcnMgYXV0b3BsYXkgd2lsbCBvbmx5IHdvcmsgd2l0aCBgbXV0ZWQ6IHRydWVgXHJcblx0XHRhdXRvcGxheTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxvb3A6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyB3aWxsIGxvb3AgYmFjayB0byB0aGUgYmVnaW5uaW5nIHdoZW4gcGxheWVkLlxyXG5cdFx0bG9vcDogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGtlZXBBc3BlY3RSYXRpbzogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHdpbGwgc2F2ZSBhc3BlY3QgcmF0aW8gYWZ0ZXIgdGhlIHByb2plY3Rpb24uXHJcblx0XHQvLyBSZWxldmFudCBmb3Igc3VwcG9ydGVkIGJyb3dzZXJzLiBTZWUgW2Jyb3dzZXIgY29tcGF0aWJpbGl0eV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL29iamVjdC1maXQpXHJcblx0XHRrZWVwQXNwZWN0UmF0aW86IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtdXRlZDogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyBzdGFydHMgb24gbXV0ZSB3aGVuIGxvYWRlZC5cclxuXHRcdG11dGVkOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHBsYXlzSW5saW5lOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gTW9iaWxlIGJyb3dzZXJzIHdpbGwgcGxheSB0aGUgdmlkZW8gcmlnaHQgd2hlcmUgaXQgaXMgaW5zdGVhZCBvZiBvcGVuIGl0IHVwIGluIGZ1bGxzY3JlZW4gbW9kZS5cclxuXHRcdHBsYXlzSW5saW5lOiB0cnVlXHJcblx0fSxcclxuXHJcblx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHdhc0VsZW1lbnRTdXBwbGllZCA9IHRoaXMuX3VybC50YWdOYW1lID09PSAnVklERU8nO1xyXG5cdFx0dmFyIHZpZCA9IHRoaXMuX2ltYWdlID0gd2FzRWxlbWVudFN1cHBsaWVkID8gdGhpcy5fdXJsIDogRG9tVXRpbC5jcmVhdGUoJ3ZpZGVvJyk7XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh2aWQsICdsZWFmbGV0LWltYWdlLWxheWVyJyk7XHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7IERvbVV0aWwuYWRkQ2xhc3ModmlkLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7IH1cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7IERvbVV0aWwuYWRkQ2xhc3ModmlkLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTsgfVxyXG5cclxuXHRcdHZpZC5vbnNlbGVjdHN0YXJ0ID0gVXRpbC5mYWxzZUZuO1xyXG5cdFx0dmlkLm9ubW91c2Vtb3ZlID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdmlkZW8gaGFzIGZpbmlzaGVkIGxvYWRpbmcgdGhlIGZpcnN0IGZyYW1lXHJcblx0XHR2aWQub25sb2FkZWRkYXRhID0gVXRpbC5iaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuXHJcblx0XHRpZiAod2FzRWxlbWVudFN1cHBsaWVkKSB7XHJcblx0XHRcdHZhciBzb3VyY2VFbGVtZW50cyA9IHZpZC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc291cmNlJyk7XHJcblx0XHRcdHZhciBzb3VyY2VzID0gW107XHJcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgc291cmNlRWxlbWVudHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRzb3VyY2VzLnB1c2goc291cmNlRWxlbWVudHNbal0uc3JjKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fdXJsID0gKHNvdXJjZUVsZW1lbnRzLmxlbmd0aCA+IDApID8gc291cmNlcyA6IFt2aWQuc3JjXTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghVXRpbC5pc0FycmF5KHRoaXMuX3VybCkpIHsgdGhpcy5fdXJsID0gW3RoaXMuX3VybF07IH1cclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5rZWVwQXNwZWN0UmF0aW8gJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZpZC5zdHlsZSwgJ29iamVjdEZpdCcpKSB7XHJcblx0XHRcdHZpZC5zdHlsZVsnb2JqZWN0Rml0J10gPSAnZmlsbCc7XHJcblx0XHR9XHJcblx0XHR2aWQuYXV0b3BsYXkgPSAhIXRoaXMub3B0aW9ucy5hdXRvcGxheTtcclxuXHRcdHZpZC5sb29wID0gISF0aGlzLm9wdGlvbnMubG9vcDtcclxuXHRcdHZpZC5tdXRlZCA9ICEhdGhpcy5vcHRpb25zLm11dGVkO1xyXG5cdFx0dmlkLnBsYXlzSW5saW5lID0gISF0aGlzLm9wdGlvbnMucGxheXNJbmxpbmU7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3VybC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgc291cmNlID0gRG9tVXRpbC5jcmVhdGUoJ3NvdXJjZScpO1xyXG5cdFx0XHRzb3VyY2Uuc3JjID0gdGhpcy5fdXJsW2ldO1xyXG5cdFx0XHR2aWQuYXBwZW5kQ2hpbGQoc291cmNlKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBIVE1MVmlkZW9FbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BIVE1MVmlkZW9FbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hUTUxWaWRlb0VsZW1lbnQpXHJcblx0Ly8gdXNlZCBieSB0aGlzIG92ZXJsYXkuXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwudmlkZW9PdmVybGF5KHZpZGVvOiBTdHJpbmd8QXJyYXl8SFRNTFZpZGVvRWxlbWVudCwgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBWaWRlb092ZXJsYXkgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIHRoZSBVUkwgb2YgdGhlIHZpZGVvIChvciBhcnJheSBvZiBVUkxzLCBvciBldmVuIGEgdmlkZW8gZWxlbWVudCkgYW5kIHRoZVxyXG4vLyBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdmlkZW9PdmVybGF5KHZpZGVvLCBib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IFZpZGVvT3ZlcmxheSh2aWRlbywgYm91bmRzLCBvcHRpb25zKTtcclxufVxyXG4iLCJpbXBvcnQge0ltYWdlT3ZlcmxheX0gZnJvbSAnLi9JbWFnZU92ZXJsYXknO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgU1ZHT3ZlcmxheVxuICogQGFrYSBMLlNWR092ZXJsYXlcbiAqIEBpbmhlcml0cyBJbWFnZU92ZXJsYXlcbiAqXG4gKiBVc2VkIHRvIGxvYWQsIGRpc3BsYXkgYW5kIHByb3ZpZGUgRE9NIGFjY2VzcyB0byBhbiBTVkcgZmlsZSBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBJbWFnZU92ZXJsYXlgLlxuICpcbiAqIEFuIFNWRyBvdmVybGF5IHVzZXMgdGhlIFtgPHN2Zz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvRWxlbWVudC9zdmcpIGVsZW1lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogdmFyIHN2Z0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiKTtcbiAqIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd4bWxucycsIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIik7XG4gKiBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIFwiMCAwIDIwMCAyMDBcIik7XG4gKiBzdmdFbGVtZW50LmlubmVySFRNTCA9ICc8cmVjdCB3aWR0aD1cIjIwMFwiIGhlaWdodD1cIjIwMFwiLz48cmVjdCB4PVwiNzVcIiB5PVwiMjNcIiB3aWR0aD1cIjUwXCIgaGVpZ2h0PVwiNTBcIiBzdHlsZT1cImZpbGw6cmVkXCIvPjxyZWN0IHg9XCI3NVwiIHk9XCIxMjNcIiB3aWR0aD1cIjUwXCIgaGVpZ2h0PVwiNTBcIiBzdHlsZT1cImZpbGw6IzAwMTNmZlwiLz4nO1xuICogdmFyIHN2Z0VsZW1lbnRCb3VuZHMgPSBbIFsgMzIsIC0xMzAgXSwgWyAxMywgLTEwMCBdIF07XG4gKiBMLnN2Z092ZXJsYXkoc3ZnRWxlbWVudCwgc3ZnRWxlbWVudEJvdW5kcykuYWRkVG8obWFwKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgU1ZHT3ZlcmxheSA9IEltYWdlT3ZlcmxheS5leHRlbmQoe1xuXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGVsID0gdGhpcy5faW1hZ2UgPSB0aGlzLl91cmw7XG5cblx0XHREb21VdGlsLmFkZENsYXNzKGVsLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHsgRG9tVXRpbC5hZGRDbGFzcyhlbCwgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpOyB9XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHsgRG9tVXRpbC5hZGRDbGFzcyhlbCwgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSk7IH1cblxuXHRcdGVsLm9uc2VsZWN0c3RhcnQgPSBVdGlsLmZhbHNlRm47XG5cdFx0ZWwub25tb3VzZW1vdmUgPSBVdGlsLmZhbHNlRm47XG5cdH1cblxuXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQoKTogU1ZHRWxlbWVudFxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYFNWR0VsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvU1ZHRWxlbWVudClcblx0Ly8gdXNlZCBieSB0aGlzIG92ZXJsYXkuXG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLnN2Z092ZXJsYXkoc3ZnOiBTdHJpbmd8U1ZHRWxlbWVudCwgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBTVkdPdmVybGF5IG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gYW4gU1ZHIGVsZW1lbnQgYW5kIHRoZSBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXG4vLyBBIHZpZXdCb3ggYXR0cmlidXRlIGlzIHJlcXVpcmVkIG9uIHRoZSBTVkcgZWxlbWVudCB0byB6b29tIGluIGFuZCBvdXQgcHJvcGVybHkuXG5cbmV4cG9ydCBmdW5jdGlvbiBzdmdPdmVybGF5KGVsLCBib3VuZHMsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBTVkdPdmVybGF5KGVsLCBib3VuZHMsIG9wdGlvbnMpO1xufVxuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xyXG5pbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcclxuaW1wb3J0IHtGZWF0dXJlR3JvdXB9IGZyb20gJy4vRmVhdHVyZUdyb3VwJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3RvTGF0TG5nLCBMYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRGl2T3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICogQGFrYSBMLkRpdk92ZXJsYXlcclxuICogQmFzZSBtb2RlbCBmb3IgTC5Qb3B1cCBhbmQgTC5Ub29sdGlwLiBJbmhlcml0IGZyb20gaXQgZm9yIGN1c3RvbSBvdmVybGF5cyBsaWtlIHBsdWdpbnMuXHJcbiAqL1xyXG5cclxuLy8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcbmV4cG9ydCB2YXIgRGl2T3ZlcmxheSA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBEaXZPdmVybGF5IG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGludGVyYWN0aXZlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIHRydWUsIHRoZSBwb3B1cC90b29sdGlwIHdpbGwgbGlzdGVuIHRvIHRoZSBtb3VzZSBldmVudHMuXHJcblx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgMClcclxuXHRcdC8vIFRoZSBvZmZzZXQgb2YgdGhlIG92ZXJsYXkgcG9zaXRpb24uXHJcblx0XHRvZmZzZXQ6IFswLCAwXSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIENTUyBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgb3ZlcmxheS5cclxuXHRcdGNsYXNzTmFtZTogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSB1bmRlZmluZWRcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIG92ZXJsYXkgd2lsbCBiZSBhZGRlZC5cclxuXHRcdHBhbmU6IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbiA9ICcnXHJcblx0XHQvLyBTZXRzIHRoZSBIVE1MIGNvbnRlbnQgb2YgdGhlIG92ZXJsYXkgd2hpbGUgaW5pdGlhbGl6aW5nLiBJZiBhIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aGUgc291cmNlIGxheWVyIHdpbGwgYmVcclxuXHRcdC8vIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YCB0byBiZSB1c2VkIGluIHRoZSBvdmVybGF5LlxyXG5cdFx0Y29udGVudDogJydcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcblx0XHRpZiAob3B0aW9ucyAmJiAob3B0aW9ucyBpbnN0YW5jZW9mIExhdExuZyB8fCBVdGlsLmlzQXJyYXkob3B0aW9ucykpKSB7XHJcblx0XHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKG9wdGlvbnMpO1xyXG5cdFx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgc291cmNlKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHRcdFx0dGhpcy5fc291cmNlID0gc291cmNlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jb250ZW50KSB7XHJcblx0XHRcdHRoaXMuX2NvbnRlbnQgPSB0aGlzLm9wdGlvbnMuY29udGVudDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG9wZW5PbihtYXA6IE1hcCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBvdmVybGF5IHRvIHRoZSBtYXAuXHJcblx0Ly8gQWx0ZXJuYXRpdmUgdG8gYG1hcC5vcGVuUG9wdXAocG9wdXApYC9gLm9wZW5Ub29sdGlwKHRvb2x0aXApYC5cclxuXHRvcGVuT246IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcCA9IGFyZ3VtZW50cy5sZW5ndGggPyBtYXAgOiB0aGlzLl9zb3VyY2UuX21hcDsgLy8gZXhwZXJpbWVudGFsLCBub3QgdGhlIHBhcnQgb2YgcHVibGljIGFwaVxyXG5cdFx0aWYgKCFtYXAuaGFzTGF5ZXIodGhpcykpIHtcclxuXHRcdFx0bWFwLmFkZExheWVyKHRoaXMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9zZSgpOiB0aGlzXHJcblx0Ly8gQ2xvc2VzIHRoZSBvdmVybGF5LlxyXG5cdC8vIEFsdGVybmF0aXZlIHRvIGBtYXAuY2xvc2VQb3B1cChwb3B1cClgL2AuY2xvc2VUb29sdGlwKHRvb2x0aXApYFxyXG5cdC8vIGFuZCBgbGF5ZXIuY2xvc2VQb3B1cCgpYC9gLmNsb3NlVG9vbHRpcCgpYC5cclxuXHRjbG9zZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvZ2dsZShsYXllcj86IExheWVyKTogdGhpc1xyXG5cdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgb3ZlcmxheSBib3VuZCB0byBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXHJcblx0Ly8gQXJndW1lbnQgbWF5IGJlIG9taXR0ZWQgb25seSBmb3Igb3ZlcmxheSBib3VuZCB0byBsYXllci5cclxuXHQvLyBBbHRlcm5hdGl2ZSB0byBgbGF5ZXIudG9nZ2xlUG9wdXAoKWAvYC50b2dnbGVUb29sdGlwKClgLlxyXG5cdHRvZ2dsZTogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuY2xvc2UoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdFx0dGhpcy5fc291cmNlID0gbGF5ZXI7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGF5ZXIgPSB0aGlzLl9zb3VyY2U7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fcHJlcGFyZU9wZW4oKTtcclxuXHJcblx0XHRcdC8vIG9wZW4gdGhlIG92ZXJsYXkgb24gdGhlIG1hcFxyXG5cdFx0XHR0aGlzLm9wZW5PbihsYXllci5fbWFwKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBtYXAuX3pvb21BbmltYXRlZDtcclxuXHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xyXG5cdFx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9yZW1vdmVUaW1lb3V0KTtcclxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAxKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmJyaW5nVG9Gcm9udCgpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcblx0XHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDApO1xyXG5cdFx0XHR0aGlzLl9yZW1vdmVUaW1lb3V0ID0gc2V0VGltZW91dChVdGlsLmJpbmQoRG9tVXRpbC5yZW1vdmUsIHVuZGVmaW5lZCwgdGhpcy5fY29udGFpbmVyKSwgMjAwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHRcdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBuYW1lc3BhY2UgRGl2T3ZlcmxheVxyXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgcG9pbnQgb2YgdGhlIG92ZXJsYXkuXHJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGdlb2dyYXBoaWNhbCBwb2ludCB3aGVyZSB0aGUgb3ZlcmxheSB3aWxsIG9wZW4uXHJcblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG5cdFx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgb3ZlcmxheS5cclxuXHRnZXRDb250ZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGVudDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldENvbnRlbnQoaHRtbENvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBIVE1MIGNvbnRlbnQgb2YgdGhlIG92ZXJsYXkuIElmIGEgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBzb3VyY2UgbGF5ZXIgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLlxyXG5cdC8vIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YCB0byBiZSB1c2VkIGluIHRoZSBvdmVybGF5LlxyXG5cdHNldENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcblx0XHR0aGlzLl9jb250ZW50ID0gY29udGVudDtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQ6IFN0cmluZ3xIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIEhUTUwgY29udGFpbmVyIG9mIHRoZSBvdmVybGF5LlxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1cGRhdGU6IG51bGxcclxuXHQvLyBVcGRhdGVzIHRoZSBvdmVybGF5IGNvbnRlbnQsIGxheW91dCBhbmQgcG9zaXRpb24uIFVzZWZ1bCBmb3IgdXBkYXRpbmcgdGhlIG92ZXJsYXkgYWZ0ZXIgc29tZXRoaW5nIGluc2lkZSBjaGFuZ2VkLCBlLmcuIGltYWdlIGxvYWRlZC5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlQ29udGVudCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlTGF5b3V0KCk7XHJcblx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XHJcblxyXG5cdFx0dGhpcy5fYWRqdXN0UGFuKCk7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZXZlbnRzID0ge1xyXG5cdFx0XHR6b29tOiB0aGlzLl91cGRhdGVQb3NpdGlvbixcclxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl91cGRhdGVQb3NpdGlvblxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGlzT3BlbjogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIHdoZW4gdGhlIG92ZXJsYXkgaXMgdmlzaWJsZSBvbiB0aGUgbWFwLlxyXG5cdGlzT3BlbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhdGhpcy5fbWFwICYmIHRoaXMuX21hcC5oYXNMYXllcih0aGlzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udDogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGlzIG92ZXJsYXkgaW4gZnJvbnQgb2Ygb3RoZXIgb3ZlcmxheXMgKGluIHRoZSBzYW1lIG1hcCBwYW5lKS5cclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0RG9tVXRpbC50b0Zyb250KHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoaXMgb3ZlcmxheSB0byB0aGUgYmFjayBvZiBvdGhlciBvdmVybGF5cyAoaW4gdGhlIHNhbWUgbWFwIHBhbmUpLlxyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9CYWNrKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBwcmVwYXJlIGJvdW5kIG92ZXJsYXkgdG8gb3BlbjogdXBkYXRlIGxhdGxuZyBwb3MgLyBjb250ZW50IHNvdXJjZSAoZm9yIEZlYXR1cmVHcm91cClcclxuXHRfcHJlcGFyZU9wZW46IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBzb3VyY2UgPSB0aGlzLl9zb3VyY2U7XHJcblx0XHRpZiAoIXNvdXJjZS5fbWFwKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdGlmIChzb3VyY2UgaW5zdGFuY2VvZiBGZWF0dXJlR3JvdXApIHtcclxuXHRcdFx0c291cmNlID0gbnVsbDtcclxuXHRcdFx0dmFyIGxheWVycyA9IHRoaXMuX3NvdXJjZS5fbGF5ZXJzO1xyXG5cdFx0XHRmb3IgKHZhciBpZCBpbiBsYXllcnMpIHtcclxuXHRcdFx0XHRpZiAobGF5ZXJzW2lkXS5fbWFwKSB7XHJcblx0XHRcdFx0XHRzb3VyY2UgPSBsYXllcnNbaWRdO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghc291cmNlKSB7IHJldHVybiBmYWxzZTsgfSAvLyBVbmFibGUgdG8gZ2V0IHNvdXJjZSBsYXllci5cclxuXHJcblx0XHRcdC8vIHNldCBvdmVybGF5IHNvdXJjZSB0byB0aGlzIGxheWVyXHJcblx0XHRcdHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWxhdGxuZykge1xyXG5cdFx0XHRpZiAoc291cmNlLmdldENlbnRlcikge1xyXG5cdFx0XHRcdGxhdGxuZyA9IHNvdXJjZS5nZXRDZW50ZXIoKTtcclxuXHRcdFx0fSBlbHNlIGlmIChzb3VyY2UuZ2V0TGF0TG5nKSB7XHJcblx0XHRcdFx0bGF0bG5nID0gc291cmNlLmdldExhdExuZygpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHNvdXJjZS5nZXRCb3VuZHMpIHtcclxuXHRcdFx0XHRsYXRsbmcgPSBzb3VyY2UuZ2V0Qm91bmRzKCkuZ2V0Q2VudGVyKCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IHNvdXJjZSBsYXllciBMYXRMbmcuJyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHRoaXMuc2V0TGF0TG5nKGxhdGxuZyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHQvLyB1cGRhdGUgdGhlIG92ZXJsYXkgKGNvbnRlbnQsIGxheW91dCwgZXRjLi4uKVxyXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVDb250ZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRlbnQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIG5vZGUgPSB0aGlzLl9jb250ZW50Tm9kZTtcclxuXHRcdHZhciBjb250ZW50ID0gKHR5cGVvZiB0aGlzLl9jb250ZW50ID09PSAnZnVuY3Rpb24nKSA/IHRoaXMuX2NvbnRlbnQodGhpcy5fc291cmNlIHx8IHRoaXMpIDogdGhpcy5fY29udGVudDtcclxuXHJcblx0XHRpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdG5vZGUuaW5uZXJIVE1MID0gY29udGVudDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHdoaWxlIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xyXG5cdFx0XHRcdG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRub2RlLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgRGl2T3ZlcmxheVxyXG5cdFx0Ly8gQHNlY3Rpb24gRGl2T3ZlcmxheSBldmVudHNcclxuXHRcdC8vIEBldmVudCBjb250ZW50dXBkYXRlOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgY29udGVudCBvZiB0aGUgb3ZlcmxheSBpcyB1cGRhdGVkXHJcblx0XHR0aGlzLmZpcmUoJ2NvbnRlbnR1cGRhdGUnKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyksXHJcblx0XHQgICAgb2Zmc2V0ID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcclxuXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MuYWRkKGFuY2hvcikpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2Zmc2V0ID0gb2Zmc2V0LmFkZChwb3MpLmFkZChhbmNob3IpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBib3R0b20gPSB0aGlzLl9jb250YWluZXJCb3R0b20gPSAtb2Zmc2V0LnksXHJcblx0XHQgICAgbGVmdCA9IHRoaXMuX2NvbnRhaW5lckxlZnQgPSAtTWF0aC5yb3VuZCh0aGlzLl9jb250YWluZXJXaWR0aCAvIDIpICsgb2Zmc2V0Lng7XHJcblxyXG5cdFx0Ly8gYm90dG9tIHBvc2l0aW9uIHRoZSBvdmVybGF5IGluIGNhc2UgdGhlIGhlaWdodCBvZiB0aGUgb3ZlcmxheSBjaGFuZ2VzIChpbWFnZXMgbG9hZGluZyBldGMpXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuYm90dG9tID0gYm90dG9tICsgJ3B4JztcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XHJcblx0fSxcclxuXHJcblx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIFswLCAwXTtcclxuXHR9XHJcblxyXG59KTtcclxuXHJcbk1hcC5pbmNsdWRlKHtcclxuXHRfaW5pdE92ZXJsYXk6IGZ1bmN0aW9uIChPdmVybGF5Q2xhc3MsIGNvbnRlbnQsIGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0dmFyIG92ZXJsYXkgPSBjb250ZW50O1xyXG5cdFx0aWYgKCEob3ZlcmxheSBpbnN0YW5jZW9mIE92ZXJsYXlDbGFzcykpIHtcclxuXHRcdFx0b3ZlcmxheSA9IG5ldyBPdmVybGF5Q2xhc3Mob3B0aW9ucykuc2V0Q29udGVudChjb250ZW50KTtcclxuXHRcdH1cclxuXHRcdGlmIChsYXRsbmcpIHtcclxuXHRcdFx0b3ZlcmxheS5zZXRMYXRMbmcobGF0bG5nKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBvdmVybGF5O1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuTGF5ZXIuaW5jbHVkZSh7XHJcblx0X2luaXRPdmVybGF5OiBmdW5jdGlvbiAoT3ZlcmxheUNsYXNzLCBvbGQsIGNvbnRlbnQsIG9wdGlvbnMpIHtcclxuXHRcdHZhciBvdmVybGF5ID0gY29udGVudDtcclxuXHRcdGlmIChvdmVybGF5IGluc3RhbmNlb2YgT3ZlcmxheUNsYXNzKSB7XHJcblx0XHRcdFV0aWwuc2V0T3B0aW9ucyhvdmVybGF5LCBvcHRpb25zKTtcclxuXHRcdFx0b3ZlcmxheS5fc291cmNlID0gdGhpcztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG92ZXJsYXkgPSAob2xkICYmICFvcHRpb25zKSA/IG9sZCA6IG5ldyBPdmVybGF5Q2xhc3Mob3B0aW9ucywgdGhpcyk7XHJcblx0XHRcdG92ZXJsYXkuc2V0Q29udGVudChjb250ZW50KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBvdmVybGF5O1xyXG5cdH1cclxufSk7XHJcbiIsImltcG9ydCB7RGl2T3ZlcmxheX0gZnJvbSAnLi9EaXZPdmVybGF5JztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCB7UG9pbnQsIHRvUG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xyXG5pbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcclxuaW1wb3J0IHtQYXRofSBmcm9tICcuL3ZlY3Rvci9QYXRoJztcclxuaW1wb3J0IHtGZWF0dXJlR3JvdXB9IGZyb20gJy4vRmVhdHVyZUdyb3VwJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBQb3B1cFxyXG4gKiBAaW5oZXJpdHMgRGl2T3ZlcmxheVxyXG4gKiBAYWthIEwuUG9wdXBcclxuICogVXNlZCB0byBvcGVuIHBvcHVwcyBpbiBjZXJ0YWluIHBsYWNlcyBvZiB0aGUgbWFwLiBVc2UgW01hcC5vcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSB0b1xyXG4gKiBvcGVuIHBvcHVwcyB3aGlsZSBtYWtpbmcgc3VyZSB0aGF0IG9ubHkgb25lIHBvcHVwIGlzIG9wZW4gYXQgb25lIHRpbWVcclxuICogKHJlY29tbWVuZGVkIGZvciB1c2FiaWxpdHkpLCBvciB1c2UgW01hcC5hZGRMYXllcl0oI21hcC1hZGRsYXllcikgdG8gb3BlbiBhcyBtYW55IGFzIHlvdSB3YW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBJZiB5b3Ugd2FudCB0byBqdXN0IGJpbmQgYSBwb3B1cCB0byBtYXJrZXIgY2xpY2sgYW5kIHRoZW4gb3BlbiBpdCwgaXQncyByZWFsbHkgZWFzeTpcclxuICpcclxuICogYGBganNcclxuICogbWFya2VyLmJpbmRQb3B1cChwb3B1cENvbnRlbnQpLm9wZW5Qb3B1cCgpO1xyXG4gKiBgYGBcclxuICogUGF0aCBvdmVybGF5cyBsaWtlIHBvbHlsaW5lcyBhbHNvIGhhdmUgYSBgYmluZFBvcHVwYCBtZXRob2QuXHJcbiAqXHJcbiAqIEEgcG9wdXAgY2FuIGJlIGFsc28gc3RhbmRhbG9uZTpcclxuICpcclxuICogYGBganNcclxuICogdmFyIHBvcHVwID0gTC5wb3B1cCgpXHJcbiAqIFx0LnNldExhdExuZyhsYXRsbmcpXHJcbiAqIFx0LnNldENvbnRlbnQoJzxwPkhlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHBvcHVwLjwvcD4nKVxyXG4gKiBcdC5vcGVuT24obWFwKTtcclxuICogYGBgXHJcbiAqIG9yXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwb3B1cCA9IEwucG9wdXAobGF0bG5nLCB7Y29udGVudDogJzxwPkhlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHBvcHVwLjwvcD4nKVxyXG4gKiBcdC5vcGVuT24obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9wdXBcclxuZXhwb3J0IHZhciBQb3B1cCA9IERpdk92ZXJsYXkuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFBvcHVwIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdwb3B1cFBhbmUnXHJcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBwb3B1cCB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0cGFuZTogJ3BvcHVwUGFuZScsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgNylcclxuXHRcdC8vIFRoZSBvZmZzZXQgb2YgdGhlIHBvcHVwIHBvc2l0aW9uLlxyXG5cdFx0b2Zmc2V0OiBbMCwgN10sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMzAwXHJcblx0XHQvLyBNYXggd2lkdGggb2YgdGhlIHBvcHVwLCBpbiBwaXhlbHMuXHJcblx0XHRtYXhXaWR0aDogMzAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWluV2lkdGg6IE51bWJlciA9IDUwXHJcblx0XHQvLyBNaW4gd2lkdGggb2YgdGhlIHBvcHVwLCBpbiBwaXhlbHMuXHJcblx0XHRtaW5XaWR0aDogNTAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhIZWlnaHQ6IE51bWJlciA9IG51bGxcclxuXHRcdC8vIElmIHNldCwgY3JlYXRlcyBhIHNjcm9sbGFibGUgY29udGFpbmVyIG9mIHRoZSBnaXZlbiBoZWlnaHRcclxuXHRcdC8vIGluc2lkZSBhIHBvcHVwIGlmIGl0cyBjb250ZW50IGV4Y2VlZHMgaXQuXHJcblx0XHQvLyBUaGUgc2Nyb2xsYWJsZSBjb250YWluZXIgY2FuIGJlIHN0eWxlZCB1c2luZyB0aGVcclxuXHRcdC8vIGBsZWFmbGV0LXBvcHVwLXNjcm9sbGVkYCBDU1MgY2xhc3Mgc2VsZWN0b3IuXHJcblx0XHRtYXhIZWlnaHQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IGRvbid0IHdhbnQgdGhlIG1hcCB0byBkbyBwYW5uaW5nIGFuaW1hdGlvblxyXG5cdFx0Ly8gdG8gZml0IHRoZSBvcGVuZWQgcG9wdXAuXHJcblx0XHRhdXRvUGFuOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmdUb3BMZWZ0OiBQb2ludCA9IG51bGxcclxuXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIG1hcFxyXG5cdFx0Ly8gdmlldyBhZnRlciBhdXRvcGFubmluZyB3YXMgcGVyZm9ybWVkLlxyXG5cdFx0YXV0b1BhblBhZGRpbmdUb3BMZWZ0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogUG9pbnQgPSBudWxsXHJcblx0XHQvLyBUaGUgbWFyZ2luIGJldHdlZW4gdGhlIHBvcHVwIGFuZCB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgbWFwXHJcblx0XHQvLyB2aWV3IGFmdGVyIGF1dG9wYW5uaW5nIHdhcyBwZXJmb3JtZWQuXHJcblx0XHRhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmc6IFBvaW50ID0gUG9pbnQoNSwgNSlcclxuXHRcdC8vIEVxdWl2YWxlbnQgb2Ygc2V0dGluZyBib3RoIHRvcCBsZWZ0IGFuZCBib3R0b20gcmlnaHQgYXV0b3BhbiBwYWRkaW5nIHRvIHRoZSBzYW1lIHZhbHVlLlxyXG5cdFx0YXV0b1BhblBhZGRpbmc6IFs1LCA1XSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGtlZXBJblZpZXc6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGB0cnVlYCBpZiB5b3Ugd2FudCB0byBwcmV2ZW50IHVzZXJzIGZyb20gcGFubmluZyB0aGUgcG9wdXBcclxuXHRcdC8vIG9mZiBvZiB0aGUgc2NyZWVuIHdoaWxlIGl0IGlzIG9wZW4uXHJcblx0XHRrZWVwSW5WaWV3OiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsb3NlQnV0dG9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gQ29udHJvbHMgdGhlIHByZXNlbmNlIG9mIGEgY2xvc2UgYnV0dG9uIGluIHRoZSBwb3B1cC5cclxuXHRcdGNsb3NlQnV0dG9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b0Nsb3NlOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2ZcclxuXHRcdC8vIHRoZSBwb3B1cCBjbG9zaW5nIHdoZW4gYW5vdGhlciBwb3B1cCBpcyBvcGVuZWQuXHJcblx0XHRhdXRvQ2xvc2U6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbG9zZU9uRXNjYXBlS2V5OiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2ZcclxuXHRcdC8vIHRoZSBFU0Mga2V5IGZvciBjbG9zaW5nIG9mIHRoZSBwb3B1cC5cclxuXHRcdGNsb3NlT25Fc2NhcGVLZXk6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbG9zZU9uQ2xpY2s6IEJvb2xlYW4gPSAqXHJcblx0XHQvLyBTZXQgaXQgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgdGhlIHBvcHVwIGNsb3Npbmcgd2hlbiB1c2VyIGNsaWNrc1xyXG5cdFx0Ly8gb24gdGhlIG1hcC4gRGVmYXVsdHMgdG8gdGhlIG1hcCdzIFtgY2xvc2VQb3B1cE9uQ2xpY2tgXSgjbWFwLWNsb3NlcG9wdXBvbmNsaWNrKSBvcHRpb24uXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBBIGN1c3RvbSBDU1MgY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHBvcHVwLlxyXG5cdFx0Y2xhc3NOYW1lOiAnJ1xyXG5cdH0sXHJcblxyXG5cdC8vIEBuYW1lc3BhY2UgUG9wdXBcclxuXHQvLyBAbWV0aG9kIG9wZW5PbihtYXA6IE1hcCk6IHRoaXNcclxuXHQvLyBBbHRlcm5hdGl2ZSB0byBgbWFwLm9wZW5Qb3B1cChwb3B1cClgLlxyXG5cdC8vIEFkZHMgdGhlIHBvcHVwIHRvIHRoZSBtYXAgYW5kIGNsb3NlcyB0aGUgcHJldmlvdXMgb25lLlxyXG5cdG9wZW5PbjogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwID0gYXJndW1lbnRzLmxlbmd0aCA/IG1hcCA6IHRoaXMuX3NvdXJjZS5fbWFwOyAvLyBleHBlcmltZW50YWwsIG5vdCB0aGUgcGFydCBvZiBwdWJsaWMgYXBpXHJcblxyXG5cdFx0aWYgKCFtYXAuaGFzTGF5ZXIodGhpcykgJiYgbWFwLl9wb3B1cCAmJiBtYXAuX3BvcHVwLm9wdGlvbnMuYXV0b0Nsb3NlKSB7XHJcblx0XHRcdG1hcC5yZW1vdmVMYXllcihtYXAuX3BvcHVwKTtcclxuXHRcdH1cclxuXHRcdG1hcC5fcG9wdXAgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiBEaXZPdmVybGF5LnByb3RvdHlwZS5vcGVuT24uY2FsbCh0aGlzLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHBvcHVwb3BlbjogUG9wdXBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGlzIG9wZW5lZCBpbiB0aGUgbWFwXHJcblx0XHRtYXAuZmlyZSgncG9wdXBvcGVuJywge3BvcHVwOiB0aGlzfSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXHJcblx0XHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIG9wZW5lZFxyXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBvcGVuJywge3BvcHVwOiB0aGlzfSwgdHJ1ZSk7XHJcblx0XHRcdC8vIEZvciBub24tcGF0aCBsYXllcnMsIHdlIHRvZ2dsZSB0aGUgcG9wdXAgd2hlbiBjbGlja2luZ1xyXG5cdFx0XHQvLyBhZ2FpbiB0aGUgbGF5ZXIsIHNvIHByZXZlbnQgdGhlIG1hcCB0byByZW9wZW4gaXQuXHJcblx0XHRcdGlmICghKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIFBhdGgpKSB7XHJcblx0XHRcdFx0dGhpcy5fc291cmNlLm9uKCdwcmVjbGljaycsIERvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaW4gdGhlIG1hcCBpcyBjbG9zZWRcclxuXHRcdG1hcC5maXJlKCdwb3B1cGNsb3NlJywge3BvcHVwOiB0aGlzfSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXHJcblx0XHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0XHQvLyBAZXZlbnQgcG9wdXBjbG9zZTogUG9wdXBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWRcclxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuXHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgUGF0aCkpIHtcclxuXHRcdFx0XHR0aGlzLl9zb3VyY2Uub2ZmKCdwcmVjbGljaycsIERvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSBEaXZPdmVybGF5LnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayAhPT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayA6IHRoaXMuX21hcC5vcHRpb25zLmNsb3NlUG9wdXBPbkNsaWNrKSB7XHJcblx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuY2xvc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5rZWVwSW5WaWV3KSB7XHJcblx0XHRcdGV2ZW50cy5tb3ZlZW5kID0gdGhpcy5fYWRqdXN0UGFuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwcmVmaXggPSAnbGVhZmxldC1wb3B1cCcsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsXHJcblx0XHRcdHByZWZpeCArICcgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArXHJcblx0XHRcdCcgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcblxyXG5cdFx0dmFyIHdyYXBwZXIgPSB0aGlzLl93cmFwcGVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctY29udGVudC13cmFwcGVyJywgY29udGFpbmVyKTtcclxuXHRcdHRoaXMuX2NvbnRlbnROb2RlID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctY29udGVudCcsIHdyYXBwZXIpO1xyXG5cclxuXHRcdERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblx0XHREb21FdmVudC5kaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24odGhpcy5fY29udGVudE5vZGUpO1xyXG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnY29udGV4dG1lbnUnLCBEb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cclxuXHRcdHRoaXMuX3RpcENvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLXRpcC1jb250YWluZXInLCBjb250YWluZXIpO1xyXG5cdFx0dGhpcy5fdGlwID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctdGlwJywgdGhpcy5fdGlwQ29udGFpbmVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uKSB7XHJcblx0XHRcdHZhciBjbG9zZUJ1dHRvbiA9IHRoaXMuX2Nsb3NlQnV0dG9uID0gRG9tVXRpbC5jcmVhdGUoJ2EnLCBwcmVmaXggKyAnLWNsb3NlLWJ1dHRvbicsIGNvbnRhaW5lcik7XHJcblx0XHRcdGNsb3NlQnV0dG9uLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTsgLy8gb3ZlcnJpZGVzIHRoZSBpbXBsaWNpdCByb2xlPWxpbmsgb2YgPGE+IGVsZW1lbnRzICM3Mzk5XHJcblx0XHRcdGNsb3NlQnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsICdDbG9zZSBwb3B1cCcpO1xyXG5cdFx0XHRjbG9zZUJ1dHRvbi5ocmVmID0gJyNjbG9zZSc7XHJcblx0XHRcdGNsb3NlQnV0dG9uLmlubmVySFRNTCA9ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mIzIxNTs8L3NwYW4+JztcclxuXHJcblx0XHRcdERvbUV2ZW50Lm9uKGNsb3NlQnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoZXYpIHtcclxuXHRcdFx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChldik7XHJcblx0XHRcdFx0dGhpcy5jbG9zZSgpO1xyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGVudE5vZGUsXHJcblx0XHQgICAgc3R5bGUgPSBjb250YWluZXIuc3R5bGU7XHJcblxyXG5cdFx0c3R5bGUud2lkdGggPSAnJztcclxuXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztcclxuXHJcblx0XHR2YXIgd2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGg7XHJcblx0XHR3aWR0aCA9IE1hdGgubWluKHdpZHRoLCB0aGlzLm9wdGlvbnMubWF4V2lkdGgpO1xyXG5cdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgdGhpcy5vcHRpb25zLm1pbldpZHRoKTtcclxuXHJcblx0XHRzdHlsZS53aWR0aCA9ICh3aWR0aCArIDEpICsgJ3B4JztcclxuXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnJztcclxuXHJcblx0XHRzdHlsZS5oZWlnaHQgPSAnJztcclxuXHJcblx0XHR2YXIgaGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcclxuXHRcdCAgICBtYXhIZWlnaHQgPSB0aGlzLm9wdGlvbnMubWF4SGVpZ2h0LFxyXG5cdFx0ICAgIHNjcm9sbGVkQ2xhc3MgPSAnbGVhZmxldC1wb3B1cC1zY3JvbGxlZCc7XHJcblxyXG5cdFx0aWYgKG1heEhlaWdodCAmJiBoZWlnaHQgPiBtYXhIZWlnaHQpIHtcclxuXHRcdFx0c3R5bGUuaGVpZ2h0ID0gbWF4SGVpZ2h0ICsgJ3B4JztcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIGUuem9vbSwgZS5jZW50ZXIpLFxyXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcblx0fSxcclxuXHJcblx0X2FkanVzdFBhbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYXV0b1BhbikgeyByZXR1cm47IH1cclxuXHRcdGlmICh0aGlzLl9tYXAuX3BhbkFuaW0pIHsgdGhpcy5fbWFwLl9wYW5BbmltLnN0b3AoKTsgfVxyXG5cclxuXHRcdC8vIFdlIGNhbiBlbmRsZXNzbHkgcmVjdXJzZSBpZiBrZWVwSW5WaWV3IGlzIHNldCBhbmQgdGhlIHZpZXcgcmVzZXRzLlxyXG5cdFx0Ly8gTGV0J3MgZ3VhcmQgYWdhaW5zdCB0aGF0IGJ5IGV4aXRpbmcgZWFybHkgaWYgd2UncmUgcmVzcG9uZGluZyB0byBvdXIgb3duIGF1dG9wYW4uXHJcblx0XHRpZiAodGhpcy5fYXV0b3Bhbm5pbmcpIHtcclxuXHRcdFx0dGhpcy5fYXV0b3Bhbm5pbmcgPSBmYWxzZTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgbWFyZ2luQm90dG9tID0gcGFyc2VJbnQoRG9tVXRpbC5nZXRTdHlsZSh0aGlzLl9jb250YWluZXIsICdtYXJnaW5Cb3R0b20nKSwgMTApIHx8IDAsXHJcblx0XHQgICAgY29udGFpbmVySGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCArIG1hcmdpbkJvdHRvbSxcclxuXHRcdCAgICBjb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lcldpZHRoLFxyXG5cdFx0ICAgIGxheWVyUG9zID0gbmV3IFBvaW50KHRoaXMuX2NvbnRhaW5lckxlZnQsIC1jb250YWluZXJIZWlnaHQgLSB0aGlzLl9jb250YWluZXJCb3R0b20pO1xyXG5cclxuXHRcdGxheWVyUG9zLl9hZGQoRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpKTtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyUG9zID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KGxheWVyUG9zKSxcclxuXHRcdCAgICBwYWRkaW5nID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcpLFxyXG5cdFx0ICAgIHBhZGRpbmdUTCA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nVG9wTGVmdCB8fCBwYWRkaW5nKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0IHx8IHBhZGRpbmcpLFxyXG5cdFx0ICAgIHNpemUgPSBtYXAuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIGR4ID0gMCxcclxuXHRcdCAgICBkeSA9IDA7XHJcblxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggKyBwYWRkaW5nQlIueCA+IHNpemUueCkgeyAvLyByaWdodFxyXG5cdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggLSBzaXplLnggKyBwYWRkaW5nQlIueDtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueCAtIGR4IC0gcGFkZGluZ1RMLnggPCAwKSB7IC8vIGxlZnRcclxuXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCAtIHBhZGRpbmdUTC54O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0ICsgcGFkZGluZ0JSLnkgPiBzaXplLnkpIHsgLy8gYm90dG9tXHJcblx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgLSBzaXplLnkgKyBwYWRkaW5nQlIueTtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueSAtIGR5IC0gcGFkZGluZ1RMLnkgPCAwKSB7IC8vIHRvcFxyXG5cdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55IC0gcGFkZGluZ1RMLnk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGF1dG9wYW5zdGFydDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBzdGFydHMgYXV0b3Bhbm5pbmcgd2hlbiBvcGVuaW5nIGEgcG9wdXAuXHJcblx0XHRpZiAoZHggfHwgZHkpIHtcclxuXHRcdFx0Ly8gVHJhY2sgdGhhdCB3ZSdyZSBhdXRvcGFubmluZywgYXMgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlLXJhbiBvbiBtb3ZlZW5kXHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMua2VlcEluVmlldykge1xyXG5cdFx0XHRcdHRoaXMuX2F1dG9wYW5uaW5nID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bWFwXHJcblx0XHRcdCAgICAuZmlyZSgnYXV0b3BhbnN0YXJ0JylcclxuXHRcdFx0ICAgIC5wYW5CeShbZHgsIGR5XSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gV2hlcmUgc2hvdWxkIHdlIGFuY2hvciB0aGUgcG9wdXAgb24gdGhlIHNvdXJjZSBsYXllcj9cclxuXHRcdHJldHVybiB0b1BvaW50KHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yID8gdGhpcy5fc291cmNlLl9nZXRQb3B1cEFuY2hvcigpIDogWzAsIDBdKTtcclxuXHR9XHJcblxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9wdXBcclxuLy8gQGZhY3RvcnkgTC5wb3B1cChvcHRpb25zPzogUG9wdXAgb3B0aW9ucywgc291cmNlPzogTGF5ZXIpXHJcbi8vIEluc3RhbnRpYXRlcyBhIGBQb3B1cGAgb2JqZWN0IGdpdmVuIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uIGFuZCBhbiBvcHRpb25hbCBgc291cmNlYCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHRhZyB0aGUgcG9wdXAgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgTGF5ZXIgdG8gd2hpY2ggaXQgcmVmZXJzLlxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5wb3B1cChsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIGBQb3B1cGAgb2JqZWN0IGdpdmVuIGBsYXRsbmdgIHdoZXJlIHRoZSBwb3B1cCB3aWxsIG9wZW4gYW5kIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uLlxyXG5leHBvcnQgdmFyIHBvcHVwID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xyXG5cdHJldHVybiBuZXcgUG9wdXAob3B0aW9ucywgc291cmNlKTtcclxufTtcclxuXHJcblxyXG4vKiBAbmFtZXNwYWNlIE1hcFxyXG4gKiBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXHJcbiAqIEBvcHRpb24gY2xvc2VQb3B1cE9uQ2xpY2s6IEJvb2xlYW4gPSB0cnVlXHJcbiAqIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHBvcHVwcyB0byBjbG9zZSB3aGVuIHVzZXIgY2xpY2tzIHRoZSBtYXAuXHJcbiAqL1xyXG5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHRjbG9zZVBvcHVwT25DbGljazogdHJ1ZVxyXG59KTtcclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXHJcbk1hcC5pbmNsdWRlKHtcclxuXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChwb3B1cDogUG9wdXApOiB0aGlzXHJcblx0Ly8gT3BlbnMgdGhlIHNwZWNpZmllZCBwb3B1cCB3aGlsZSBjbG9zaW5nIHRoZSBwcmV2aW91c2x5IG9wZW5lZCAodG8gbWFrZSBzdXJlIG9ubHkgb25lIGlzIG9wZW5lZCBhdCBvbmUgdGltZSBmb3IgdXNhYmlsaXR5KS5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnQsIGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogUG9wdXAgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBDcmVhdGVzIGEgcG9wdXAgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYW5kIG9wdGlvbnMgYW5kIG9wZW5zIGl0IGluIHRoZSBnaXZlbiBwb2ludCBvbiBhIG1hcC5cclxuXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCwgbGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHR0aGlzLl9pbml0T3ZlcmxheShQb3B1cCwgcG9wdXAsIGxhdGxuZywgb3B0aW9ucylcclxuXHRcdCAgLm9wZW5Pbih0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsb3NlUG9wdXAocG9wdXA/OiBQb3B1cCk6IHRoaXNcclxuXHQvLyBDbG9zZXMgdGhlIHBvcHVwIHByZXZpb3VzbHkgb3BlbmVkIHdpdGggW29wZW5Qb3B1cF0oI21hcC1vcGVucG9wdXApIChvciB0aGUgZ2l2ZW4gb25lKS5cclxuXHRjbG9zZVBvcHVwOiBmdW5jdGlvbiAocG9wdXApIHtcclxuXHRcdHBvcHVwID0gYXJndW1lbnRzLmxlbmd0aCA/IHBvcHVwIDogdGhpcy5fcG9wdXA7XHJcblx0XHRpZiAocG9wdXApIHtcclxuXHRcdFx0cG9wdXAuY2xvc2UoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufSk7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIExheWVyXHJcbiAqIEBzZWN0aW9uIFBvcHVwIG1ldGhvZHMgZXhhbXBsZVxyXG4gKlxyXG4gKiBBbGwgbGF5ZXJzIHNoYXJlIGEgc2V0IG9mIG1ldGhvZHMgY29udmVuaWVudCBmb3IgYmluZGluZyBwb3B1cHMgdG8gaXQuXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBsYXllciA9IEwuUG9seWdvbihsYXRsbmdzKS5iaW5kUG9wdXAoJ0hpIFRoZXJlIScpLmFkZFRvKG1hcCk7XHJcbiAqIGxheWVyLm9wZW5Qb3B1cCgpO1xyXG4gKiBsYXllci5jbG9zZVBvcHVwKCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBQb3B1cHMgd2lsbCBhbHNvIGJlIGF1dG9tYXRpY2FsbHkgb3BlbmVkIHdoZW4gdGhlIGxheWVyIGlzIGNsaWNrZWQgb24gYW5kIGNsb3NlZCB3aGVuIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcCBvciBhbm90aGVyIHBvcHVwIGlzIG9wZW5lZC5cclxuICovXHJcblxyXG4vLyBAc2VjdGlvbiBQb3B1cCBtZXRob2RzXHJcbkxheWVyLmluY2x1ZGUoe1xyXG5cclxuXHQvLyBAbWV0aG9kIGJpbmRQb3B1cChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb258UG9wdXAsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKTogdGhpc1xyXG5cdC8vIEJpbmRzIGEgcG9wdXAgdG8gdGhlIGxheWVyIHdpdGggdGhlIHBhc3NlZCBgY29udGVudGAgYW5kIHNldHMgdXAgdGhlXHJcblx0Ly8gbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycy4gSWYgYSBgRnVuY3Rpb25gIGlzIHBhc3NlZCBpdCB3aWxsIHJlY2VpdmVcclxuXHQvLyB0aGUgbGF5ZXIgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YC5cclxuXHRiaW5kUG9wdXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XHJcblx0XHR0aGlzLl9wb3B1cCA9IHRoaXMuX2luaXRPdmVybGF5KFBvcHVwLCB0aGlzLl9wb3B1cCwgY29udGVudCwgb3B0aW9ucyk7XHJcblx0XHRpZiAoIXRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCkge1xyXG5cdFx0XHR0aGlzLm9uKHtcclxuXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxyXG5cdFx0XHRcdGtleXByZXNzOiB0aGlzLl9vbktleVByZXNzLFxyXG5cdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxyXG5cdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxyXG5cdFx0XHR9KTtcclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVuYmluZFBvcHVwKCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBwb3B1cCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRQb3B1cGAuXHJcblx0dW5iaW5kUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLm9mZih7XHJcblx0XHRcdFx0Y2xpY2s6IHRoaXMuX29wZW5Qb3B1cCxcclxuXHRcdFx0XHRrZXlwcmVzczogdGhpcy5fb25LZXlQcmVzcyxcclxuXHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VQb3B1cCxcclxuXHRcdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlUG9wdXBcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gT3BlbnMgdGhlIGJvdW5kIHBvcHVwIGF0IHRoZSBzcGVjaWZpZWQgYGxhdGxuZ2Agb3IgYXQgdGhlIGRlZmF1bHQgcG9wdXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cclxuXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHRpZiAoISh0aGlzIGluc3RhbmNlb2YgRmVhdHVyZUdyb3VwKSkge1xyXG5cdFx0XHRcdHRoaXMuX3BvcHVwLl9zb3VyY2UgPSB0aGlzO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0aGlzLl9wb3B1cC5fcHJlcGFyZU9wZW4obGF0bG5nIHx8IHRoaXMuX2xhdGxuZykpIHtcclxuXHRcdFx0XHQvLyBvcGVuIHRoZSBwb3B1cCBvbiB0aGUgbWFwXHJcblx0XHRcdFx0dGhpcy5fcG9wdXAub3Blbk9uKHRoaXMuX21hcCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xvc2VQb3B1cCgpOiB0aGlzXHJcblx0Ly8gQ2xvc2VzIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlmIGl0IGlzIG9wZW4uXHJcblx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwLmNsb3NlKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvZ2dsZVBvcHVwKCk6IHRoaXNcclxuXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxyXG5cdHRvZ2dsZVBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAudG9nZ2xlKHRoaXMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpc1BvcHVwT3BlbigpOiBib29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY3VycmVudGx5IG9wZW4uXHJcblx0aXNQb3B1cE9wZW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAodGhpcy5fcG9wdXAgPyB0aGlzLl9wb3B1cC5pc09wZW4oKSA6IGZhbHNlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFBvcHVwQ29udGVudChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8UG9wdXApOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgY29udGVudCBvZiB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cclxuXHRzZXRQb3B1cENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UG9wdXAoKTogUG9wdXBcclxuXHQvLyBSZXR1cm5zIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyLlxyXG5cdGdldFBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcG9wdXA7XHJcblx0fSxcclxuXHJcblx0X29wZW5Qb3B1cDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fcG9wdXAgfHwgIXRoaXMuX21hcCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHQvLyBwcmV2ZW50IG1hcCBjbGlja1xyXG5cdFx0RG9tRXZlbnQuc3RvcChlKTtcclxuXHJcblx0XHR2YXIgdGFyZ2V0ID0gZS5sYXllciB8fCBlLnRhcmdldDtcclxuXHRcdGlmICh0aGlzLl9wb3B1cC5fc291cmNlID09PSB0YXJnZXQgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG5cdFx0XHQvLyB0cmVhdCBpdCBsaWtlIGEgbWFya2VyIGFuZCBmaWd1cmUgb3V0XHJcblx0XHRcdC8vIGlmIHdlIHNob3VsZCB0b2dnbGUgaXQgb3Blbi9jbG9zZWRcclxuXHRcdFx0aWYgKHRoaXMuX21hcC5oYXNMYXllcih0aGlzLl9wb3B1cCkpIHtcclxuXHRcdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLm9wZW5Qb3B1cChlLmxhdGxuZyk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fcG9wdXAuX3NvdXJjZSA9IHRhcmdldDtcclxuXHRcdHRoaXMub3BlblBvcHVwKGUubGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHRfbW92ZVBvcHVwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dGhpcy5fcG9wdXAuc2V0TGF0TG5nKGUubGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHRfb25LZXlQcmVzczogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmIChlLm9yaWdpbmFsRXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcclxuXHRcdFx0dGhpcy5fb3BlblBvcHVwKGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcbiIsImltcG9ydCB7RGl2T3ZlcmxheX0gZnJvbSAnLi9EaXZPdmVybGF5JztcbmltcG9ydCB7dG9Qb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge0ZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xuXG4vKlxuICogQGNsYXNzIFRvb2x0aXBcbiAqIEBpbmhlcml0cyBEaXZPdmVybGF5XG4gKiBAYWthIEwuVG9vbHRpcFxuICogVXNlZCB0byBkaXNwbGF5IHNtYWxsIHRleHRzIG9uIHRvcCBvZiBtYXAgbGF5ZXJzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBJZiB5b3Ugd2FudCB0byBqdXN0IGJpbmQgYSB0b29sdGlwIHRvIG1hcmtlcjpcbiAqXG4gKiBgYGBqc1xuICogbWFya2VyLmJpbmRUb29sdGlwKFwibXkgdG9vbHRpcCB0ZXh0XCIpLm9wZW5Ub29sdGlwKCk7XG4gKiBgYGBcbiAqIFBhdGggb3ZlcmxheXMgbGlrZSBwb2x5bGluZXMgYWxzbyBoYXZlIGEgYGJpbmRUb29sdGlwYCBtZXRob2QuXG4gKlxuICogQSB0b29sdGlwIGNhbiBiZSBhbHNvIHN0YW5kYWxvbmU6XG4gKlxuICogYGBganNcbiAqIHZhciB0b29sdGlwID0gTC50b29sdGlwKClcbiAqIFx0LnNldExhdExuZyhsYXRsbmcpXG4gKiBcdC5zZXRDb250ZW50KCdIZWxsbyB3b3JsZCE8YnIgLz5UaGlzIGlzIGEgbmljZSB0b29sdGlwLicpXG4gKiBcdC5hZGRUbyhtYXApO1xuICogYGBgXG4gKiBvclxuICogYGBganNcbiAqIHZhciB0b29sdGlwID0gTC50b29sdGlwKGxhdGxuZywge2NvbnRlbnQ6ICdIZWxsbyB3b3JsZCE8YnIgLz5UaGlzIGlzIGEgbmljZSB0b29sdGlwLid9KVxuICogXHQuYWRkVG8obWFwKTtcbiAqIGBgYFxuICpcbiAqXG4gKiBOb3RlIGFib3V0IHRvb2x0aXAgb2Zmc2V0LiBMZWFmbGV0IHRha2VzIHR3byBvcHRpb25zIGluIGNvbnNpZGVyYXRpb25cbiAqIGZvciBjb21wdXRpbmcgdG9vbHRpcCBvZmZzZXR0aW5nOlxuICogLSB0aGUgYG9mZnNldGAgVG9vbHRpcCBvcHRpb246IGl0IGRlZmF1bHRzIHRvIFswLCAwXSwgYW5kIGl0J3Mgc3BlY2lmaWMgdG8gb25lIHRvb2x0aXAuXG4gKiAgIEFkZCBhIHBvc2l0aXZlIHggb2Zmc2V0IHRvIG1vdmUgdGhlIHRvb2x0aXAgdG8gdGhlIHJpZ2h0LCBhbmQgYSBwb3NpdGl2ZSB5IG9mZnNldCB0b1xuICogICBtb3ZlIGl0IHRvIHRoZSBib3R0b20uIE5lZ2F0aXZlcyB3aWxsIG1vdmUgdG8gdGhlIGxlZnQgYW5kIHRvcC5cbiAqIC0gdGhlIGB0b29sdGlwQW5jaG9yYCBJY29uIG9wdGlvbjogdGhpcyB3aWxsIG9ubHkgYmUgY29uc2lkZXJlZCBmb3IgTWFya2VyLiBZb3VcbiAqICAgc2hvdWxkIGFkYXB0IHRoaXMgdmFsdWUgaWYgeW91IHVzZSBhIGN1c3RvbSBpY29uLlxuICovXG5cblxuLy8gQG5hbWVzcGFjZSBUb29sdGlwXG5leHBvcnQgdmFyIFRvb2x0aXAgPSBEaXZPdmVybGF5LmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBUb29sdGlwIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3Rvb2x0aXBQYW5lJ1xuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHRvb2x0aXAgd2lsbCBiZSBhZGRlZC5cblx0XHRwYW5lOiAndG9vbHRpcFBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgMClcblx0XHQvLyBPcHRpb25hbCBvZmZzZXQgb2YgdGhlIHRvb2x0aXAgcG9zaXRpb24uXG5cdFx0b2Zmc2V0OiBbMCwgMF0sXG5cblx0XHQvLyBAb3B0aW9uIGRpcmVjdGlvbjogU3RyaW5nID0gJ2F1dG8nXG5cdFx0Ly8gRGlyZWN0aW9uIHdoZXJlIHRvIG9wZW4gdGhlIHRvb2x0aXAuIFBvc3NpYmxlIHZhbHVlcyBhcmU6IGByaWdodGAsIGBsZWZ0YCxcblx0XHQvLyBgdG9wYCwgYGJvdHRvbWAsIGBjZW50ZXJgLCBgYXV0b2AuXG5cdFx0Ly8gYGF1dG9gIHdpbGwgZHluYW1pY2FsbHkgc3dpdGNoIGJldHdlZW4gYHJpZ2h0YCBhbmQgYGxlZnRgIGFjY29yZGluZyB0byB0aGUgdG9vbHRpcFxuXHRcdC8vIHBvc2l0aW9uIG9uIHRoZSBtYXAuXG5cdFx0ZGlyZWN0aW9uOiAnYXV0bycsXG5cblx0XHQvLyBAb3B0aW9uIHBlcm1hbmVudDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciB0byBvcGVuIHRoZSB0b29sdGlwIHBlcm1hbmVudGx5IG9yIG9ubHkgb24gbW91c2VvdmVyLlxuXHRcdHBlcm1hbmVudDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIHN0aWNreTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gSWYgdHJ1ZSwgdGhlIHRvb2x0aXAgd2lsbCBmb2xsb3cgdGhlIG1vdXNlIGluc3RlYWQgb2YgYmVpbmcgZml4ZWQgYXQgdGhlIGZlYXR1cmUgY2VudGVyLlxuXHRcdHN0aWNreTogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDAuOVxuXHRcdC8vIFRvb2x0aXAgY29udGFpbmVyIG9wYWNpdHkuXG5cdFx0b3BhY2l0eTogMC45XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG5cdFx0dGhpcy5zZXRPcGFjaXR5KHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXG5cdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHQvLyBAZXZlbnQgdG9vbHRpcG9wZW46IFRvb2x0aXBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGlzIG9wZW5lZCBpbiB0aGUgbWFwLlxuXHRcdG1hcC5maXJlKCd0b29sdGlwb3BlbicsIHt0b29sdGlwOiB0aGlzfSk7XG5cblx0XHRpZiAodGhpcy5fc291cmNlKSB7XG5cdFx0XHR0aGlzLmFkZEV2ZW50UGFyZW50KHRoaXMuX3NvdXJjZSk7XG5cblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcblx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0XHQvLyBAZXZlbnQgdG9vbHRpcG9wZW46IFRvb2x0aXBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBvcGVuZWQuXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgndG9vbHRpcG9wZW4nLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuXHRcdH1cblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXG5cdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBpbiB0aGUgbWFwIGlzIGNsb3NlZC5cblx0XHRtYXAuZmlyZSgndG9vbHRpcGNsb3NlJywge3Rvb2x0aXA6IHRoaXN9KTtcblxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcblx0XHRcdHRoaXMucmVtb3ZlRXZlbnRQYXJlbnQodGhpcy5fc291cmNlKTtcblxuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuXHRcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWQuXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgndG9vbHRpcGNsb3NlJywge3Rvb2x0aXA6IHRoaXN9LCB0cnVlKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IERpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMucGVybWFuZW50KSB7XG5cdFx0XHRldmVudHMucHJlY2xpY2sgPSB0aGlzLmNsb3NlO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtdG9vbHRpcCcsXG5cdFx0ICAgIGNsYXNzTmFtZSA9IHByZWZpeCArICcgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArICcgbGVhZmxldC16b29tLScgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyk7XG5cblx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpO1xuXG5cdFx0dGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZSgncm9sZScsICd0b29sdGlwJyk7XG5cdFx0dGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaWQnLCAnbGVhZmxldC10b29sdGlwLScgKyBVdGlsLnN0YW1wKHRoaXMpKTtcblx0fSxcblxuXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7fSxcblxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7fSxcblxuXHRfc2V0UG9zaXRpb246IGZ1bmN0aW9uIChwb3MpIHtcblx0XHR2YXIgc3ViWCwgc3ViWSxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsXG5cdFx0ICAgIGNlbnRlclBvaW50ID0gbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobWFwLmdldENlbnRlcigpKSxcblx0XHQgICAgdG9vbHRpcFBvaW50ID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvcyksXG5cdFx0ICAgIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb24sXG5cdFx0ICAgIHRvb2x0aXBXaWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aCxcblx0XHQgICAgdG9vbHRpcEhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXG5cdFx0ICAgIG9mZnNldCA9IHRvUG9pbnQodGhpcy5vcHRpb25zLm9mZnNldCksXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xuXG5cdFx0aWYgKGRpcmVjdGlvbiA9PT0gJ3RvcCcpIHtcblx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGggLyAyO1xuXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQ7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdib3R0b20nKSB7XG5cdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoIC8gMjtcblx0XHRcdHN1YlkgPSAwO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnY2VudGVyJykge1xuXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCAvIDI7XG5cdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcblx0XHRcdHN1YlggPSAwO1xuXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcblx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGg7XG5cdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG5cdFx0fSBlbHNlIGlmICh0b29sdGlwUG9pbnQueCA8IGNlbnRlclBvaW50LngpIHtcblx0XHRcdGRpcmVjdGlvbiA9ICdyaWdodCc7XG5cdFx0XHRzdWJYID0gMDtcblx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGlyZWN0aW9uID0gJ2xlZnQnO1xuXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCArIChvZmZzZXQueCArIGFuY2hvci54KSAqIDI7XG5cdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG5cdFx0fVxuXG5cdFx0cG9zID0gcG9zLnN1YnRyYWN0KHRvUG9pbnQoc3ViWCwgc3ViWSwgdHJ1ZSkpLmFkZChvZmZzZXQpLmFkZChhbmNob3IpO1xuXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtcmlnaHQnKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1sZWZ0Jyk7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtdG9wJyk7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtYm90dG9tJyk7XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtJyArIGRpcmVjdGlvbik7XG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihjb250YWluZXIsIHBvcyk7XG5cdH0sXG5cblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHR0aGlzLl9zZXRQb3NpdGlvbihwb3MpO1xuXHR9LFxuXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikge1xuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgb3BhY2l0eSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKTtcblx0XHR0aGlzLl9zZXRQb3NpdGlvbihwb3MpO1xuXHR9LFxuXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSB0b29sdGlwIG9uIHRoZSBzb3VyY2UgbGF5ZXI/XG5cdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvciAmJiAhdGhpcy5vcHRpb25zLnN0aWNreSA/IHRoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvcigpIDogWzAsIDBdKTtcblx0fVxuXG59KTtcblxuLy8gQG5hbWVzcGFjZSBUb29sdGlwXG4vLyBAZmFjdG9yeSBMLnRvb2x0aXAob3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucywgc291cmNlPzogTGF5ZXIpXG4vLyBJbnN0YW50aWF0ZXMgYSBgVG9vbHRpcGAgb2JqZWN0IGdpdmVuIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uIGFuZCBhbiBvcHRpb25hbCBgc291cmNlYCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHRhZyB0aGUgdG9vbHRpcCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXG4vLyBAYWx0ZXJuYXRpdmVcbi8vIEBmYWN0b3J5IEwudG9vbHRpcChsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIGBUb29sdGlwYCBvYmplY3QgZ2l2ZW4gYGxhdGxuZ2Agd2hlcmUgdGhlIHRvb2x0aXAgd2lsbCBvcGVuIGFuZCBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbi5cbmV4cG9ydCB2YXIgdG9vbHRpcCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcblx0cmV0dXJuIG5ldyBUb29sdGlwKG9wdGlvbnMsIHNvdXJjZSk7XG59O1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xuTWFwLmluY2x1ZGUoe1xuXG5cdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAodG9vbHRpcDogVG9vbHRpcCk6IHRoaXNcblx0Ly8gT3BlbnMgdGhlIHNwZWNpZmllZCB0b29sdGlwLlxuXHQvLyBAYWx0ZXJuYXRpdmVcblx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnQsIGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zKTogdGhpc1xuXHQvLyBDcmVhdGVzIGEgdG9vbHRpcCB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBhbmQgb3B0aW9ucyBhbmQgb3BlbiBpdC5cblx0b3BlblRvb2x0aXA6IGZ1bmN0aW9uICh0b29sdGlwLCBsYXRsbmcsIG9wdGlvbnMpIHtcblx0XHR0aGlzLl9pbml0T3ZlcmxheShUb29sdGlwLCB0b29sdGlwLCBsYXRsbmcsIG9wdGlvbnMpXG5cdFx0ICAub3Blbk9uKHRoaXMpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZVRvb2x0aXAodG9vbHRpcDogVG9vbHRpcCk6IHRoaXNcblx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGdpdmVuIGFzIHBhcmFtZXRlci5cblx0Y2xvc2VUb29sdGlwOiBmdW5jdGlvbiAodG9vbHRpcCkge1xuXHRcdHRvb2x0aXAuY2xvc2UoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG59KTtcblxuLypcbiAqIEBuYW1lc3BhY2UgTGF5ZXJcbiAqIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kcyBleGFtcGxlXG4gKlxuICogQWxsIGxheWVycyBzaGFyZSBhIHNldCBvZiBtZXRob2RzIGNvbnZlbmllbnQgZm9yIGJpbmRpbmcgdG9vbHRpcHMgdG8gaXQuXG4gKlxuICogYGBganNcbiAqIHZhciBsYXllciA9IEwuUG9seWdvbihsYXRsbmdzKS5iaW5kVG9vbHRpcCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcbiAqIGxheWVyLm9wZW5Ub29sdGlwKCk7XG4gKiBsYXllci5jbG9zZVRvb2x0aXAoKTtcbiAqIGBgYFxuICovXG5cbi8vIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kc1xuTGF5ZXIuaW5jbHVkZSh7XG5cblx0Ly8gQG1ldGhvZCBiaW5kVG9vbHRpcChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb258VG9vbHRpcCwgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucyk6IHRoaXNcblx0Ly8gQmluZHMgYSB0b29sdGlwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxuXHQvLyBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxuXHQvLyB0aGUgbGF5ZXIgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YC5cblx0YmluZFRvb2x0aXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG5cblx0XHRpZiAodGhpcy5fdG9vbHRpcCAmJiB0aGlzLmlzVG9vbHRpcE9wZW4oKSkge1xuXHRcdFx0dGhpcy51bmJpbmRUb29sdGlwKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdG9vbHRpcCA9IHRoaXMuX2luaXRPdmVybGF5KFRvb2x0aXAsIHRoaXMuX3Rvb2x0aXAsIGNvbnRlbnQsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zKCk7XG5cblx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCAmJiB0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpKSB7XG5cdFx0XHR0aGlzLm9wZW5Ub29sdGlwKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCB1bmJpbmRUb29sdGlwKCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgdG9vbHRpcCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRUb29sdGlwYC5cblx0dW5iaW5kVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucyh0cnVlKTtcblx0XHRcdHRoaXMuY2xvc2VUb29sdGlwKCk7XG5cdFx0XHR0aGlzLl90b29sdGlwID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2luaXRUb29sdGlwSW50ZXJhY3Rpb25zOiBmdW5jdGlvbiAocmVtb3ZlKSB7XG5cdFx0aWYgKCFyZW1vdmUgJiYgdGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIG9uT2ZmID0gcmVtb3ZlID8gJ29mZicgOiAnb24nLFxuXHRcdCAgICBldmVudHMgPSB7XG5cdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VUb29sdGlwLFxuXHRcdFx0bW92ZTogdGhpcy5fbW92ZVRvb2x0aXBcblx0XHQgICAgfTtcblx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQpIHtcblx0XHRcdGV2ZW50cy5tb3VzZW92ZXIgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHRcdGV2ZW50cy5tb3VzZW91dCA9IHRoaXMuY2xvc2VUb29sdGlwO1xuXHRcdFx0ZXZlbnRzLmNsaWNrID0gdGhpcy5fb3BlblRvb2x0aXA7XG5cdFx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHRcdHRoaXMuX2FkZEZvY3VzTGlzdGVuZXJzKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRldmVudHMuYWRkID0gdGhpcy5fYWRkRm9jdXNMaXN0ZW5lcnM7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV2ZW50cy5hZGQgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHR9XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kpIHtcblx0XHRcdGV2ZW50cy5tb3VzZW1vdmUgPSB0aGlzLl9tb3ZlVG9vbHRpcDtcblx0XHR9XG5cdFx0dGhpc1tvbk9mZl0oZXZlbnRzKTtcblx0XHR0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCA9ICFyZW1vdmU7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXG5cdC8vIE9wZW5zIHRoZSBib3VuZCB0b29sdGlwIGF0IHRoZSBzcGVjaWZpZWQgYGxhdGxuZ2Agb3IgYXQgdGhlIGRlZmF1bHQgdG9vbHRpcCBhbmNob3IgaWYgbm8gYGxhdGxuZ2AgaXMgcGFzc2VkLlxuXHRvcGVuVG9vbHRpcDogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHRpZiAoISh0aGlzIGluc3RhbmNlb2YgRmVhdHVyZUdyb3VwKSkge1xuXHRcdFx0XHR0aGlzLl90b29sdGlwLl9zb3VyY2UgPSB0aGlzO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAuX3ByZXBhcmVPcGVuKGxhdGxuZykpIHtcblx0XHRcdFx0Ly8gb3BlbiB0aGUgdG9vbHRpcCBvbiB0aGUgbWFwXG5cdFx0XHRcdHRoaXMuX3Rvb2x0aXAub3Blbk9uKHRoaXMuX21hcCk7XG5cblx0XHRcdFx0aWYgKHRoaXMuZ2V0RWxlbWVudCkge1xuXHRcdFx0XHRcdHRoaXMuX3NldEFyaWFEZXNjcmliZWRCeU9uTGF5ZXIodGhpcyk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5lYWNoTGF5ZXIpIHtcblx0XHRcdFx0XHR0aGlzLmVhY2hMYXllcih0aGlzLl9zZXRBcmlhRGVzY3JpYmVkQnlPbkxheWVyLCB0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGNsb3NlVG9vbHRpcCgpOiB0aGlzXG5cdC8vIENsb3NlcyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlmIGl0IGlzIG9wZW4uXG5cdGNsb3NlVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcC5jbG9zZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBAbWV0aG9kIHRvZ2dsZVRvb2x0aXAoKTogdGhpc1xuXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXG5cdHRvZ2dsZVRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5fdG9vbHRpcC50b2dnbGUodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNUb29sdGlwT3BlbigpOiBib29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY3VycmVudGx5IG9wZW4uXG5cdGlzVG9vbHRpcE9wZW46IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcC5pc09wZW4oKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFRvb2x0aXBDb250ZW50KGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxUb29sdGlwKTogdGhpc1xuXHQvLyBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXG5cdHNldFRvb2x0aXBDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl90b29sdGlwLnNldENvbnRlbnQoY29udGVudCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0VG9vbHRpcCgpOiBUb29sdGlwXG5cdC8vIFJldHVybnMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0Z2V0VG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl90b29sdGlwO1xuXHR9LFxuXG5cdF9hZGRGb2N1c0xpc3RlbmVyczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLmdldEVsZW1lbnQpIHtcblx0XHRcdHRoaXMuX2FkZEZvY3VzTGlzdGVuZXJzT25MYXllcih0aGlzKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMuZWFjaExheWVyKSB7XG5cdFx0XHR0aGlzLmVhY2hMYXllcih0aGlzLl9hZGRGb2N1c0xpc3RlbmVyc09uTGF5ZXIsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkRm9jdXNMaXN0ZW5lcnNPbkxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgZWwgPSB0eXBlb2YgbGF5ZXIuZ2V0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiBsYXllci5nZXRFbGVtZW50KCk7XG5cdFx0aWYgKGVsKSB7XG5cdFx0XHREb21FdmVudC5vbihlbCwgJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLl90b29sdGlwLl9zb3VyY2UgPSBsYXllcjtcblx0XHRcdFx0dGhpcy5vcGVuVG9vbHRpcCgpO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0XHREb21FdmVudC5vbihlbCwgJ2JsdXInLCB0aGlzLmNsb3NlVG9vbHRpcCwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRBcmlhRGVzY3JpYmVkQnlPbkxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgZWwgPSB0eXBlb2YgbGF5ZXIuZ2V0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiBsYXllci5nZXRFbGVtZW50KCk7XG5cdFx0aWYgKGVsKSB7XG5cdFx0XHRlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknLCB0aGlzLl90b29sdGlwLl9jb250YWluZXIuaWQpO1xuXHRcdH1cblx0fSxcblxuXG5cdF9vcGVuVG9vbHRpcDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAgfHwgIXRoaXMuX21hcCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZSBtYXAgaXMgbW92aW5nLCB3ZSB3aWxsIHNob3cgdGhlIHRvb2x0aXAgYWZ0ZXIgaXQncyBkb25lLlxuXHRcdGlmICh0aGlzLl9tYXAuZHJhZ2dpbmcgJiYgdGhpcy5fbWFwLmRyYWdnaW5nLm1vdmluZygpICYmICF0aGlzLl9vcGVuT25jZUZsYWcpIHtcblx0XHRcdHRoaXMuX29wZW5PbmNlRmxhZyA9IHRydWU7XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHR0aGlzLl9tYXAub25jZSgnbW92ZWVuZCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhhdC5fb3Blbk9uY2VGbGFnID0gZmFsc2U7XG5cdFx0XHRcdHRoYXQuX29wZW5Ub29sdGlwKGUpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fdG9vbHRpcC5fc291cmNlID0gZS5sYXllciB8fCBlLnRhcmdldDtcblxuXHRcdHRoaXMub3BlblRvb2x0aXAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSA/IGUubGF0bG5nIDogdW5kZWZpbmVkKTtcblx0fSxcblxuXHRfbW92ZVRvb2x0aXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxhdGxuZyA9IGUubGF0bG5nLCBjb250YWluZXJQb2ludCwgbGF5ZXJQb2ludDtcblx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSAmJiBlLm9yaWdpbmFsRXZlbnQpIHtcblx0XHRcdGNvbnRhaW5lclBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUub3JpZ2luYWxFdmVudCk7XG5cdFx0XHRsYXllclBvaW50ID0gdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGNvbnRhaW5lclBvaW50KTtcblx0XHRcdGxhdGxuZyA9IHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcobGF5ZXJQb2ludCk7XG5cdFx0fVxuXHRcdHRoaXMuX3Rvb2x0aXAuc2V0TGF0TG5nKGxhdGxuZyk7XG5cdH1cbn0pO1xuIiwiaW1wb3J0IHtJY29ufSBmcm9tICcuL0ljb24nO1xuaW1wb3J0IHt0b1BvaW50IGFzIHBvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQge2VtcHR5fSBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgRGl2SWNvblxuICogQGFrYSBMLkRpdkljb25cbiAqIEBpbmhlcml0cyBJY29uXG4gKlxuICogUmVwcmVzZW50cyBhIGxpZ2h0d2VpZ2h0IGljb24gZm9yIG1hcmtlcnMgdGhhdCB1c2VzIGEgc2ltcGxlIGA8ZGl2PmBcbiAqIGVsZW1lbnQgaW5zdGVhZCBvZiBhbiBpbWFnZS4gSW5oZXJpdHMgZnJvbSBgSWNvbmAgYnV0IGlnbm9yZXMgdGhlIGBpY29uVXJsYCBhbmQgc2hhZG93IG9wdGlvbnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiB2YXIgbXlJY29uID0gTC5kaXZJY29uKHtjbGFzc05hbWU6ICdteS1kaXYtaWNvbid9KTtcbiAqIC8vIHlvdSBjYW4gc2V0IC5teS1kaXYtaWNvbiBzdHlsZXMgaW4gQ1NTXG4gKlxuICogTC5tYXJrZXIoWzUwLjUwNSwgMzAuNTddLCB7aWNvbjogbXlJY29ufSkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICpcbiAqIEJ5IGRlZmF1bHQsIGl0IGhhcyBhICdsZWFmbGV0LWRpdi1pY29uJyBDU1MgY2xhc3MgYW5kIGlzIHN0eWxlZCBhcyBhIGxpdHRsZSB3aGl0ZSBzcXVhcmUgd2l0aCBhIHNoYWRvdy5cbiAqL1xuXG5leHBvcnQgdmFyIERpdkljb24gPSBJY29uLmV4dGVuZCh7XG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAc2VjdGlvblxuXHRcdC8vIEBha2EgRGl2SWNvbiBvcHRpb25zXG5cdFx0aWNvblNpemU6IFsxMiwgMTJdLCAvLyBhbHNvIGNhbiBiZSBzZXQgdGhyb3VnaCBDU1NcblxuXHRcdC8vIGljb25BbmNob3I6IChQb2ludCksXG5cdFx0Ly8gcG9wdXBBbmNob3I6IChQb2ludCksXG5cblx0XHQvLyBAb3B0aW9uIGh0bWw6IFN0cmluZ3xIVE1MRWxlbWVudCA9ICcnXG5cdFx0Ly8gQ3VzdG9tIEhUTUwgY29kZSB0byBwdXQgaW5zaWRlIHRoZSBkaXYgZWxlbWVudCwgZW1wdHkgYnkgZGVmYXVsdC4gQWx0ZXJuYXRpdmVseSxcblx0XHQvLyBhbiBpbnN0YW5jZSBvZiBgSFRNTEVsZW1lbnRgLlxuXHRcdGh0bWw6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBiZ1BvczogUG9pbnQgPSBbMCwgMF1cblx0XHQvLyBPcHRpb25hbCByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgYmFja2dyb3VuZCwgaW4gcGl4ZWxzXG5cdFx0YmdQb3M6IG51bGwsXG5cblx0XHRjbGFzc05hbWU6ICdsZWFmbGV0LWRpdi1pY29uJ1xuXHR9LFxuXG5cdGNyZWF0ZUljb246IGZ1bmN0aW9uIChvbGRJY29uKSB7XG5cdFx0dmFyIGRpdiA9IChvbGRJY29uICYmIG9sZEljb24udGFnTmFtZSA9PT0gJ0RJVicpID8gb2xkSWNvbiA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKG9wdGlvbnMuaHRtbCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcblx0XHRcdGVtcHR5KGRpdik7XG5cdFx0XHRkaXYuYXBwZW5kQ2hpbGQob3B0aW9ucy5odG1sKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGl2LmlubmVySFRNTCA9IG9wdGlvbnMuaHRtbCAhPT0gZmFsc2UgPyBvcHRpb25zLmh0bWwgOiAnJztcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5iZ1Bvcykge1xuXHRcdFx0dmFyIGJnUG9zID0gcG9pbnQob3B0aW9ucy5iZ1Bvcyk7XG5cdFx0XHRkaXYuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gKC1iZ1Bvcy54KSArICdweCAnICsgKC1iZ1Bvcy55KSArICdweCc7XG5cdFx0fVxuXHRcdHRoaXMuX3NldEljb25TdHlsZXMoZGl2LCAnaWNvbicpO1xuXG5cdFx0cmV0dXJuIGRpdjtcblx0fSxcblxuXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuZGl2SWNvbihvcHRpb25zOiBEaXZJY29uIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgYERpdkljb25gIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gZGl2SWNvbihvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgRGl2SWNvbihvcHRpb25zKTtcbn1cbiIsImltcG9ydCB7SWNvbn0gZnJvbSAnLi9JY29uJztcbmV4cG9ydCB7aWNvbn0gZnJvbSAnLi9JY29uJztcbmltcG9ydCB7SWNvbkRlZmF1bHR9IGZyb20gJy4vSWNvbi5EZWZhdWx0Jztcbkljb24uRGVmYXVsdCA9IEljb25EZWZhdWx0O1xuZXhwb3J0IHtJY29ufTtcblxuZXhwb3J0IHtEaXZJY29uLCBkaXZJY29ufSBmcm9tICcuL0Rpdkljb24nO1xuZXhwb3J0IHtNYXJrZXIsIG1hcmtlcn0gZnJvbSAnLi9NYXJrZXInO1xuIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vTGF5ZXInO1xuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQge0xhdExuZ0JvdW5kcywgdG9MYXRMbmdCb3VuZHMgYXMgbGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcblxuLypcbiAqIEBjbGFzcyBHcmlkTGF5ZXJcbiAqIEBpbmhlcml0cyBMYXllclxuICogQGFrYSBMLkdyaWRMYXllclxuICpcbiAqIEdlbmVyaWMgY2xhc3MgZm9yIGhhbmRsaW5nIGEgdGlsZWQgZ3JpZCBvZiBIVE1MIGVsZW1lbnRzLiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgdGlsZSBsYXllcnMgYW5kIHJlcGxhY2VzIGBUaWxlTGF5ZXIuQ2FudmFzYC5cbiAqIEdyaWRMYXllciBjYW4gYmUgZXh0ZW5kZWQgdG8gY3JlYXRlIGEgdGlsZWQgZ3JpZCBvZiBIVE1MIGVsZW1lbnRzIGxpa2UgYDxjYW52YXM+YCwgYDxpbWc+YCBvciBgPGRpdj5gLiBHcmlkTGF5ZXIgd2lsbCBoYW5kbGUgY3JlYXRpbmcgYW5kIGFuaW1hdGluZyB0aGVzZSBET00gZWxlbWVudHMgZm9yIHlvdS5cbiAqXG4gKlxuICogQHNlY3Rpb24gU3luY2hyb25vdXMgdXNhZ2VcbiAqIEBleGFtcGxlXG4gKlxuICogVG8gY3JlYXRlIGEgY3VzdG9tIGxheWVyLCBleHRlbmQgR3JpZExheWVyIGFuZCBpbXBsZW1lbnQgdGhlIGBjcmVhdGVUaWxlKClgIG1ldGhvZCwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgYSBgUG9pbnRgIG9iamVjdCB3aXRoIHRoZSBgeGAsIGB5YCwgYW5kIGB6YCAoem9vbSBsZXZlbCkgY29vcmRpbmF0ZXMgdG8gZHJhdyB5b3VyIHRpbGUuXG4gKlxuICogYGBganNcbiAqIHZhciBDYW52YXNMYXllciA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG4gKiAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzKXtcbiAqICAgICAgICAgLy8gY3JlYXRlIGEgPGNhbnZhcz4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICogICAgICAgICB2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2NhbnZhcycsICdsZWFmbGV0LXRpbGUnKTtcbiAqXG4gKiAgICAgICAgIC8vIHNldHVwIHRpbGUgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAqICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gKiAgICAgICAgIHRpbGUud2lkdGggPSBzaXplLng7XG4gKiAgICAgICAgIHRpbGUuaGVpZ2h0ID0gc2l6ZS55O1xuICpcbiAqICAgICAgICAgLy8gZ2V0IGEgY2FudmFzIGNvbnRleHQgYW5kIGRyYXcgc29tZXRoaW5nIG9uIGl0IHVzaW5nIGNvb3Jkcy54LCBjb29yZHMueSBhbmQgY29vcmRzLnpcbiAqICAgICAgICAgdmFyIGN0eCA9IHRpbGUuZ2V0Q29udGV4dCgnMmQnKTtcbiAqXG4gKiAgICAgICAgIC8vIHJldHVybiB0aGUgdGlsZSBzbyBpdCBjYW4gYmUgcmVuZGVyZWQgb24gc2NyZWVuXG4gKiAgICAgICAgIHJldHVybiB0aWxlO1xuICogICAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHNlY3Rpb24gQXN5bmNocm9ub3VzIHVzYWdlXG4gKiBAZXhhbXBsZVxuICpcbiAqIFRpbGUgY3JlYXRpb24gY2FuIGFsc28gYmUgYXN5bmNocm9ub3VzLCB0aGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGEgdGhpcmQtcGFydHkgZHJhd2luZyBsaWJyYXJ5LiBPbmNlIHRoZSB0aWxlIGlzIGZpbmlzaGVkIGRyYXdpbmcgaXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgYGRvbmUoKWAgY2FsbGJhY2suXG4gKlxuICogYGBganNcbiAqIHZhciBDYW52YXNMYXllciA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG4gKiAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzLCBkb25lKXtcbiAqICAgICAgICAgdmFyIGVycm9yO1xuICpcbiAqICAgICAgICAgLy8gY3JlYXRlIGEgPGNhbnZhcz4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICogICAgICAgICB2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2NhbnZhcycsICdsZWFmbGV0LXRpbGUnKTtcbiAqXG4gKiAgICAgICAgIC8vIHNldHVwIHRpbGUgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAqICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gKiAgICAgICAgIHRpbGUud2lkdGggPSBzaXplLng7XG4gKiAgICAgICAgIHRpbGUuaGVpZ2h0ID0gc2l6ZS55O1xuICpcbiAqICAgICAgICAgLy8gZHJhdyBzb21ldGhpbmcgYXN5bmNocm9ub3VzbHkgYW5kIHBhc3MgdGhlIHRpbGUgdG8gdGhlIGRvbmUoKSBjYWxsYmFja1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgZG9uZShlcnJvciwgdGlsZSk7XG4gKiAgICAgICAgIH0sIDEwMDApO1xuICpcbiAqICAgICAgICAgcmV0dXJuIHRpbGU7XG4gKiAgICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAc2VjdGlvblxuICovXG5cblxuZXhwb3J0IHZhciBHcmlkTGF5ZXIgPSBMYXllci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgR3JpZExheWVyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gdGlsZVNpemU6IE51bWJlcnxQb2ludCA9IDI1NlxuXHRcdC8vIFdpZHRoIGFuZCBoZWlnaHQgb2YgdGlsZXMgaW4gdGhlIGdyaWQuIFVzZSBhIG51bWJlciBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBlcXVhbCwgb3IgYEwucG9pbnQod2lkdGgsIGhlaWdodClgIG90aGVyd2lzZS5cblx0XHR0aWxlU2l6ZTogMjU2LFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcblx0XHQvLyBPcGFjaXR5IG9mIHRoZSB0aWxlcy4gQ2FuIGJlIHVzZWQgaW4gdGhlIGBjcmVhdGVUaWxlKClgIGZ1bmN0aW9uLlxuXHRcdG9wYWNpdHk6IDEsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5JZGxlOiBCb29sZWFuID0gKGRlcGVuZHMpXG5cdFx0Ly8gTG9hZCBuZXcgdGlsZXMgb25seSB3aGVuIHBhbm5pbmcgZW5kcy5cblx0XHQvLyBgdHJ1ZWAgYnkgZGVmYXVsdCBvbiBtb2JpbGUgYnJvd3NlcnMsIGluIG9yZGVyIHRvIGF2b2lkIHRvbyBtYW55IHJlcXVlc3RzIGFuZCBrZWVwIHNtb290aCBuYXZpZ2F0aW9uLlxuXHRcdC8vIGBmYWxzZWAgb3RoZXJ3aXNlIGluIG9yZGVyIHRvIGRpc3BsYXkgbmV3IHRpbGVzIF9kdXJpbmdfIHBhbm5pbmcsIHNpbmNlIGl0IGlzIGVhc3kgdG8gcGFuIG91dHNpZGUgdGhlXG5cdFx0Ly8gW2BrZWVwQnVmZmVyYF0oI2dyaWRsYXllci1rZWVwYnVmZmVyKSBvcHRpb24gaW4gZGVza3RvcCBicm93c2Vycy5cblx0XHR1cGRhdGVXaGVuSWRsZTogQnJvd3Nlci5tb2JpbGUsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5ab29taW5nOiBCb29sZWFuID0gdHJ1ZVxuXHRcdC8vIEJ5IGRlZmF1bHQsIGEgc21vb3RoIHpvb20gYW5pbWF0aW9uIChkdXJpbmcgYSBbdG91Y2ggem9vbV0oI21hcC10b3VjaHpvb20pIG9yIGEgW2BmbHlUbygpYF0oI21hcC1mbHl0bykpIHdpbGwgdXBkYXRlIGdyaWQgbGF5ZXJzIGV2ZXJ5IGludGVnZXIgem9vbSBsZXZlbC4gU2V0dGluZyB0aGlzIG9wdGlvbiB0byBgZmFsc2VgIHdpbGwgdXBkYXRlIHRoZSBncmlkIGxheWVyIG9ubHkgd2hlbiB0aGUgc21vb3RoIGFuaW1hdGlvbiBlbmRzLlxuXHRcdHVwZGF0ZVdoZW5ab29taW5nOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVJbnRlcnZhbDogTnVtYmVyID0gMjAwXG5cdFx0Ly8gVGlsZXMgd2lsbCBub3QgdXBkYXRlIG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IGB1cGRhdGVJbnRlcnZhbGAgbWlsbGlzZWNvbmRzIHdoZW4gcGFubmluZy5cblx0XHR1cGRhdGVJbnRlcnZhbDogMjAwLFxuXG5cdFx0Ly8gQG9wdGlvbiB6SW5kZXg6IE51bWJlciA9IDFcblx0XHQvLyBUaGUgZXhwbGljaXQgekluZGV4IG9mIHRoZSB0aWxlIGxheWVyLlxuXHRcdHpJbmRleDogMSxcblxuXHRcdC8vIEBvcHRpb24gYm91bmRzOiBMYXRMbmdCb3VuZHMgPSB1bmRlZmluZWRcblx0XHQvLyBJZiBzZXQsIHRpbGVzIHdpbGwgb25seSBiZSBsb2FkZWQgaW5zaWRlIHRoZSBzZXQgYExhdExuZ0JvdW5kc2AuXG5cdFx0Ym91bmRzOiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAwXG5cdFx0Ly8gVGhlIG1pbmltdW0gem9vbSBsZXZlbCBkb3duIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXG5cdFx0bWluWm9vbTogMCxcblxuXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG5cdFx0Ly8gVGhlIG1heGltdW0gem9vbSBsZXZlbCB1cCB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxuXHRcdG1heFpvb206IHVuZGVmaW5lZCxcblxuXHRcdC8vIEBvcHRpb24gbWF4TmF0aXZlWm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG5cdFx0Ly8gTWF4aW11bSB6b29tIG51bWJlciB0aGUgdGlsZSBzb3VyY2UgaGFzIGF2YWlsYWJsZS4gSWYgaXQgaXMgc3BlY2lmaWVkLFxuXHRcdC8vIHRoZSB0aWxlcyBvbiBhbGwgem9vbSBsZXZlbHMgaGlnaGVyIHRoYW4gYG1heE5hdGl2ZVpvb21gIHdpbGwgYmUgbG9hZGVkXG5cdFx0Ly8gZnJvbSBgbWF4TmF0aXZlWm9vbWAgbGV2ZWwgYW5kIGF1dG8tc2NhbGVkLlxuXHRcdG1heE5hdGl2ZVpvb206IHVuZGVmaW5lZCxcblxuXHRcdC8vIEBvcHRpb24gbWluTmF0aXZlWm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG5cdFx0Ly8gTWluaW11bSB6b29tIG51bWJlciB0aGUgdGlsZSBzb3VyY2UgaGFzIGF2YWlsYWJsZS4gSWYgaXQgaXMgc3BlY2lmaWVkLFxuXHRcdC8vIHRoZSB0aWxlcyBvbiBhbGwgem9vbSBsZXZlbHMgbG93ZXIgdGhhbiBgbWluTmF0aXZlWm9vbWAgd2lsbCBiZSBsb2FkZWRcblx0XHQvLyBmcm9tIGBtaW5OYXRpdmVab29tYCBsZXZlbCBhbmQgYXV0by1zY2FsZWQuXG5cdFx0bWluTmF0aXZlWm9vbTogdW5kZWZpbmVkLFxuXG5cdFx0Ly8gQG9wdGlvbiBub1dyYXA6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIFdoZXRoZXIgdGhlIGxheWVyIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBhbnRpbWVyaWRpYW4uIElmIGB0cnVlYCwgdGhlXG5cdFx0Ly8gR3JpZExheWVyIHdpbGwgb25seSBiZSBkaXNwbGF5ZWQgb25jZSBhdCBsb3cgem9vbSBsZXZlbHMuIEhhcyBub1xuXHRcdC8vIGVmZmVjdCB3aGVuIHRoZSBbbWFwIENSU10oI21hcC1jcnMpIGRvZXNuJ3Qgd3JhcCBhcm91bmQuIENhbiBiZSB1c2VkXG5cdFx0Ly8gaW4gY29tYmluYXRpb24gd2l0aCBbYGJvdW5kc2BdKCNncmlkbGF5ZXItYm91bmRzKSB0byBwcmV2ZW50IHJlcXVlc3Rpbmdcblx0XHQvLyB0aWxlcyBvdXRzaWRlIHRoZSBDUlMgbGltaXRzLlxuXHRcdG5vV3JhcDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICd0aWxlUGFuZSdcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBncmlkIGxheWVyIHdpbGwgYmUgYWRkZWQuXG5cdFx0cGFuZTogJ3RpbGVQYW5lJyxcblxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xuXHRcdC8vIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSB0aWxlIGxheWVyLiBFbXB0eSBieSBkZWZhdWx0LlxuXHRcdGNsYXNzTmFtZTogJycsXG5cblx0XHQvLyBAb3B0aW9uIGtlZXBCdWZmZXI6IE51bWJlciA9IDJcblx0XHQvLyBXaGVuIHBhbm5pbmcgdGhlIG1hcCwga2VlcCB0aGlzIG1hbnkgcm93cyBhbmQgY29sdW1ucyBvZiB0aWxlcyBiZWZvcmUgdW5sb2FkaW5nIHRoZW0uXG5cdFx0a2VlcEJ1ZmZlcjogMlxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5faW5pdENvbnRhaW5lcigpO1xuXG5cdFx0dGhpcy5fbGV2ZWxzID0ge307XG5cdFx0dGhpcy5fdGlsZXMgPSB7fTtcblxuXHRcdHRoaXMuX3Jlc2V0VmlldygpOyAvLyBpbXBsaWNpdCBfdXBkYXRlKCkgY2FsbFxuXHR9LFxuXG5cdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5fYWRkWm9vbUxpbWl0KHRoaXMpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHRcdG1hcC5fcmVtb3ZlWm9vbUxpbWl0KHRoaXMpO1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IG51bGw7XG5cdFx0dGhpcy5fdGlsZVpvb20gPSB1bmRlZmluZWQ7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQ6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIHRpbGUgbGF5ZXJzLlxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHREb21VdGlsLnRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcblx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5tYXgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgdGlsZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCB0aWxlIGxheWVycy5cblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHREb21VdGlsLnRvQmFjayh0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1pbik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgW29wYWNpdHldKCNncmlkbGF5ZXItb3BhY2l0eSkgb2YgdGhlIGdyaWQgbGF5ZXIuXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuXHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2dyaWRsYXllci16aW5kZXgpIG9mIHRoZSBncmlkIGxheWVyLlxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gekluZGV4O1xuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc0xvYWRpbmc6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IHRpbGUgaW4gdGhlIGdyaWQgbGF5ZXIgaGFzIG5vdCBmaW5pc2hlZCBsb2FkaW5nLlxuXHRpc0xvYWRpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbG9hZGluZztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlZHJhdzogdGhpc1xuXHQvLyBDYXVzZXMgdGhlIGxheWVyIHRvIGNsZWFyIGFsbCB0aGUgdGlsZXMgYW5kIHJlcXVlc3QgdGhlbSBhZ2Fpbi5cblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRcdHZhciB0aWxlWm9vbSA9IHRoaXMuX2NsYW1wWm9vbSh0aGlzLl9tYXAuZ2V0Wm9vbSgpKTtcblx0XHRcdGlmICh0aWxlWm9vbSAhPT0gdGhpcy5fdGlsZVpvb20pIHtcblx0XHRcdFx0dGhpcy5fdGlsZVpvb20gPSB0aWxlWm9vbTtcblx0XHRcdFx0dGhpcy5fdXBkYXRlTGV2ZWxzKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IHtcblx0XHRcdHZpZXdwcmVyZXNldDogdGhpcy5faW52YWxpZGF0ZUFsbCxcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRWaWV3LFxuXHRcdFx0em9vbTogdGhpcy5fcmVzZXRWaWV3LFxuXHRcdFx0bW92ZWVuZDogdGhpcy5fb25Nb3ZlRW5kXG5cdFx0fTtcblxuXHRcdGlmICghdGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlKSB7XG5cdFx0XHQvLyB1cGRhdGUgdGlsZXMgb24gbW92ZSwgYnV0IG5vdCBtb3JlIG9mdGVuIHRoYW4gb25jZSBwZXIgZ2l2ZW4gaW50ZXJ2YWxcblx0XHRcdGlmICghdGhpcy5fb25Nb3ZlKSB7XG5cdFx0XHRcdHRoaXMuX29uTW92ZSA9IFV0aWwudGhyb3R0bGUodGhpcy5fb25Nb3ZlRW5kLCB0aGlzLm9wdGlvbnMudXBkYXRlSW50ZXJ2YWwsIHRoaXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRldmVudHMubW92ZSA9IHRoaXMuX29uTW92ZTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG5cdC8vIExheWVycyBleHRlbmRpbmcgYEdyaWRMYXllcmAgc2hhbGwgcmVpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2QuXG5cdC8vIEBtZXRob2QgY3JlYXRlVGlsZShjb29yZHM6IE9iamVjdCwgZG9uZT86IEZ1bmN0aW9uKTogSFRNTEVsZW1lbnRcblx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgbXVzdCBiZSBvdmVycmlkZGVuIGJ5IGNsYXNzZXMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgLlxuXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGBjb29yZHNgLiBJZiB0aGUgYGRvbmVgIGNhbGxiYWNrXG5cdC8vIGlzIHNwZWNpZmllZCwgaXQgbXVzdCBiZSBjYWxsZWQgd2hlbiB0aGUgdGlsZSBoYXMgZmluaXNoZWQgbG9hZGluZyBhbmQgZHJhd2luZy5cblx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0fSxcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAbWV0aG9kIGdldFRpbGVTaXplOiBQb2ludFxuXHQvLyBOb3JtYWxpemVzIHRoZSBbdGlsZVNpemUgb3B0aW9uXSgjZ3JpZGxheWVyLXRpbGVzaXplKSBpbnRvIGEgcG9pbnQuIFVzZWQgYnkgdGhlIGBjcmVhdGVUaWxlKClgIG1ldGhvZC5cblx0Z2V0VGlsZVNpemU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcyA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcblx0XHRyZXR1cm4gcyBpbnN0YW5jZW9mIFBvaW50ID8gcyA6IG5ldyBQb2ludChzLCBzKTtcblx0fSxcblxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRBdXRvWkluZGV4OiBmdW5jdGlvbiAoY29tcGFyZSkge1xuXHRcdC8vIGdvIHRocm91Z2ggYWxsIG90aGVyIGxheWVycyBvZiB0aGUgc2FtZSBwYW5lLCBzZXQgekluZGV4IHRvIG1heCArIDEgKGZyb250KSBvciBtaW4gLSAxIChiYWNrKVxuXG5cdFx0dmFyIGxheWVycyA9IHRoaXMuZ2V0UGFuZSgpLmNoaWxkcmVuLFxuXHRcdCAgICBlZGdlWkluZGV4ID0gLWNvbXBhcmUoLUluZmluaXR5LCBJbmZpbml0eSk7IC8vIC1JbmZpbml0eSBmb3IgbWF4LCBJbmZpbml0eSBmb3IgbWluXG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aCwgekluZGV4OyBpIDwgbGVuOyBpKyspIHtcblxuXHRcdFx0ekluZGV4ID0gbGF5ZXJzW2ldLnN0eWxlLnpJbmRleDtcblxuXHRcdFx0aWYgKGxheWVyc1tpXSAhPT0gdGhpcy5fY29udGFpbmVyICYmIHpJbmRleCkge1xuXHRcdFx0XHRlZGdlWkluZGV4ID0gY29tcGFyZShlZGdlWkluZGV4LCArekluZGV4KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNGaW5pdGUoZWRnZVpJbmRleCkpIHtcblx0XHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSBlZGdlWkluZGV4ICsgY29tcGFyZSgtMSwgMSk7XG5cdFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdC8vIElFIGRvZXNuJ3QgaW5oZXJpdCBmaWx0ZXIgb3BhY2l0eSBwcm9wZXJseSwgc28gd2UncmUgZm9yY2VkIHRvIHNldCBpdCBvbiB0aWxlc1xuXHRcdGlmIChCcm93c2VyLmllbHQ5KSB7IHJldHVybjsgfVxuXG5cdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXG5cdFx0dmFyIG5vdyA9ICtuZXcgRGF0ZSgpLFxuXHRcdCAgICBuZXh0RnJhbWUgPSBmYWxzZSxcblx0XHQgICAgd2lsbFBydW5lID0gZmFsc2U7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRcdGlmICghdGlsZS5jdXJyZW50IHx8ICF0aWxlLmxvYWRlZCkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHR2YXIgZmFkZSA9IE1hdGgubWluKDEsIChub3cgLSB0aWxlLmxvYWRlZCkgLyAyMDApO1xuXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGlsZS5lbCwgZmFkZSk7XG5cdFx0XHRpZiAoZmFkZSA8IDEpIHtcblx0XHRcdFx0bmV4dEZyYW1lID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHRcdHdpbGxQcnVuZSA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fb25PcGFxdWVUaWxlKHRpbGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRpbGUuYWN0aXZlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAod2lsbFBydW5lICYmICF0aGlzLl9ub1BydW5lKSB7IHRoaXMuX3BydW5lVGlsZXMoKTsgfVxuXG5cdFx0aWYgKG5leHRGcmFtZSkge1xuXHRcdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcblx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVPcGFjaXR5LCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X29uT3BhcXVlVGlsZTogVXRpbC5mYWxzZUZuLFxuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1sYXllciAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHR9XG5cblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVMZXZlbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXG5cdFx0ICAgIG1heFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbTtcblxuXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG5cdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdHogPSBOdW1iZXIoeik7XG5cdFx0XHRpZiAodGhpcy5fbGV2ZWxzW3pdLmVsLmNoaWxkcmVuLmxlbmd0aCB8fCB6ID09PSB6b29tKSB7XG5cdFx0XHRcdHRoaXMuX2xldmVsc1t6XS5lbC5zdHlsZS56SW5kZXggPSBtYXhab29tIC0gTWF0aC5hYnMoem9vbSAtIHopO1xuXHRcdFx0XHR0aGlzLl9vblVwZGF0ZUxldmVsKHopO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fbGV2ZWxzW3pdLmVsKTtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZXNBdFpvb20oeik7XG5cdFx0XHRcdHRoaXMuX29uUmVtb3ZlTGV2ZWwoeik7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9sZXZlbHNbel07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW3pvb21dLFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAoIWxldmVsKSB7XG5cdFx0XHRsZXZlbCA9IHRoaXMuX2xldmVsc1t6b29tXSA9IHt9O1xuXG5cdFx0XHRsZXZlbC5lbCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC10aWxlLWNvbnRhaW5lciBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnLCB0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0bGV2ZWwuZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbTtcblxuXHRcdFx0bGV2ZWwub3JpZ2luID0gbWFwLnByb2plY3QobWFwLnVucHJvamVjdChtYXAuZ2V0UGl4ZWxPcmlnaW4oKSksIHpvb20pLnJvdW5kKCk7XG5cdFx0XHRsZXZlbC56b29tID0gem9vbTtcblxuXHRcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybShsZXZlbCwgbWFwLmdldENlbnRlcigpLCBtYXAuZ2V0Wm9vbSgpKTtcblxuXHRcdFx0Ly8gZm9yY2UgdGhlIGJyb3dzZXIgdG8gY29uc2lkZXIgdGhlIG5ld2x5IGFkZGVkIGVsZW1lbnQgZm9yIHRyYW5zaXRpb25cblx0XHRcdFV0aWwuZmFsc2VGbihsZXZlbC5lbC5vZmZzZXRXaWR0aCk7XG5cblx0XHRcdHRoaXMuX29uQ3JlYXRlTGV2ZWwobGV2ZWwpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2xldmVsID0gbGV2ZWw7XG5cblx0XHRyZXR1cm4gbGV2ZWw7XG5cdH0sXG5cblx0X29uVXBkYXRlTGV2ZWw6IFV0aWwuZmFsc2VGbixcblxuXHRfb25SZW1vdmVMZXZlbDogVXRpbC5mYWxzZUZuLFxuXG5cdF9vbkNyZWF0ZUxldmVsOiBVdGlsLmZhbHNlRm4sXG5cblx0X3BydW5lVGlsZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBrZXksIHRpbGU7XG5cblx0XHR2YXIgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG5cdFx0aWYgKHpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSB8fFxuXHRcdFx0em9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRcdHRpbGUucmV0YWluID0gdGlsZS5jdXJyZW50O1xuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRcdGlmICh0aWxlLmN1cnJlbnQgJiYgIXRpbGUuYWN0aXZlKSB7XG5cdFx0XHRcdHZhciBjb29yZHMgPSB0aWxlLmNvb3Jkcztcblx0XHRcdFx0aWYgKCF0aGlzLl9yZXRhaW5QYXJlbnQoY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLnogLSA1KSkge1xuXHRcdFx0XHRcdHRoaXMuX3JldGFpbkNoaWxkcmVuKGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy56ICsgMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0aWYgKCF0aGlzLl90aWxlc1trZXldLnJldGFpbikge1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVUaWxlc0F0Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICh0aGlzLl90aWxlc1trZXldLmNvb3Jkcy56ICE9PSB6b29tKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlQWxsVGlsZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHR9XG5cdH0sXG5cblx0X2ludmFsaWRhdGVBbGw6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciB6IGluIHRoaXMuX2xldmVscykge1xuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fbGV2ZWxzW3pdLmVsKTtcblx0XHRcdHRoaXMuX29uUmVtb3ZlTGV2ZWwoTnVtYmVyKHopKTtcblx0XHRcdGRlbGV0ZSB0aGlzLl9sZXZlbHNbel07XG5cdFx0fVxuXHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cblx0XHR0aGlzLl90aWxlWm9vbSA9IHVuZGVmaW5lZDtcblx0fSxcblxuXHRfcmV0YWluUGFyZW50OiBmdW5jdGlvbiAoeCwgeSwgeiwgbWluWm9vbSkge1xuXHRcdHZhciB4MiA9IE1hdGguZmxvb3IoeCAvIDIpLFxuXHRcdCAgICB5MiA9IE1hdGguZmxvb3IoeSAvIDIpLFxuXHRcdCAgICB6MiA9IHogLSAxLFxuXHRcdCAgICBjb29yZHMyID0gbmV3IFBvaW50KCt4MiwgK3kyKTtcblx0XHRjb29yZHMyLnogPSArejI7XG5cblx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkczIpLFxuXHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdGlmICh0aWxlICYmIHRpbGUuYWN0aXZlKSB7XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH0gZWxzZSBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCkge1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICh6MiA+IG1pblpvb20pIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZXRhaW5QYXJlbnQoeDIsIHkyLCB6MiwgbWluWm9vbSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9yZXRhaW5DaGlsZHJlbjogZnVuY3Rpb24gKHgsIHksIHosIG1heFpvb20pIHtcblxuXHRcdGZvciAodmFyIGkgPSAyICogeDsgaSA8IDIgKiB4ICsgMjsgaSsrKSB7XG5cdFx0XHRmb3IgKHZhciBqID0gMiAqIHk7IGogPCAyICogeSArIDI7IGorKykge1xuXG5cdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgUG9pbnQoaSwgaik7XG5cdFx0XHRcdGNvb3Jkcy56ID0geiArIDE7XG5cblx0XHRcdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpLFxuXHRcdFx0XHQgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cblx0XHRcdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcblx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG5cdFx0XHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHogKyAxIDwgbWF4Wm9vbSkge1xuXHRcdFx0XHRcdHRoaXMuX3JldGFpbkNoaWxkcmVuKGksIGosIHogKyAxLCBtYXhab29tKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVzZXRWaWV3OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBhbmltYXRpbmcgPSBlICYmIChlLnBpbmNoIHx8IGUuZmx5VG8pO1xuXHRcdHRoaXMuX3NldFZpZXcodGhpcy5fbWFwLmdldENlbnRlcigpLCB0aGlzLl9tYXAuZ2V0Wm9vbSgpLCBhbmltYXRpbmcsIGFuaW1hdGluZyk7XG5cdH0sXG5cblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xuXHRcdHRoaXMuX3NldFZpZXcoZS5jZW50ZXIsIGUuem9vbSwgdHJ1ZSwgZS5ub1VwZGF0ZSk7XG5cdH0sXG5cblx0X2NsYW1wWm9vbTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGlmICh1bmRlZmluZWQgIT09IG9wdGlvbnMubWluTmF0aXZlWm9vbSAmJiB6b29tIDwgb3B0aW9ucy5taW5OYXRpdmVab29tKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucy5taW5OYXRpdmVab29tO1xuXHRcdH1cblxuXHRcdGlmICh1bmRlZmluZWQgIT09IG9wdGlvbnMubWF4TmF0aXZlWm9vbSAmJiBvcHRpb25zLm1heE5hdGl2ZVpvb20gPCB6b29tKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucy5tYXhOYXRpdmVab29tO1xuXHRcdH1cblxuXHRcdHJldHVybiB6b29tO1xuXHR9LFxuXG5cdF9zZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBub1BydW5lLCBub1VwZGF0ZSkge1xuXHRcdHZhciB0aWxlWm9vbSA9IE1hdGgucm91bmQoem9vbSk7XG5cdFx0aWYgKCh0aGlzLm9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkICYmIHRpbGVab29tID4gdGhpcy5vcHRpb25zLm1heFpvb20pIHx8XG5cdFx0ICAgICh0aGlzLm9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkICYmIHRpbGVab29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pKSB7XG5cdFx0XHR0aWxlWm9vbSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGlsZVpvb20gPSB0aGlzLl9jbGFtcFpvb20odGlsZVpvb20pO1xuXHRcdH1cblxuXHRcdHZhciB0aWxlWm9vbUNoYW5nZWQgPSB0aGlzLm9wdGlvbnMudXBkYXRlV2hlblpvb21pbmcgJiYgKHRpbGVab29tICE9PSB0aGlzLl90aWxlWm9vbSk7XG5cblx0XHRpZiAoIW5vVXBkYXRlIHx8IHRpbGVab29tQ2hhbmdlZCkge1xuXG5cdFx0XHR0aGlzLl90aWxlWm9vbSA9IHRpbGVab29tO1xuXG5cdFx0XHRpZiAodGhpcy5fYWJvcnRMb2FkaW5nKSB7XG5cdFx0XHRcdHRoaXMuX2Fib3J0TG9hZGluZygpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl91cGRhdGVMZXZlbHMoKTtcblx0XHRcdHRoaXMuX3Jlc2V0R3JpZCgpO1xuXG5cdFx0XHRpZiAodGlsZVpvb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLl91cGRhdGUoY2VudGVyKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFub1BydW5lKSB7XG5cdFx0XHRcdHRoaXMuX3BydW5lVGlsZXMoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRmxhZyB0byBwcmV2ZW50IF91cGRhdGVPcGFjaXR5IGZyb20gcHJ1bmluZyB0aWxlcyBkdXJpbmdcblx0XHRcdC8vIGEgem9vbSBhbmltIG9yIGEgcGluY2ggZ2VzdHVyZVxuXHRcdFx0dGhpcy5fbm9QcnVuZSA9ICEhbm9QcnVuZTtcblx0XHR9XG5cblx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtcyhjZW50ZXIsIHpvb20pO1xuXHR9LFxuXG5cdF9zZXRab29tVHJhbnNmb3JtczogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtKHRoaXMuX2xldmVsc1tpXSwgY2VudGVyLCB6b29tKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldFpvb21UcmFuc2Zvcm06IGZ1bmN0aW9uIChsZXZlbCwgY2VudGVyLCB6b29tKSB7XG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh6b29tLCBsZXZlbC56b29tKSxcblx0XHQgICAgdHJhbnNsYXRlID0gbGV2ZWwub3JpZ2luLm11bHRpcGx5Qnkoc2NhbGUpXG5cdFx0ICAgICAgICAuc3VidHJhY3QodGhpcy5fbWFwLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pKS5yb3VuZCgpO1xuXG5cdFx0aWYgKEJyb3dzZXIuYW55M2QpIHtcblx0XHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKGxldmVsLmVsLCB0cmFuc2xhdGUsIHNjYWxlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihsZXZlbC5lbCwgdHJhbnNsYXRlKTtcblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0R3JpZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycyxcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLl90aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKSxcblx0XHQgICAgdGlsZVpvb20gPSB0aGlzLl90aWxlWm9vbTtcblxuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0UGl4ZWxXb3JsZEJvdW5kcyh0aGlzLl90aWxlWm9vbSk7XG5cdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0dGhpcy5fZ2xvYmFsVGlsZVJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShib3VuZHMpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3dyYXBYID0gY3JzLndyYXBMbmcgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xuXHRcdFx0TWF0aC5mbG9vcihtYXAucHJvamVjdChbMCwgY3JzLndyYXBMbmdbMF1dLCB0aWxlWm9vbSkueCAvIHRpbGVTaXplLngpLFxuXHRcdFx0TWF0aC5jZWlsKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1sxXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueSlcblx0XHRdO1xuXHRcdHRoaXMuX3dyYXBZID0gY3JzLndyYXBMYXQgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xuXHRcdFx0TWF0aC5mbG9vcihtYXAucHJvamVjdChbY3JzLndyYXBMYXRbMF0sIDBdLCB0aWxlWm9vbSkueSAvIHRpbGVTaXplLngpLFxuXHRcdFx0TWF0aC5jZWlsKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFsxXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueSlcblx0XHRdO1xuXHR9LFxuXG5cdF9vbk1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfZ2V0VGlsZWRQaXhlbEJvdW5kczogZnVuY3Rpb24gKGNlbnRlcikge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG1hcFpvb20gPSBtYXAuX2FuaW1hdGluZ1pvb20gPyBNYXRoLm1heChtYXAuX2FuaW1hdGVUb1pvb20sIG1hcC5nZXRab29tKCkpIDogbWFwLmdldFpvb20oKSxcblx0XHQgICAgc2NhbGUgPSBtYXAuZ2V0Wm9vbVNjYWxlKG1hcFpvb20sIHRoaXMuX3RpbGVab29tKSxcblx0XHQgICAgcGl4ZWxDZW50ZXIgPSBtYXAucHJvamVjdChjZW50ZXIsIHRoaXMuX3RpbGVab29tKS5mbG9vcigpLFxuXHRcdCAgICBoYWxmU2l6ZSA9IG1hcC5nZXRTaXplKCkuZGl2aWRlQnkoc2NhbGUgKiAyKTtcblxuXHRcdHJldHVybiBuZXcgQm91bmRzKHBpeGVsQ2VudGVyLnN1YnRyYWN0KGhhbGZTaXplKSwgcGl4ZWxDZW50ZXIuYWRkKGhhbGZTaXplKSk7XG5cdH0sXG5cblx0Ly8gUHJpdmF0ZSBtZXRob2QgdG8gbG9hZCB0aWxlcyBpbiB0aGUgZ3JpZCdzIGFjdGl2ZSB6b29tIGxldmVsIGFjY29yZGluZyB0byBtYXAgYm91bmRzXG5cdF91cGRhdGU6IGZ1bmN0aW9uIChjZW50ZXIpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXHRcdGlmICghbWFwKSB7IHJldHVybjsgfVxuXHRcdHZhciB6b29tID0gdGhpcy5fY2xhbXBab29tKG1hcC5nZXRab29tKCkpO1xuXG5cdFx0aWYgKGNlbnRlciA9PT0gdW5kZWZpbmVkKSB7IGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTsgfVxuXHRcdGlmICh0aGlzLl90aWxlWm9vbSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybjsgfVx0Ly8gaWYgb3V0IG9mIG1pbnpvb20vbWF4em9vbVxuXG5cdFx0dmFyIHBpeGVsQm91bmRzID0gdGhpcy5fZ2V0VGlsZWRQaXhlbEJvdW5kcyhjZW50ZXIpLFxuXHRcdCAgICB0aWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKHBpeGVsQm91bmRzKSxcblx0XHQgICAgdGlsZUNlbnRlciA9IHRpbGVSYW5nZS5nZXRDZW50ZXIoKSxcblx0XHQgICAgcXVldWUgPSBbXSxcblx0XHQgICAgbWFyZ2luID0gdGhpcy5vcHRpb25zLmtlZXBCdWZmZXIsXG5cdFx0ICAgIG5vUHJ1bmVSYW5nZSA9IG5ldyBCb3VuZHModGlsZVJhbmdlLmdldEJvdHRvbUxlZnQoKS5zdWJ0cmFjdChbbWFyZ2luLCAtbWFyZ2luXSksXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZVJhbmdlLmdldFRvcFJpZ2h0KCkuYWRkKFttYXJnaW4sIC1tYXJnaW5dKSk7XG5cblx0XHQvLyBTYW5pdHkgY2hlY2s6IHBhbmljIGlmIHRoZSB0aWxlIHJhbmdlIGNvbnRhaW5zIEluZmluaXR5IHNvbWV3aGVyZS5cblx0XHRpZiAoIShpc0Zpbml0ZSh0aWxlUmFuZ2UubWluLngpICYmXG5cdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1pbi55KSAmJlxuXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5tYXgueCkgJiZcblx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWF4LnkpKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBsb2FkIGFuIGluZmluaXRlIG51bWJlciBvZiB0aWxlcycpOyB9XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHZhciBjID0gdGhpcy5fdGlsZXNba2V5XS5jb29yZHM7XG5cdFx0XHRpZiAoYy56ICE9PSB0aGlzLl90aWxlWm9vbSB8fCAhbm9QcnVuZVJhbmdlLmNvbnRhaW5zKG5ldyBQb2ludChjLngsIGMueSkpKSB7XG5cdFx0XHRcdHRoaXMuX3RpbGVzW2tleV0uY3VycmVudCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIF91cGRhdGUganVzdCBsb2FkcyBtb3JlIHRpbGVzLiBJZiB0aGUgdGlsZSB6b29tIGxldmVsIGRpZmZlcnMgdG9vIG11Y2hcblx0XHQvLyBmcm9tIHRoZSBtYXAncywgbGV0IF9zZXRWaWV3IHJlc2V0IGxldmVscyBhbmQgcHJ1bmUgb2xkIHRpbGVzLlxuXHRcdGlmIChNYXRoLmFicyh6b29tIC0gdGhpcy5fdGlsZVpvb20pID4gMSkgeyB0aGlzLl9zZXRWaWV3KGNlbnRlciwgem9vbSk7IHJldHVybjsgfVxuXG5cdFx0Ly8gY3JlYXRlIGEgcXVldWUgb2YgY29vcmRpbmF0ZXMgdG8gbG9hZCB0aWxlcyBmcm9tXG5cdFx0Zm9yICh2YXIgaiA9IHRpbGVSYW5nZS5taW4ueTsgaiA8PSB0aWxlUmFuZ2UubWF4Lnk7IGorKykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IHRpbGVSYW5nZS5taW4ueDsgaSA8PSB0aWxlUmFuZ2UubWF4Lng7IGkrKykge1xuXHRcdFx0XHR2YXIgY29vcmRzID0gbmV3IFBvaW50KGksIGopO1xuXHRcdFx0XHRjb29yZHMueiA9IHRoaXMuX3RpbGVab29tO1xuXG5cdFx0XHRcdGlmICghdGhpcy5faXNWYWxpZFRpbGUoY29vcmRzKSkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNbdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyldO1xuXHRcdFx0XHRpZiAodGlsZSkge1xuXHRcdFx0XHRcdHRpbGUuY3VycmVudCA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaChjb29yZHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gc29ydCB0aWxlIHF1ZXVlIHRvIGxvYWQgdGlsZXMgaW4gb3JkZXIgb2YgdGhlaXIgZGlzdGFuY2UgdG8gY2VudGVyXG5cdFx0cXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0cmV0dXJuIGEuZGlzdGFuY2VUbyh0aWxlQ2VudGVyKSAtIGIuZGlzdGFuY2VUbyh0aWxlQ2VudGVyKTtcblx0XHR9KTtcblxuXHRcdGlmIChxdWV1ZS5sZW5ndGggIT09IDApIHtcblx0XHRcdC8vIGlmIGl0J3MgdGhlIGZpcnN0IGJhdGNoIG9mIHRpbGVzIHRvIGxvYWRcblx0XHRcdGlmICghdGhpcy5fbG9hZGluZykge1xuXHRcdFx0XHR0aGlzLl9sb2FkaW5nID0gdHJ1ZTtcblx0XHRcdFx0Ly8gQGV2ZW50IGxvYWRpbmc6IEV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgc3RhcnRzIGxvYWRpbmcgdGlsZXMuXG5cdFx0XHRcdHRoaXMuZmlyZSgnbG9hZGluZycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjcmVhdGUgRE9NIGZyYWdtZW50IHRvIGFwcGVuZCB0aWxlcyBpbiBvbmUgYmF0Y2hcblx0XHRcdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX2FkZFRpbGUocXVldWVbaV0sIGZyYWdtZW50KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbGV2ZWwuZWwuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuXHRcdH1cblx0fSxcblxuXHRfaXNWYWxpZFRpbGU6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgY3JzID0gdGhpcy5fbWFwLm9wdGlvbnMuY3JzO1xuXG5cdFx0aWYgKCFjcnMuaW5maW5pdGUpIHtcblx0XHRcdC8vIGRvbid0IGxvYWQgdGlsZSBpZiBpdCdzIG91dCBvZiBib3VuZHMgYW5kIG5vdCB3cmFwcGVkXG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fZ2xvYmFsVGlsZVJhbmdlO1xuXHRcdFx0aWYgKCghY3JzLndyYXBMbmcgJiYgKGNvb3Jkcy54IDwgYm91bmRzLm1pbi54IHx8IGNvb3Jkcy54ID4gYm91bmRzLm1heC54KSkgfHxcblx0XHRcdCAgICAoIWNycy53cmFwTGF0ICYmIChjb29yZHMueSA8IGJvdW5kcy5taW4ueSB8fCBjb29yZHMueSA+IGJvdW5kcy5tYXgueSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblxuXHRcdGlmICghdGhpcy5vcHRpb25zLmJvdW5kcykgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IHRoZSBib3VuZHMgaW4gb3B0aW9uc1xuXHRcdHZhciB0aWxlQm91bmRzID0gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKGNvb3Jkcyk7XG5cdFx0cmV0dXJuIGxhdExuZ0JvdW5kcyh0aGlzLm9wdGlvbnMuYm91bmRzKS5vdmVybGFwcyh0aWxlQm91bmRzKTtcblx0fSxcblxuXHRfa2V5VG9Cb3VuZHM6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRyZXR1cm4gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKHRoaXMuX2tleVRvVGlsZUNvb3JkcyhrZXkpKTtcblx0fSxcblxuXHRfdGlsZUNvb3Jkc1RvTndTZTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuXHRcdCAgICBud1BvaW50ID0gY29vcmRzLnNjYWxlQnkodGlsZVNpemUpLFxuXHRcdCAgICBzZVBvaW50ID0gbndQb2ludC5hZGQodGlsZVNpemUpLFxuXHRcdCAgICBudyA9IG1hcC51bnByb2plY3QobndQb2ludCwgY29vcmRzLnopLFxuXHRcdCAgICBzZSA9IG1hcC51bnByb2plY3Qoc2VQb2ludCwgY29vcmRzLnopO1xuXHRcdHJldHVybiBbbncsIHNlXTtcblx0fSxcblxuXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGl0cyBnZW9ncmFwaGljYWwgYm91bmRzXG5cdF90aWxlQ29vcmRzVG9Cb3VuZHM6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgYnAgPSB0aGlzLl90aWxlQ29vcmRzVG9Od1NlKGNvb3JkcyksXG5cdFx0ICAgIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoYnBbMF0sIGJwWzFdKTtcblxuXHRcdGlmICghdGhpcy5vcHRpb25zLm5vV3JhcCkge1xuXHRcdFx0Ym91bmRzID0gdGhpcy5fbWFwLndyYXBMYXRMbmdCb3VuZHMoYm91bmRzKTtcblx0XHR9XG5cdFx0cmV0dXJuIGJvdW5kcztcblx0fSxcblx0Ly8gY29udmVydHMgdGlsZSBjb29yZGluYXRlcyB0byBrZXkgZm9yIHRoZSB0aWxlIGNhY2hlXG5cdF90aWxlQ29vcmRzVG9LZXk6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHRyZXR1cm4gY29vcmRzLnggKyAnOicgKyBjb29yZHMueSArICc6JyArIGNvb3Jkcy56O1xuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIHRpbGUgY2FjaGUga2V5IHRvIGNvb3JkaW5hdGVzXG5cdF9rZXlUb1RpbGVDb29yZHM6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgayA9IGtleS5zcGxpdCgnOicpLFxuXHRcdCAgICBjb29yZHMgPSBuZXcgUG9pbnQoK2tbMF0sICtrWzFdKTtcblx0XHRjb29yZHMueiA9ICtrWzJdO1xuXHRcdHJldHVybiBjb29yZHM7XG5cdH0sXG5cblx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0aWYgKCF0aWxlKSB7IHJldHVybjsgfVxuXG5cdFx0RG9tVXRpbC5yZW1vdmUodGlsZS5lbCk7XG5cblx0XHRkZWxldGUgdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdC8vIEBldmVudCB0aWxldW5sb2FkOiBUaWxlRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZW1vdmVkIChlLmcuIHdoZW4gYSB0aWxlIGdvZXMgb2ZmIHRoZSBzY3JlZW4pLlxuXHRcdHRoaXMuZmlyZSgndGlsZXVubG9hZCcsIHtcblx0XHRcdHRpbGU6IHRpbGUuZWwsXG5cdFx0XHRjb29yZHM6IHRoaXMuX2tleVRvVGlsZUNvb3JkcyhrZXkpXG5cdFx0fSk7XG5cdH0sXG5cblx0X2luaXRUaWxlOiBmdW5jdGlvbiAodGlsZSkge1xuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGlsZSwgJ2xlYWZsZXQtdGlsZScpO1xuXG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuXHRcdHRpbGUuc3R5bGUud2lkdGggPSB0aWxlU2l6ZS54ICsgJ3B4Jztcblx0XHR0aWxlLnN0eWxlLmhlaWdodCA9IHRpbGVTaXplLnkgKyAncHgnO1xuXG5cdFx0dGlsZS5vbnNlbGVjdHN0YXJ0ID0gVXRpbC5mYWxzZUZuO1xuXHRcdHRpbGUub25tb3VzZW1vdmUgPSBVdGlsLmZhbHNlRm47XG5cblx0XHQvLyB1cGRhdGUgb3BhY2l0eSBvbiB0aWxlcyBpbiBJRTctOCBiZWNhdXNlIG9mIGZpbHRlciBpbmhlcml0YW5jZSBwcm9ibGVtc1xuXHRcdGlmIChCcm93c2VyLmllbHQ5ICYmIHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblx0XHR9XG5cdH0sXG5cblx0X2FkZFRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGNvbnRhaW5lcikge1xuXHRcdHZhciB0aWxlUG9zID0gdGhpcy5fZ2V0VGlsZVBvcyhjb29yZHMpLFxuXHRcdCAgICBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcblxuXHRcdHZhciB0aWxlID0gdGhpcy5jcmVhdGVUaWxlKHRoaXMuX3dyYXBDb29yZHMoY29vcmRzKSwgVXRpbC5iaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzKSk7XG5cblx0XHR0aGlzLl9pbml0VGlsZSh0aWxlKTtcblxuXHRcdC8vIGlmIGNyZWF0ZVRpbGUgaXMgZGVmaW5lZCB3aXRoIGEgc2Vjb25kIGFyZ3VtZW50IChcImRvbmVcIiBjYWxsYmFjayksXG5cdFx0Ly8gd2Uga25vdyB0aGF0IHRpbGUgaXMgYXN5bmMgYW5kIHdpbGwgYmUgcmVhZHkgbGF0ZXI7IG90aGVyd2lzZVxuXHRcdGlmICh0aGlzLmNyZWF0ZVRpbGUubGVuZ3RoIDwgMikge1xuXHRcdFx0Ly8gbWFyayB0aWxlIGFzIHJlYWR5LCBidXQgZGVsYXkgb25lIGZyYW1lIGZvciBvcGFjaXR5IGFuaW1hdGlvbiB0byBoYXBwZW5cblx0XHRcdFV0aWwucmVxdWVzdEFuaW1GcmFtZShVdGlsLmJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMsIG51bGwsIHRpbGUpKTtcblx0XHR9XG5cblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRpbGUsIHRpbGVQb3MpO1xuXG5cdFx0Ly8gc2F2ZSB0aWxlIGluIGNhY2hlXG5cdFx0dGhpcy5fdGlsZXNba2V5XSA9IHtcblx0XHRcdGVsOiB0aWxlLFxuXHRcdFx0Y29vcmRzOiBjb29yZHMsXG5cdFx0XHRjdXJyZW50OiB0cnVlXG5cdFx0fTtcblxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aWxlKTtcblx0XHQvLyBAZXZlbnQgdGlsZWxvYWRzdGFydDogVGlsZUV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVxdWVzdGVkIGFuZCBzdGFydHMgbG9hZGluZy5cblx0XHR0aGlzLmZpcmUoJ3RpbGVsb2Fkc3RhcnQnLCB7XG5cdFx0XHR0aWxlOiB0aWxlLFxuXHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHR9KTtcblx0fSxcblxuXHRfdGlsZVJlYWR5OiBmdW5jdGlvbiAoY29vcmRzLCBlcnIsIHRpbGUpIHtcblx0XHRpZiAoZXJyKSB7XG5cdFx0XHQvLyBAZXZlbnQgdGlsZWVycm9yOiBUaWxlRXJyb3JFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGVyZSBpcyBhbiBlcnJvciBsb2FkaW5nIGEgdGlsZS5cblx0XHRcdHRoaXMuZmlyZSgndGlsZWVycm9yJywge1xuXHRcdFx0XHRlcnJvcjogZXJyLFxuXHRcdFx0XHR0aWxlOiB0aWxlLFxuXHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG5cdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0aWYgKCF0aWxlKSB7IHJldHVybjsgfVxuXG5cdFx0dGlsZS5sb2FkZWQgPSArbmV3IERhdGUoKTtcblx0XHRpZiAodGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQpIHtcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aWxlLmVsLCAwKTtcblx0XHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZhZGVGcmFtZSk7XG5cdFx0XHR0aGlzLl9mYWRlRnJhbWUgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlT3BhY2l0eSwgdGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRpbGUuYWN0aXZlID0gdHJ1ZTtcblx0XHRcdHRoaXMuX3BydW5lVGlsZXMoKTtcblx0XHR9XG5cblx0XHRpZiAoIWVycikge1xuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aWxlLmVsLCAnbGVhZmxldC10aWxlLWxvYWRlZCcpO1xuXG5cdFx0XHQvLyBAZXZlbnQgdGlsZWxvYWQ6IFRpbGVFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgbG9hZHMuXG5cdFx0XHR0aGlzLmZpcmUoJ3RpbGVsb2FkJywge1xuXHRcdFx0XHR0aWxlOiB0aWxlLmVsLFxuXHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX25vVGlsZXNUb0xvYWQoKSkge1xuXHRcdFx0dGhpcy5fbG9hZGluZyA9IGZhbHNlO1xuXHRcdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBncmlkIGxheWVyIGxvYWRlZCBhbGwgdmlzaWJsZSB0aWxlcy5cblx0XHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xuXG5cdFx0XHRpZiAoQnJvd3Nlci5pZWx0OSB8fCAhdGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQpIHtcblx0XHRcdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gV2FpdCBhIGJpdCBtb3JlIHRoYW4gMC4yIHNlY3MgKHRoZSBkdXJhdGlvbiBvZiB0aGUgdGlsZSBmYWRlLWluKVxuXHRcdFx0XHQvLyB0byB0cmlnZ2VyIGEgcHJ1bmluZy5cblx0XHRcdFx0c2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyksIDI1MCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRUaWxlUG9zOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0cmV0dXJuIGNvb3Jkcy5zY2FsZUJ5KHRoaXMuZ2V0VGlsZVNpemUoKSkuc3VidHJhY3QodGhpcy5fbGV2ZWwub3JpZ2luKTtcblx0fSxcblxuXHRfd3JhcENvb3JkczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBuZXdDb29yZHMgPSBuZXcgUG9pbnQoXG5cdFx0XHR0aGlzLl93cmFwWCA/IFV0aWwud3JhcE51bShjb29yZHMueCwgdGhpcy5fd3JhcFgpIDogY29vcmRzLngsXG5cdFx0XHR0aGlzLl93cmFwWSA/IFV0aWwud3JhcE51bShjb29yZHMueSwgdGhpcy5fd3JhcFkpIDogY29vcmRzLnkpO1xuXHRcdG5ld0Nvb3Jkcy56ID0gY29vcmRzLno7XG5cdFx0cmV0dXJuIG5ld0Nvb3Jkcztcblx0fSxcblxuXHRfcHhCb3VuZHNUb1RpbGVSYW5nZTogZnVuY3Rpb24gKGJvdW5kcykge1xuXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhcblx0XHRcdGJvdW5kcy5taW4udW5zY2FsZUJ5KHRpbGVTaXplKS5mbG9vcigpLFxuXHRcdFx0Ym91bmRzLm1heC51bnNjYWxlQnkodGlsZVNpemUpLmNlaWwoKS5zdWJ0cmFjdChbMSwgMV0pKTtcblx0fSxcblxuXHRfbm9UaWxlc1RvTG9hZDogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0aWYgKCF0aGlzLl90aWxlc1trZXldLmxvYWRlZCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmdyaWRMYXllcihvcHRpb25zPzogR3JpZExheWVyIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEdyaWRMYXllciB3aXRoIHRoZSBzdXBwbGllZCBvcHRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIGdyaWRMYXllcihvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgR3JpZExheWVyKG9wdGlvbnMpO1xufVxuIiwiaW1wb3J0IHtHcmlkTGF5ZXJ9IGZyb20gJy4vR3JpZExheWVyJztcclxuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcclxuXHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgVGlsZUxheWVyXHJcbiAqIEBpbmhlcml0cyBHcmlkTGF5ZXJcclxuICogQGFrYSBMLlRpbGVMYXllclxyXG4gKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgdGlsZSBsYXllcnMgb24gdGhlIG1hcC4gTm90ZSB0aGF0IG1vc3QgdGlsZSBzZXJ2ZXJzIHJlcXVpcmUgYXR0cmlidXRpb24sIHdoaWNoIHlvdSBjYW4gc2V0IHVuZGVyIGBMYXllcmAuIEV4dGVuZHMgYEdyaWRMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwudGlsZUxheWVyKCdodHRwczovL3RpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nP3tmb299Jywge2ZvbzogJ2JhcicsIGF0dHJpYnV0aW9uOiAnJmNvcHk7IDxhIGhyZWY9XCJodHRwczovL3d3dy5vcGVuc3RyZWV0bWFwLm9yZy9jb3B5cmlnaHRcIj5PcGVuU3RyZWV0TWFwPC9hPiBjb250cmlidXRvcnMnfSkuYWRkVG8obWFwKTtcbiAqIGBgYFxyXG4gKlxyXG4gKiBAc2VjdGlvbiBVUkwgdGVtcGxhdGVcclxuICogQGV4YW1wbGVcclxuICpcclxuICogQSBzdHJpbmcgb2YgdGhlIGZvbGxvd2luZyBmb3JtOlxyXG4gKlxyXG4gKiBgYGBcclxuICogJ2h0dHBzOi8ve3N9LnNvbWVkb21haW4uY29tL2JsYWJsYS97en0ve3h9L3t5fXtyfS5wbmcnXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBge3N9YCBtZWFucyBvbmUgb2YgdGhlIGF2YWlsYWJsZSBzdWJkb21haW5zICh1c2VkIHNlcXVlbnRpYWxseSB0byBoZWxwIHdpdGggYnJvd3NlciBwYXJhbGxlbCByZXF1ZXN0cyBwZXIgZG9tYWluIGxpbWl0YXRpb247IHN1YmRvbWFpbiB2YWx1ZXMgYXJlIHNwZWNpZmllZCBpbiBvcHRpb25zOyBgYWAsIGBiYCBvciBgY2AgYnkgZGVmYXVsdCwgY2FuIGJlIG9taXR0ZWQpLCBge3p9YCDigJQgem9vbSBsZXZlbCwgYHt4fWAgYW5kIGB7eX1gIOKAlCB0aWxlIGNvb3JkaW5hdGVzLiBge3J9YCBjYW4gYmUgdXNlZCB0byBhZGQgXCImY29tbWF0OzJ4XCIgdG8gdGhlIFVSTCB0byBsb2FkIHJldGluYSB0aWxlcy5cclxuICpcclxuICogWW91IGNhbiB1c2UgY3VzdG9tIGtleXMgaW4gdGhlIHRlbXBsYXRlLCB3aGljaCB3aWxsIGJlIFtldmFsdWF0ZWRdKCN1dGlsLXRlbXBsYXRlKSBmcm9tIFRpbGVMYXllciBvcHRpb25zLCBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBMLnRpbGVMYXllcignaHR0cHM6Ly97c30uc29tZWRvbWFpbi5jb20ve2Zvb30ve3p9L3t4fS97eX0ucG5nJywge2ZvbzogJ2Jhcid9KTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbmV4cG9ydCB2YXIgVGlsZUxheWVyID0gR3JpZExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBUaWxlTGF5ZXIgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gMFxyXG5cdFx0Ly8gVGhlIG1pbmltdW0gem9vbSBsZXZlbCBkb3duIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXHJcblx0XHRtaW5ab29tOiAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gMThcclxuXHRcdC8vIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdXAgdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cclxuXHRcdG1heFpvb206IDE4LFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc3ViZG9tYWluczogU3RyaW5nfFN0cmluZ1tdID0gJ2FiYydcclxuXHRcdC8vIFN1YmRvbWFpbnMgb2YgdGhlIHRpbGUgc2VydmljZS4gQ2FuIGJlIHBhc3NlZCBpbiB0aGUgZm9ybSBvZiBvbmUgc3RyaW5nICh3aGVyZSBlYWNoIGxldHRlciBpcyBhIHN1YmRvbWFpbiBuYW1lKSBvciBhbiBhcnJheSBvZiBzdHJpbmdzLlxyXG5cdFx0c3ViZG9tYWluczogJ2FiYycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBlcnJvclRpbGVVcmw6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBVUkwgdG8gdGhlIHRpbGUgaW1hZ2UgdG8gc2hvdyBpbiBwbGFjZSBvZiB0aGUgdGlsZSB0aGF0IGZhaWxlZCB0byBsb2FkLlxyXG5cdFx0ZXJyb3JUaWxlVXJsOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21PZmZzZXQ6IE51bWJlciA9IDBcclxuXHRcdC8vIFRoZSB6b29tIG51bWJlciB1c2VkIGluIHRpbGUgVVJMcyB3aWxsIGJlIG9mZnNldCB3aXRoIHRoaXMgdmFsdWUuXHJcblx0XHR6b29tT2Zmc2V0OiAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdG1zOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgaW52ZXJzZXMgWSBheGlzIG51bWJlcmluZyBmb3IgdGlsZXMgKHR1cm4gdGhpcyBvbiBmb3IgW1RNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGlsZV9NYXBfU2VydmljZSkgc2VydmljZXMpLlxyXG5cdFx0dG1zOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21SZXZlcnNlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIHNldCB0byB0cnVlLCB0aGUgem9vbSBudW1iZXIgdXNlZCBpbiB0aWxlIFVSTHMgd2lsbCBiZSByZXZlcnNlZCAoYG1heFpvb20gLSB6b29tYCBpbnN0ZWFkIG9mIGB6b29tYClcclxuXHRcdHpvb21SZXZlcnNlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGRldGVjdFJldGluYTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAgYW5kIHVzZXIgaXMgb24gYSByZXRpbmEgZGlzcGxheSwgaXQgd2lsbCByZXF1ZXN0IGZvdXIgdGlsZXMgb2YgaGFsZiB0aGUgc3BlY2lmaWVkIHNpemUgYW5kIGEgYmlnZ2VyIHpvb20gbGV2ZWwgaW4gcGxhY2Ugb2Ygb25lIHRvIHV0aWxpemUgdGhlIGhpZ2ggcmVzb2x1dGlvbi5cclxuXHRcdGRldGVjdFJldGluYTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjcm9zc09yaWdpbjogQm9vbGVhbnxTdHJpbmcgPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRpbGVzLlxyXG5cdFx0Ly8gSWYgYSBTdHJpbmcgaXMgcHJvdmlkZWQsIGFsbCB0aWxlcyB3aWxsIGhhdmUgdGhlaXIgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byB0aGUgU3RyaW5nIHByb3ZpZGVkLiBUaGlzIGlzIG5lZWRlZCBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgdGlsZSBwaXhlbCBkYXRhLlxyXG5cdFx0Ly8gUmVmZXIgdG8gW0NPUlMgU2V0dGluZ3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzKSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuXHRcdGNyb3NzT3JpZ2luOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJlZmVycmVyUG9saWN5OiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSByZWZlcnJlclBvbGljeSBhdHRyaWJ1dGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgdGlsZXMuXHJcblx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgYWxsIHRpbGVzIHdpbGwgaGF2ZSB0aGVpciByZWZlcnJlclBvbGljeSBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuXHJcblx0XHQvLyBUaGlzIG1heSBiZSBuZWVkZWQgaWYgeW91ciBtYXAncyByZW5kZXJpbmcgY29udGV4dCBoYXMgYSBzdHJpY3QgZGVmYXVsdCBidXQgeW91ciB0aWxlIHByb3ZpZGVyIGV4cGVjdHMgYSB2YWxpZCByZWZlcnJlclxyXG5cdFx0Ly8gKGUuZy4gdG8gdmFsaWRhdGUgYW4gQVBJIHRva2VuKS5cclxuXHRcdC8vIFJlZmVyIHRvIFtIVE1MSW1hZ2VFbGVtZW50LnJlZmVycmVyUG9saWN5XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTEltYWdlRWxlbWVudC9yZWZlcnJlclBvbGljeSkgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcblx0XHRyZWZlcnJlclBvbGljeTogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdG9wdGlvbnMgPSBVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0Ly8gZGV0ZWN0aW5nIHJldGluYSBkaXNwbGF5cywgYWRqdXN0aW5nIHRpbGVTaXplIGFuZCB6b29tIGxldmVsc1xyXG5cdFx0aWYgKG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIEJyb3dzZXIucmV0aW5hICYmIG9wdGlvbnMubWF4Wm9vbSA+IDApIHtcclxuXHJcblx0XHRcdG9wdGlvbnMudGlsZVNpemUgPSBNYXRoLmZsb29yKG9wdGlvbnMudGlsZVNpemUgLyAyKTtcclxuXHJcblx0XHRcdGlmICghb3B0aW9ucy56b29tUmV2ZXJzZSkge1xyXG5cdFx0XHRcdG9wdGlvbnMuem9vbU9mZnNldCsrO1xyXG5cdFx0XHRcdG9wdGlvbnMubWF4Wm9vbSA9IE1hdGgubWF4KG9wdGlvbnMubWluWm9vbSwgb3B0aW9ucy5tYXhab29tIC0gMSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0LS07XHJcblx0XHRcdFx0b3B0aW9ucy5taW5ab29tID0gTWF0aC5taW4ob3B0aW9ucy5tYXhab29tLCBvcHRpb25zLm1pblpvb20gKyAxKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b3B0aW9ucy5taW5ab29tID0gTWF0aC5tYXgoMCwgb3B0aW9ucy5taW5ab29tKTtcclxuXHRcdH0gZWxzZSBpZiAoIW9wdGlvbnMuem9vbVJldmVyc2UpIHtcclxuXHRcdFx0Ly8gbWFrZSBzdXJlIG1heFpvb20gaXMgZ3RlIG1pblpvb21cclxuXHRcdFx0b3B0aW9ucy5tYXhab29tID0gTWF0aC5tYXgob3B0aW9ucy5taW5ab29tLCBvcHRpb25zLm1heFpvb20pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gbWFrZSBzdXJlIG1pblpvb20gaXMgbHRlIG1heFpvb21cclxuXHRcdFx0b3B0aW9ucy5taW5ab29tID0gTWF0aC5taW4ob3B0aW9ucy5tYXhab29tLCBvcHRpb25zLm1pblpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucy5zdWJkb21haW5zID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRvcHRpb25zLnN1YmRvbWFpbnMgPSBvcHRpb25zLnN1YmRvbWFpbnMuc3BsaXQoJycpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMub24oJ3RpbGV1bmxvYWQnLCB0aGlzLl9vblRpbGVSZW1vdmUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VXJsKHVybDogU3RyaW5nLCBub1JlZHJhdz86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gVXBkYXRlcyB0aGUgbGF5ZXIncyBVUkwgdGVtcGxhdGUgYW5kIHJlZHJhd3MgaXQgKHVubGVzcyBgbm9SZWRyYXdgIGlzIHNldCB0byBgdHJ1ZWApLlxyXG5cdC8vIElmIHRoZSBVUkwgZG9lcyBub3QgY2hhbmdlLCB0aGUgbGF5ZXIgd2lsbCBub3QgYmUgcmVkcmF3biB1bmxlc3NcclxuXHQvLyB0aGUgbm9SZWRyYXcgcGFyYW1ldGVyIGlzIHNldCB0byBmYWxzZS5cclxuXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwsIG5vUmVkcmF3KSB7XHJcblx0XHRpZiAodGhpcy5fdXJsID09PSB1cmwgJiYgbm9SZWRyYXcgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRub1JlZHJhdyA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdGlmICghbm9SZWRyYXcpIHtcclxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY3JlYXRlVGlsZShjb29yZHM6IE9iamVjdCwgZG9uZT86IEZ1bmN0aW9uKTogSFRNTEVsZW1lbnRcclxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBvdmVycmlkZXMgR3JpZExheWVyJ3MgW2BjcmVhdGVUaWxlKClgXSgjZ3JpZGxheWVyLWNyZWF0ZXRpbGUpXHJcblx0Ly8gdG8gcmV0dXJuIGFuIGA8aW1nPmAgSFRNTCBlbGVtZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIGltYWdlIFVSTCBnaXZlbiBgY29vcmRzYC4gVGhlIGBkb25lYFxyXG5cdC8vIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSB0aWxlIGhhcyBiZWVuIGxvYWRlZC5cclxuXHRjcmVhdGVUaWxlOiBmdW5jdGlvbiAoY29vcmRzLCBkb25lKSB7XHJcblx0XHR2YXIgdGlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG5cclxuXHRcdERvbUV2ZW50Lm9uKHRpbGUsICdsb2FkJywgVXRpbC5iaW5kKHRoaXMuX3RpbGVPbkxvYWQsIHRoaXMsIGRvbmUsIHRpbGUpKTtcclxuXHRcdERvbUV2ZW50Lm9uKHRpbGUsICdlcnJvcicsIFV0aWwuYmluZCh0aGlzLl90aWxlT25FcnJvciwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gfHwgdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSAnJykge1xyXG5cdFx0XHR0aWxlLmNyb3NzT3JpZ2luID0gdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSB0cnVlID8gJycgOiB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZm9yIHRoaXMgbmV3IG9wdGlvbiB3ZSBmb2xsb3cgdGhlIGRvY3VtZW50ZWQgYmVoYXZpb3JcclxuXHRcdC8vIG1vcmUgY2xvc2VseSBieSBvbmx5IHNldHRpbmcgdGhlIHByb3BlcnR5IHdoZW4gc3RyaW5nXHJcblx0XHRpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5yZWZlcnJlclBvbGljeSA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0dGlsZS5yZWZlcnJlclBvbGljeSA9IHRoaXMub3B0aW9ucy5yZWZlcnJlclBvbGljeTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBUaGUgYWx0IGF0dHJpYnV0ZSBpcyBzZXQgdG8gdGhlIGVtcHR5IHN0cmluZyxcclxuXHRcdC8vIGFsbG93aW5nIHNjcmVlbiByZWFkZXJzIHRvIGlnbm9yZSB0aGUgZGVjb3JhdGl2ZSBpbWFnZSB0aWxlcy5cclxuXHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvdHV0b3JpYWxzL2ltYWdlcy9kZWNvcmF0aXZlL1xyXG5cdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWwtYXJpYS8jZWwtaW1nLWVtcHR5LWFsdFxyXG5cdFx0dGlsZS5hbHQgPSAnJztcclxuXHJcblx0XHR0aWxlLnNyYyA9IHRoaXMuZ2V0VGlsZVVybChjb29yZHMpO1xyXG5cclxuXHRcdHJldHVybiB0aWxlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXHJcblx0Ly8gQHVuaW5oZXJpdGFibGVcclxuXHQvLyBMYXllcnMgZXh0ZW5kaW5nIGBUaWxlTGF5ZXJgIG1pZ2h0IHJlaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kLlxyXG5cdC8vIEBtZXRob2QgZ2V0VGlsZVVybChjb29yZHM6IE9iamVjdCk6IFN0cmluZ1xyXG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIHJldHVybnMgdGhlIFVSTCBmb3IgYSB0aWxlIGdpdmVuIGl0cyBjb29yZGluYXRlcy5cclxuXHQvLyBDbGFzc2VzIGV4dGVuZGluZyBgVGlsZUxheWVyYCBjYW4gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBwcm92aWRlIGN1c3RvbSB0aWxlIFVSTCBuYW1pbmcgc2NoZW1lcy5cclxuXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0cjogQnJvd3Nlci5yZXRpbmEgPyAnQDJ4JyA6ICcnLFxyXG5cdFx0XHRzOiB0aGlzLl9nZXRTdWJkb21haW4oY29vcmRzKSxcclxuXHRcdFx0eDogY29vcmRzLngsXHJcblx0XHRcdHk6IGNvb3Jkcy55LFxyXG5cdFx0XHR6OiB0aGlzLl9nZXRab29tRm9yVXJsKClcclxuXHRcdH07XHJcblx0XHRpZiAodGhpcy5fbWFwICYmICF0aGlzLl9tYXAub3B0aW9ucy5jcnMuaW5maW5pdGUpIHtcclxuXHRcdFx0dmFyIGludmVydGVkWSA9IHRoaXMuX2dsb2JhbFRpbGVSYW5nZS5tYXgueSAtIGNvb3Jkcy55O1xyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnRtcykge1xyXG5cdFx0XHRcdGRhdGFbJ3knXSA9IGludmVydGVkWTtcclxuXHRcdFx0fVxyXG5cdFx0XHRkYXRhWycteSddID0gaW52ZXJ0ZWRZO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBVdGlsLnRlbXBsYXRlKHRoaXMuX3VybCwgVXRpbC5leHRlbmQoZGF0YSwgdGhpcy5vcHRpb25zKSk7XHJcblx0fSxcclxuXHJcblx0X3RpbGVPbkxvYWQ6IGZ1bmN0aW9uIChkb25lLCB0aWxlKSB7XHJcblx0XHQvLyBGb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMzMzMlxyXG5cdFx0aWYgKEJyb3dzZXIuaWVsdDkpIHtcclxuXHRcdFx0c2V0VGltZW91dChVdGlsLmJpbmQoZG9uZSwgdGhpcywgbnVsbCwgdGlsZSksIDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZG9uZShudWxsLCB0aWxlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdGlsZU9uRXJyb3I6IGZ1bmN0aW9uIChkb25lLCB0aWxlLCBlKSB7XHJcblx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JUaWxlVXJsO1xyXG5cdFx0aWYgKGVycm9yVXJsICYmIHRpbGUuZ2V0QXR0cmlidXRlKCdzcmMnKSAhPT0gZXJyb3JVcmwpIHtcclxuXHRcdFx0dGlsZS5zcmMgPSBlcnJvclVybDtcclxuXHRcdH1cclxuXHRcdGRvbmUoZSwgdGlsZSk7XHJcblx0fSxcclxuXHJcblx0X29uVGlsZVJlbW92ZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGUudGlsZS5vbmxvYWQgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRab29tRm9yVXJsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgem9vbSA9IHRoaXMuX3RpbGVab29tLFxyXG5cdFx0bWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tLFxyXG5cdFx0em9vbVJldmVyc2UgPSB0aGlzLm9wdGlvbnMuem9vbVJldmVyc2UsXHJcblx0XHR6b29tT2Zmc2V0ID0gdGhpcy5vcHRpb25zLnpvb21PZmZzZXQ7XHJcblxyXG5cdFx0aWYgKHpvb21SZXZlcnNlKSB7XHJcblx0XHRcdHpvb20gPSBtYXhab29tIC0gem9vbTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gem9vbSArIHpvb21PZmZzZXQ7XHJcblx0fSxcclxuXHJcblx0X2dldFN1YmRvbWFpbjogZnVuY3Rpb24gKHRpbGVQb2ludCkge1xyXG5cdFx0dmFyIGluZGV4ID0gTWF0aC5hYnModGlsZVBvaW50LnggKyB0aWxlUG9pbnQueSkgJSB0aGlzLm9wdGlvbnMuc3ViZG9tYWlucy5sZW5ndGg7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnN1YmRvbWFpbnNbaW5kZXhdO1xyXG5cdH0sXHJcblxyXG5cdC8vIHN0b3BzIGxvYWRpbmcgYWxsIHRpbGVzIGluIHRoZSBiYWNrZ3JvdW5kIGxheWVyXHJcblx0X2Fib3J0TG9hZGluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGksIHRpbGU7XHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fdGlsZXMpIHtcclxuXHRcdFx0aWYgKHRoaXMuX3RpbGVzW2ldLmNvb3Jkcy56ICE9PSB0aGlzLl90aWxlWm9vbSkge1xyXG5cdFx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1tpXS5lbDtcclxuXHJcblx0XHRcdFx0dGlsZS5vbmxvYWQgPSBVdGlsLmZhbHNlRm47XHJcblx0XHRcdFx0dGlsZS5vbmVycm9yID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdFx0XHRpZiAoIXRpbGUuY29tcGxldGUpIHtcclxuXHRcdFx0XHRcdHRpbGUuc3JjID0gVXRpbC5lbXB0eUltYWdlVXJsO1xyXG5cdFx0XHRcdFx0dmFyIGNvb3JkcyA9IHRoaXMuX3RpbGVzW2ldLmNvb3JkcztcclxuXHRcdFx0XHRcdERvbVV0aWwucmVtb3ZlKHRpbGUpO1xyXG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX3RpbGVzW2ldO1xyXG5cdFx0XHRcdFx0Ly8gQGV2ZW50IHRpbGVhYm9ydDogVGlsZUV2ZW50XHJcblx0XHRcdFx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSB3YXMgbG9hZGluZyBidXQgaXMgbm93IG5vdCB3YW50ZWQuXHJcblx0XHRcdFx0XHR0aGlzLmZpcmUoJ3RpbGVhYm9ydCcsIHtcclxuXHRcdFx0XHRcdFx0dGlsZTogdGlsZSxcclxuXHRcdFx0XHRcdFx0Y29vcmRzOiBjb29yZHNcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVUaWxlOiBmdW5jdGlvbiAoa2V5KSB7XHJcblx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XHJcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gQ2FuY2VscyBhbnkgcGVuZGluZyBodHRwIHJlcXVlc3RzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdGlsZVxyXG5cdFx0dGlsZS5lbC5zZXRBdHRyaWJ1dGUoJ3NyYycsIFV0aWwuZW1wdHlJbWFnZVVybCk7XHJcblxyXG5cdFx0cmV0dXJuIEdyaWRMYXllci5wcm90b3R5cGUuX3JlbW92ZVRpbGUuY2FsbCh0aGlzLCBrZXkpO1xyXG5cdH0sXHJcblxyXG5cdF90aWxlUmVhZHk6IGZ1bmN0aW9uIChjb29yZHMsIGVyciwgdGlsZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXAgfHwgKHRpbGUgJiYgdGlsZS5nZXRBdHRyaWJ1dGUoJ3NyYycpID09PSBVdGlsLmVtcHR5SW1hZ2VVcmwpKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gR3JpZExheWVyLnByb3RvdHlwZS5fdGlsZVJlYWR5LmNhbGwodGhpcywgY29vcmRzLCBlcnIsIHRpbGUpO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC50aWxlbGF5ZXIodXJsVGVtcGxhdGU6IFN0cmluZywgb3B0aW9ucz86IFRpbGVMYXllciBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSB0aWxlIGxheWVyIG9iamVjdCBnaXZlbiBhIGBVUkwgdGVtcGxhdGVgIGFuZCBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LlxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRpbGVMYXllcih1cmwsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IFRpbGVMYXllcih1cmwsIG9wdGlvbnMpO1xyXG59XHJcbiIsImltcG9ydCB7VGlsZUxheWVyfSBmcm9tICcuL1RpbGVMYXllcic7XHJcbmltcG9ydCB7ZXh0ZW5kLCBzZXRPcHRpb25zLCBnZXRQYXJhbVN0cmluZ30gZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0IHtFUFNHNDMyNn0gZnJvbSAnLi4vLi4vZ2VvL2Nycy9DUlMuRVBTRzQzMjYnO1xyXG5pbXBvcnQge3RvQm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFRpbGVMYXllci5XTVNcclxuICogQGluaGVyaXRzIFRpbGVMYXllclxyXG4gKiBAYWthIEwuVGlsZUxheWVyLldNU1xyXG4gKiBVc2VkIHRvIGRpc3BsYXkgW1dNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2ViX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcyBhcyB0aWxlIGxheWVycyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBUaWxlTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbmV4cmFkID0gTC50aWxlTGF5ZXIud21zKFwiaHR0cDovL21lc29uZXQuYWdyb24uaWFzdGF0ZS5lZHUvY2dpLWJpbi93bXMvbmV4cmFkL24wci5jZ2lcIiwge1xyXG4gKiBcdGxheWVyczogJ25leHJhZC1uMHItOTAwOTEzJyxcclxuICogXHRmb3JtYXQ6ICdpbWFnZS9wbmcnLFxyXG4gKiBcdHRyYW5zcGFyZW50OiB0cnVlLFxyXG4gKiBcdGF0dHJpYnV0aW9uOiBcIldlYXRoZXIgZGF0YSDCqSAyMDEyIElFTSBOZXhyYWRcIlxyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBUaWxlTGF5ZXJXTVMgPSBUaWxlTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFRpbGVMYXllci5XTVMgb3B0aW9uc1xyXG5cdC8vIElmIGFueSBjdXN0b20gb3B0aW9ucyBub3QgZG9jdW1lbnRlZCBoZXJlIGFyZSB1c2VkLCB0aGV5IHdpbGwgYmUgc2VudCB0byB0aGVcclxuXHQvLyBXTVMgc2VydmVyIGFzIGV4dHJhIHBhcmFtZXRlcnMgaW4gZWFjaCByZXF1ZXN0IFVSTC4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvclxyXG5cdC8vIFtub24tc3RhbmRhcmQgdmVuZG9yIFdNUyBwYXJhbWV0ZXJzXShodHRwczovL2RvY3MuZ2Vvc2VydmVyLm9yZy9zdGFibGUvZW4vdXNlci9zZXJ2aWNlcy93bXMvdmVuZG9yLmh0bWwpLlxyXG5cdGRlZmF1bHRXbXNQYXJhbXM6IHtcclxuXHRcdHNlcnZpY2U6ICdXTVMnLFxyXG5cdFx0cmVxdWVzdDogJ0dldE1hcCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBsYXllcnM6IFN0cmluZyA9ICcnXHJcblx0XHQvLyAqKihyZXF1aXJlZCkqKiBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgbGF5ZXJzIHRvIHNob3cuXHJcblx0XHRsYXllcnM6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc3R5bGVzOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgV01TIHN0eWxlcy5cclxuXHRcdHN0eWxlczogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBmb3JtYXQ6IFN0cmluZyA9ICdpbWFnZS9qcGVnJ1xyXG5cdFx0Ly8gV01TIGltYWdlIGZvcm1hdCAodXNlIGAnaW1hZ2UvcG5nJ2AgZm9yIGxheWVycyB3aXRoIHRyYW5zcGFyZW5jeSkuXHJcblx0XHRmb3JtYXQ6ICdpbWFnZS9qcGVnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRyYW5zcGFyZW50OiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIFdNUyBzZXJ2aWNlIHdpbGwgcmV0dXJuIGltYWdlcyB3aXRoIHRyYW5zcGFyZW5jeS5cclxuXHRcdHRyYW5zcGFyZW50OiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHZlcnNpb246IFN0cmluZyA9ICcxLjEuMSdcclxuXHRcdC8vIFZlcnNpb24gb2YgdGhlIFdNUyBzZXJ2aWNlIHRvIHVzZVxyXG5cdFx0dmVyc2lvbjogJzEuMS4xJ1xyXG5cdH0sXHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gY3JzOiBDUlMgPSBudWxsXHJcblx0XHQvLyBDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW0gdG8gdXNlIGZvciB0aGUgV01TIHJlcXVlc3RzLCBkZWZhdWx0cyB0b1xyXG5cdFx0Ly8gbWFwIENSUy4gRG9uJ3QgY2hhbmdlIHRoaXMgaWYgeW91J3JlIG5vdCBzdXJlIHdoYXQgaXQgbWVhbnMuXHJcblx0XHRjcnM6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB1cHBlcmNhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCBXTVMgcmVxdWVzdCBwYXJhbWV0ZXIga2V5cyB3aWxsIGJlIHVwcGVyY2FzZS5cclxuXHRcdHVwcGVyY2FzZTogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdHZhciB3bXNQYXJhbXMgPSBleHRlbmQoe30sIHRoaXMuZGVmYXVsdFdtc1BhcmFtcyk7XHJcblxyXG5cdFx0Ly8gYWxsIGtleXMgdGhhdCBhcmUgbm90IFRpbGVMYXllciBvcHRpb25zIGdvIHRvIFdNUyBwYXJhbXNcclxuXHRcdGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xyXG5cdFx0XHRpZiAoIShpIGluIHRoaXMub3B0aW9ucykpIHtcclxuXHRcdFx0XHR3bXNQYXJhbXNbaV0gPSBvcHRpb25zW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0b3B0aW9ucyA9IHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dmFyIHJlYWxSZXRpbmEgPSBvcHRpb25zLmRldGVjdFJldGluYSAmJiBCcm93c2VyLnJldGluYSA/IDIgOiAxO1xyXG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xyXG5cdFx0d21zUGFyYW1zLndpZHRoID0gdGlsZVNpemUueCAqIHJlYWxSZXRpbmE7XHJcblx0XHR3bXNQYXJhbXMuaGVpZ2h0ID0gdGlsZVNpemUueSAqIHJlYWxSZXRpbmE7XHJcblxyXG5cdFx0dGhpcy53bXNQYXJhbXMgPSB3bXNQYXJhbXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHJcblx0XHR0aGlzLl9jcnMgPSB0aGlzLm9wdGlvbnMuY3JzIHx8IG1hcC5vcHRpb25zLmNycztcclxuXHRcdHRoaXMuX3dtc1ZlcnNpb24gPSBwYXJzZUZsb2F0KHRoaXMud21zUGFyYW1zLnZlcnNpb24pO1xyXG5cclxuXHRcdHZhciBwcm9qZWN0aW9uS2V5ID0gdGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgPyAnY3JzJyA6ICdzcnMnO1xyXG5cdFx0dGhpcy53bXNQYXJhbXNbcHJvamVjdGlvbktleV0gPSB0aGlzLl9jcnMuY29kZTtcclxuXHJcblx0XHRUaWxlTGF5ZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHR9LFxyXG5cclxuXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblxyXG5cdFx0dmFyIHRpbGVCb3VuZHMgPSB0aGlzLl90aWxlQ29vcmRzVG9Od1NlKGNvb3JkcyksXHJcblx0XHQgICAgY3JzID0gdGhpcy5fY3JzLFxyXG5cdFx0ICAgIGJvdW5kcyA9IHRvQm91bmRzKGNycy5wcm9qZWN0KHRpbGVCb3VuZHNbMF0pLCBjcnMucHJvamVjdCh0aWxlQm91bmRzWzFdKSksXHJcblx0XHQgICAgbWluID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXggPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIGJib3ggPSAodGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgJiYgdGhpcy5fY3JzID09PSBFUFNHNDMyNiA/XHJcblx0XHQgICAgW21pbi55LCBtaW4ueCwgbWF4LnksIG1heC54XSA6XHJcblx0XHQgICAgW21pbi54LCBtaW4ueSwgbWF4LngsIG1heC55XSkuam9pbignLCcpLFxyXG5cdFx0ICAgIHVybCA9IFRpbGVMYXllci5wcm90b3R5cGUuZ2V0VGlsZVVybC5jYWxsKHRoaXMsIGNvb3Jkcyk7XHJcblx0XHRyZXR1cm4gdXJsICtcclxuXHRcdFx0Z2V0UGFyYW1TdHJpbmcodGhpcy53bXNQYXJhbXMsIHVybCwgdGhpcy5vcHRpb25zLnVwcGVyY2FzZSkgK1xyXG5cdFx0XHQodGhpcy5vcHRpb25zLnVwcGVyY2FzZSA/ICcmQkJPWD0nIDogJyZiYm94PScpICsgYmJveDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFBhcmFtcyhwYXJhbXM6IE9iamVjdCwgbm9SZWRyYXc/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIE1lcmdlcyBhbiBvYmplY3Qgd2l0aCB0aGUgbmV3IHBhcmFtZXRlcnMgYW5kIHJlLXJlcXVlc3RzIHRpbGVzIG9uIHRoZSBjdXJyZW50IHNjcmVlbiAodW5sZXNzIGBub1JlZHJhd2Agd2FzIHNldCB0byB0cnVlKS5cclxuXHRzZXRQYXJhbXM6IGZ1bmN0aW9uIChwYXJhbXMsIG5vUmVkcmF3KSB7XHJcblxyXG5cdFx0ZXh0ZW5kKHRoaXMud21zUGFyYW1zLCBwYXJhbXMpO1xyXG5cclxuXHRcdGlmICghbm9SZWRyYXcpIHtcclxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwudGlsZUxheWVyLndtcyhiYXNlVXJsOiBTdHJpbmcsIG9wdGlvbnM6IFRpbGVMYXllci5XTVMgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgV01TIHRpbGUgbGF5ZXIgb2JqZWN0IGdpdmVuIGEgYmFzZSBVUkwgb2YgdGhlIFdNUyBzZXJ2aWNlIGFuZCBhIFdNUyBwYXJhbWV0ZXJzL29wdGlvbnMgb2JqZWN0LlxyXG5leHBvcnQgZnVuY3Rpb24gdGlsZUxheWVyV01TKHVybCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVGlsZUxheWVyV01TKHVybCwgb3B0aW9ucyk7XHJcbn1cclxuIiwiZXhwb3J0IHtHcmlkTGF5ZXIsIGdyaWRMYXllcn0gZnJvbSAnLi9HcmlkTGF5ZXInO1xuaW1wb3J0IHtUaWxlTGF5ZXIsIHRpbGVMYXllcn0gZnJvbSAnLi9UaWxlTGF5ZXInO1xuaW1wb3J0IHtUaWxlTGF5ZXJXTVMsIHRpbGVMYXllcldNU30gZnJvbSAnLi9UaWxlTGF5ZXIuV01TJztcblRpbGVMYXllci5XTVMgPSBUaWxlTGF5ZXJXTVM7XG50aWxlTGF5ZXIud21zID0gdGlsZUxheWVyV01TO1xuZXhwb3J0IHtUaWxlTGF5ZXIsIHRpbGVMYXllcn07XG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuLi9MYXllcic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuXG5cbi8qXG4gKiBAY2xhc3MgUmVuZGVyZXJcbiAqIEBpbmhlcml0cyBMYXllclxuICogQGFrYSBMLlJlbmRlcmVyXG4gKlxuICogQmFzZSBjbGFzcyBmb3IgdmVjdG9yIHJlbmRlcmVyIGltcGxlbWVudGF0aW9ucyAoYFNWR2AsIGBDYW52YXNgKS4gSGFuZGxlcyB0aGVcbiAqIERPTSBjb250YWluZXIgb2YgdGhlIHJlbmRlcmVyLCBpdHMgYm91bmRzLCBhbmQgaXRzIHpvb20gYW5pbWF0aW9uLlxuICpcbiAqIEEgYFJlbmRlcmVyYCB3b3JrcyBhcyBhbiBpbXBsaWNpdCBsYXllciBncm91cCBmb3IgYWxsIGBQYXRoYHMgLSB0aGUgcmVuZGVyZXJcbiAqIGl0c2VsZiBjYW4gYmUgYWRkZWQgb3IgcmVtb3ZlZCB0byB0aGUgbWFwLiBBbGwgcGF0aHMgdXNlIGEgcmVuZGVyZXIsIHdoaWNoIGNhblxuICogYmUgaW1wbGljaXQgKHRoZSBtYXAgd2lsbCBkZWNpZGUgdGhlIHR5cGUgb2YgcmVuZGVyZXIgYW5kIHVzZSBpdCBhdXRvbWF0aWNhbGx5KVxuICogb3IgZXhwbGljaXQgKHVzaW5nIHRoZSBbYHJlbmRlcmVyYF0oI3BhdGgtcmVuZGVyZXIpIG9wdGlvbiBvZiB0aGUgcGF0aCkuXG4gKlxuICogRG8gbm90IHVzZSB0aGlzIGNsYXNzIGRpcmVjdGx5LCB1c2UgYFNWR2AgYW5kIGBDYW52YXNgIGluc3RlYWQuXG4gKlxuICogQGV2ZW50IHVwZGF0ZTogRXZlbnRcbiAqIEZpcmVkIHdoZW4gdGhlIHJlbmRlcmVyIHVwZGF0ZXMgaXRzIGJvdW5kcywgY2VudGVyIGFuZCB6b29tLCBmb3IgZXhhbXBsZSB3aGVuXG4gKiBpdHMgbWFwIGhhcyBtb3ZlZFxuICovXG5cbmV4cG9ydCB2YXIgUmVuZGVyZXIgPSBMYXllci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUmVuZGVyZXIgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBwYWRkaW5nOiBOdW1iZXIgPSAwLjFcblx0XHQvLyBIb3cgbXVjaCB0byBleHRlbmQgdGhlIGNsaXAgYXJlYSBhcm91bmQgdGhlIG1hcCB2aWV3IChyZWxhdGl2ZSB0byBpdHMgc2l6ZSlcblx0XHQvLyBlLmcuIDAuMSB3b3VsZCBiZSAxMCUgb2YgbWFwIHZpZXcgaW4gZWFjaCBkaXJlY3Rpb25cblx0XHRwYWRkaW5nOiAwLjFcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHRVdGlsLnN0YW1wKHRoaXMpO1xuXHRcdHRoaXMuX2xheWVycyA9IHRoaXMuX2xheWVycyB8fCB7fTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7IC8vIGRlZmluZWQgYnkgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zXG5cblx0XHRcdC8vIGFsd2F5cyBrZWVwIHRyYW5zZm9ybS1vcmlnaW4gYXMgMCAwXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xuXHRcdH1cblxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdFx0dGhpcy5vbigndXBkYXRlJywgdGhpcy5fdXBkYXRlUGF0aHMsIHRoaXMpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5vZmYoJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZVBhdGhzLCB0aGlzKTtcblx0XHR0aGlzLl9kZXN0cm95Q29udGFpbmVyKCk7XG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IHtcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXQsXG5cdFx0XHR6b29tOiB0aGlzLl9vblpvb20sXG5cdFx0XHRtb3ZlZW5kOiB0aGlzLl91cGRhdGUsXG5cdFx0XHR6b29tZW5kOiB0aGlzLl9vblpvb21FbmRcblx0XHR9O1xuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX29uQW5pbVpvb207XG5cdFx0fVxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X29uQW5pbVpvb206IGZ1bmN0aW9uIChldikge1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybShldi5jZW50ZXIsIGV2Lnpvb20pO1xuXHR9LFxuXG5cdF9vblpvb206IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0odGhpcy5fbWFwLmdldENlbnRlcigpLCB0aGlzLl9tYXAuZ2V0Wm9vbSgpKTtcblx0fSxcblxuXHRfdXBkYXRlVHJhbnNmb3JtOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh6b29tLCB0aGlzLl96b29tKSxcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLm11bHRpcGx5QnkoMC41ICsgdGhpcy5vcHRpb25zLnBhZGRpbmcpLFxuXHRcdCAgICBjdXJyZW50Q2VudGVyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdCh0aGlzLl9jZW50ZXIsIHpvb20pLFxuXG5cdFx0ICAgIHRvcExlZnRPZmZzZXQgPSB2aWV3SGFsZi5tdWx0aXBseUJ5KC1zY2FsZSkuYWRkKGN1cnJlbnRDZW50ZXJQb2ludClcblx0XHRcdFx0ICAuc3VidHJhY3QodGhpcy5fbWFwLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pKTtcblxuXHRcdGlmIChCcm93c2VyLmFueTNkKSB7XG5cdFx0XHREb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9jb250YWluZXIsIHRvcExlZnRPZmZzZXQsIHNjYWxlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHRvcExlZnRPZmZzZXQpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0odGhpcy5fY2VudGVyLCB0aGlzLl96b29tKTtcblxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fcmVzZXQoKTtcblx0XHR9XG5cdH0sXG5cblx0X29uWm9vbUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fcHJvamVjdCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUGF0aHM6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3VwZGF0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVXBkYXRlIHBpeGVsIGJvdW5kcyBvZiByZW5kZXJlciBjb250YWluZXIgKGZvciBwb3NpdGlvbmluZy9zaXppbmcvY2xpcHBpbmcgbGF0ZXIpXG5cdFx0Ly8gU3ViY2xhc3NlcyBhcmUgcmVzcG9uc2libGUgb2YgZmlyaW5nIHRoZSAndXBkYXRlJyBldmVudC5cblx0XHR2YXIgcCA9IHRoaXMub3B0aW9ucy5wYWRkaW5nLFxuXHRcdCAgICBzaXplID0gdGhpcy5fbWFwLmdldFNpemUoKSxcblx0XHQgICAgbWluID0gdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHNpemUubXVsdGlwbHlCeSgtcCkpLnJvdW5kKCk7XG5cblx0XHR0aGlzLl9ib3VuZHMgPSBuZXcgQm91bmRzKG1pbiwgbWluLmFkZChzaXplLm11bHRpcGx5QnkoMSArIHAgKiAyKSkucm91bmQoKSk7XG5cblx0XHR0aGlzLl9jZW50ZXIgPSB0aGlzLl9tYXAuZ2V0Q2VudGVyKCk7XG5cdFx0dGhpcy5fem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG5cdH1cbn0pO1xuIiwiaW1wb3J0IHtSZW5kZXJlcn0gZnJvbSAnLi9SZW5kZXJlcic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cbi8qXG4gKiBAY2xhc3MgQ2FudmFzXG4gKiBAaW5oZXJpdHMgUmVuZGVyZXJcbiAqIEBha2EgTC5DYW52YXNcbiAqXG4gKiBBbGxvd3MgdmVjdG9yIGxheWVycyB0byBiZSBkaXNwbGF5ZWQgd2l0aCBbYDxjYW52YXM+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc19BUEkpLlxuICogSW5oZXJpdHMgYFJlbmRlcmVyYC5cbiAqXG4gKiBEdWUgdG8gW3RlY2huaWNhbCBsaW1pdGF0aW9uc10oaHR0cHM6Ly9jYW5pdXNlLmNvbS9jYW52YXMpLCBDYW52YXMgaXMgbm90XG4gKiBhdmFpbGFibGUgaW4gYWxsIHdlYiBicm93c2Vycywgbm90YWJseSBJRTgsIGFuZCBvdmVybGFwcGluZyBnZW9tZXRyaWVzIG1pZ2h0XG4gKiBub3QgZGlzcGxheSBwcm9wZXJseSBpbiBzb21lIGVkZ2UgY2FzZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBVc2UgQ2FudmFzIGJ5IGRlZmF1bHQgZm9yIGFsbCBwYXRocyBpbiB0aGUgbWFwOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcbiAqIFx0cmVuZGVyZXI6IEwuY2FudmFzKClcbiAqIH0pO1xuICogYGBgXG4gKlxuICogVXNlIGEgQ2FudmFzIHJlbmRlcmVyIHdpdGggZXh0cmEgcGFkZGluZyBmb3Igc3BlY2lmaWMgdmVjdG9yIGdlb21ldHJpZXM6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJyk7XG4gKiB2YXIgbXlSZW5kZXJlciA9IEwuY2FudmFzKHsgcGFkZGluZzogMC41IH0pO1xuICogdmFyIGxpbmUgPSBMLnBvbHlsaW5lKCBjb29yZGluYXRlcywgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiB2YXIgY2lyY2xlID0gTC5jaXJjbGUoIGNlbnRlciwgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIENhbnZhcyA9IFJlbmRlcmVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBDYW52YXMgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiB0b2xlcmFuY2U6IE51bWJlciA9IDBcblx0XHQvLyBIb3cgbXVjaCB0byBleHRlbmQgdGhlIGNsaWNrIHRvbGVyYW5jZSBhcm91bmQgYSBwYXRoL29iamVjdCBvbiB0aGUgbWFwLlxuXHRcdHRvbGVyYW5jZTogMFxuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSBSZW5kZXJlci5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG5cdFx0ZXZlbnRzLnZpZXdwcmVyZXNldCA9IHRoaXMuX29uVmlld1ByZVJlc2V0O1xuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X29uVmlld1ByZVJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gU2V0IGEgZmxhZyBzbyB0aGF0IGEgdmlld3ByZXJlc2V0K21vdmVlbmQrdmlld3Jlc2V0IG9ubHkgdXBkYXRlcyZyZWRyYXdzIG9uY2Vcblx0XHR0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzID0gdHJ1ZTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMpO1xuXG5cdFx0Ly8gUmVkcmF3IHZlY3RvcnMgc2luY2UgY2FudmFzIGlzIGNsZWFyZWQgdXBvbiByZW1vdmFsLFxuXHRcdC8vIGluIGNhc2Ugb2YgcmVtb3ZpbmcgdGhlIHJlbmRlcmVyIGl0c2VsZiBmcm9tIHRoZSBtYXAuXG5cdFx0dGhpcy5fZHJhdygpO1xuXHR9LFxuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpO1xuXHRcdERvbUV2ZW50Lm9uKGNvbnRhaW5lciwgJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIGNvbnRleHRtZW51JywgdGhpcy5fb25DbGljaywgdGhpcyk7XG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnbW91c2VvdXQnLCB0aGlzLl9oYW5kbGVNb3VzZU91dCwgdGhpcyk7XG5cdFx0Y29udGFpbmVyWydfbGVhZmxldF9kaXNhYmxlX2V2ZW50cyddID0gdHJ1ZTtcblxuXHRcdHRoaXMuX2N0eCA9IGNvbnRhaW5lci5nZXRDb250ZXh0KCcyZCcpO1xuXHR9LFxuXG5cdF9kZXN0cm95Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fcmVkcmF3UmVxdWVzdCk7XG5cdFx0ZGVsZXRlIHRoaXMuX2N0eDtcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIpO1xuXHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGhzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbGF5ZXI7XG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcblx0XHRcdGxheWVyLl91cGRhdGUoKTtcblx0XHR9XG5cdFx0dGhpcy5fcmVkcmF3KCk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20gJiYgdGhpcy5fYm91bmRzKSB7IHJldHVybjsgfVxuXG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuXHRcdHZhciBiID0gdGhpcy5fYm91bmRzLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsXG5cdFx0ICAgIHNpemUgPSBiLmdldFNpemUoKSxcblx0XHQgICAgbSA9IEJyb3dzZXIucmV0aW5hID8gMiA6IDE7XG5cblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXG5cdFx0Ly8gc2V0IGNhbnZhcyBzaXplIChhbHNvIGNsZWFyaW5nIGl0KTsgdXNlIGRvdWJsZSBzaXplIG9uIHJldGluYVxuXHRcdGNvbnRhaW5lci53aWR0aCA9IG0gKiBzaXplLng7XG5cdFx0Y29udGFpbmVyLmhlaWdodCA9IG0gKiBzaXplLnk7XG5cdFx0Y29udGFpbmVyLnN0eWxlLndpZHRoID0gc2l6ZS54ICsgJ3B4Jztcblx0XHRjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcblxuXHRcdGlmIChCcm93c2VyLnJldGluYSkge1xuXHRcdFx0dGhpcy5fY3R4LnNjYWxlKDIsIDIpO1xuXHRcdH1cblxuXHRcdC8vIHRyYW5zbGF0ZSBzbyB3ZSB1c2UgdGhlIHNhbWUgcGF0aCBjb29yZGluYXRlcyBhZnRlciBjYW52YXMgZWxlbWVudCBtb3Zlc1xuXHRcdHRoaXMuX2N0eC50cmFuc2xhdGUoLWIubWluLngsIC1iLm1pbi55KTtcblxuXHRcdC8vIFRlbGwgcGF0aHMgdG8gcmVkcmF3IHRoZW1zZWx2ZXNcblx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fcmVzZXQuY2FsbCh0aGlzKTtcblxuXHRcdGlmICh0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzKSB7XG5cdFx0XHR0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzID0gZmFsc2U7XG5cdFx0XHR0aGlzLl91cGRhdGVQYXRocygpO1xuXHRcdH1cblx0fSxcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3VwZGF0ZURhc2hBcnJheShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXG5cdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyID0ge1xuXHRcdFx0bGF5ZXI6IGxheWVyLFxuXHRcdFx0cHJldjogdGhpcy5fZHJhd0xhc3QsXG5cdFx0XHRuZXh0OiBudWxsXG5cdFx0fTtcblx0XHRpZiAodGhpcy5fZHJhd0xhc3QpIHsgdGhpcy5fZHJhd0xhc3QubmV4dCA9IG9yZGVyOyB9XG5cdFx0dGhpcy5fZHJhd0xhc3QgPSBvcmRlcjtcblx0XHR0aGlzLl9kcmF3Rmlyc3QgPSB0aGlzLl9kcmF3Rmlyc3QgfHwgdGhpcy5fZHJhd0xhc3Q7XG5cdH0sXG5cblx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG5cdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuXHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuXHRcdGlmIChuZXh0KSB7XG5cdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG5cdFx0fVxuXHRcdGlmIChwcmV2KSB7XG5cdFx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9kcmF3Rmlyc3QgPSBuZXh0O1xuXHRcdH1cblxuXHRcdGRlbGV0ZSBsYXllci5fb3JkZXI7XG5cblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXTtcblxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHQvLyBSZWRyYXcgdGhlIHVuaW9uIG9mIHRoZSBsYXllcidzIG9sZCBwaXhlbFxuXHRcdC8vIGJvdW5kcyBhbmQgdGhlIG5ldyBwaXhlbCBib3VuZHMuXG5cdFx0dGhpcy5fZXh0ZW5kUmVkcmF3Qm91bmRzKGxheWVyKTtcblx0XHRsYXllci5fcHJvamVjdCgpO1xuXHRcdGxheWVyLl91cGRhdGUoKTtcblx0XHQvLyBUaGUgcmVkcmF3IHdpbGwgZXh0ZW5kIHRoZSByZWRyYXcgYm91bmRzXG5cdFx0Ly8gd2l0aCB0aGUgbmV3IHBpeGVsIGJvdW5kcy5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3VwZGF0ZURhc2hBcnJheShsYXllcik7XG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3VwZGF0ZURhc2hBcnJheTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKHR5cGVvZiBsYXllci5vcHRpb25zLmRhc2hBcnJheSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHZhciBwYXJ0cyA9IGxheWVyLm9wdGlvbnMuZGFzaEFycmF5LnNwbGl0KC9bLCBdKy8pLFxuXHRcdFx0ICAgIGRhc2hBcnJheSA9IFtdLFxuXHRcdFx0ICAgIGRhc2hWYWx1ZSxcblx0XHRcdCAgICBpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRhc2hWYWx1ZSA9IE51bWJlcihwYXJ0c1tpXSk7XG5cdFx0XHRcdC8vIElnbm9yZSBkYXNoIGFycmF5IGNvbnRhaW5pbmcgaW52YWxpZCBsZW5ndGhzXG5cdFx0XHRcdGlmIChpc05hTihkYXNoVmFsdWUpKSB7IHJldHVybjsgfVxuXHRcdFx0XHRkYXNoQXJyYXkucHVzaChkYXNoVmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0bGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5ID0gZGFzaEFycmF5O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgPSBsYXllci5vcHRpb25zLmRhc2hBcnJheTtcblx0XHR9XG5cdH0sXG5cblx0X3JlcXVlc3RSZWRyYXc6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZXh0ZW5kUmVkcmF3Qm91bmRzKGxheWVyKTtcblx0XHR0aGlzLl9yZWRyYXdSZXF1ZXN0ID0gdGhpcy5fcmVkcmF3UmVxdWVzdCB8fCBVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fcmVkcmF3LCB0aGlzKTtcblx0fSxcblxuXHRfZXh0ZW5kUmVkcmF3Qm91bmRzOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAobGF5ZXIuX3B4Qm91bmRzKSB7XG5cdFx0XHR2YXIgcGFkZGluZyA9IChsYXllci5vcHRpb25zLndlaWdodCB8fCAwKSArIDE7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHMgfHwgbmV3IEJvdW5kcygpO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLmV4dGVuZChsYXllci5fcHhCb3VuZHMubWluLnN1YnRyYWN0KFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLmV4dGVuZChsYXllci5fcHhCb3VuZHMubWF4LmFkZChbcGFkZGluZywgcGFkZGluZ10pKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSBudWxsO1xuXG5cdFx0aWYgKHRoaXMuX3JlZHJhd0JvdW5kcykge1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLm1pbi5fZmxvb3IoKTtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5tYXguX2NlaWwoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9jbGVhcigpOyAvLyBjbGVhciBsYXllcnMgaW4gcmVkcmF3IGJvdW5kc1xuXHRcdHRoaXMuX2RyYXcoKTsgLy8gZHJhdyBsYXllcnNcblxuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG5cdH0sXG5cblx0X2NsZWFyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcztcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR2YXIgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cdFx0XHR0aGlzLl9jdHguY2xlYXJSZWN0KGJvdW5kcy5taW4ueCwgYm91bmRzLm1pbi55LCBzaXplLngsIHNpemUueSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2N0eC5zYXZlKCk7XG5cdFx0XHR0aGlzLl9jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdFx0dGhpcy5fY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl9jb250YWluZXIud2lkdGgsIHRoaXMuX2NvbnRhaW5lci5oZWlnaHQpO1xuXHRcdFx0dGhpcy5fY3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbGF5ZXIsIGJvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcztcblx0XHR0aGlzLl9jdHguc2F2ZSgpO1xuXHRcdGlmIChib3VuZHMpIHtcblx0XHRcdHZhciBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblx0XHRcdHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcblx0XHRcdHRoaXMuX2N0eC5yZWN0KGJvdW5kcy5taW4ueCwgYm91bmRzLm1pbi55LCBzaXplLngsIHNpemUueSk7XG5cdFx0XHR0aGlzLl9jdHguY2xpcCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RyYXdpbmcgPSB0cnVlO1xuXG5cdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG5cdFx0XHRpZiAoIWJvdW5kcyB8fCAobGF5ZXIuX3B4Qm91bmRzICYmIGxheWVyLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpKSB7XG5cdFx0XHRcdGxheWVyLl91cGRhdGVQYXRoKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhd2luZyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fY3R4LnJlc3RvcmUoKTsgIC8vIFJlc3RvcmUgc3RhdGUgYmVmb3JlIGNsaXBwaW5nLlxuXHR9LFxuXG5cdF91cGRhdGVQb2x5OiBmdW5jdGlvbiAobGF5ZXIsIGNsb3NlZCkge1xuXHRcdGlmICghdGhpcy5fZHJhd2luZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBpLCBqLCBsZW4yLCBwLFxuXHRcdCAgICBwYXJ0cyA9IGxheWVyLl9wYXJ0cyxcblx0XHQgICAgbGVuID0gcGFydHMubGVuZ3RoLFxuXHRcdCAgICBjdHggPSB0aGlzLl9jdHg7XG5cblx0XHRpZiAoIWxlbikgeyByZXR1cm47IH1cblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnRzW2ldLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuXHRcdFx0XHRwID0gcGFydHNbaV1bal07XG5cdFx0XHRcdGN0eFtqID8gJ2xpbmVUbycgOiAnbW92ZVRvJ10ocC54LCBwLnkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmlsbFN0cm9rZShjdHgsIGxheWVyKTtcblxuXHRcdC8vIFRPRE8gb3B0aW1pemF0aW9uOiAxIGZpbGwvc3Ryb2tlIGZvciBhbGwgZmVhdHVyZXMgd2l0aCBlcXVhbCBzdHlsZSBpbnN0ZWFkIG9mIDEgZm9yIGVhY2ggZmVhdHVyZVxuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXG5cdFx0aWYgKCF0aGlzLl9kcmF3aW5nIHx8IGxheWVyLl9lbXB0eSgpKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQsXG5cdFx0ICAgIGN0eCA9IHRoaXMuX2N0eCxcblx0XHQgICAgciA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksIDEpLFxuXHRcdCAgICBzID0gKE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kpLCAxKSB8fCByKSAvIHI7XG5cblx0XHRpZiAocyAhPT0gMSkge1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC5zY2FsZSgxLCBzKTtcblx0XHR9XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LmFyYyhwLngsIHAueSAvIHMsIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG5cblx0XHRpZiAocyAhPT0gMSkge1xuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuXHR9LFxuXG5cdF9maWxsU3Ryb2tlOiBmdW5jdGlvbiAoY3R4LCBsYXllcikge1xuXHRcdHZhciBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcblx0XHRcdGN0eC5maWxsKG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UgJiYgb3B0aW9ucy53ZWlnaHQgIT09IDApIHtcblx0XHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGxheWVyLm9wdGlvbnMgJiYgbGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5IHx8IFtdKTtcblx0XHRcdH1cblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wdGlvbnMub3BhY2l0eTtcblx0XHRcdGN0eC5saW5lV2lkdGggPSBvcHRpb25zLndlaWdodDtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRjdHgubGluZUNhcCA9IG9wdGlvbnMubGluZUNhcDtcblx0XHRcdGN0eC5saW5lSm9pbiA9IG9wdGlvbnMubGluZUpvaW47XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIENhbnZhcyBvYnZpb3VzbHkgZG9lc24ndCBoYXZlIG1vdXNlIGV2ZW50cyBmb3IgaW5kaXZpZHVhbCBkcmF3biBvYmplY3RzLFxuXHQvLyBzbyB3ZSBlbXVsYXRlIHRoYXQgYnkgY2FsY3VsYXRpbmcgd2hhdCdzIHVuZGVyIHRoZSBtb3VzZSBvbiBtb3VzZW1vdmUvY2xpY2sgbWFudWFsbHlcblxuXHRfb25DbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSwgbGF5ZXIsIGNsaWNrZWRMYXllcjtcblxuXHRcdGZvciAodmFyIG9yZGVyID0gdGhpcy5fZHJhd0ZpcnN0OyBvcmRlcjsgb3JkZXIgPSBvcmRlci5uZXh0KSB7XG5cdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG5cdFx0XHRcdGlmICghKGUudHlwZSA9PT0gJ2NsaWNrJyB8fCBlLnR5cGUgPT09ICdwcmVjbGljaycpIHx8ICF0aGlzLl9tYXAuX2RyYWdnYWJsZU1vdmVkKGxheWVyKSkge1xuXHRcdFx0XHRcdGNsaWNrZWRMYXllciA9IGxheWVyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX2ZpcmVFdmVudChjbGlja2VkTGF5ZXIgPyBbY2xpY2tlZExheWVyXSA6IGZhbHNlLCBlKTtcblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXAgfHwgdGhpcy5fbWFwLmRyYWdnaW5nLm1vdmluZygpIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBwb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpO1xuXHRcdHRoaXMuX2hhbmRsZU1vdXNlSG92ZXIoZSwgcG9pbnQpO1xuXHR9LFxuXG5cblx0X2hhbmRsZU1vdXNlT3V0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IHRoaXMuX2hvdmVyZWRMYXllcjtcblx0XHRpZiAobGF5ZXIpIHtcblx0XHRcdC8vIGlmIHdlJ3JlIGxlYXZpbmcgdGhlIGxheWVyLCBmaXJlIG1vdXNlb3V0XG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcblx0XHRcdHRoaXMuX2ZpcmVFdmVudChbbGF5ZXJdLCBlLCAnbW91c2VvdXQnKTtcblx0XHRcdHRoaXMuX2hvdmVyZWRMYXllciA9IG51bGw7XG5cdFx0XHR0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkID0gZmFsc2U7XG5cdFx0fVxuXHR9LFxuXG5cdF9oYW5kbGVNb3VzZUhvdmVyOiBmdW5jdGlvbiAoZSwgcG9pbnQpIHtcblx0XHRpZiAodGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBsYXllciwgY2FuZGlkYXRlSG92ZXJlZExheWVyO1xuXG5cdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG5cdFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpIHtcblx0XHRcdFx0Y2FuZGlkYXRlSG92ZXJlZExheWVyID0gbGF5ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllciAhPT0gdGhpcy5faG92ZXJlZExheWVyKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVNb3VzZU91dChlKTtcblxuXHRcdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllcikge1xuXHRcdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTsgLy8gY2hhbmdlIGN1cnNvclxuXHRcdFx0XHR0aGlzLl9maXJlRXZlbnQoW2NhbmRpZGF0ZUhvdmVyZWRMYXllcl0sIGUsICdtb3VzZW92ZXInKTtcblx0XHRcdFx0dGhpcy5faG92ZXJlZExheWVyID0gY2FuZGlkYXRlSG92ZXJlZExheWVyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2ZpcmVFdmVudCh0aGlzLl9ob3ZlcmVkTGF5ZXIgPyBbdGhpcy5faG92ZXJlZExheWVyXSA6IGZhbHNlLCBlKTtcblxuXHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSB0cnVlO1xuXHRcdHNldFRpbWVvdXQoVXRpbC5iaW5kKGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSBmYWxzZTtcblx0XHR9LCB0aGlzKSwgMzIpO1xuXHR9LFxuXG5cdF9maXJlRXZlbnQ6IGZ1bmN0aW9uIChsYXllcnMsIGUsIHR5cGUpIHtcblx0XHR0aGlzLl9tYXAuX2ZpcmVET01FdmVudChlLCB0eXBlIHx8IGUudHlwZSwgbGF5ZXJzKTtcblx0fSxcblxuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG5cblx0XHRpZiAoIW9yZGVyKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuXHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuXHRcdGlmIChuZXh0KSB7XG5cdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBBbHJlYWR5IGxhc3Rcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIGlmIChuZXh0KSB7XG5cdFx0XHQvLyBVcGRhdGUgZmlyc3QgZW50cnkgdW5sZXNzIHRoaXMgaXMgdGhlXG5cdFx0XHQvLyBzaW5nbGUgZW50cnlcblx0XHRcdHRoaXMuX2RyYXdGaXJzdCA9IG5leHQ7XG5cdFx0fVxuXG5cdFx0b3JkZXIucHJldiA9IHRoaXMuX2RyYXdMYXN0O1xuXHRcdHRoaXMuX2RyYXdMYXN0Lm5leHQgPSBvcmRlcjtcblxuXHRcdG9yZGVyLm5leHQgPSBudWxsO1xuXHRcdHRoaXMuX2RyYXdMYXN0ID0gb3JkZXI7XG5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblxuXHRcdGlmICghb3JkZXIpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEFscmVhZHkgZmlyc3Rcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIGlmIChwcmV2KSB7XG5cdFx0XHQvLyBVcGRhdGUgbGFzdCBlbnRyeSB1bmxlc3MgdGhpcyBpcyB0aGVcblx0XHRcdC8vIHNpbmdsZSBlbnRyeVxuXHRcdFx0dGhpcy5fZHJhd0xhc3QgPSBwcmV2O1xuXHRcdH1cblxuXHRcdG9yZGVyLnByZXYgPSBudWxsO1xuXG5cdFx0b3JkZXIubmV4dCA9IHRoaXMuX2RyYXdGaXJzdDtcblx0XHR0aGlzLl9kcmF3Rmlyc3QucHJldiA9IG9yZGVyO1xuXHRcdHRoaXMuX2RyYXdGaXJzdCA9IG9yZGVyO1xuXG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmNhbnZhcyhvcHRpb25zPzogUmVuZGVyZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBjYW52YXMob3B0aW9ucykge1xuXHRyZXR1cm4gQnJvd3Nlci5jYW52YXMgPyBuZXcgQ2FudmFzKG9wdGlvbnMpIDogbnVsbDtcbn1cbiIsImltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHtSZW5kZXJlcn0gZnJvbSAnLi9SZW5kZXJlcic7XG5cbi8qXG4gKiBUaGFua3MgdG8gRG1pdHJ5IEJhcmFub3Zza3kgYW5kIGhpcyBSYXBoYWVsIGxpYnJhcnkgZm9yIGluc3BpcmF0aW9uIVxuICovXG5cblxuZXhwb3J0IHZhciB2bWxDcmVhdGUgPSAoZnVuY3Rpb24gKCkge1xuXHR0cnkge1xuXHRcdGRvY3VtZW50Lm5hbWVzcGFjZXMuYWRkKCdsdm1sJywgJ3VybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sJyk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGx2bWw6JyArIG5hbWUgKyAnIGNsYXNzPVwibHZtbFwiPicpO1xuXHRcdH07XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBEbyBub3QgcmV0dXJuIGZuIGZyb20gY2F0Y2ggYmxvY2sgc28gYGVgIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L3B1bGwvNzI3OVxuXHR9XG5cdHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8JyArIG5hbWUgKyAnIHhtbG5zPVwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LmNvbTp2bWxcIiBjbGFzcz1cImx2bWxcIj4nKTtcblx0fTtcbn0pKCk7XG5cblxuLypcbiAqIEBjbGFzcyBTVkdcbiAqXG4gKlxuICogVk1MIHdhcyBkZXByZWNhdGVkIGluIDIwMTIsIHdoaWNoIG1lYW5zIFZNTCBmdW5jdGlvbmFsaXR5IGV4aXN0cyBvbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICogd2l0aCBvbGQgdmVyc2lvbnMgb2YgSW50ZXJuZXQgRXhwbG9yZXIuXG4gKi9cblxuLy8gbWl4aW4gdG8gcmVkZWZpbmUgc29tZSBTVkcgbWV0aG9kcyB0byBoYW5kbGUgVk1MIHN5bnRheCB3aGljaCBpcyBzaW1pbGFyIGJ1dCB3aXRoIHNvbWUgZGlmZmVyZW5jZXNcbmV4cG9ydCB2YXIgdm1sTWl4aW4gPSB7XG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtdm1sLWNvbnRhaW5lcicpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0fSxcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyID0gdm1sQ3JlYXRlKCdzaGFwZScpO1xuXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXZtbC1zaGFwZSAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblxuXHRcdGNvbnRhaW5lci5jb29yZHNpemUgPSAnMSAxJztcblxuXHRcdGxheWVyLl9wYXRoID0gdm1sQ3JlYXRlKCdwYXRoJyk7XG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblxuXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKGxheWVyKTtcblx0XHR0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildID0gbGF5ZXI7XG5cdH0sXG5cblx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXHRcdHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcblx0XHRcdGxheWVyLmFkZEludGVyYWN0aXZlVGFyZ2V0KGNvbnRhaW5lcik7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblx0XHREb21VdGlsLnJlbW92ZShjb250YWluZXIpO1xuXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGNvbnRhaW5lcik7XG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tVdGlsLnN0YW1wKGxheWVyKV07XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgc3Ryb2tlID0gbGF5ZXIuX3N0cm9rZSxcblx0XHQgICAgZmlsbCA9IGxheWVyLl9maWxsLFxuXHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucyxcblx0XHQgICAgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblxuXHRcdGNvbnRhaW5lci5zdHJva2VkID0gISFvcHRpb25zLnN0cm9rZTtcblx0XHRjb250YWluZXIuZmlsbGVkID0gISFvcHRpb25zLmZpbGw7XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcblx0XHRcdGlmICghc3Ryb2tlKSB7XG5cdFx0XHRcdHN0cm9rZSA9IGxheWVyLl9zdHJva2UgPSB2bWxDcmVhdGUoJ3N0cm9rZScpO1xuXHRcdFx0fVxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHN0cm9rZSk7XG5cdFx0XHRzdHJva2Uud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQgKyAncHgnO1xuXHRcdFx0c3Ryb2tlLmNvbG9yID0gb3B0aW9ucy5jb2xvcjtcblx0XHRcdHN0cm9rZS5vcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5O1xuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9IFV0aWwuaXNBcnJheShvcHRpb25zLmRhc2hBcnJheSkgP1xuXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkuam9pbignICcpIDpcblx0XHRcdFx0ICAgIG9wdGlvbnMuZGFzaEFycmF5LnJlcGxhY2UoLyggKiwgKikvZywgJyAnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSAnJztcblx0XHRcdH1cblx0XHRcdHN0cm9rZS5lbmRjYXAgPSBvcHRpb25zLmxpbmVDYXAucmVwbGFjZSgnYnV0dCcsICdmbGF0Jyk7XG5cdFx0XHRzdHJva2Uuam9pbnN0eWxlID0gb3B0aW9ucy5saW5lSm9pbjtcblxuXHRcdH0gZWxzZSBpZiAoc3Ryb2tlKSB7XG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoc3Ryb2tlKTtcblx0XHRcdGxheWVyLl9zdHJva2UgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdGlmICghZmlsbCkge1xuXHRcdFx0XHRmaWxsID0gbGF5ZXIuX2ZpbGwgPSB2bWxDcmVhdGUoJ2ZpbGwnKTtcblx0XHRcdH1cblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChmaWxsKTtcblx0XHRcdGZpbGwuY29sb3IgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xuXHRcdFx0ZmlsbC5vcGFjaXR5ID0gb3B0aW9ucy5maWxsT3BhY2l0eTtcblxuXHRcdH0gZWxzZSBpZiAoZmlsbCkge1xuXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKGZpbGwpO1xuXHRcdFx0bGF5ZXIuX2ZpbGwgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludC5yb3VuZCgpLFxuXHRcdCAgICByID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSxcblx0XHQgICAgcjIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZIHx8IHIpO1xuXG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuXHRcdFx0J0FMICcgKyBwLnggKyAnLCcgKyBwLnkgKyAnICcgKyByICsgJywnICsgcjIgKyAnIDAsJyArICg2NTUzNSAqIDM2MCkpO1xuXHR9LFxuXG5cdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcblx0XHRsYXllci5fcGF0aC52ID0gcGF0aDtcblx0fSxcblxuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnRvRnJvbnQobGF5ZXIuX2NvbnRhaW5lcik7XG5cdH0sXG5cblx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnRvQmFjayhsYXllci5fY29udGFpbmVyKTtcblx0fVxufTtcbiIsImltcG9ydCB7UmVuZGVyZXJ9IGZyb20gJy4vUmVuZGVyZXInO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCB7c3RhbXB9IGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge3N2Z0NyZWF0ZSwgcG9pbnRzVG9QYXRofSBmcm9tICcuL1NWRy5VdGlsJztcbmV4cG9ydCB7cG9pbnRzVG9QYXRofTtcbmltcG9ydCB7dm1sTWl4aW4sIHZtbENyZWF0ZX0gZnJvbSAnLi9TVkcuVk1MJztcblxuZXhwb3J0IHZhciBjcmVhdGUgPSBCcm93c2VyLnZtbCA/IHZtbENyZWF0ZSA6IHN2Z0NyZWF0ZTtcblxuLypcbiAqIEBjbGFzcyBTVkdcbiAqIEBpbmhlcml0cyBSZW5kZXJlclxuICogQGFrYSBMLlNWR1xuICpcbiAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXG4gKiBJbmhlcml0cyBgUmVuZGVyZXJgLlxuICpcbiAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwczovL2Nhbml1c2UuY29tL3N2ZyksIFNWRyBpcyBub3RcbiAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IEFuZHJvaWQgMi54IGFuZCAzLnguXG4gKlxuICogQWx0aG91Z2ggU1ZHIGlzIG5vdCBhdmFpbGFibGUgb24gSUU3IGFuZCBJRTgsIHRoZXNlIGJyb3dzZXJzIHN1cHBvcnRcbiAqIFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpXG4gKiAoYSBub3cgZGVwcmVjYXRlZCB0ZWNobm9sb2d5KSwgYW5kIHRoZSBTVkcgcmVuZGVyZXIgd2lsbCBmYWxsIGJhY2sgdG8gVk1MIGluXG4gKiB0aGlzIGNhc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBVc2UgU1ZHIGJ5IGRlZmF1bHQgZm9yIGFsbCBwYXRocyBpbiB0aGUgbWFwOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcbiAqIFx0cmVuZGVyZXI6IEwuc3ZnKClcbiAqIH0pO1xuICogYGBgXG4gKlxuICogVXNlIGEgU1ZHIHJlbmRlcmVyIHdpdGggZXh0cmEgcGFkZGluZyBmb3Igc3BlY2lmaWMgdmVjdG9yIGdlb21ldHJpZXM6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJyk7XG4gKiB2YXIgbXlSZW5kZXJlciA9IEwuc3ZnKHsgcGFkZGluZzogMC41IH0pO1xuICogdmFyIGxpbmUgPSBMLnBvbHlsaW5lKCBjb29yZGluYXRlcywgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiB2YXIgY2lyY2xlID0gTC5jaXJjbGUoIGNlbnRlciwgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIFNWRyA9IFJlbmRlcmVyLmV4dGVuZCh7XG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jb250YWluZXIgPSBjcmVhdGUoJ3N2ZycpO1xuXG5cdFx0Ly8gbWFrZXMgaXQgcG9zc2libGUgdG8gY2xpY2sgdGhyb3VnaCBzdmcgcm9vdDsgd2UnbGwgcmVzZXQgaXQgYmFjayBpbiBpbmRpdmlkdWFsIHBhdGhzXG5cdFx0dGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xuXG5cdFx0dGhpcy5fcm9vdEdyb3VwID0gY3JlYXRlKCdnJyk7XG5cdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3Jvb3RHcm91cCk7XG5cdH0sXG5cblx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIpO1xuXHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG5cdFx0ZGVsZXRlIHRoaXMuX3Jvb3RHcm91cDtcblx0XHRkZWxldGUgdGhpcy5fc3ZnU2l6ZTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHsgcmV0dXJuOyB9XG5cblx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG5cdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG5cdFx0ICAgIHNpemUgPSBiLmdldFNpemUoKSxcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuXG5cdFx0Ly8gc2V0IHNpemUgb2Ygc3ZnLWNvbnRhaW5lciBpZiBjaGFuZ2VkXG5cdFx0aWYgKCF0aGlzLl9zdmdTaXplIHx8ICF0aGlzLl9zdmdTaXplLmVxdWFscyhzaXplKSkge1xuXHRcdFx0dGhpcy5fc3ZnU2l6ZSA9IHNpemU7XG5cdFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHNpemUueCk7XG5cdFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBzaXplLnkpO1xuXHRcdH1cblxuXHRcdC8vIG1vdmVtZW50OiB1cGRhdGUgY29udGFpbmVyIHZpZXdCb3ggc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGNoYW5nZSBjb29yZGluYXRlcyBvZiBpbmRpdmlkdWFsIGxheWVyc1xuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG5cdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgndmlld0JveCcsIFtiLm1pbi54LCBiLm1pbi55LCBzaXplLngsIHNpemUueV0uam9pbignICcpKTtcblxuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0Ly8gbWV0aG9kcyBiZWxvdyBhcmUgY2FsbGVkIGJ5IHZlY3RvciBsYXllcnMgaW1wbGVtZW50YXRpb25zXG5cblx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoID0gY3JlYXRlKCdwYXRoJyk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIFBhdGhcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEN1c3RvbSBjbGFzcyBuYW1lIHNldCBvbiBhbiBlbGVtZW50LiBPbmx5IGZvciBTVkcgcmVuZGVyZXIuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuY2xhc3NOYW1lKSB7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHBhdGgsIGxheWVyLm9wdGlvbnMuY2xhc3NOYW1lKTtcblx0XHR9XG5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYXRoLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKGxheWVyKTtcblx0XHR0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHR9LFxuXG5cdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoIXRoaXMuX3Jvb3RHcm91cCkgeyB0aGlzLl9pbml0Q29udGFpbmVyKCk7IH1cblx0XHR0aGlzLl9yb290R3JvdXAuYXBwZW5kQ2hpbGQobGF5ZXIuX3BhdGgpO1xuXHRcdGxheWVyLmFkZEludGVyYWN0aXZlVGFyZ2V0KGxheWVyLl9wYXRoKTtcblx0fSxcblxuXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmUobGF5ZXIuX3BhdGgpO1xuXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGxheWVyLl9wYXRoKTtcblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV07XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGxheWVyLl9wcm9qZWN0KCk7XG5cdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHBhdGggPSBsYXllci5fcGF0aCxcblx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XG5cblx0XHRpZiAoIXBhdGgpIHsgcmV0dXJuOyB9XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCBvcHRpb25zLmNvbG9yKTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utb3BhY2l0eScsIG9wdGlvbnMub3BhY2l0eSk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgb3B0aW9ucy53ZWlnaHQpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgb3B0aW9ucy5saW5lQ2FwKTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWpvaW4nLCBvcHRpb25zLmxpbmVKb2luKTtcblxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XG5cdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jywgb3B0aW9ucy5kYXNoQXJyYXkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGF0aC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaE9mZnNldCkge1xuXHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnLCBvcHRpb25zLmRhc2hPZmZzZXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGF0aC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCAnbm9uZScpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcik7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1vcGFjaXR5Jywgb3B0aW9ucy5maWxsT3BhY2l0eSk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1ydWxlJywgb3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJyk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQb2x5OiBmdW5jdGlvbiAobGF5ZXIsIGNsb3NlZCkge1xuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIHBvaW50c1RvUGF0aChsYXllci5fcGFydHMsIGNsb3NlZCkpO1xuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LFxuXHRcdCAgICByID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSwgMSksXG5cdFx0ICAgIHIyID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSksIDEpIHx8IHIsXG5cdFx0ICAgIGFyYyA9ICdhJyArIHIgKyAnLCcgKyByMiArICcgMCAxLDAgJztcblxuXHRcdC8vIGRyYXdpbmcgYSBjaXJjbGUgd2l0aCB0d28gaGFsZi1hcmNzXG5cdFx0dmFyIGQgPSBsYXllci5fZW1wdHkoKSA/ICdNMCAwJyA6XG5cdFx0XHQnTScgKyAocC54IC0gcikgKyAnLCcgKyBwLnkgK1xuXHRcdFx0YXJjICsgKHIgKiAyKSArICcsMCAnICtcblx0XHRcdGFyYyArICgtciAqIDIpICsgJywwICc7XG5cblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBkKTtcblx0fSxcblxuXHRfc2V0UGF0aDogZnVuY3Rpb24gKGxheWVyLCBwYXRoKSB7XG5cdFx0bGF5ZXIuX3BhdGguc2V0QXR0cmlidXRlKCdkJywgcGF0aCk7XG5cdH0sXG5cblx0Ly8gU1ZHIGRvZXMgbm90IGhhdmUgdGhlIGNvbmNlcHQgb2YgekluZGV4IHNvIHdlIHJlc29ydCB0byBjaGFuZ2luZyB0aGUgRE9NIG9yZGVyIG9mIGVsZW1lbnRzXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwudG9Gcm9udChsYXllci5fcGF0aCk7XG5cdH0sXG5cblx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnRvQmFjayhsYXllci5fcGF0aCk7XG5cdH1cbn0pO1xuXG5pZiAoQnJvd3Nlci52bWwpIHtcblx0U1ZHLmluY2x1ZGUodm1sTWl4aW4pO1xufVxuXG4vLyBAbmFtZXNwYWNlIFNWR1xuLy8gQGZhY3RvcnkgTC5zdmcob3B0aW9ucz86IFJlbmRlcmVyIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgU1ZHIHJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gc3ZnKG9wdGlvbnMpIHtcblx0cmV0dXJuIEJyb3dzZXIuc3ZnIHx8IEJyb3dzZXIudm1sID8gbmV3IFNWRyhvcHRpb25zKSA6IG51bGw7XG59XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vLi4vbWFwL01hcCc7XG5pbXBvcnQge2NhbnZhc30gZnJvbSAnLi9DYW52YXMnO1xuaW1wb3J0IHtzdmd9IGZyb20gJy4vU1ZHJztcblxuTWFwLmluY2x1ZGUoe1xuXHQvLyBAbmFtZXNwYWNlIE1hcDsgQG1ldGhvZCBnZXRSZW5kZXJlcihsYXllcjogUGF0aCk6IFJlbmRlcmVyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZW5kZXIgdGhlIGdpdmVuXG5cdC8vIGBQYXRoYC4gSXQgd2lsbCBlbnN1cmUgdGhhdCB0aGUgYHJlbmRlcmVyYCBvcHRpb25zIG9mIHRoZSBtYXAgYW5kIHBhdGhzXG5cdC8vIGFyZSByZXNwZWN0ZWQsIGFuZCB0aGF0IHRoZSByZW5kZXJlcnMgZG8gZXhpc3Qgb24gdGhlIG1hcC5cblx0Z2V0UmVuZGVyZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdC8vIEBuYW1lc3BhY2UgUGF0aDsgQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXJcblx0XHQvLyBVc2UgdGhpcyBzcGVjaWZpYyBpbnN0YW5jZSBvZiBgUmVuZGVyZXJgIGZvciB0aGlzIHBhdGguIFRha2VzXG5cdFx0Ly8gcHJlY2VkZW5jZSBvdmVyIHRoZSBtYXAncyBbZGVmYXVsdCByZW5kZXJlcl0oI21hcC1yZW5kZXJlcikuXG5cdFx0dmFyIHJlbmRlcmVyID0gbGF5ZXIub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9nZXRQYW5lUmVuZGVyZXIobGF5ZXIub3B0aW9ucy5wYW5lKSB8fCB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgdGhpcy5fcmVuZGVyZXI7XG5cblx0XHRpZiAoIXJlbmRlcmVyKSB7XG5cdFx0XHRyZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyID0gdGhpcy5fY3JlYXRlUmVuZGVyZXIoKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuaGFzTGF5ZXIocmVuZGVyZXIpKSB7XG5cdFx0XHR0aGlzLmFkZExheWVyKHJlbmRlcmVyKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlbmRlcmVyO1xuXHR9LFxuXG5cdF9nZXRQYW5lUmVuZGVyZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0aWYgKG5hbWUgPT09ICdvdmVybGF5UGFuZScgfHwgbmFtZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIHJlbmRlcmVyID0gdGhpcy5fcGFuZVJlbmRlcmVyc1tuYW1lXTtcblx0XHRpZiAocmVuZGVyZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmVuZGVyZXIgPSB0aGlzLl9jcmVhdGVSZW5kZXJlcih7cGFuZTogbmFtZX0pO1xuXHRcdFx0dGhpcy5fcGFuZVJlbmRlcmVyc1tuYW1lXSA9IHJlbmRlcmVyO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVuZGVyZXI7XG5cdH0sXG5cblx0X2NyZWF0ZVJlbmRlcmVyOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdC8vIEBuYW1lc3BhY2UgTWFwOyBAb3B0aW9uIHByZWZlckNhbnZhczogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciBgUGF0aGBzIHNob3VsZCBiZSByZW5kZXJlZCBvbiBhIGBDYW52YXNgIHJlbmRlcmVyLlxuXHRcdC8vIEJ5IGRlZmF1bHQsIGFsbCBgUGF0aGBzIGFyZSByZW5kZXJlZCBpbiBhIGBTVkdgIHJlbmRlcmVyLlxuXHRcdHJldHVybiAodGhpcy5vcHRpb25zLnByZWZlckNhbnZhcyAmJiBjYW52YXMob3B0aW9ucykpIHx8IHN2ZyhvcHRpb25zKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge1BvbHlnb259IGZyb20gJy4vUG9seWdvbic7XG5pbXBvcnQge3RvTGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcblxuLypcbiAqIEwuUmVjdGFuZ2xlIGV4dGVuZHMgUG9seWdvbiBhbmQgY3JlYXRlcyBhIHJlY3RhbmdsZSB3aGVuIHBhc3NlZCBhIExhdExuZ0JvdW5kcyBvYmplY3QuXG4gKi9cblxuLypcbiAqIEBjbGFzcyBSZWN0YW5nbGVcbiAqIEBha2EgTC5SZWN0YW5nbGVcbiAqIEBpbmhlcml0cyBQb2x5Z29uXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyByZWN0YW5nbGUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBvbHlnb25gLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGRlZmluZSByZWN0YW5nbGUgZ2VvZ3JhcGhpY2FsIGJvdW5kc1xuICogdmFyIGJvdW5kcyA9IFtbNTQuNTU5MzIyLCAtNS43Njc4MjJdLCBbNTYuMTIxMDYwNCwgLTMuMDIxMjQwXV07XG4gKlxuICogLy8gY3JlYXRlIGFuIG9yYW5nZSByZWN0YW5nbGVcbiAqIEwucmVjdGFuZ2xlKGJvdW5kcywge2NvbG9yOiBcIiNmZjc4MDBcIiwgd2VpZ2h0OiAxfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHJlY3RhbmdsZSBib3VuZHNcbiAqIG1hcC5maXRCb3VuZHMoYm91bmRzKTtcbiAqIGBgYFxuICpcbiAqL1xuXG5cbmV4cG9ydCB2YXIgUmVjdGFuZ2xlID0gUG9seWdvbi5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG5cdFx0UG9seWdvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpLCBvcHRpb25zKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldEJvdW5kcyhsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcblx0Ly8gUmVkcmF3cyB0aGUgcmVjdGFuZ2xlIHdpdGggdGhlIHBhc3NlZCBib3VuZHMuXG5cdHNldEJvdW5kczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcykge1xuXHRcdHJldHVybiB0aGlzLnNldExhdExuZ3ModGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcykpO1xuXHR9LFxuXG5cdF9ib3VuZHNUb0xhdExuZ3M6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcblx0XHRsYXRMbmdCb3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhsYXRMbmdCb3VuZHMpO1xuXHRcdHJldHVybiBbXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhXZXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KClcblx0XHRdO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLnJlY3RhbmdsZShsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG5leHBvcnQgZnVuY3Rpb24gcmVjdGFuZ2xlKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFJlY3RhbmdsZShsYXRMbmdCb3VuZHMsIG9wdGlvbnMpO1xufVxuIiwiZXhwb3J0IHtSZW5kZXJlcn0gZnJvbSAnLi9SZW5kZXJlcic7XG5leHBvcnQge0NhbnZhcywgY2FudmFzfSBmcm9tICcuL0NhbnZhcyc7XG5pbXBvcnQge1NWRywgY3JlYXRlLCBwb2ludHNUb1BhdGgsIHN2Z30gZnJvbSAnLi9TVkcnO1xuU1ZHLmNyZWF0ZSA9IGNyZWF0ZTtcblNWRy5wb2ludHNUb1BhdGggPSBwb2ludHNUb1BhdGg7XG5leHBvcnQge1NWRywgc3ZnfTtcbmltcG9ydCAnLi9SZW5kZXJlci5nZXRSZW5kZXJlcic7XHQvLyBUaGlzIGlzIGEgYml0IG9mIGEgaGFjaywgYnV0IG5lZWRlZCBiZWNhdXNlIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xuXG5leHBvcnQge1BhdGh9IGZyb20gJy4vUGF0aCc7XG5leHBvcnQge0NpcmNsZU1hcmtlciwgY2lyY2xlTWFya2VyfSBmcm9tICcuL0NpcmNsZU1hcmtlcic7XG5leHBvcnQge0NpcmNsZSwgY2lyY2xlfSBmcm9tICcuL0NpcmNsZSc7XG5leHBvcnQge1BvbHlsaW5lLCBwb2x5bGluZX0gZnJvbSAnLi9Qb2x5bGluZSc7XG5leHBvcnQge1BvbHlnb24sIHBvbHlnb259IGZyb20gJy4vUG9seWdvbic7XG5leHBvcnQge1JlY3RhbmdsZSwgcmVjdGFuZ2xlfSBmcm9tICcuL1JlY3RhbmdsZSc7XG4iLCJleHBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcbmV4cG9ydCB7TGF5ZXJHcm91cCwgbGF5ZXJHcm91cH0gZnJvbSAnLi9MYXllckdyb3VwJztcbmV4cG9ydCB7RmVhdHVyZUdyb3VwLCBmZWF0dXJlR3JvdXB9IGZyb20gJy4vRmVhdHVyZUdyb3VwJztcbmltcG9ydCB7R2VvSlNPTiwgZ2VvSlNPTiwgZ2VvSnNvbiwgZ2VvbWV0cnlUb0xheWVyLCBjb29yZHNUb0xhdExuZywgY29vcmRzVG9MYXRMbmdzLCBsYXRMbmdUb0Nvb3JkcywgbGF0TG5nc1RvQ29vcmRzLCBnZXRGZWF0dXJlLCBhc0ZlYXR1cmV9IGZyb20gJy4vR2VvSlNPTic7XG5HZW9KU09OLmdlb21ldHJ5VG9MYXllciA9IGdlb21ldHJ5VG9MYXllcjtcbkdlb0pTT04uY29vcmRzVG9MYXRMbmcgPSBjb29yZHNUb0xhdExuZztcbkdlb0pTT04uY29vcmRzVG9MYXRMbmdzID0gY29vcmRzVG9MYXRMbmdzO1xuR2VvSlNPTi5sYXRMbmdUb0Nvb3JkcyA9IGxhdExuZ1RvQ29vcmRzO1xuR2VvSlNPTi5sYXRMbmdzVG9Db29yZHMgPSBsYXRMbmdzVG9Db29yZHM7XG5HZW9KU09OLmdldEZlYXR1cmUgPSBnZXRGZWF0dXJlO1xuR2VvSlNPTi5hc0ZlYXR1cmUgPSBhc0ZlYXR1cmU7XG5leHBvcnQge0dlb0pTT04sIGdlb0pTT04sIGdlb0pzb259O1xuXG5leHBvcnQge0ltYWdlT3ZlcmxheSwgaW1hZ2VPdmVybGF5fSBmcm9tICcuL0ltYWdlT3ZlcmxheSc7XG5leHBvcnQge1ZpZGVvT3ZlcmxheSwgdmlkZW9PdmVybGF5fSBmcm9tICcuL1ZpZGVvT3ZlcmxheSc7XG5leHBvcnQge1NWR092ZXJsYXksIHN2Z092ZXJsYXl9IGZyb20gJy4vU1ZHT3ZlcmxheSc7XG5cbmV4cG9ydCB7RGl2T3ZlcmxheX0gZnJvbSAnLi9EaXZPdmVybGF5JztcbmV4cG9ydCB7UG9wdXAsIHBvcHVwfSBmcm9tICcuL1BvcHVwJztcbmV4cG9ydCB7VG9vbHRpcCwgdG9vbHRpcH0gZnJvbSAnLi9Ub29sdGlwJztcblxuZXhwb3J0ICogZnJvbSAnLi9tYXJrZXIvaW5kZXgnO1xuZXhwb3J0ICogZnJvbSAnLi90aWxlL2luZGV4JztcbmV4cG9ydCAqIGZyb20gJy4vdmVjdG9yL2luZGV4JztcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cbi8qXG4gKiBMLkhhbmRsZXIuQm94Wm9vbSBpcyB1c2VkIHRvIGFkZCBzaGlmdC1kcmFnIHpvb20gaW50ZXJhY3Rpb24gdG8gdGhlIG1hcFxuICogKHpvb20gdG8gYSBzZWxlY3RlZCBib3VuZGluZyBib3gpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGJveFpvb206IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIHRvIGEgcmVjdGFuZ3VsYXIgYXJlYSBzcGVjaWZpZWQgYnlcblx0Ly8gZHJhZ2dpbmcgdGhlIG1vdXNlIHdoaWxlIHByZXNzaW5nIHRoZSBzaGlmdCBrZXkuXG5cdGJveFpvb206IHRydWVcbn0pO1xuXG5leHBvcnQgdmFyIEJveFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gbWFwLl9jb250YWluZXI7XG5cdFx0dGhpcy5fcGFuZSA9IG1hcC5fcGFuZXMub3ZlcmxheVBhbmU7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuXHRcdG1hcC5vbigndW5sb2FkJywgdGhpcy5fZGVzdHJveSwgdGhpcyk7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vbih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vZmYodGhpcy5fY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21vdmVkO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fcGFuZSk7XG5cdFx0ZGVsZXRlIHRoaXMuX3BhbmU7XG5cdH0sXG5cblx0X3Jlc2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcblx0fSxcblxuXHRfY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgIT09IDApIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9yZXNldFN0YXRlVGltZW91dCk7XG5cdFx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUuc2hpZnRLZXkgfHwgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdC8vIENsZWFyIHRoZSBkZWZlcnJlZCByZXNldFN0YXRlIGlmIGl0IGhhc24ndCBleGVjdXRlZCB5ZXQsIG90aGVyd2lzZSBpdFxuXHRcdC8vIHdpbGwgaW50ZXJydXB0IHRoZSBpbnRlcmFjdGlvbiBhbmQgb3JwaGFuIGEgYm94IGVsZW1lbnQgaW4gdGhlIGNvbnRhaW5lci5cblx0XHR0aGlzLl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSgpO1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGUoKTtcblxuXHRcdERvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcblx0XHREb21VdGlsLmRpc2FibGVJbWFnZURyYWcoKTtcblxuXHRcdHRoaXMuX3N0YXJ0UG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHREb21FdmVudC5vbihkb2N1bWVudCwge1xuXHRcdFx0Y29udGV4dG1lbnU6IERvbUV2ZW50LnN0b3AsXG5cdFx0XHRtb3VzZW1vdmU6IHRoaXMuX29uTW91c2VNb3ZlLFxuXHRcdFx0bW91c2V1cDogdGhpcy5fb25Nb3VzZVVwLFxuXHRcdFx0a2V5ZG93bjogdGhpcy5fb25LZXlEb3duXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcblxuXHRcdFx0dGhpcy5fYm94ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXpvb20tYm94JywgdGhpcy5fY29udGFpbmVyKTtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcblxuXHRcdFx0dGhpcy5fbWFwLmZpcmUoJ2JveHpvb21zdGFydCcpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBCb3VuZHModGhpcy5fcG9pbnQsIHRoaXMuX3N0YXJ0UG9pbnQpLFxuXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fYm94LCBib3VuZHMubWluKTtcblxuXHRcdHRoaXMuX2JveC5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xuXHRcdHRoaXMuX2JveC5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuXHR9LFxuXG5cdF9maW5pc2g6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbW92ZWQpIHtcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2JveCk7XG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY3Jvc3NoYWlyJyk7XG5cdFx0fVxuXG5cdFx0RG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0RG9tVXRpbC5lbmFibGVJbWFnZURyYWcoKTtcblxuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwge1xuXHRcdFx0Y29udGV4dG1lbnU6IERvbUV2ZW50LnN0b3AsXG5cdFx0XHRtb3VzZW1vdmU6IHRoaXMuX29uTW91c2VNb3ZlLFxuXHRcdFx0bW91c2V1cDogdGhpcy5fb25Nb3VzZVVwLFxuXHRcdFx0a2V5ZG93bjogdGhpcy5fb25LZXlEb3duXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9maW5pc2goKTtcblxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHsgcmV0dXJuOyB9XG5cdFx0Ly8gUG9zdHBvbmUgdG8gbmV4dCBKUyB0aWNrIHNvIGludGVybmFsIGNsaWNrIGV2ZW50IGhhbmRsaW5nXG5cdFx0Ly8gc3RpbGwgc2VlIGl0IGFzIFwibW92ZWRcIi5cblx0XHR0aGlzLl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSgpO1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gc2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5fcmVzZXRTdGF0ZSwgdGhpcyksIDApO1xuXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoXG5cdFx0ICAgICAgICB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9zdGFydFBvaW50KSxcblx0XHQgICAgICAgIHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50KSk7XG5cblx0XHR0aGlzLl9tYXBcblx0XHRcdC5maXRCb3VuZHMoYm91bmRzKVxuXHRcdFx0LmZpcmUoJ2JveHpvb21lbmQnLCB7Ym94Wm9vbUJvdW5kczogYm91bmRzfSk7XG5cdH0sXG5cblx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoZS5rZXlDb2RlID09PSAyNykge1xuXHRcdFx0dGhpcy5fZmluaXNoKCk7XG5cdFx0XHR0aGlzLl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSgpO1xuXHRcdFx0dGhpcy5fcmVzZXRTdGF0ZSgpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgYm94Wm9vbTogSGFuZGxlclxuLy8gQm94IChzaGlmdC1kcmFnIHdpdGggbW91c2UpIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdib3hab29tJywgQm94Wm9vbSk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcblxuLypcbiAqIEwuSGFuZGxlci5Eb3VibGVDbGlja1pvb20gaXMgdXNlZCB0byBoYW5kbGUgZG91YmxlLWNsaWNrIHpvb20gb24gdGhlIG1hcCwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5cbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGRvdWJsZUNsaWNrWm9vbTogQm9vbGVhbnxTdHJpbmcgPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGluIGJ5IGRvdWJsZSBjbGlja2luZyBvbiBpdCBhbmRcblx0Ly8gem9vbWVkIG91dCBieSBkb3VibGUgY2xpY2tpbmcgd2hpbGUgaG9sZGluZyBzaGlmdC4gSWYgcGFzc2VkXG5cdC8vIGAnY2VudGVyJ2AsIGRvdWJsZS1jbGljayB6b29tIHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZVxuXHQvLyAgdmlldyByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBtb3VzZSB3YXMuXG5cdGRvdWJsZUNsaWNrWm9vbTogdHJ1ZVxufSk7XG5cbmV4cG9ydCB2YXIgRG91YmxlQ2xpY2tab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX21hcC5vbignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX21hcC5vZmYoJ2RibGNsaWNrJywgdGhpcy5fb25Eb3VibGVDbGljaywgdGhpcyk7XG5cdH0sXG5cblx0X29uRG91YmxlQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgb2xkWm9vbSA9IG1hcC5nZXRab29tKCksXG5cdFx0ICAgIGRlbHRhID0gbWFwLm9wdGlvbnMuem9vbURlbHRhLFxuXHRcdCAgICB6b29tID0gZS5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5ID8gb2xkWm9vbSAtIGRlbHRhIDogb2xkWm9vbSArIGRlbHRhO1xuXG5cdFx0aWYgKG1hcC5vcHRpb25zLmRvdWJsZUNsaWNrWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdG1hcC5zZXRab29tKHpvb20pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXAuc2V0Wm9vbUFyb3VuZChlLmNvbnRhaW5lclBvaW50LCB6b29tKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy9cbi8vIE1hcCBwcm9wZXJ0aWVzIGluY2x1ZGUgaW50ZXJhY3Rpb24gaGFuZGxlcnMgdGhhdCBhbGxvdyB5b3UgdG8gY29udHJvbFxuLy8gaW50ZXJhY3Rpb24gYmVoYXZpb3IgaW4gcnVudGltZSwgZW5hYmxpbmcgb3IgZGlzYWJsaW5nIGNlcnRhaW4gZmVhdHVyZXMgc3VjaFxuLy8gYXMgZHJhZ2dpbmcgb3IgdG91Y2ggem9vbSAoc2VlIGBIYW5kbGVyYCBtZXRob2RzKS4gRm9yIGV4YW1wbGU6XG4vL1xuLy8gYGBganNcbi8vIG1hcC5kb3VibGVDbGlja1pvb20uZGlzYWJsZSgpO1xuLy8gYGBgXG4vL1xuLy8gQHByb3BlcnR5IGRvdWJsZUNsaWNrWm9vbTogSGFuZGxlclxuLy8gRG91YmxlIGNsaWNrIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkb3VibGVDbGlja1pvb20nLCBEb3VibGVDbGlja1pvb20pO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQge0RyYWdnYWJsZX0gZnJvbSAnLi4vLi4vZG9tL0RyYWdnYWJsZSc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCB7dG9MYXRMbmdCb3VuZHMgYXMgbGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcbmltcG9ydCB7dG9Cb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cbi8qXG4gKiBMLkhhbmRsZXIuTWFwRHJhZyBpcyB1c2VkIHRvIG1ha2UgdGhlIG1hcCBkcmFnZ2FibGUgKHdpdGggcGFubmluZyBpbmVydGlhKSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBkcmFnZ2luZzogQm9vbGVhbiA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGlzIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cblx0ZHJhZ2dpbmc6IHRydWUsXG5cblx0Ly8gQHNlY3Rpb24gUGFubmluZyBJbmVydGlhIE9wdGlvbnNcblx0Ly8gQG9wdGlvbiBpbmVydGlhOiBCb29sZWFuID0gKlxuXHQvLyBJZiBlbmFibGVkLCBwYW5uaW5nIG9mIHRoZSBtYXAgd2lsbCBoYXZlIGFuIGluZXJ0aWEgZWZmZWN0IHdoZXJlXG5cdC8vIHRoZSBtYXAgYnVpbGRzIG1vbWVudHVtIHdoaWxlIGRyYWdnaW5nIGFuZCBjb250aW51ZXMgbW92aW5nIGluXG5cdC8vIHRoZSBzYW1lIGRpcmVjdGlvbiBmb3Igc29tZSB0aW1lLiBGZWVscyBlc3BlY2lhbGx5IG5pY2Ugb24gdG91Y2hcblx0Ly8gZGV2aWNlcy4gRW5hYmxlZCBieSBkZWZhdWx0LlxuXHRpbmVydGlhOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24gaW5lcnRpYURlY2VsZXJhdGlvbjogTnVtYmVyID0gMzAwMFxuXHQvLyBUaGUgcmF0ZSB3aXRoIHdoaWNoIHRoZSBpbmVydGlhbCBtb3ZlbWVudCBzbG93cyBkb3duLCBpbiBwaXhlbHMvc2Vjb25kwrIuXG5cdGluZXJ0aWFEZWNlbGVyYXRpb246IDM0MDAsIC8vIHB4L3NeMlxuXG5cdC8vIEBvcHRpb24gaW5lcnRpYU1heFNwZWVkOiBOdW1iZXIgPSBJbmZpbml0eVxuXHQvLyBNYXggc3BlZWQgb2YgdGhlIGluZXJ0aWFsIG1vdmVtZW50LCBpbiBwaXhlbHMvc2Vjb25kLlxuXHRpbmVydGlhTWF4U3BlZWQ6IEluZmluaXR5LCAvLyBweC9zXG5cblx0Ly8gQG9wdGlvbiBlYXNlTGluZWFyaXR5OiBOdW1iZXIgPSAwLjJcblx0ZWFzZUxpbmVhcml0eTogMC4yLFxuXG5cdC8vIFRPRE8gcmVmYWN0b3IsIG1vdmUgdG8gQ1JTXG5cdC8vIEBvcHRpb24gd29ybGRDb3B5SnVtcDogQm9vbGVhbiA9IGZhbHNlXG5cdC8vIFdpdGggdGhpcyBvcHRpb24gZW5hYmxlZCwgdGhlIG1hcCB0cmFja3Mgd2hlbiB5b3UgcGFuIHRvIGFub3RoZXIgXCJjb3B5XCJcblx0Ly8gb2YgdGhlIHdvcmxkIGFuZCBzZWFtbGVzc2x5IGp1bXBzIHRvIHRoZSBvcmlnaW5hbCBvbmUgc28gdGhhdCBhbGwgb3ZlcmxheXNcblx0Ly8gbGlrZSBtYXJrZXJzIGFuZCB2ZWN0b3IgbGF5ZXJzIGFyZSBzdGlsbCB2aXNpYmxlLlxuXHR3b3JsZENvcHlKdW1wOiBmYWxzZSxcblxuXHQvLyBAb3B0aW9uIG1heEJvdW5kc1Zpc2Nvc2l0eTogTnVtYmVyID0gMC4wXG5cdC8vIElmIGBtYXhCb3VuZHNgIGlzIHNldCwgdGhpcyBvcHRpb24gd2lsbCBjb250cm9sIGhvdyBzb2xpZCB0aGUgYm91bmRzXG5cdC8vIGFyZSB3aGVuIGRyYWdnaW5nIHRoZSBtYXAgYXJvdW5kLiBUaGUgZGVmYXVsdCB2YWx1ZSBvZiBgMC4wYCBhbGxvd3MgdGhlXG5cdC8vIHVzZXIgdG8gZHJhZyBvdXRzaWRlIHRoZSBib3VuZHMgYXQgbm9ybWFsIHNwZWVkLCBoaWdoZXIgdmFsdWVzIHdpbGxcblx0Ly8gc2xvdyBkb3duIG1hcCBkcmFnZ2luZyBvdXRzaWRlIGJvdW5kcywgYW5kIGAxLjBgIG1ha2VzIHRoZSBib3VuZHMgZnVsbHlcblx0Ly8gc29saWQsIHByZXZlbnRpbmcgdGhlIHVzZXIgZnJvbSBkcmFnZ2luZyBvdXRzaWRlIHRoZSBib3VuZHMuXG5cdG1heEJvdW5kc1Zpc2Nvc2l0eTogMC4wXG59KTtcblxuZXhwb3J0IHZhciBEcmFnID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKG1hcC5fbWFwUGFuZSwgbWFwLl9jb250YWluZXIpO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuXHRcdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ0xpbWl0LCB0aGlzKTtcblx0XHRcdGlmIChtYXAub3B0aW9ucy53b3JsZENvcHlKdW1wKSB7XG5cdFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ1dyYXAsIHRoaXMpO1xuXHRcdFx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXG5cdFx0XHRcdG1hcC53aGVuUmVhZHkodGhpcy5fb25ab29tRW5kLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtZ3JhYiBsZWFmbGV0LXRvdWNoLWRyYWcnKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuZW5hYmxlKCk7XG5cdFx0dGhpcy5fcG9zaXRpb25zID0gW107XG5cdFx0dGhpcy5fdGltZXMgPSBbXTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWInKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC1kcmFnJyk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmRpc2FibGUoKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcblx0fSxcblxuXHRtb3Zpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92aW5nO1xuXHR9LFxuXG5cdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRtYXAuX3N0b3AoKTtcblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzICYmIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkge1xuXHRcdFx0dmFyIGJvdW5kcyA9IGxhdExuZ0JvdW5kcyh0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG5cdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IHRvQm91bmRzKFxuXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLm11bHRpcGx5QnkoLTEpLFxuXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0U291dGhFYXN0KCkpLm11bHRpcGx5QnkoLTEpXG5cdFx0XHRcdFx0LmFkZCh0aGlzLl9tYXAuZ2V0U2l6ZSgpKSk7XG5cblx0XHRcdHRoaXMuX3Zpc2Nvc2l0eSA9IE1hdGgubWluKDEuMCwgTWF0aC5tYXgoMC4wLCB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fb2Zmc2V0TGltaXQgPSBudWxsO1xuXHRcdH1cblxuXHRcdG1hcFxuXHRcdCAgICAuZmlyZSgnbW92ZXN0YXJ0Jylcblx0XHQgICAgLmZpcmUoJ2RyYWdzdGFydCcpO1xuXG5cdFx0aWYgKG1hcC5vcHRpb25zLmluZXJ0aWEpIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuXHRcdFx0dGhpcy5fdGltZXMgPSBbXTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuXHRcdFx0dmFyIHRpbWUgPSB0aGlzLl9sYXN0VGltZSA9ICtuZXcgRGF0ZSgpLFxuXHRcdFx0ICAgIHBvcyA9IHRoaXMuX2xhc3RQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyB8fCB0aGlzLl9kcmFnZ2FibGUuX25ld1BvcztcblxuXHRcdFx0dGhpcy5fcG9zaXRpb25zLnB1c2gocG9zKTtcblx0XHRcdHRoaXMuX3RpbWVzLnB1c2godGltZSk7XG5cblx0XHRcdHRoaXMuX3BydW5lUG9zaXRpb25zKHRpbWUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX21hcFxuXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG5cdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG5cdH0sXG5cblx0X3BydW5lUG9zaXRpb25zOiBmdW5jdGlvbiAodGltZSkge1xuXHRcdHdoaWxlICh0aGlzLl9wb3NpdGlvbnMubGVuZ3RoID4gMSAmJiB0aW1lIC0gdGhpcy5fdGltZXNbMF0gPiA1MCkge1xuXHRcdFx0dGhpcy5fcG9zaXRpb25zLnNoaWZ0KCk7XG5cdFx0XHR0aGlzLl90aW1lcy5zaGlmdCgpO1xuXHRcdH1cblx0fSxcblxuXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHB4Q2VudGVyID0gdGhpcy5fbWFwLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcblx0XHQgICAgcHhXb3JsZENlbnRlciA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQoWzAsIDBdKTtcblxuXHRcdHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCA9IHB4V29ybGRDZW50ZXIuc3VidHJhY3QocHhDZW50ZXIpLng7XG5cdFx0dGhpcy5fd29ybGRXaWR0aCA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKCkuZ2V0U2l6ZSgpLng7XG5cdH0sXG5cblx0X3Zpc2NvdXNMaW1pdDogZnVuY3Rpb24gKHZhbHVlLCB0aHJlc2hvbGQpIHtcblx0XHRyZXR1cm4gdmFsdWUgLSAodmFsdWUgLSB0aHJlc2hvbGQpICogdGhpcy5fdmlzY29zaXR5O1xuXHR9LFxuXG5cdF9vblByZURyYWdMaW1pdDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fdmlzY29zaXR5IHx8ICF0aGlzLl9vZmZzZXRMaW1pdCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zKTtcblxuXHRcdHZhciBsaW1pdCA9IHRoaXMuX29mZnNldExpbWl0O1xuXHRcdGlmIChvZmZzZXQueCA8IGxpbWl0Lm1pbi54KSB7IG9mZnNldC54ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC54LCBsaW1pdC5taW4ueCk7IH1cblx0XHRpZiAob2Zmc2V0LnkgPCBsaW1pdC5taW4ueSkgeyBvZmZzZXQueSA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueSwgbGltaXQubWluLnkpOyB9XG5cdFx0aWYgKG9mZnNldC54ID4gbGltaXQubWF4LngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1heC54KTsgfVxuXHRcdGlmIChvZmZzZXQueSA+IGxpbWl0Lm1heC55KSB7IG9mZnNldC55ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC55LCBsaW1pdC5tYXgueSk7IH1cblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcy5hZGQob2Zmc2V0KTtcblx0fSxcblxuXHRfb25QcmVEcmFnV3JhcDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFRPRE8gcmVmYWN0b3IgdG8gYmUgYWJsZSB0byBhZGp1c3QgbWFwIHBhbmUgcG9zaXRpb24gYWZ0ZXIgem9vbVxuXHRcdHZhciB3b3JsZFdpZHRoID0gdGhpcy5fd29ybGRXaWR0aCxcblx0XHQgICAgaGFsZldpZHRoID0gTWF0aC5yb3VuZCh3b3JsZFdpZHRoIC8gMiksXG5cdFx0ICAgIGR4ID0gdGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0LFxuXHRcdCAgICB4ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCxcblx0XHQgICAgbmV3WDEgPSAoeCAtIGhhbGZXaWR0aCArIGR4KSAlIHdvcmxkV2lkdGggKyBoYWxmV2lkdGggLSBkeCxcblx0XHQgICAgbmV3WDIgPSAoeCArIGhhbGZXaWR0aCArIGR4KSAlIHdvcmxkV2lkdGggLSBoYWxmV2lkdGggLSBkeCxcblx0XHQgICAgbmV3WCA9IE1hdGguYWJzKG5ld1gxICsgZHgpIDwgTWF0aC5hYnMobmV3WDIgKyBkeCkgPyBuZXdYMSA6IG5ld1gyO1xuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9hYnNQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5jbG9uZSgpO1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnggPSBuZXdYO1xuXHR9LFxuXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgb3B0aW9ucyA9IG1hcC5vcHRpb25zLFxuXG5cdFx0ICAgIG5vSW5lcnRpYSA9ICFvcHRpb25zLmluZXJ0aWEgfHwgZS5ub0luZXJ0aWEgfHwgdGhpcy5fdGltZXMubGVuZ3RoIDwgMjtcblxuXHRcdG1hcC5maXJlKCdkcmFnZW5kJywgZSk7XG5cblx0XHRpZiAobm9JbmVydGlhKSB7XG5cdFx0XHRtYXAuZmlyZSgnbW92ZWVuZCcpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3BydW5lUG9zaXRpb25zKCtuZXcgRGF0ZSgpKTtcblxuXHRcdFx0dmFyIGRpcmVjdGlvbiA9IHRoaXMuX2xhc3RQb3Muc3VidHJhY3QodGhpcy5fcG9zaXRpb25zWzBdKSxcblx0XHRcdCAgICBkdXJhdGlvbiA9ICh0aGlzLl9sYXN0VGltZSAtIHRoaXMuX3RpbWVzWzBdKSAvIDEwMDAsXG5cdFx0XHQgICAgZWFzZSA9IG9wdGlvbnMuZWFzZUxpbmVhcml0eSxcblxuXHRcdFx0ICAgIHNwZWVkVmVjdG9yID0gZGlyZWN0aW9uLm11bHRpcGx5QnkoZWFzZSAvIGR1cmF0aW9uKSxcblx0XHRcdCAgICBzcGVlZCA9IHNwZWVkVmVjdG9yLmRpc3RhbmNlVG8oWzAsIDBdKSxcblxuXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZCA9IE1hdGgubWluKG9wdGlvbnMuaW5lcnRpYU1heFNwZWVkLCBzcGVlZCksXG5cdFx0XHQgICAgbGltaXRlZFNwZWVkVmVjdG9yID0gc3BlZWRWZWN0b3IubXVsdGlwbHlCeShsaW1pdGVkU3BlZWQgLyBzcGVlZCksXG5cblx0XHRcdCAgICBkZWNlbGVyYXRpb25EdXJhdGlvbiA9IGxpbWl0ZWRTcGVlZCAvIChvcHRpb25zLmluZXJ0aWFEZWNlbGVyYXRpb24gKiBlYXNlKSxcblx0XHRcdCAgICBvZmZzZXQgPSBsaW1pdGVkU3BlZWRWZWN0b3IubXVsdGlwbHlCeSgtZGVjZWxlcmF0aW9uRHVyYXRpb24gLyAyKS5yb3VuZCgpO1xuXG5cdFx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkge1xuXHRcdFx0XHRtYXAuZmlyZSgnbW92ZWVuZCcpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvZmZzZXQgPSBtYXAuX2xpbWl0T2Zmc2V0KG9mZnNldCwgbWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblxuXHRcdFx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQsIHtcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkZWNlbGVyYXRpb25EdXJhdGlvbixcblx0XHRcdFx0XHRcdGVhc2VMaW5lYXJpdHk6IGVhc2UsXG5cdFx0XHRcdFx0XHRub01vdmVTdGFydDogdHJ1ZSxcblx0XHRcdFx0XHRcdGFuaW1hdGU6IHRydWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBkcmFnZ2luZzogSGFuZGxlclxuLy8gTWFwIGRyYWdnaW5nIGhhbmRsZXIgKGJ5IGJvdGggbW91c2UgYW5kIHRvdWNoKS5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkcmFnZ2luZycsIERyYWcpO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQge29uLCBvZmYsIHN0b3B9IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcblxuXG4vKlxuICogTC5NYXAuS2V5Ym9hcmQgaXMgaGFuZGxpbmcga2V5Ym9hcmQgaW50ZXJhY3Rpb24gd2l0aCB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEtleWJvYXJkIE5hdmlnYXRpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24ga2V5Ym9hcmQ6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIE1ha2VzIHRoZSBtYXAgZm9jdXNhYmxlIGFuZCBhbGxvd3MgdXNlcnMgdG8gbmF2aWdhdGUgdGhlIG1hcCB3aXRoIGtleWJvYXJkXG5cdC8vIGFycm93cyBhbmQgYCtgL2AtYCBrZXlzLlxuXHRrZXlib2FyZDogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIGtleWJvYXJkUGFuRGVsdGE6IE51bWJlciA9IDgwXG5cdC8vIEFtb3VudCBvZiBwaXhlbHMgdG8gcGFuIHdoZW4gcHJlc3NpbmcgYW4gYXJyb3cga2V5LlxuXHRrZXlib2FyZFBhbkRlbHRhOiA4MFxufSk7XG5cbmV4cG9ydCB2YXIgS2V5Ym9hcmQgPSBIYW5kbGVyLmV4dGVuZCh7XG5cblx0a2V5Q29kZXM6IHtcblx0XHRsZWZ0OiAgICBbMzddLFxuXHRcdHJpZ2h0OiAgIFszOV0sXG5cdFx0ZG93bjogICAgWzQwXSxcblx0XHR1cDogICAgICBbMzhdLFxuXHRcdHpvb21JbjogIFsxODcsIDEwNywgNjEsIDE3MV0sXG5cdFx0em9vbU91dDogWzE4OSwgMTA5LCA1NCwgMTczXVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cblx0XHR0aGlzLl9zZXRQYW5EZWx0YShtYXAub3B0aW9ucy5rZXlib2FyZFBhbkRlbHRhKTtcblx0XHR0aGlzLl9zZXRab29tRGVsdGEobWFwLm9wdGlvbnMuem9vbURlbHRhKTtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9tYXAuX2NvbnRhaW5lcjtcblxuXHRcdC8vIG1ha2UgdGhlIGNvbnRhaW5lciBmb2N1c2FibGUgYnkgdGFiYmluZ1xuXHRcdGlmIChjb250YWluZXIudGFiSW5kZXggPD0gMCkge1xuXHRcdFx0Y29udGFpbmVyLnRhYkluZGV4ID0gJzAnO1xuXHRcdH1cblxuXHRcdG9uKGNvbnRhaW5lciwge1xuXHRcdFx0Zm9jdXM6IHRoaXMuX29uRm9jdXMsXG5cdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG5cdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXAub24oe1xuXHRcdFx0Zm9jdXM6IHRoaXMuX2FkZEhvb2tzLFxuXHRcdFx0Ymx1cjogdGhpcy5fcmVtb3ZlSG9va3Ncblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbW92ZUhvb2tzKCk7XG5cblx0XHRvZmYodGhpcy5fbWFwLl9jb250YWluZXIsIHtcblx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuXHRcdFx0Ymx1cjogdGhpcy5fb25CbHVyLFxuXHRcdFx0bW91c2Vkb3duOiB0aGlzLl9vbk1vdXNlRG93blxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFwLm9mZih7XG5cdFx0XHRmb2N1czogdGhpcy5fYWRkSG9va3MsXG5cdFx0XHRibHVyOiB0aGlzLl9yZW1vdmVIb29rc1xuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9mb2N1c2VkKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5LFxuXHRcdCAgICBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblx0XHQgICAgdG9wID0gYm9keS5zY3JvbGxUb3AgfHwgZG9jRWwuc2Nyb2xsVG9wLFxuXHRcdCAgICBsZWZ0ID0gYm9keS5zY3JvbGxMZWZ0IHx8IGRvY0VsLnNjcm9sbExlZnQ7XG5cblx0XHR0aGlzLl9tYXAuX2NvbnRhaW5lci5mb2N1cygpO1xuXG5cdFx0d2luZG93LnNjcm9sbFRvKGxlZnQsIHRvcCk7XG5cdH0sXG5cblx0X29uRm9jdXM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9mb2N1c2VkID0gdHJ1ZTtcblx0XHR0aGlzLl9tYXAuZmlyZSgnZm9jdXMnKTtcblx0fSxcblxuXHRfb25CbHVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZm9jdXNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX21hcC5maXJlKCdibHVyJyk7XG5cdH0sXG5cblx0X3NldFBhbkRlbHRhOiBmdW5jdGlvbiAocGFuRGVsdGEpIHtcblx0XHR2YXIga2V5cyA9IHRoaXMuX3BhbktleXMgPSB7fSxcblx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuXHRcdCAgICBpLCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5sZWZ0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLmxlZnRbaV1dID0gWy0xICogcGFuRGVsdGEsIDBdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5yaWdodC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5yaWdodFtpXV0gPSBbcGFuRGVsdGEsIDBdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5kb3duLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLmRvd25baV1dID0gWzAsIHBhbkRlbHRhXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMudXAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMudXBbaV1dID0gWzAsIC0xICogcGFuRGVsdGFdO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Wm9vbURlbHRhOiBmdW5jdGlvbiAoem9vbURlbHRhKSB7XG5cdFx0dmFyIGtleXMgPSB0aGlzLl96b29tS2V5cyA9IHt9LFxuXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG5cdFx0ICAgIGksIGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21Jbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy56b29tSW5baV1dID0gem9vbURlbHRhO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tT3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnpvb21PdXRbaV1dID0gLXpvb21EZWx0YTtcblx0XHR9XG5cdH0sXG5cblx0X2FkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0b24oZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcblx0fSxcblxuXHRfcmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRvZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcblx0fSxcblxuXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGtleSA9IGUua2V5Q29kZSxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvZmZzZXQ7XG5cblx0XHRpZiAoa2V5IGluIHRoaXMuX3BhbktleXMpIHtcblx0XHRcdGlmICghbWFwLl9wYW5BbmltIHx8ICFtYXAuX3BhbkFuaW0uX2luUHJvZ3Jlc3MpIHtcblx0XHRcdFx0b2Zmc2V0ID0gdGhpcy5fcGFuS2V5c1trZXldO1xuXHRcdFx0XHRpZiAoZS5zaGlmdEtleSkge1xuXHRcdFx0XHRcdG9mZnNldCA9IHRvUG9pbnQob2Zmc2V0KS5tdWx0aXBseUJ5KDMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG1hcC5vcHRpb25zLm1heEJvdW5kcykge1xuXHRcdFx0XHRcdG9mZnNldCA9IG1hcC5fbGltaXRPZmZzZXQodG9Qb2ludChvZmZzZXQpLCBtYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG1hcC5vcHRpb25zLndvcmxkQ29weUp1bXApIHtcblx0XHRcdFx0XHR2YXIgbmV3TGF0TG5nID0gbWFwLndyYXBMYXRMbmcobWFwLnVucHJvamVjdChtYXAucHJvamVjdChtYXAuZ2V0Q2VudGVyKCkpLmFkZChvZmZzZXQpKSk7XG5cdFx0XHRcdFx0bWFwLnBhblRvKG5ld0xhdExuZyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWFwLnBhbkJ5KG9mZnNldCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGtleSBpbiB0aGlzLl96b29tS2V5cykge1xuXHRcdFx0bWFwLnNldFpvb20obWFwLmdldFpvb20oKSArIChlLnNoaWZ0S2V5ID8gMyA6IDEpICogdGhpcy5fem9vbUtleXNba2V5XSk7XG5cblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gMjcgJiYgbWFwLl9wb3B1cCAmJiBtYXAuX3BvcHVwLm9wdGlvbnMuY2xvc2VPbkVzY2FwZUtleSkge1xuXHRcdFx0bWFwLmNsb3NlUG9wdXAoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0c3RvcChlKTtcblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGtleWJvYXJkOiBIYW5kbGVyXG4vLyBLZXlib2FyZCBuYXZpZ2F0aW9uIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAna2V5Ym9hcmQnLCBLZXlib2FyZCk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBMLkhhbmRsZXIuU2Nyb2xsV2hlZWxab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gZW5hYmxlIG1vdXNlIHNjcm9sbCB3aGVlbCB6b29tIG9uIHRoZSBtYXAuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAc2VjdGlvbiBNb3VzZSB3aGVlbCBvcHRpb25zXG5cdC8vIEBvcHRpb24gc2Nyb2xsV2hlZWxab29tOiBCb29sZWFufFN0cmluZyA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgYnkgdXNpbmcgdGhlIG1vdXNlIHdoZWVsLiBJZiBwYXNzZWQgYCdjZW50ZXInYCxcblx0Ly8gaXQgd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgcmVnYXJkbGVzcyBvZiB3aGVyZSB0aGUgbW91c2Ugd2FzLlxuXHRzY3JvbGxXaGVlbFpvb206IHRydWUsXG5cblx0Ly8gQG9wdGlvbiB3aGVlbERlYm91bmNlVGltZTogTnVtYmVyID0gNDBcblx0Ly8gTGltaXRzIHRoZSByYXRlIGF0IHdoaWNoIGEgd2hlZWwgY2FuIGZpcmUgKGluIG1pbGxpc2Vjb25kcykuIEJ5IGRlZmF1bHRcblx0Ly8gdXNlciBjYW4ndCB6b29tIHZpYSB3aGVlbCBtb3JlIG9mdGVuIHRoYW4gb25jZSBwZXIgNDAgbXMuXG5cdHdoZWVsRGVib3VuY2VUaW1lOiA0MCxcblxuXHQvLyBAb3B0aW9uIHdoZWVsUHhQZXJab29tTGV2ZWw6IE51bWJlciA9IDYwXG5cdC8vIEhvdyBtYW55IHNjcm9sbCBwaXhlbHMgKGFzIHJlcG9ydGVkIGJ5IFtMLkRvbUV2ZW50LmdldFdoZWVsRGVsdGFdKCNkb21ldmVudC1nZXR3aGVlbGRlbHRhKSlcblx0Ly8gbWVhbiBhIGNoYW5nZSBvZiBvbmUgZnVsbCB6b29tIGxldmVsLiBTbWFsbGVyIHZhbHVlcyB3aWxsIG1ha2Ugd2hlZWwtem9vbWluZ1xuXHQvLyBmYXN0ZXIgKGFuZCB2aWNlIHZlcnNhKS5cblx0d2hlZWxQeFBlclpvb21MZXZlbDogNjBcbn0pO1xuXG5leHBvcnQgdmFyIFNjcm9sbFdoZWVsWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3doZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCwgdGhpcyk7XG5cblx0XHR0aGlzLl9kZWx0YSA9IDA7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuXHR9LFxuXG5cdF9vbldoZWVsU2Nyb2xsOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBkZWx0YSA9IERvbUV2ZW50LmdldFdoZWVsRGVsdGEoZSk7XG5cblx0XHR2YXIgZGVib3VuY2UgPSB0aGlzLl9tYXAub3B0aW9ucy53aGVlbERlYm91bmNlVGltZTtcblxuXHRcdHRoaXMuX2RlbHRhICs9IGRlbHRhO1xuXHRcdHRoaXMuX2xhc3RNb3VzZVBvcyA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuXHRcdGlmICghdGhpcy5fc3RhcnRUaW1lKSB7XG5cdFx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblx0XHR9XG5cblx0XHR2YXIgbGVmdCA9IE1hdGgubWF4KGRlYm91bmNlIC0gKCtuZXcgRGF0ZSgpIC0gdGhpcy5fc3RhcnRUaW1lKSwgMCk7XG5cblx0XHRjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuXHRcdHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5fcGVyZm9ybVpvb20sIHRoaXMpLCBsZWZ0KTtcblxuXHRcdERvbUV2ZW50LnN0b3AoZSk7XG5cdH0sXG5cblx0X3BlcmZvcm1ab29tOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgem9vbSA9IG1hcC5nZXRab29tKCksXG5cdFx0ICAgIHNuYXAgPSB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCB8fCAwO1xuXG5cdFx0bWFwLl9zdG9wKCk7IC8vIHN0b3AgcGFubmluZyBhbmQgZmx5IGFuaW1hdGlvbnMgaWYgYW55XG5cblx0XHQvLyBtYXAgdGhlIGRlbHRhIHdpdGggYSBzaWdtb2lkIGZ1bmN0aW9uIHRvIC00Li40IHJhbmdlIGxlYW5pbmcgb24gLTEuLjFcblx0XHR2YXIgZDIgPSB0aGlzLl9kZWx0YSAvICh0aGlzLl9tYXAub3B0aW9ucy53aGVlbFB4UGVyWm9vbUxldmVsICogNCksXG5cdFx0ICAgIGQzID0gNCAqIE1hdGgubG9nKDIgLyAoMSArIE1hdGguZXhwKC1NYXRoLmFicyhkMikpKSkgLyBNYXRoLkxOMixcblx0XHQgICAgZDQgPSBzbmFwID8gTWF0aC5jZWlsKGQzIC8gc25hcCkgKiBzbmFwIDogZDMsXG5cdFx0ICAgIGRlbHRhID0gbWFwLl9saW1pdFpvb20oem9vbSArICh0aGlzLl9kZWx0YSA+IDAgPyBkNCA6IC1kNCkpIC0gem9vbTtcblxuXHRcdHRoaXMuX2RlbHRhID0gMDtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuXG5cdFx0aWYgKCFkZWx0YSkgeyByZXR1cm47IH1cblxuXHRcdGlmIChtYXAub3B0aW9ucy5zY3JvbGxXaGVlbFpvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbSh6b29tICsgZGVsdGEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXAuc2V0Wm9vbUFyb3VuZCh0aGlzLl9sYXN0TW91c2VQb3MsIHpvb20gKyBkZWx0YSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBzY3JvbGxXaGVlbFpvb206IEhhbmRsZXJcbi8vIFNjcm9sbCB3aGVlbCB6b29tIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnc2Nyb2xsV2hlZWxab29tJywgU2Nyb2xsV2hlZWxab29tKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5cbi8qXG4gKiBMLk1hcC5UYXBIb2xkIGlzIHVzZWQgdG8gc2ltdWxhdGUgYGNvbnRleHRtZW51YCBldmVudCBvbiBsb25nIGhvbGQsXG4gKiB3aGljaCBvdGhlcndpc2UgaXMgbm90IGZpcmVkIGJ5IG1vYmlsZSBTYWZhcmkuXG4gKi9cblxudmFyIHRhcEhvbGREZWxheSA9IDYwMDtcblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAc2VjdGlvbiBUb3VjaCBpbnRlcmFjdGlvbiBvcHRpb25zXG5cdC8vIEBvcHRpb24gdGFwSG9sZDogQm9vbGVhblxuXHQvLyBFbmFibGVzIHNpbXVsYXRpb24gb2YgYGNvbnRleHRtZW51YCBldmVudCwgZGVmYXVsdCBpcyBgdHJ1ZWAgZm9yIG1vYmlsZSBTYWZhcmkuXG5cdHRhcEhvbGQ6IEJyb3dzZXIudG91Y2hOYXRpdmUgJiYgQnJvd3Nlci5zYWZhcmkgJiYgQnJvd3Nlci5tb2JpbGUsXG5cblx0Ly8gQG9wdGlvbiB0YXBUb2xlcmFuY2U6IE51bWJlciA9IDE1XG5cdC8vIFRoZSBtYXggbnVtYmVyIG9mIHBpeGVscyBhIHVzZXIgY2FuIHNoaWZ0IGhpcyBmaW5nZXIgZHVyaW5nIHRvdWNoXG5cdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgdGFwLlxuXHR0YXBUb2xlcmFuY2U6IDE1XG59KTtcblxuZXhwb3J0IHZhciBUYXBIb2xkID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcblx0fSxcblxuXHRfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9ob2xkVGltZW91dCk7XG5cdFx0aWYgKGUudG91Y2hlcy5sZW5ndGggIT09IDEpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXNbMF07XG5cdFx0dGhpcy5fc3RhcnRQb3MgPSB0aGlzLl9uZXdQb3MgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cblx0XHR0aGlzLl9ob2xkVGltZW91dCA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuX2NhbmNlbCgpO1xuXHRcdFx0aWYgKCF0aGlzLl9pc1RhcFZhbGlkKCkpIHsgcmV0dXJuOyB9XG5cblx0XHRcdC8vIHByZXZlbnQgc2ltdWxhdGVkIG1vdXNlIGV2ZW50cyBodHRwczovL3czYy5naXRodWIuaW8vdG91Y2gtZXZlbnRzLyNtb3VzZS1ldmVudHNcblx0XHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCAndG91Y2hlbmQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XG5cdFx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fY2FuY2VsQ2xpY2tQcmV2ZW50KTtcblx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ2NvbnRleHRtZW51JywgZmlyc3QpO1xuXHRcdH0sIHRoaXMpLCB0YXBIb2xkRGVsYXkpO1xuXG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCBjb250ZXh0bWVudScsIHRoaXMuX2NhbmNlbCwgdGhpcyk7XG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdmUsIHRoaXMpO1xuXHR9LFxuXG5cdF9jYW5jZWxDbGlja1ByZXZlbnQ6IGZ1bmN0aW9uIGNhbmNlbENsaWNrUHJldmVudCgpIHtcblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICd0b3VjaGVuZCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIGNhbmNlbENsaWNrUHJldmVudCk7XG5cdH0sXG5cblx0X2NhbmNlbDogZnVuY3Rpb24gKCkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9ob2xkVGltZW91dCk7XG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwgY29udGV4dG1lbnUnLCB0aGlzLl9jYW5jZWwsIHRoaXMpO1xuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXNbMF07XG5cdFx0dGhpcy5fbmV3UG9zID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xuXHR9LFxuXG5cdF9pc1RhcFZhbGlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX25ld1Bvcy5kaXN0YW5jZVRvKHRoaXMuX3N0YXJ0UG9zKSA8PSB0aGlzLl9tYXAub3B0aW9ucy50YXBUb2xlcmFuY2U7XG5cdH0sXG5cblx0X3NpbXVsYXRlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG5cdFx0dmFyIHNpbXVsYXRlZEV2ZW50ID0gbmV3IE1vdXNlRXZlbnQodHlwZSwge1xuXHRcdFx0YnViYmxlczogdHJ1ZSxcblx0XHRcdGNhbmNlbGFibGU6IHRydWUsXG5cdFx0XHR2aWV3OiB3aW5kb3csXG5cdFx0XHQvLyBkZXRhaWw6IDEsXG5cdFx0XHRzY3JlZW5YOiBlLnNjcmVlblgsXG5cdFx0XHRzY3JlZW5ZOiBlLnNjcmVlblksXG5cdFx0XHRjbGllbnRYOiBlLmNsaWVudFgsXG5cdFx0XHRjbGllbnRZOiBlLmNsaWVudFksXG5cdFx0XHQvLyBidXR0b246IDIsXG5cdFx0XHQvLyBidXR0b25zOiAyXG5cdFx0fSk7XG5cblx0XHRzaW11bGF0ZWRFdmVudC5fc2ltdWxhdGVkID0gdHJ1ZTtcblxuXHRcdGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQoc2ltdWxhdGVkRXZlbnQpO1xuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSB0YXBIb2xkOiBIYW5kbGVyXG4vLyBMb25nIHRhcCBoYW5kbGVyIHRvIHNpbXVsYXRlIGBjb250ZXh0bWVudWAgZXZlbnQgKHVzZWZ1bCBpbiBtb2JpbGUgU2FmYXJpKS5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0YXBIb2xkJywgVGFwSG9sZCk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5cbi8qXG4gKiBMLkhhbmRsZXIuVG91Y2hab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gYWRkIHBpbmNoIHpvb20gb24gc3VwcG9ydGVkIG1vYmlsZSBicm93c2Vycy5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiB0b3VjaFpvb206IEJvb2xlYW58U3RyaW5nID0gKlxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB0b3VjaC1kcmFnZ2luZyB3aXRoIHR3byBmaW5nZXJzLiBJZlxuXHQvLyBwYXNzZWQgYCdjZW50ZXInYCwgaXQgd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgcmVnYXJkbGVzcyBvZlxuXHQvLyB3aGVyZSB0aGUgdG91Y2ggZXZlbnRzIChmaW5nZXJzKSB3ZXJlLiBFbmFibGVkIGZvciB0b3VjaC1jYXBhYmxlIHdlYlxuXHQvLyBicm93c2Vycy5cblx0dG91Y2hab29tOiBCcm93c2VyLnRvdWNoLFxuXG5cdC8vIEBvcHRpb24gYm91bmNlQXRab29tTGltaXRzOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBTZXQgaXQgdG8gZmFsc2UgaWYgeW91IGRvbid0IHdhbnQgdGhlIG1hcCB0byB6b29tIGJleW9uZCBtaW4vbWF4IHpvb21cblx0Ly8gYW5kIHRoZW4gYm91bmNlIGJhY2sgd2hlbiBwaW5jaC16b29taW5nLlxuXHRib3VuY2VBdFpvb21MaW1pdHM6IHRydWVcbn0pO1xuXG5leHBvcnQgdmFyIFRvdWNoWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC16b29tJyk7XG5cdFx0RG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLXpvb20nKTtcblx0XHREb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcblx0fSxcblxuXHRfb25Ub3VjaFN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCBtYXAuX2FuaW1hdGluZ1pvb20gfHwgdGhpcy5fem9vbWluZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBwMSA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMF0pLFxuXHRcdCAgICBwMiA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMV0pO1xuXG5cdFx0dGhpcy5fY2VudGVyUG9pbnQgPSBtYXAuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcblx0XHR0aGlzLl9zdGFydExhdExuZyA9IG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX2NlbnRlclBvaW50KTtcblx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tICE9PSAnY2VudGVyJykge1xuXHRcdFx0dGhpcy5fcGluY2hTdGFydExhdExuZyA9IG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHAxLmFkZChwMikuX2RpdmlkZUJ5KDIpKTtcblx0XHR9XG5cblx0XHR0aGlzLl9zdGFydERpc3QgPSBwMS5kaXN0YW5jZVRvKHAyKTtcblx0XHR0aGlzLl9zdGFydFpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcblx0XHR0aGlzLl96b29taW5nID0gdHJ1ZTtcblxuXHRcdG1hcC5fc3RvcCgpO1xuXG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcyk7XG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIHRoaXMuX29uVG91Y2hFbmQsIHRoaXMpO1xuXG5cdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdH0sXG5cblx0X29uVG91Y2hNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgIXRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBwMSA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMF0pLFxuXHRcdCAgICBwMiA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMV0pLFxuXHRcdCAgICBzY2FsZSA9IHAxLmRpc3RhbmNlVG8ocDIpIC8gdGhpcy5fc3RhcnREaXN0O1xuXG5cdFx0dGhpcy5fem9vbSA9IG1hcC5nZXRTY2FsZVpvb20oc2NhbGUsIHRoaXMuX3N0YXJ0Wm9vbSk7XG5cblx0XHRpZiAoIW1hcC5vcHRpb25zLmJvdW5jZUF0Wm9vbUxpbWl0cyAmJiAoXG5cdFx0XHQodGhpcy5fem9vbSA8IG1hcC5nZXRNaW5ab29tKCkgJiYgc2NhbGUgPCAxKSB8fFxuXHRcdFx0KHRoaXMuX3pvb20gPiBtYXAuZ2V0TWF4Wm9vbSgpICYmIHNjYWxlID4gMSkpKSB7XG5cdFx0XHR0aGlzLl96b29tID0gbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSk7XG5cdFx0fVxuXG5cdFx0aWYgKG1hcC5vcHRpb25zLnRvdWNoWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdHRoaXMuX2NlbnRlciA9IHRoaXMuX3N0YXJ0TGF0TG5nO1xuXHRcdFx0aWYgKHNjYWxlID09PSAxKSB7IHJldHVybjsgfVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBHZXQgZGVsdGEgZnJvbSBwaW5jaCB0byBjZW50ZXIsIHNvIGNlbnRlckxhdExuZyBpcyBkZWx0YSBhcHBsaWVkIHRvIGluaXRpYWwgcGluY2hMYXRMbmdcblx0XHRcdHZhciBkZWx0YSA9IHAxLl9hZGQocDIpLl9kaXZpZGVCeSgyKS5fc3VidHJhY3QodGhpcy5fY2VudGVyUG9pbnQpO1xuXHRcdFx0aWYgKHNjYWxlID09PSAxICYmIGRlbHRhLnggPT09IDAgJiYgZGVsdGEueSA9PT0gMCkgeyByZXR1cm47IH1cblx0XHRcdHRoaXMuX2NlbnRlciA9IG1hcC51bnByb2plY3QobWFwLnByb2plY3QodGhpcy5fcGluY2hTdGFydExhdExuZywgdGhpcy5fem9vbSkuc3VidHJhY3QoZGVsdGEpLCB0aGlzLl96b29tKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG5cdFx0XHRtYXAuX21vdmVTdGFydCh0cnVlLCBmYWxzZSk7XG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG5cdFx0dmFyIG1vdmVGbiA9IFV0aWwuYmluZChtYXAuX21vdmUsIG1hcCwgdGhpcy5fY2VudGVyLCB0aGlzLl96b29tLCB7cGluY2g6IHRydWUsIHJvdW5kOiBmYWxzZX0sIHVuZGVmaW5lZCk7XG5cdFx0dGhpcy5fYW5pbVJlcXVlc3QgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUobW92ZUZuLCB0aGlzLCB0cnVlKTtcblxuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHR9LFxuXG5cdF9vblRvdWNoRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCB8fCAhdGhpcy5fem9vbWluZykge1xuXHRcdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcyk7XG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCB0aGlzLl9vblRvdWNoRW5kLCB0aGlzKTtcblxuXHRcdC8vIFBpbmNoIHVwZGF0ZXMgR3JpZExheWVycycgbGV2ZWxzIG9ubHkgd2hlbiB6b29tU25hcCBpcyBvZmYsIHNvIHpvb21TbmFwIGJlY29tZXMgbm9VcGRhdGUuXG5cdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLnpvb21BbmltYXRpb24pIHtcblx0XHRcdHRoaXMuX21hcC5fYW5pbWF0ZVpvb20odGhpcy5fY2VudGVyLCB0aGlzLl9tYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSwgdHJ1ZSwgdGhpcy5fbWFwLm9wdGlvbnMuem9vbVNuYXApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9tYXAuX3Jlc2V0Vmlldyh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHRvdWNoWm9vbTogSGFuZGxlclxuLy8gVG91Y2ggem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RvdWNoWm9vbScsIFRvdWNoWm9vbSk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi9NYXAnO1xuaW1wb3J0IHtCb3hab29tfSBmcm9tICcuL2hhbmRsZXIvTWFwLkJveFpvb20nO1xuTWFwLkJveFpvb20gPSBCb3hab29tO1xuaW1wb3J0IHtEb3VibGVDbGlja1pvb219IGZyb20gJy4vaGFuZGxlci9NYXAuRG91YmxlQ2xpY2tab29tJztcbk1hcC5Eb3VibGVDbGlja1pvb20gPSBEb3VibGVDbGlja1pvb207XG5pbXBvcnQge0RyYWd9IGZyb20gJy4vaGFuZGxlci9NYXAuRHJhZyc7XG5NYXAuRHJhZyA9IERyYWc7XG5pbXBvcnQge0tleWJvYXJkfSBmcm9tICcuL2hhbmRsZXIvTWFwLktleWJvYXJkJztcbk1hcC5LZXlib2FyZCA9IEtleWJvYXJkO1xuaW1wb3J0IHtTY3JvbGxXaGVlbFpvb219IGZyb20gJy4vaGFuZGxlci9NYXAuU2Nyb2xsV2hlZWxab29tJztcbk1hcC5TY3JvbGxXaGVlbFpvb20gPSBTY3JvbGxXaGVlbFpvb207XG5pbXBvcnQge1RhcEhvbGR9IGZyb20gJy4vaGFuZGxlci9NYXAuVGFwSG9sZCc7XG5NYXAuVGFwSG9sZCA9IFRhcEhvbGQ7XG5pbXBvcnQge1RvdWNoWm9vbX0gZnJvbSAnLi9oYW5kbGVyL01hcC5Ub3VjaFpvb20nO1xuTWFwLlRvdWNoWm9vbSA9IFRvdWNoWm9vbTtcblxuZXhwb3J0IHtNYXAsIGNyZWF0ZU1hcCBhcyBtYXB9IGZyb20gJy4vTWFwJztcbiJdLCJuYW1lcyI6WyJleHRlbmQiLCJkZXN0IiwiaSIsImoiLCJsZW4iLCJzcmMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJjcmVhdGUkMiIsIk9iamVjdCIsImNyZWF0ZSIsIkYiLCJwcm90byIsInByb3RvdHlwZSIsImJpbmQiLCJmbiIsIm9iaiIsInNsaWNlIiwiQXJyYXkiLCJhcHBseSIsImNhbGwiLCJhcmdzIiwiY29uY2F0IiwibGFzdElkIiwic3RhbXAiLCJfbGVhZmxldF9pZCIsInRocm90dGxlIiwidGltZSIsImNvbnRleHQiLCJsb2NrIiwid3JhcHBlckZuIiwibGF0ZXIiLCJzZXRUaW1lb3V0Iiwid3JhcE51bSIsIngiLCJyYW5nZSIsImluY2x1ZGVNYXgiLCJtYXgiLCJtaW4iLCJkIiwiZmFsc2VGbiIsImZvcm1hdE51bSIsIm51bSIsInByZWNpc2lvbiIsInBvdyIsIk1hdGgiLCJ1bmRlZmluZWQiLCJyb3VuZCIsInRyaW0iLCJzdHIiLCJyZXBsYWNlIiwic3BsaXRXb3JkcyIsInNwbGl0Iiwic2V0T3B0aW9ucyIsIm9wdGlvbnMiLCJoYXNPd25Qcm9wZXJ0eSIsImdldFBhcmFtU3RyaW5nIiwiZXhpc3RpbmdVcmwiLCJ1cHBlcmNhc2UiLCJwYXJhbXMiLCJwdXNoIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwidG9VcHBlckNhc2UiLCJpbmRleE9mIiwiam9pbiIsInRlbXBsYXRlUmUiLCJ0ZW1wbGF0ZSIsImRhdGEiLCJrZXkiLCJ2YWx1ZSIsIkVycm9yIiwiaXNBcnJheSIsInRvU3RyaW5nIiwiYXJyYXkiLCJlbCIsImVtcHR5SW1hZ2VVcmwiLCJnZXRQcmVmaXhlZCIsIm5hbWUiLCJ3aW5kb3ciLCJsYXN0VGltZSIsInRpbWVvdXREZWZlciIsIkRhdGUiLCJ0aW1lVG9DYWxsIiwicmVxdWVzdEZuIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsRm4iLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImlkIiwiY2xlYXJUaW1lb3V0IiwicmVxdWVzdEFuaW1GcmFtZSIsImltbWVkaWF0ZSIsImNhbmNlbEFuaW1GcmFtZSIsIkNsYXNzIiwicHJvcHMiLCJOZXdDbGFzcyIsImluaXRpYWxpemUiLCJjYWxsSW5pdEhvb2tzIiwicGFyZW50UHJvdG8iLCJfX3N1cGVyX18iLCJjb25zdHJ1Y3RvciIsInN0YXRpY3MiLCJpbmNsdWRlcyIsImNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzIiwiX2luaXRIb29rcyIsIl9pbml0SG9va3NDYWxsZWQiLCJpbmNsdWRlIiwicGFyZW50T3B0aW9ucyIsIm1lcmdlT3B0aW9ucyIsImFkZEluaXRIb29rIiwiaW5pdCIsIkwiLCJNaXhpbiIsIkV2ZW50cyIsImNvbnNvbGUiLCJ3YXJuIiwic3RhY2siLCJvbiIsInR5cGVzIiwiX3R5cGVvZiIsInR5cGUiLCJfb24iLCJvZmYiLCJfZXZlbnRzIiwiX29mZiIsInJlbW92ZUFsbCIsIl9vbmNlIiwiX2xpc3RlbnMiLCJuZXdMaXN0ZW5lciIsImN0eCIsIm9uY2UiLCJsaXN0ZW5lcnMiLCJfZmlyaW5nQ291bnQiLCJpbmRleCIsImxpc3RlbmVyIiwic3BsaWNlIiwiZmlyZSIsInByb3BhZ2F0ZSIsImxpc3RlbnMiLCJldmVudCIsInRhcmdldCIsInNvdXJjZVRhcmdldCIsImwiLCJfcHJvcGFnYXRlRXZlbnQiLCJfZm4iLCJfZXZlbnRQYXJlbnRzIiwiYWRkRXZlbnRQYXJlbnQiLCJyZW1vdmVFdmVudFBhcmVudCIsImUiLCJsYXllciIsInByb3BhZ2F0ZWRGcm9tIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjbGVhckFsbEV2ZW50TGlzdGVuZXJzIiwiYWRkT25lVGltZUV2ZW50TGlzdGVuZXIiLCJmaXJlRXZlbnQiLCJoYXNFdmVudExpc3RlbmVycyIsIkV2ZW50ZWQiLCJQb2ludCIsInkiLCJ0cnVuYyIsInYiLCJmbG9vciIsImNlaWwiLCJjbG9uZSIsImFkZCIsInBvaW50IiwiX2FkZCIsInRvUG9pbnQiLCJzdWJ0cmFjdCIsIl9zdWJ0cmFjdCIsImRpdmlkZUJ5IiwiX2RpdmlkZUJ5IiwibXVsdGlwbHlCeSIsIl9tdWx0aXBseUJ5Iiwic2NhbGVCeSIsInVuc2NhbGVCeSIsIl9yb3VuZCIsIl9mbG9vciIsIl9jZWlsIiwiX3RydW5jIiwiZGlzdGFuY2VUbyIsInNxcnQiLCJlcXVhbHMiLCJjb250YWlucyIsImFicyIsIkJvdW5kcyIsImEiLCJiIiwicG9pbnRzIiwibWluMiIsIm1heDIiLCJ0b0JvdW5kcyIsImdldENlbnRlciIsImdldEJvdHRvbUxlZnQiLCJnZXRUb3BSaWdodCIsImdldFRvcExlZnQiLCJnZXRCb3R0b21SaWdodCIsImdldFNpemUiLCJpbnRlcnNlY3RzIiwiYm91bmRzIiwieEludGVyc2VjdHMiLCJ5SW50ZXJzZWN0cyIsIm92ZXJsYXBzIiwieE92ZXJsYXBzIiwieU92ZXJsYXBzIiwiaXNWYWxpZCIsInBhZCIsImJ1ZmZlclJhdGlvIiwiaGVpZ2h0QnVmZmVyIiwid2lkdGhCdWZmZXIiLCJMYXRMbmdCb3VuZHMiLCJjb3JuZXIxIiwiY29ybmVyMiIsImxhdGxuZ3MiLCJzdyIsIl9zb3V0aFdlc3QiLCJuZSIsIl9ub3J0aEVhc3QiLCJzdzIiLCJuZTIiLCJMYXRMbmciLCJ0b0xhdExuZyIsInRvTGF0TG5nQm91bmRzIiwibGF0IiwibG5nIiwiZ2V0U291dGhXZXN0IiwiZ2V0Tm9ydGhFYXN0IiwiZ2V0Tm9ydGhXZXN0IiwiZ2V0Tm9ydGgiLCJnZXRXZXN0IiwiZ2V0U291dGhFYXN0IiwiZ2V0U291dGgiLCJnZXRFYXN0IiwibGF0SW50ZXJzZWN0cyIsImxuZ0ludGVyc2VjdHMiLCJsYXRPdmVybGFwcyIsImxuZ092ZXJsYXBzIiwidG9CQm94U3RyaW5nIiwibWF4TWFyZ2luIiwiYWx0IiwiaXNOYU4iLCJtYXJnaW4iLCJvdGhlciIsIkVhcnRoIiwiZGlzdGFuY2UiLCJ3cmFwIiwid3JhcExhdExuZyIsInNpemVJbk1ldGVycyIsImxhdEFjY3VyYWN5IiwibG5nQWNjdXJhY3kiLCJjb3MiLCJQSSIsImMiLCJsb24iLCJDUlMiLCJsYXRMbmdUb1BvaW50IiwibGF0bG5nIiwiem9vbSIsInByb2plY3RlZFBvaW50IiwicHJvamVjdGlvbiIsInByb2plY3QiLCJzY2FsZSIsInRyYW5zZm9ybWF0aW9uIiwiX3RyYW5zZm9ybSIsInBvaW50VG9MYXRMbmciLCJ1bnRyYW5zZm9ybWVkUG9pbnQiLCJ1bnRyYW5zZm9ybSIsInVucHJvamVjdCIsImxvZyIsIkxOMiIsImdldFByb2plY3RlZEJvdW5kcyIsImluZmluaXRlIiwicyIsInRyYW5zZm9ybSIsIndyYXBMbmciLCJ3cmFwTGF0Iiwid3JhcExhdExuZ0JvdW5kcyIsImNlbnRlciIsIm5ld0NlbnRlciIsImxhdFNoaWZ0IiwibG5nU2hpZnQiLCJuZXdTdyIsIm5ld05lIiwiUiIsImxhdGxuZzEiLCJsYXRsbmcyIiwicmFkIiwibGF0MSIsImxhdDIiLCJzaW5ETGF0Iiwic2luIiwic2luRExvbiIsImF0YW4yIiwiZWFydGhSYWRpdXMiLCJTcGhlcmljYWxNZXJjYXRvciIsIk1BWF9MQVRJVFVERSIsImF0YW4iLCJleHAiLCJUcmFuc2Zvcm1hdGlvbiIsIl9hIiwiX2IiLCJfYyIsIl9kIiwidG9UcmFuc2Zvcm1hdGlvbiIsIkVQU0czODU3IiwiY29kZSIsIkVQU0c5MDA5MTMiLCJzdmdDcmVhdGUiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnROUyIsInBvaW50c1RvUGF0aCIsInJpbmdzIiwiY2xvc2VkIiwibGVuMiIsInAiLCJCcm93c2VyIiwic3ZnIiwic3R5bGUiLCJkb2N1bWVudEVsZW1lbnQiLCJpZSIsImllbHQ5IiwiZWRnZSIsIm5hdmlnYXRvciIsIndlYmtpdCIsInVzZXJBZ2VudENvbnRhaW5zIiwiYW5kcm9pZCIsImFuZHJvaWQyMyIsIndlYmtpdFZlciIsInBhcnNlSW50IiwiZXhlYyIsInVzZXJBZ2VudCIsImFuZHJvaWRTdG9jayIsIm9wZXJhIiwiY2hyb21lIiwiZ2Vja28iLCJzYWZhcmkiLCJwaGFudG9tIiwib3BlcmExMiIsIndpbiIsInBsYXRmb3JtIiwiaWUzZCIsIndlYmtpdDNkIiwiV2ViS2l0Q1NTTWF0cml4IiwiZ2Vja28zZCIsImFueTNkIiwiTF9ESVNBQkxFXzNEIiwibW9iaWxlIiwib3JpZW50YXRpb24iLCJtb2JpbGVXZWJraXQiLCJtb2JpbGVXZWJraXQzZCIsIm1zUG9pbnRlciIsIlBvaW50ZXJFdmVudCIsIk1TUG9pbnRlckV2ZW50IiwicG9pbnRlciIsInRvdWNoTmF0aXZlIiwiVG91Y2hFdmVudCIsInRvdWNoIiwiTF9OT19UT1VDSCIsIm1vYmlsZU9wZXJhIiwibW9iaWxlR2Vja28iLCJyZXRpbmEiLCJkZXZpY2VQaXhlbFJhdGlvIiwic2NyZWVuIiwiZGV2aWNlWERQSSIsImxvZ2ljYWxYRFBJIiwicGFzc2l2ZUV2ZW50cyIsInN1cHBvcnRzUGFzc2l2ZU9wdGlvbiIsIm9wdHMiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImNhbnZhcyQxIiwiY3JlYXRlRWxlbWVudCIsImdldENvbnRleHQiLCJzdmckMSIsImNyZWF0ZVNWR1JlY3QiLCJpbmxpbmVTdmciLCJkaXYiLCJpbm5lckhUTUwiLCJmaXJzdENoaWxkIiwibmFtZXNwYWNlVVJJIiwidm1sIiwic2hhcGUiLCJiZWhhdmlvciIsImFkaiIsIm1hYyIsImxpbnV4IiwidG9Mb3dlckNhc2UiLCJjYW52YXMiLCJQT0lOVEVSX0RPV04iLCJQT0lOVEVSX01PVkUiLCJQT0lOVEVSX1VQIiwiUE9JTlRFUl9DQU5DRUwiLCJwRXZlbnQiLCJ0b3VjaHN0YXJ0IiwidG91Y2htb3ZlIiwidG91Y2hlbmQiLCJ0b3VjaGNhbmNlbCIsImhhbmRsZSIsIl9vblBvaW50ZXJTdGFydCIsIl9oYW5kbGVQb2ludGVyIiwiX3BvaW50ZXJzIiwiX3BvaW50ZXJEb2NMaXN0ZW5lciIsImFkZFBvaW50ZXJMaXN0ZW5lciIsImhhbmRsZXIiLCJfYWRkUG9pbnRlckRvY0xpc3RlbmVyIiwicmVtb3ZlUG9pbnRlckxpc3RlbmVyIiwiX2dsb2JhbFBvaW50ZXJEb3duIiwicG9pbnRlcklkIiwiX2dsb2JhbFBvaW50ZXJNb3ZlIiwiX2dsb2JhbFBvaW50ZXJVcCIsInBvaW50ZXJUeXBlIiwiTVNQT0lOVEVSX1RZUEVfTU9VU0UiLCJ0b3VjaGVzIiwiY2hhbmdlZFRvdWNoZXMiLCJNU1BPSU5URVJfVFlQRV9UT1VDSCIsInByZXZlbnREZWZhdWx0IiwibWFrZURibGNsaWNrIiwibmV3RXZlbnQiLCJwcm9wIiwiZGV0YWlsIiwiaXNUcnVzdGVkIiwiX3NpbXVsYXRlZCIsImRlbGF5IiwiYWRkRG91YmxlVGFwTGlzdGVuZXIiLCJsYXN0Iiwic2ltRGJsY2xpY2siLCJzb3VyY2VDYXBhYmlsaXRpZXMiLCJmaXJlc1RvdWNoRXZlbnRzIiwicGF0aCIsImdldFByb3BhZ2F0aW9uUGF0aCIsInNvbWUiLCJIVE1MTGFiZWxFbGVtZW50IiwiYXR0cmlidXRlcyIsIkhUTUxJbnB1dEVsZW1lbnQiLCJIVE1MU2VsZWN0RWxlbWVudCIsIm5vdyIsImRibGNsaWNrIiwicmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIiLCJoYW5kbGVycyIsIlRSQU5TRk9STSIsInRlc3RQcm9wIiwiVFJBTlNJVElPTiIsIlRSQU5TSVRJT05fRU5EIiwiZ2V0RWxlbWVudEJ5SWQiLCJnZXRTdHlsZSIsImN1cnJlbnRTdHlsZSIsImRlZmF1bHRWaWV3IiwiY3NzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImNyZWF0ZSQxIiwidGFnTmFtZSIsImNsYXNzTmFtZSIsImNvbnRhaW5lciIsImFwcGVuZENoaWxkIiwicmVtb3ZlIiwicGFyZW50IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZW1wdHkiLCJ0b0Zyb250IiwibGFzdENoaWxkIiwidG9CYWNrIiwiaW5zZXJ0QmVmb3JlIiwiaGFzQ2xhc3MiLCJjbGFzc0xpc3QiLCJnZXRDbGFzcyIsIlJlZ0V4cCIsInRlc3QiLCJhZGRDbGFzcyIsImNsYXNzZXMiLCJzZXRDbGFzcyIsInJlbW92ZUNsYXNzIiwiYmFzZVZhbCIsImNvcnJlc3BvbmRpbmdFbGVtZW50Iiwic2V0T3BhY2l0eSIsIm9wYWNpdHkiLCJfc2V0T3BhY2l0eUlFIiwiZmlsdGVyIiwiZmlsdGVyTmFtZSIsImZpbHRlcnMiLCJpdGVtIiwiRW5hYmxlZCIsIk9wYWNpdHkiLCJzZXRUcmFuc2Zvcm0iLCJvZmZzZXQiLCJwb3MiLCJzZXRQb3NpdGlvbiIsIl9sZWFmbGV0X3BvcyIsImxlZnQiLCJ0b3AiLCJnZXRQb3NpdGlvbiIsImRpc2FibGVUZXh0U2VsZWN0aW9uIiwiZW5hYmxlVGV4dFNlbGVjdGlvbiIsIl91c2VyU2VsZWN0IiwidXNlclNlbGVjdFByb3BlcnR5IiwiZGlzYWJsZUltYWdlRHJhZyIsImVuYWJsZUltYWdlRHJhZyIsIl9vdXRsaW5lRWxlbWVudCIsIl9vdXRsaW5lU3R5bGUiLCJwcmV2ZW50T3V0bGluZSIsImVsZW1lbnQiLCJ0YWJJbmRleCIsInJlc3RvcmVPdXRsaW5lIiwib3V0bGluZVN0eWxlIiwiZ2V0U2l6ZWRQYXJlbnROb2RlIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJib2R5IiwiZ2V0U2NhbGUiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJib3VuZGluZ0NsaWVudFJlY3QiLCJhZGRPbmUiLCJldmVudHNLZXkiLCJiYXRjaFJlbW92ZSIsInJlbW92ZU9uZSIsImZpbHRlckZuIiwibW91c2VTdWJzdCIsIm1vdXNlZW50ZXIiLCJtb3VzZWxlYXZlIiwid2hlZWwiLCJvcmlnaW5hbEhhbmRsZXIiLCJwYXNzaXZlIiwiaXNFeHRlcm5hbFRhcmdldCIsImF0dGFjaEV2ZW50IiwiZGV0YWNoRXZlbnQiLCJzdG9wUHJvcGFnYXRpb24iLCJvcmlnaW5hbEV2ZW50IiwiX3N0b3BwZWQiLCJjYW5jZWxCdWJibGUiLCJkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24iLCJkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbiIsInJldHVyblZhbHVlIiwic3RvcCIsImV2IiwiY29tcG9zZWRQYXRoIiwiZ2V0TW91c2VQb3NpdGlvbiIsImNsaWVudFgiLCJjbGllbnRZIiwiY2xpZW50TGVmdCIsImNsaWVudFRvcCIsIndoZWVsUHhGYWN0b3IiLCJnZXRXaGVlbERlbHRhIiwid2hlZWxEZWx0YVkiLCJkZWx0YVkiLCJkZWx0YU1vZGUiLCJkZWx0YVgiLCJkZWx0YVoiLCJ3aGVlbERlbHRhIiwicmVsYXRlZCIsInJlbGF0ZWRUYXJnZXQiLCJlcnIiLCJQb3NBbmltYXRpb24iLCJydW4iLCJuZXdQb3MiLCJkdXJhdGlvbiIsImVhc2VMaW5lYXJpdHkiLCJfZWwiLCJfaW5Qcm9ncmVzcyIsIl9kdXJhdGlvbiIsIl9lYXNlT3V0UG93ZXIiLCJfc3RhcnRQb3MiLCJfb2Zmc2V0IiwiX3N0YXJ0VGltZSIsIl9hbmltYXRlIiwiX3N0ZXAiLCJfY29tcGxldGUiLCJfYW5pbUlkIiwiZWxhcHNlZCIsIl9ydW5GcmFtZSIsIl9lYXNlT3V0IiwicHJvZ3Jlc3MiLCJ0IiwiTWFwIiwiY3JzIiwibWluWm9vbSIsIm1heFpvb20iLCJsYXllcnMiLCJtYXhCb3VuZHMiLCJyZW5kZXJlciIsInpvb21BbmltYXRpb24iLCJ6b29tQW5pbWF0aW9uVGhyZXNob2xkIiwiZmFkZUFuaW1hdGlvbiIsIm1hcmtlclpvb21BbmltYXRpb24iLCJ0cmFuc2Zvcm0zRExpbWl0Iiwiem9vbVNuYXAiLCJ6b29tRGVsdGEiLCJ0cmFja1Jlc2l6ZSIsIl9oYW5kbGVycyIsIl9sYXllcnMiLCJfem9vbUJvdW5kTGF5ZXJzIiwiX3NpemVDaGFuZ2VkIiwiX2luaXRDb250YWluZXIiLCJfaW5pdExheW91dCIsIl9vblJlc2l6ZSIsIl9pbml0RXZlbnRzIiwic2V0TWF4Qm91bmRzIiwiX3pvb20iLCJfbGltaXRab29tIiwic2V0VmlldyIsInJlc2V0IiwiX3pvb21BbmltYXRlZCIsIl9jcmVhdGVBbmltUHJveHkiLCJfcHJveHkiLCJfY2F0Y2hUcmFuc2l0aW9uRW5kIiwiX2FkZExheWVycyIsIl9saW1pdENlbnRlciIsIl9zdG9wIiwiX2xvYWRlZCIsImFuaW1hdGUiLCJwYW4iLCJtb3ZlZCIsIl90cnlBbmltYXRlZFpvb20iLCJfdHJ5QW5pbWF0ZWRQYW4iLCJfc2l6ZVRpbWVyIiwiX3Jlc2V0VmlldyIsIm5vTW92ZVN0YXJ0Iiwic2V0Wm9vbSIsInpvb21JbiIsImRlbHRhIiwiem9vbU91dCIsInNldFpvb21Bcm91bmQiLCJnZXRab29tU2NhbGUiLCJ2aWV3SGFsZiIsImNvbnRhaW5lclBvaW50IiwibGF0TG5nVG9Db250YWluZXJQb2ludCIsImNlbnRlck9mZnNldCIsImNvbnRhaW5lclBvaW50VG9MYXRMbmciLCJfZ2V0Qm91bmRzQ2VudGVyWm9vbSIsImdldEJvdW5kcyIsInBhZGRpbmdUTCIsInBhZGRpbmdUb3BMZWZ0IiwicGFkZGluZyIsInBhZGRpbmdCUiIsInBhZGRpbmdCb3R0b21SaWdodCIsImdldEJvdW5kc1pvb20iLCJJbmZpbml0eSIsInBhZGRpbmdPZmZzZXQiLCJzd1BvaW50IiwibmVQb2ludCIsImZpdEJvdW5kcyIsImZpdFdvcmxkIiwicGFuVG8iLCJwYW5CeSIsImdldFpvb20iLCJfcGFuQW5pbSIsIl9vblBhblRyYW5zaXRpb25TdGVwIiwiX29uUGFuVHJhbnNpdGlvbkVuZCIsIl9tYXBQYW5lIiwiX2dldE1hcFBhbmVQb3MiLCJfcmF3UGFuQnkiLCJmbHlUbyIsInRhcmdldENlbnRlciIsInRhcmdldFpvb20iLCJmcm9tIiwidG8iLCJzaXplIiwic3RhcnRab29tIiwidzAiLCJ3MSIsInUxIiwicmhvIiwicmhvMiIsInIiLCJzMSIsInMyIiwidDEiLCJiMSIsInNxIiwic2luaCIsIm4iLCJjb3NoIiwidGFuaCIsInIwIiwidyIsInUiLCJlYXNlT3V0Iiwic3RhcnQiLCJTIiwiZnJhbWUiLCJfZmx5VG9GcmFtZSIsIl9tb3ZlIiwiZ2V0U2NhbGVab29tIiwiX21vdmVFbmQiLCJfbW92ZVN0YXJ0IiwiZmx5VG9Cb3VuZHMiLCJfcGFuSW5zaWRlTWF4Qm91bmRzIiwic2V0TWluWm9vbSIsIm9sZFpvb20iLCJzZXRNYXhab29tIiwicGFuSW5zaWRlQm91bmRzIiwiX2VuZm9yY2luZ0JvdW5kcyIsInBhbkluc2lkZSIsInBpeGVsQ2VudGVyIiwicGl4ZWxQb2ludCIsInBpeGVsQm91bmRzIiwiZ2V0UGl4ZWxCb3VuZHMiLCJwYWRkZWRCb3VuZHMiLCJwYWRkZWRTaXplIiwiaW52YWxpZGF0ZVNpemUiLCJvbGRTaXplIiwiX2xhc3RDZW50ZXIiLCJuZXdTaXplIiwib2xkQ2VudGVyIiwiZGVib3VuY2VNb3ZlZW5kIiwibG9jYXRlIiwiX2xvY2F0ZU9wdGlvbnMiLCJ0aW1lb3V0Iiwid2F0Y2giLCJfaGFuZGxlR2VvbG9jYXRpb25FcnJvciIsIm1lc3NhZ2UiLCJvblJlc3BvbnNlIiwiX2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2UiLCJvbkVycm9yIiwiX2xvY2F0aW9uV2F0Y2hJZCIsImdlb2xvY2F0aW9uIiwid2F0Y2hQb3NpdGlvbiIsImdldEN1cnJlbnRQb3NpdGlvbiIsInN0b3BMb2NhdGUiLCJjbGVhcldhdGNoIiwiZXJyb3IiLCJfY29udGFpbmVyIiwiY29vcmRzIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJhY2N1cmFjeSIsInRpbWVzdGFtcCIsImFkZEhhbmRsZXIiLCJIYW5kbGVyQ2xhc3MiLCJlbmFibGUiLCJfY29udGFpbmVySWQiLCJfY2xlYXJDb250cm9sUG9zIiwiX3Jlc2l6ZVJlcXVlc3QiLCJfY2xlYXJIYW5kbGVycyIsIl9wYW5lcyIsIl9yZW5kZXJlciIsImNyZWF0ZVBhbmUiLCJwYW5lIiwiX2NoZWNrSWZMb2FkZWQiLCJfbW92ZWQiLCJsYXllclBvaW50VG9MYXRMbmciLCJfZ2V0Q2VudGVyTGF5ZXJQb2ludCIsImdldE1pblpvb20iLCJfbGF5ZXJzTWluWm9vbSIsImdldE1heFpvb20iLCJfbGF5ZXJzTWF4Wm9vbSIsImluc2lkZSIsIm53Iiwic2UiLCJib3VuZHNTaXplIiwic25hcCIsInNjYWxleCIsInNjYWxleSIsIl9zaXplIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJ0b3BMZWZ0UG9pbnQiLCJfZ2V0VG9wTGVmdFBvaW50IiwiZ2V0UGl4ZWxPcmlnaW4iLCJfcGl4ZWxPcmlnaW4iLCJnZXRQaXhlbFdvcmxkQm91bmRzIiwiZ2V0UGFuZSIsImdldFBhbmVzIiwiZ2V0Q29udGFpbmVyIiwidG9ab29tIiwiZnJvbVpvb20iLCJsYXRMbmdUb0xheWVyUG9pbnQiLCJjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCIsImxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50IiwibGF5ZXJQb2ludCIsIm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50IiwibW91c2VFdmVudFRvTGF5ZXJQb2ludCIsIm1vdXNlRXZlbnRUb0xhdExuZyIsIl9vblNjcm9sbCIsIl9mYWRlQW5pbWF0ZWQiLCJwb3NpdGlvbiIsIl9pbml0UGFuZXMiLCJfaW5pdENvbnRyb2xQb3MiLCJwYW5lcyIsIl9wYW5lUmVuZGVyZXJzIiwibWFya2VyUGFuZSIsInNoYWRvd1BhbmUiLCJsb2FkaW5nIiwiem9vbUNoYW5nZWQiLCJzdXByZXNzRXZlbnQiLCJfZ2V0TmV3UGl4ZWxPcmlnaW4iLCJwaW5jaCIsIl9nZXRab29tU3BhbiIsIl90YXJnZXRzIiwib25PZmYiLCJfaGFuZGxlRE9NRXZlbnQiLCJfb25Nb3ZlRW5kIiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsIl9maW5kRXZlbnRUYXJnZXRzIiwidGFyZ2V0cyIsImlzSG92ZXIiLCJzcmNFbGVtZW50IiwiZHJhZ2dpbmciLCJfZHJhZ2dhYmxlTW92ZWQiLCJfaXNDbGlja0Rpc2FibGVkIiwiX2ZpcmVET01FdmVudCIsIl9tb3VzZUV2ZW50cyIsImNhbnZhc1RhcmdldHMiLCJzeW50aCIsImZpbHRlcmVkIiwiaXNNYXJrZXIiLCJnZXRMYXRMbmciLCJfcmFkaXVzIiwiYnViYmxpbmdNb3VzZUV2ZW50cyIsImVuYWJsZWQiLCJib3hab29tIiwiZGlzYWJsZSIsIndoZW5SZWFkeSIsImNhbGxiYWNrIiwicGl4ZWxPcmlnaW4iLCJfbGF0TG5nVG9OZXdMYXllclBvaW50IiwidG9wTGVmdCIsIl9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzIiwibGF0TG5nQm91bmRzIiwiX2dldENlbnRlck9mZnNldCIsImNlbnRlclBvaW50Iiwidmlld0JvdW5kcyIsIl9nZXRCb3VuZHNPZmZzZXQiLCJfbGltaXRPZmZzZXQiLCJuZXdCb3VuZHMiLCJweEJvdW5kcyIsInByb2plY3RlZE1heEJvdW5kcyIsIm1pbk9mZnNldCIsIm1heE9mZnNldCIsImR4IiwiX3JlYm91bmQiLCJkeSIsInJpZ2h0IiwicHJveHkiLCJtYXBQYW5lIiwiX2FuaW1hdGluZ1pvb20iLCJfb25ab29tVHJhbnNpdGlvbkVuZCIsIl9hbmltTW92ZUVuZCIsIl9kZXN0cm95QW5pbVByb3h5IiwieiIsInByb3BlcnR5TmFtZSIsIl9ub3RoaW5nVG9BbmltYXRlIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsIl9hbmltYXRlWm9vbSIsInN0YXJ0QW5pbSIsIm5vVXBkYXRlIiwiX2FuaW1hdGVUb0NlbnRlciIsIl9hbmltYXRlVG9ab29tIiwiX3RlbXBGaXJlWm9vbUV2ZW50IiwiY3JlYXRlTWFwIiwiQ29udHJvbCIsIm1hcCIsIl9tYXAiLCJyZW1vdmVDb250cm9sIiwiYWRkQ29udHJvbCIsImFkZFRvIiwib25BZGQiLCJjb3JuZXIiLCJfY29udHJvbENvcm5lcnMiLCJvblJlbW92ZSIsIl9yZWZvY3VzT25NYXAiLCJzY3JlZW5YIiwic2NyZWVuWSIsImZvY3VzIiwiY29udHJvbCIsImNvcm5lcnMiLCJfY29udHJvbENvbnRhaW5lciIsImNyZWF0ZUNvcm5lciIsInZTaWRlIiwiaFNpZGUiLCJMYXllcnMiLCJjb2xsYXBzZWQiLCJhdXRvWkluZGV4IiwiaGlkZVNpbmdsZUJhc2UiLCJzb3J0TGF5ZXJzIiwic29ydEZ1bmN0aW9uIiwibGF5ZXJBIiwibGF5ZXJCIiwibmFtZUEiLCJuYW1lQiIsImJhc2VMYXllcnMiLCJvdmVybGF5cyIsIl9sYXllckNvbnRyb2xJbnB1dHMiLCJfbGFzdFpJbmRleCIsIl9oYW5kbGluZ0NsaWNrIiwiX3ByZXZlbnRDbGljayIsIl9hZGRMYXllciIsIl91cGRhdGUiLCJfY2hlY2tEaXNhYmxlZExheWVycyIsIl9vbkxheWVyQ2hhbmdlIiwiX2V4cGFuZElmTm90Q29sbGFwc2VkIiwiYWRkQmFzZUxheWVyIiwiYWRkT3ZlcmxheSIsInJlbW92ZUxheWVyIiwiX2dldExheWVyIiwiZXhwYW5kIiwiX3NlY3Rpb24iLCJhY2NlcHRhYmxlSGVpZ2h0Iiwib2Zmc2V0VG9wIiwiY29sbGFwc2UiLCJzZXRBdHRyaWJ1dGUiLCJzZWN0aW9uIiwiX2V4cGFuZFNhZmVseSIsImxpbmsiLCJfbGF5ZXJzTGluayIsImhyZWYiLCJ0aXRsZSIsImtleWRvd24iLCJrZXlDb2RlIiwiY2xpY2siLCJfYmFzZUxheWVyc0xpc3QiLCJfc2VwYXJhdG9yIiwiX292ZXJsYXlzTGlzdCIsIm92ZXJsYXkiLCJzb3J0Iiwic2V0WkluZGV4IiwiYmFzZUxheWVyc1ByZXNlbnQiLCJvdmVybGF5c1ByZXNlbnQiLCJiYXNlTGF5ZXJzQ291bnQiLCJfYWRkSXRlbSIsImRpc3BsYXkiLCJfY3JlYXRlUmFkaW9FbGVtZW50IiwiY2hlY2tlZCIsInJhZGlvSHRtbCIsInJhZGlvRnJhZ21lbnQiLCJsYWJlbCIsImhhc0xheWVyIiwiaW5wdXQiLCJkZWZhdWx0Q2hlY2tlZCIsImxheWVySWQiLCJfb25JbnB1dENsaWNrIiwiaG9sZGVyIiwiaW5wdXRzIiwiYWRkZWRMYXllcnMiLCJyZW1vdmVkTGF5ZXJzIiwiYWRkTGF5ZXIiLCJkaXNhYmxlZCIsInRoYXQiLCJab29tIiwiem9vbUluVGV4dCIsInpvb21JblRpdGxlIiwiem9vbU91dFRleHQiLCJ6b29tT3V0VGl0bGUiLCJ6b29tTmFtZSIsIl96b29tSW5CdXR0b24iLCJfY3JlYXRlQnV0dG9uIiwiX3pvb21JbiIsIl96b29tT3V0QnV0dG9uIiwiX3pvb21PdXQiLCJfdXBkYXRlRGlzYWJsZWQiLCJfZGlzYWJsZWQiLCJzaGlmdEtleSIsImh0bWwiLCJ6b29tQ29udHJvbCIsIlNjYWxlIiwibWF4V2lkdGgiLCJtZXRyaWMiLCJpbXBlcmlhbCIsIl9hZGRTY2FsZXMiLCJ1cGRhdGVXaGVuSWRsZSIsIl9tU2NhbGUiLCJfaVNjYWxlIiwibWF4TWV0ZXJzIiwiX3VwZGF0ZVNjYWxlcyIsIl91cGRhdGVNZXRyaWMiLCJfdXBkYXRlSW1wZXJpYWwiLCJtZXRlcnMiLCJfZ2V0Um91bmROdW0iLCJfdXBkYXRlU2NhbGUiLCJtYXhGZWV0IiwibWF4TWlsZXMiLCJtaWxlcyIsImZlZXQiLCJ0ZXh0IiwicmF0aW8iLCJwb3cxMCIsInVrcmFpbmlhbkZsYWciLCJBdHRyaWJ1dGlvbiIsInByZWZpeCIsIl9hdHRyaWJ1dGlvbnMiLCJhdHRyaWJ1dGlvbkNvbnRyb2wiLCJnZXRBdHRyaWJ1dGlvbiIsImFkZEF0dHJpYnV0aW9uIiwiX2FkZEF0dHJpYnV0aW9uIiwicmVtb3ZlQXR0cmlidXRpb24iLCJzZXRQcmVmaXgiLCJhdHRyaWJzIiwicHJlZml4QW5kQXR0cmlicyIsImF0dHJpYnV0aW9uIiwiSGFuZGxlciIsIl9lbmFibGVkIiwiYWRkSG9va3MiLCJyZW1vdmVIb29rcyIsIlNUQVJUIiwiRHJhZ2dhYmxlIiwiY2xpY2tUb2xlcmFuY2UiLCJkcmFnU3RhcnRUYXJnZXQiLCJfZWxlbWVudCIsIl9kcmFnU3RhcnRUYXJnZXQiLCJfcHJldmVudE91dGxpbmUiLCJfb25Eb3duIiwiX2RyYWdnaW5nIiwiZmluaXNoRHJhZyIsIndoaWNoIiwiYnV0dG9uIiwiX21vdmluZyIsImZpcnN0Iiwic2l6ZWRQYXJlbnQiLCJfc3RhcnRQb2ludCIsIl9wYXJlbnRTY2FsZSIsIm1vdXNlZXZlbnQiLCJfb25Nb3ZlIiwiX29uVXAiLCJfbGFzdFRhcmdldCIsIlNWR0VsZW1lbnRJbnN0YW5jZSIsImNvcnJlc3BvbmRpbmdVc2VFbGVtZW50IiwiX25ld1BvcyIsIl9sYXN0RXZlbnQiLCJfdXBkYXRlUG9zaXRpb24iLCJub0luZXJ0aWEiLCJmaXJlRHJhZ2VuZCIsImNsaXBQb2x5Z29uIiwiY2xpcHBlZFBvaW50cyIsImVkZ2VzIiwiayIsIl9jb2RlIiwiX2dldEJpdENvZGUiLCJfZ2V0RWRnZUludGVyc2VjdGlvbiIsInBvbHlnb25DZW50ZXIiLCJwMSIsInAyIiwiZiIsImFyZWEiLCJpc0ZsYXQiLCJjZW50cm9pZExhdExuZyIsImFyZWFCb3VuZHMiLCJjZW50cm9pZCIsImxhdGxuZ0NlbnRlciIsImxhdFN1bSIsImxuZ1N1bSIsInNpbXBsaWZ5IiwidG9sZXJhbmNlIiwic3FUb2xlcmFuY2UiLCJfcmVkdWNlUG9pbnRzIiwiX3NpbXBsaWZ5RFAiLCJwb2ludFRvU2VnbWVudERpc3RhbmNlIiwiX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50IiwiY2xvc2VzdFBvaW50T25TZWdtZW50IiwiQXJyYXlDb25zdHJ1Y3RvciIsIlVpbnQ4QXJyYXkiLCJtYXJrZXJzIiwiX3NpbXBsaWZ5RFBTdGVwIiwibmV3UG9pbnRzIiwibWF4U3FEaXN0Iiwic3FEaXN0IiwicmVkdWNlZFBvaW50cyIsInByZXYiLCJfc3FEaXN0IiwiX2xhc3RDb2RlIiwiY2xpcFNlZ21lbnQiLCJ1c2VMYXN0Q29kZSIsImNvZGVBIiwiY29kZUIiLCJjb2RlT3V0IiwibmV3Q29kZSIsImRvdCIsIl9mbGF0IiwicG9seWxpbmVDZW50ZXIiLCJoYWxmRGlzdCIsInNlZ0Rpc3QiLCJkaXN0IiwiTG9uTGF0IiwiTWVyY2F0b3IiLCJSX01JTk9SIiwidG1wIiwiY29uIiwidHMiLCJ0YW4iLCJwaGkiLCJkcGhpIiwiRVBTRzMzOTUiLCJFUFNHNDMyNiIsIlNpbXBsZSIsIkxheWVyIiwicmVtb3ZlRnJvbSIsIl9tYXBUb0FkZCIsImFkZEludGVyYWN0aXZlVGFyZ2V0IiwidGFyZ2V0RWwiLCJyZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCIsIl9sYXllckFkZCIsImdldEV2ZW50cyIsImV2ZW50cyIsImJlZm9yZUFkZCIsImVhY2hMYXllciIsIm1ldGhvZCIsIl9hZGRab29tTGltaXQiLCJfdXBkYXRlWm9vbUxldmVscyIsIl9yZW1vdmVab29tTGltaXQiLCJvbGRab29tU3BhbiIsIkxheWVyR3JvdXAiLCJnZXRMYXllcklkIiwiY2xlYXJMYXllcnMiLCJpbnZva2UiLCJtZXRob2ROYW1lIiwiZ2V0TGF5ZXIiLCJnZXRMYXllcnMiLCJ6SW5kZXgiLCJsYXllckdyb3VwIiwiRmVhdHVyZUdyb3VwIiwic2V0U3R5bGUiLCJicmluZ1RvRnJvbnQiLCJicmluZ1RvQmFjayIsImZlYXR1cmVHcm91cCIsIkljb24iLCJwb3B1cEFuY2hvciIsInRvb2x0aXBBbmNob3IiLCJjcm9zc09yaWdpbiIsImNyZWF0ZUljb24iLCJvbGRJY29uIiwiX2NyZWF0ZUljb24iLCJjcmVhdGVTaGFkb3ciLCJfZ2V0SWNvblVybCIsImltZyIsIl9jcmVhdGVJbWciLCJfc2V0SWNvblN0eWxlcyIsInNpemVPcHRpb24iLCJhbmNob3IiLCJzaGFkb3dBbmNob3IiLCJpY29uQW5jaG9yIiwibWFyZ2luTGVmdCIsIm1hcmdpblRvcCIsImljb24iLCJJY29uRGVmYXVsdCIsImljb25VcmwiLCJpY29uUmV0aW5hVXJsIiwic2hhZG93VXJsIiwiaWNvblNpemUiLCJzaGFkb3dTaXplIiwiaW1hZ2VQYXRoIiwiX2RldGVjdEljb25QYXRoIiwiX3N0cmlwVXJsIiwic3RyaXAiLCJyZSIsImlkeCIsIm1hdGNoIiwicXVlcnlTZWxlY3RvciIsInN1YnN0cmluZyIsIk1hcmtlckRyYWciLCJtYXJrZXIiLCJfbWFya2VyIiwiX2ljb24iLCJfZHJhZ2dhYmxlIiwiZHJhZ3N0YXJ0IiwiX29uRHJhZ1N0YXJ0IiwicHJlZHJhZyIsIl9vblByZURyYWciLCJkcmFnIiwiX29uRHJhZyIsImRyYWdlbmQiLCJfb25EcmFnRW5kIiwiX2FkanVzdFBhbiIsInNwZWVkIiwiYXV0b1BhblNwZWVkIiwiYXV0b1BhblBhZGRpbmciLCJpY29uUG9zIiwib3JpZ2luIiwicGFuQm91bmRzIiwibW92ZW1lbnQiLCJfcGFuUmVxdWVzdCIsIl9vbGRMYXRMbmciLCJjbG9zZVBvcHVwIiwiYXV0b1BhbiIsInNoYWRvdyIsIl9zaGFkb3ciLCJfbGF0bG5nIiwib2xkTGF0TG5nIiwiTWFya2VyIiwiaW50ZXJhY3RpdmUiLCJrZXlib2FyZCIsInpJbmRleE9mZnNldCIsInJpc2VPbkhvdmVyIiwicmlzZU9mZnNldCIsImF1dG9QYW5PbkZvY3VzIiwiZHJhZ2dhYmxlIiwiX2luaXRJY29uIiwidXBkYXRlIiwiX3JlbW92ZUljb24iLCJfcmVtb3ZlU2hhZG93Iiwidmlld3Jlc2V0Iiwic2V0TGF0TG5nIiwic2V0WkluZGV4T2Zmc2V0IiwiZ2V0SWNvbiIsInNldEljb24iLCJfcG9wdXAiLCJiaW5kUG9wdXAiLCJnZXRFbGVtZW50IiwiX3NldFBvcyIsImNsYXNzVG9BZGQiLCJhZGRJY29uIiwibW91c2VvdmVyIiwiX2JyaW5nVG9Gcm9udCIsIm1vdXNlb3V0IiwiX3Jlc2V0WkluZGV4IiwiX3Bhbk9uRm9jdXMiLCJuZXdTaGFkb3ciLCJhZGRTaGFkb3ciLCJfdXBkYXRlT3BhY2l0eSIsIl9pbml0SW50ZXJhY3Rpb24iLCJfekluZGV4IiwiX3VwZGF0ZVpJbmRleCIsIm9wdCIsImljb25PcHRzIiwiX2dldFBvcHVwQW5jaG9yIiwiX2dldFRvb2x0aXBBbmNob3IiLCJQYXRoIiwic3Ryb2tlIiwiY29sb3IiLCJ3ZWlnaHQiLCJsaW5lQ2FwIiwibGluZUpvaW4iLCJkYXNoQXJyYXkiLCJkYXNoT2Zmc2V0IiwiZmlsbCIsImZpbGxDb2xvciIsImZpbGxPcGFjaXR5IiwiZmlsbFJ1bGUiLCJnZXRSZW5kZXJlciIsIl9pbml0UGF0aCIsIl9yZXNldCIsIl9hZGRQYXRoIiwiX3JlbW92ZVBhdGgiLCJyZWRyYXciLCJfdXBkYXRlUGF0aCIsIl91cGRhdGVTdHlsZSIsIl91cGRhdGVCb3VuZHMiLCJfYnJpbmdUb0JhY2siLCJfcGF0aCIsIl9wcm9qZWN0IiwiX2NsaWNrVG9sZXJhbmNlIiwiQ2lyY2xlTWFya2VyIiwicmFkaXVzIiwic2V0UmFkaXVzIiwiZ2V0UmFkaXVzIiwiX3BvaW50IiwicjIiLCJfcmFkaXVzWSIsIl9weEJvdW5kcyIsIl91cGRhdGVDaXJjbGUiLCJfZW1wdHkiLCJfYm91bmRzIiwiX2NvbnRhaW5zUG9pbnQiLCJjaXJjbGVNYXJrZXIiLCJDaXJjbGUiLCJsZWdhY3lPcHRpb25zIiwiX21SYWRpdXMiLCJoYWxmIiwibGF0UiIsImJvdHRvbSIsImxuZ1IiLCJhY29zIiwiY2lyY2xlIiwiUG9seWxpbmUiLCJzbW9vdGhGYWN0b3IiLCJub0NsaXAiLCJfc2V0TGF0TG5ncyIsImdldExhdExuZ3MiLCJfbGF0bG5ncyIsInNldExhdExuZ3MiLCJpc0VtcHR5IiwiY2xvc2VzdExheWVyUG9pbnQiLCJtaW5EaXN0YW5jZSIsIm1pblBvaW50IiwiY2xvc2VzdCIsImpMZW4iLCJfcGFydHMiLCJfZGVmYXVsdFNoYXBlIiwiYWRkTGF0TG5nIiwiX2NvbnZlcnRMYXRMbmdzIiwicmVzdWx0IiwiZmxhdCIsIl9yaW5ncyIsIl9wcm9qZWN0TGF0bG5ncyIsIl9yYXdQeEJvdW5kcyIsInByb2plY3RlZEJvdW5kcyIsInJpbmciLCJfY2xpcFBvaW50cyIsInBhcnRzIiwic2VnbWVudCIsIl9zaW1wbGlmeVBvaW50cyIsIl91cGRhdGVQb2x5IiwicGFydCIsInBvbHlsaW5lIiwiUG9seWdvbiIsInBvcCIsImNsaXBwZWQiLCJwb2x5Z29uIiwiR2VvSlNPTiIsImdlb2pzb24iLCJhZGREYXRhIiwiZmVhdHVyZXMiLCJmZWF0dXJlIiwiZ2VvbWV0cmllcyIsImdlb21ldHJ5IiwiY29vcmRpbmF0ZXMiLCJnZW9tZXRyeVRvTGF5ZXIiLCJhc0ZlYXR1cmUiLCJkZWZhdWx0T3B0aW9ucyIsInJlc2V0U3R5bGUiLCJvbkVhY2hGZWF0dXJlIiwiX3NldExheWVyU3R5bGUiLCJwb2ludFRvTGF5ZXIiLCJfY29vcmRzVG9MYXRMbmciLCJjb29yZHNUb0xhdExuZyIsIl9wb2ludFRvTGF5ZXIiLCJjb29yZHNUb0xhdExuZ3MiLCJnZW9MYXllciIsInByb3BlcnRpZXMiLCJmZWF0dXJlTGF5ZXIiLCJwb2ludFRvTGF5ZXJGbiIsIm1hcmtlcnNJbmhlcml0T3B0aW9ucyIsImxldmVsc0RlZXAiLCJsYXRMbmdUb0Nvb3JkcyIsImxhdExuZ3NUb0Nvb3JkcyIsImdldEZlYXR1cmUiLCJuZXdHZW9tZXRyeSIsIlBvaW50VG9HZW9KU09OIiwidG9HZW9KU09OIiwibXVsdGkiLCJob2xlcyIsInRvTXVsdGlQb2ludCIsImlzR2VvbWV0cnlDb2xsZWN0aW9uIiwianNvbnMiLCJqc29uIiwiZ2VvSlNPTiIsImdlb0pzb24iLCJJbWFnZU92ZXJsYXkiLCJlcnJvck92ZXJsYXlVcmwiLCJ1cmwiLCJfdXJsIiwiX2ltYWdlIiwiX2luaXRJbWFnZSIsInN0eWxlT3B0cyIsInNldFVybCIsInNldEJvdW5kcyIsInpvb21hbmltIiwid2FzRWxlbWVudFN1cHBsaWVkIiwib25zZWxlY3RzdGFydCIsIm9ubW91c2Vtb3ZlIiwib25sb2FkIiwib25lcnJvciIsIl9vdmVybGF5T25FcnJvciIsImltYWdlIiwiZXJyb3JVcmwiLCJpbWFnZU92ZXJsYXkiLCJWaWRlb092ZXJsYXkiLCJhdXRvcGxheSIsImxvb3AiLCJrZWVwQXNwZWN0UmF0aW8iLCJtdXRlZCIsInBsYXlzSW5saW5lIiwidmlkIiwib25sb2FkZWRkYXRhIiwic291cmNlRWxlbWVudHMiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInNvdXJjZXMiLCJzb3VyY2UiLCJ2aWRlb092ZXJsYXkiLCJ2aWRlbyIsIlNWR092ZXJsYXkiLCJzdmdPdmVybGF5IiwiRGl2T3ZlcmxheSIsImNvbnRlbnQiLCJfc291cmNlIiwiX2NvbnRlbnQiLCJvcGVuT24iLCJjbG9zZSIsInRvZ2dsZSIsIl9wcmVwYXJlT3BlbiIsIl9yZW1vdmVUaW1lb3V0IiwiZ2V0Q29udGVudCIsInNldENvbnRlbnQiLCJ2aXNpYmlsaXR5IiwiX3VwZGF0ZUNvbnRlbnQiLCJfdXBkYXRlTGF5b3V0IiwiaXNPcGVuIiwibm9kZSIsIl9jb250ZW50Tm9kZSIsImhhc0NoaWxkTm9kZXMiLCJfZ2V0QW5jaG9yIiwiX2NvbnRhaW5lckJvdHRvbSIsIl9jb250YWluZXJMZWZ0IiwiX2NvbnRhaW5lcldpZHRoIiwiX2luaXRPdmVybGF5IiwiT3ZlcmxheUNsYXNzIiwib2xkIiwiUG9wdXAiLCJtaW5XaWR0aCIsIm1heEhlaWdodCIsImF1dG9QYW5QYWRkaW5nVG9wTGVmdCIsImF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQiLCJrZWVwSW5WaWV3IiwiY2xvc2VCdXR0b24iLCJhdXRvQ2xvc2UiLCJjbG9zZU9uRXNjYXBlS2V5IiwicG9wdXAiLCJjbG9zZU9uQ2xpY2siLCJjbG9zZVBvcHVwT25DbGljayIsInByZWNsaWNrIiwibW92ZWVuZCIsIndyYXBwZXIiLCJfd3JhcHBlciIsIl90aXBDb250YWluZXIiLCJfdGlwIiwiX2Nsb3NlQnV0dG9uIiwid2hpdGVTcGFjZSIsInNjcm9sbGVkQ2xhc3MiLCJfYXV0b3Bhbm5pbmciLCJtYXJnaW5Cb3R0b20iLCJjb250YWluZXJIZWlnaHQiLCJjb250YWluZXJXaWR0aCIsImxheWVyUG9zIiwiY29udGFpbmVyUG9zIiwib3BlblBvcHVwIiwiX3BvcHVwSGFuZGxlcnNBZGRlZCIsIl9vcGVuUG9wdXAiLCJrZXlwcmVzcyIsIl9vbktleVByZXNzIiwibW92ZSIsIl9tb3ZlUG9wdXAiLCJ1bmJpbmRQb3B1cCIsInRvZ2dsZVBvcHVwIiwiaXNQb3B1cE9wZW4iLCJzZXRQb3B1cENvbnRlbnQiLCJnZXRQb3B1cCIsIlRvb2x0aXAiLCJkaXJlY3Rpb24iLCJwZXJtYW5lbnQiLCJzdGlja3kiLCJ0b29sdGlwIiwiX3NldFBvc2l0aW9uIiwic3ViWCIsInN1YlkiLCJ0b29sdGlwUG9pbnQiLCJ0b29sdGlwV2lkdGgiLCJ0b29sdGlwSGVpZ2h0Iiwib3BlblRvb2x0aXAiLCJjbG9zZVRvb2x0aXAiLCJiaW5kVG9vbHRpcCIsIl90b29sdGlwIiwiaXNUb29sdGlwT3BlbiIsInVuYmluZFRvb2x0aXAiLCJfaW5pdFRvb2x0aXBJbnRlcmFjdGlvbnMiLCJfdG9vbHRpcEhhbmRsZXJzQWRkZWQiLCJfbW92ZVRvb2x0aXAiLCJfb3BlblRvb2x0aXAiLCJfYWRkRm9jdXNMaXN0ZW5lcnMiLCJtb3VzZW1vdmUiLCJfc2V0QXJpYURlc2NyaWJlZEJ5T25MYXllciIsInRvZ2dsZVRvb2x0aXAiLCJzZXRUb29sdGlwQ29udGVudCIsImdldFRvb2x0aXAiLCJfYWRkRm9jdXNMaXN0ZW5lcnNPbkxheWVyIiwibW92aW5nIiwiX29wZW5PbmNlRmxhZyIsIkRpdkljb24iLCJiZ1BvcyIsIkVsZW1lbnQiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJkaXZJY29uIiwiRGVmYXVsdCIsIkdyaWRMYXllciIsInRpbGVTaXplIiwidXBkYXRlV2hlblpvb21pbmciLCJ1cGRhdGVJbnRlcnZhbCIsIm1heE5hdGl2ZVpvb20iLCJtaW5OYXRpdmVab29tIiwibm9XcmFwIiwia2VlcEJ1ZmZlciIsIl9sZXZlbHMiLCJfdGlsZXMiLCJfcmVtb3ZlQWxsVGlsZXMiLCJfdGlsZVpvb20iLCJfc2V0QXV0b1pJbmRleCIsImlzTG9hZGluZyIsIl9sb2FkaW5nIiwidGlsZVpvb20iLCJfY2xhbXBab29tIiwiX3VwZGF0ZUxldmVscyIsInZpZXdwcmVyZXNldCIsIl9pbnZhbGlkYXRlQWxsIiwiY3JlYXRlVGlsZSIsImdldFRpbGVTaXplIiwiY29tcGFyZSIsImNoaWxkcmVuIiwiZWRnZVpJbmRleCIsImlzRmluaXRlIiwibmV4dEZyYW1lIiwid2lsbFBydW5lIiwidGlsZSIsImN1cnJlbnQiLCJsb2FkZWQiLCJmYWRlIiwiYWN0aXZlIiwiX29uT3BhcXVlVGlsZSIsIl9ub1BydW5lIiwiX3BydW5lVGlsZXMiLCJfZmFkZUZyYW1lIiwiTnVtYmVyIiwiX29uVXBkYXRlTGV2ZWwiLCJfcmVtb3ZlVGlsZXNBdFpvb20iLCJfb25SZW1vdmVMZXZlbCIsImxldmVsIiwiX3NldFpvb21UcmFuc2Zvcm0iLCJfb25DcmVhdGVMZXZlbCIsIl9sZXZlbCIsInJldGFpbiIsIl9yZXRhaW5QYXJlbnQiLCJfcmV0YWluQ2hpbGRyZW4iLCJfcmVtb3ZlVGlsZSIsIngyIiwieTIiLCJ6MiIsImNvb3JkczIiLCJfdGlsZUNvb3Jkc1RvS2V5IiwiYW5pbWF0aW5nIiwiX3NldFZpZXciLCJub1BydW5lIiwidGlsZVpvb21DaGFuZ2VkIiwiX2Fib3J0TG9hZGluZyIsIl9yZXNldEdyaWQiLCJfc2V0Wm9vbVRyYW5zZm9ybXMiLCJ0cmFuc2xhdGUiLCJfdGlsZVNpemUiLCJfZ2xvYmFsVGlsZVJhbmdlIiwiX3B4Qm91bmRzVG9UaWxlUmFuZ2UiLCJfd3JhcFgiLCJfd3JhcFkiLCJfZ2V0VGlsZWRQaXhlbEJvdW5kcyIsIm1hcFpvb20iLCJoYWxmU2l6ZSIsInRpbGVSYW5nZSIsInRpbGVDZW50ZXIiLCJxdWV1ZSIsIm5vUHJ1bmVSYW5nZSIsIl9pc1ZhbGlkVGlsZSIsImZyYWdtZW50IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsIl9hZGRUaWxlIiwidGlsZUJvdW5kcyIsIl90aWxlQ29vcmRzVG9Cb3VuZHMiLCJfa2V5VG9Cb3VuZHMiLCJfa2V5VG9UaWxlQ29vcmRzIiwiX3RpbGVDb29yZHNUb053U2UiLCJud1BvaW50Iiwic2VQb2ludCIsImJwIiwiX2luaXRUaWxlIiwidGlsZVBvcyIsIl9nZXRUaWxlUG9zIiwiX3dyYXBDb29yZHMiLCJfdGlsZVJlYWR5IiwiX25vVGlsZXNUb0xvYWQiLCJuZXdDb29yZHMiLCJncmlkTGF5ZXIiLCJUaWxlTGF5ZXIiLCJzdWJkb21haW5zIiwiZXJyb3JUaWxlVXJsIiwiem9vbU9mZnNldCIsInRtcyIsInpvb21SZXZlcnNlIiwiZGV0ZWN0UmV0aW5hIiwicmVmZXJyZXJQb2xpY3kiLCJfb25UaWxlUmVtb3ZlIiwibm9SZWRyYXciLCJkb25lIiwiX3RpbGVPbkxvYWQiLCJfdGlsZU9uRXJyb3IiLCJnZXRUaWxlVXJsIiwiX2dldFN1YmRvbWFpbiIsIl9nZXRab29tRm9yVXJsIiwiaW52ZXJ0ZWRZIiwiZ2V0QXR0cmlidXRlIiwidGlsZVBvaW50IiwiY29tcGxldGUiLCJ0aWxlTGF5ZXIiLCJUaWxlTGF5ZXJXTVMiLCJkZWZhdWx0V21zUGFyYW1zIiwic2VydmljZSIsInJlcXVlc3QiLCJzdHlsZXMiLCJmb3JtYXQiLCJ0cmFuc3BhcmVudCIsInZlcnNpb24iLCJ3bXNQYXJhbXMiLCJyZWFsUmV0aW5hIiwiX2NycyIsIl93bXNWZXJzaW9uIiwicGFyc2VGbG9hdCIsInByb2plY3Rpb25LZXkiLCJiYm94Iiwic2V0UGFyYW1zIiwidGlsZUxheWVyV01TIiwiV01TIiwid21zIiwiUmVuZGVyZXIiLCJfdXBkYXRlUGF0aHMiLCJfZGVzdHJveUNvbnRhaW5lciIsIl9vblpvb20iLCJ6b29tZW5kIiwiX29uWm9vbUVuZCIsIl9vbkFuaW1ab29tIiwiX3VwZGF0ZVRyYW5zZm9ybSIsImN1cnJlbnRDZW50ZXJQb2ludCIsIl9jZW50ZXIiLCJ0b3BMZWZ0T2Zmc2V0IiwiQ2FudmFzIiwiX29uVmlld1ByZVJlc2V0IiwiX3Bvc3Rwb25lVXBkYXRlUGF0aHMiLCJfZHJhdyIsIl9vbk1vdXNlTW92ZSIsIl9vbkNsaWNrIiwiX2hhbmRsZU1vdXNlT3V0IiwiX2N0eCIsIl9yZWRyYXdSZXF1ZXN0IiwiX3JlZHJhd0JvdW5kcyIsIl9yZWRyYXciLCJtIiwiX3VwZGF0ZURhc2hBcnJheSIsIm9yZGVyIiwiX29yZGVyIiwiX2RyYXdMYXN0IiwibmV4dCIsIl9kcmF3Rmlyc3QiLCJfcmVxdWVzdFJlZHJhdyIsIl9leHRlbmRSZWRyYXdCb3VuZHMiLCJkYXNoVmFsdWUiLCJfZGFzaEFycmF5IiwiX2NsZWFyIiwiY2xlYXJSZWN0Iiwic2F2ZSIsInJlc3RvcmUiLCJiZWdpblBhdGgiLCJjbGlwIiwiX2RyYXdpbmciLCJjbG9zZVBhdGgiLCJfZmlsbFN0cm9rZSIsImFyYyIsImdsb2JhbEFscGhhIiwiZmlsbFN0eWxlIiwic2V0TGluZURhc2giLCJsaW5lV2lkdGgiLCJzdHJva2VTdHlsZSIsImNsaWNrZWRMYXllciIsIl9maXJlRXZlbnQiLCJfaGFuZGxlTW91c2VIb3ZlciIsIl9ob3ZlcmVkTGF5ZXIiLCJfbW91c2VIb3ZlclRocm90dGxlZCIsImNhbmRpZGF0ZUhvdmVyZWRMYXllciIsInZtbENyZWF0ZSIsIm5hbWVzcGFjZXMiLCJ2bWxNaXhpbiIsImNvb3Jkc2l6ZSIsIl9zdHJva2UiLCJfZmlsbCIsInN0cm9rZWQiLCJmaWxsZWQiLCJkYXNoU3R5bGUiLCJlbmRjYXAiLCJqb2luc3R5bGUiLCJfc2V0UGF0aCIsIlNWRyIsIl9yb290R3JvdXAiLCJfc3ZnU2l6ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIl9nZXRQYW5lUmVuZGVyZXIiLCJfY3JlYXRlUmVuZGVyZXIiLCJwcmVmZXJDYW52YXMiLCJSZWN0YW5nbGUiLCJfYm91bmRzVG9MYXRMbmdzIiwicmVjdGFuZ2xlIiwiQm94Wm9vbSIsIl9wYW5lIiwib3ZlcmxheVBhbmUiLCJfcmVzZXRTdGF0ZVRpbWVvdXQiLCJfZGVzdHJveSIsIl9vbk1vdXNlRG93biIsIl9yZXNldFN0YXRlIiwiX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlIiwiY29udGV4dG1lbnUiLCJtb3VzZXVwIiwiX29uTW91c2VVcCIsIl9vbktleURvd24iLCJfYm94IiwiX2ZpbmlzaCIsImJveFpvb21Cb3VuZHMiLCJkb3VibGVDbGlja1pvb20iLCJEb3VibGVDbGlja1pvb20iLCJfb25Eb3VibGVDbGljayIsImluZXJ0aWEiLCJpbmVydGlhRGVjZWxlcmF0aW9uIiwiaW5lcnRpYU1heFNwZWVkIiwid29ybGRDb3B5SnVtcCIsIm1heEJvdW5kc1Zpc2Nvc2l0eSIsIkRyYWciLCJfb25QcmVEcmFnTGltaXQiLCJfb25QcmVEcmFnV3JhcCIsIl9wb3NpdGlvbnMiLCJfdGltZXMiLCJfb2Zmc2V0TGltaXQiLCJfdmlzY29zaXR5IiwiX2xhc3RUaW1lIiwiX2xhc3RQb3MiLCJfYWJzUG9zIiwiX3BydW5lUG9zaXRpb25zIiwic2hpZnQiLCJweENlbnRlciIsInB4V29ybGRDZW50ZXIiLCJfaW5pdGlhbFdvcmxkT2Zmc2V0IiwiX3dvcmxkV2lkdGgiLCJfdmlzY291c0xpbWl0IiwidGhyZXNob2xkIiwibGltaXQiLCJ3b3JsZFdpZHRoIiwiaGFsZldpZHRoIiwibmV3WDEiLCJuZXdYMiIsIm5ld1giLCJlYXNlIiwic3BlZWRWZWN0b3IiLCJsaW1pdGVkU3BlZWQiLCJsaW1pdGVkU3BlZWRWZWN0b3IiLCJkZWNlbGVyYXRpb25EdXJhdGlvbiIsImtleWJvYXJkUGFuRGVsdGEiLCJLZXlib2FyZCIsImtleUNvZGVzIiwiZG93biIsInVwIiwiX3NldFBhbkRlbHRhIiwiX3NldFpvb21EZWx0YSIsIl9vbkZvY3VzIiwiYmx1ciIsIl9vbkJsdXIiLCJtb3VzZWRvd24iLCJfYWRkSG9va3MiLCJfcmVtb3ZlSG9va3MiLCJfZm9jdXNlZCIsImRvY0VsIiwic2Nyb2xsVG8iLCJwYW5EZWx0YSIsImtleXMiLCJfcGFuS2V5cyIsImNvZGVzIiwiX3pvb21LZXlzIiwiYWx0S2V5IiwiY3RybEtleSIsIm1ldGFLZXkiLCJuZXdMYXRMbmciLCJzY3JvbGxXaGVlbFpvb20iLCJ3aGVlbERlYm91bmNlVGltZSIsIndoZWVsUHhQZXJab29tTGV2ZWwiLCJTY3JvbGxXaGVlbFpvb20iLCJfb25XaGVlbFNjcm9sbCIsIl9kZWx0YSIsImRlYm91bmNlIiwiX2xhc3RNb3VzZVBvcyIsIl90aW1lciIsIl9wZXJmb3JtWm9vbSIsImQyIiwiZDMiLCJkNCIsInRhcEhvbGREZWxheSIsInRhcEhvbGQiLCJ0YXBUb2xlcmFuY2UiLCJUYXBIb2xkIiwiX2hvbGRUaW1lb3V0IiwiX2NhbmNlbCIsIl9pc1RhcFZhbGlkIiwiX2NhbmNlbENsaWNrUHJldmVudCIsIl9zaW11bGF0ZUV2ZW50IiwiY2FuY2VsQ2xpY2tQcmV2ZW50Iiwic2ltdWxhdGVkRXZlbnQiLCJNb3VzZUV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJ2aWV3IiwiZGlzcGF0Y2hFdmVudCIsInRvdWNoWm9vbSIsImJvdW5jZUF0Wm9vbUxpbWl0cyIsIlRvdWNoWm9vbSIsIl9vblRvdWNoU3RhcnQiLCJfem9vbWluZyIsIl9jZW50ZXJQb2ludCIsIl9zdGFydExhdExuZyIsIl9waW5jaFN0YXJ0TGF0TG5nIiwiX3N0YXJ0RGlzdCIsIl9zdGFydFpvb20iLCJfb25Ub3VjaE1vdmUiLCJfb25Ub3VjaEVuZCIsIl9hbmltUmVxdWVzdCIsIm1vdmVGbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/leaflet/dist/leaflet-src.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/leaflet/dist/leaflet.css":
/*!***********************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet.css ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"ec929f1100c6\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyIvVXNlcnMvc2FydGhhazIxNXMvRG9jdW1lbnRzL0dpdEh1Yi9JT0RhcmtXYXRjaC9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZWM5MjlmMTEwMGM2XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/leaflet/dist/leaflet.css\n");

/***/ })

};
;